# 1 "asobj/Array_as.cpp"
# 1 "/tmp/nix-build-rgk8wj8sn6jnj36k5kbrm440i7fwqywx-gnash-0.8.8.drv-0/gnash-0.8.8/libcore//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "asobj/Array_as.cpp"
# 21 "asobj/Array_as.cpp"
# 1 "../libbase/smart_ptr.h" 1
# 29 "../libbase/smart_ptr.h"
# 1 "../libbase/ref_counted.h" 1
# 22 "../libbase/ref_counted.h"
# 1 "../libbase/dsodefs.h" 1
# 23 "../libbase/dsodefs.h"
# 1 "../gnashconfig.h" 1
# 24 "../libbase/dsodefs.h" 2
# 23 "../libbase/ref_counted.h" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 37 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/features.h" 1 3 4
# 356 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/features.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/cdefs.h" 1 3 4
# 353 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/cdefs.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/wordsize.h" 1 3 4
# 354 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/cdefs.h" 2 3 4
# 357 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/features.h" 2 3 4
# 380 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/features.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/gnu/stubs.h" 1 3 4
# 381 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/features.h" 2 3 4
# 38 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 2 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 25 "../libbase/ref_counted.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/atomic_count.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/atomic_count.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count.hpp" 1
# 75 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/user.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_compiler_config.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/compiler/gcc.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_stdlib_config.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_stdlib_config.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++config.h" 1 3
# 275 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++config.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/os_defines.h" 1 3
# 276 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++config.h" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/cpu_defines.h" 1 3
# 279 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++config.h" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 149 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 211 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 3 4
typedef unsigned int size_t;
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_stdlib_config.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_stdlib_config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/utility.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/utility.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/utility" 1 3
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/utility" 3
       
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/utility" 3
# 70 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/utility" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_relops.h" 1 3
# 67 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  namespace rel_ops
  {
# 83 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 96 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 109 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 122 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 71 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/utility" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/move.h" 1 3
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/move.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/move.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/concept_check.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/concept_check.h" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/concept_check.h" 3
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/move.h" 2 3
# 95 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }

}
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 2 3






namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 113 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 3
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
# 149 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 211 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
# 257 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_pair.h" 3
}
# 72 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/utility" 2 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/utility.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_stdlib_config.hpp" 2
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/stdlib/libstdcpp3.hpp" 1
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/select_platform_config.hpp" 1
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/platform/linux.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/platform/linux.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 68 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 1 3 4
# 33 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 34 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/waitflags.h" 1 3 4
# 43 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 2 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/waitstatus.h" 1 3 4
# 65 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/waitstatus.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/endian.h" 1 3 4
# 37 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/endian.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/endian.h" 1 3 4
# 38 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/endian.h" 2 3 4
# 61 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/endian.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/byteswap.h" 1 3 4
# 62 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/endian.h" 2 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 2 3 4
# 96 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 236 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/xlocale.h" 1 3 4
# 28 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 237 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 2 3 4



extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;





extern __inline __attribute__ ((__gnu_inline__)) double
atof (__const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
extern __inline __attribute__ ((__gnu_inline__)) int
atoi (__const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
atol (__const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
atoll (__const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

# 311 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 1 3 4
# 28 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 3 4
extern "C" {

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/types.h" 1 3 4
# 28 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/types.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/wordsize.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/types.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/typesizes.h" 1 3 4
# 132 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 31 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 1 3 4
# 58 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 148 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 1 3 4
# 31 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/select.h" 1 3 4
# 32 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sigset.h" 1 3 4
# 24 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 1 3 4
# 120 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 2 3 4

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/time.h" 1 3 4
# 75 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 2 3 4
# 55 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 3 4
extern "C" {
# 109 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/sysmacros.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();


__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned long long int
gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 263 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/pthreadtypes.h" 1 3 4
# 50 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;
# 67 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/pthreadtypes.h" 3 4
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;





typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;





    int __kind;





    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
# 170 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/pthreadtypes.h" 3 4
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
# 188 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/pthreadtypes.h" 3 4
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;

    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 272 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/types.h" 2 3 4


}
# 321 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/alloca.h" 1 3 4
# 25 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/alloca.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 26 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 620 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 808 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 896 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 964 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdlib.h" 3 4
}
# 69 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 100 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 157 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 190 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std __attribute__ ((__visibility__ ("default"))) {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/platform/linux.hpp" 2
# 70 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/platform/linux.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/posix_features.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/posix_features.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 1 3 4
# 28 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern "C" {
# 203 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/posix_opt.h" 1 3 4
# 204 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 2 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/environments.h" 1 3 4
# 23 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/environments.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/wordsize.h" 1 3 4
# 24 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/environments.h" 2 3 4
# 208 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 2 3 4
# 227 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 228 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 2 3 4
# 268 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 331 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 342 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 373 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 401 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 429 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 441 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 466 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 508 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/confname.h" 1 3 4
# 26 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 607 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 643 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 669 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 686 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 890 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/getopt.h" 1 3 4
# 50 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/getopt.h" 3 4
extern "C" {
# 59 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/getopt.h" 3 4
extern char *optarg;
# 73 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 187 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/getopt.h" 3 4
}
# 891 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 976 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 1007 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1019 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1036 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1047 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1068 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1091 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1101 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1122 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();
# 1160 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/unistd.h" 3 4
}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/posix_features.hpp" 2
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/platform/linux.hpp" 2
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/suffix.hpp" 1
# 495 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/suffix.hpp"
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config.hpp" 2
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_has_sync.hpp" 1
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count.hpp" 2
# 102 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count_sync.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count_sync.hpp"
namespace boost
{

namespace detail
{

class atomic_count
{
public:

    explicit atomic_count( long v ) : value_( v ) {}

    long operator++()
    {
        return __sync_add_and_fetch( &value_, 1 );
    }

    long operator--()
    {
        return __sync_add_and_fetch( &value_, -1 );
    }

    operator long() const
    {
        return __sync_fetch_and_add( &value_, 0 );
    }

private:

    atomic_count(atomic_count const &);
    atomic_count & operator=(atomic_count const &);

    mutable long value_;
};

}

}
# 103 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/atomic_count.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/atomic_count.hpp" 2
# 26 "../libbase/ref_counted.h" 2

namespace gnash {






class ref_counted
{

private:






 typedef boost::detail::atomic_count Counter;


 mutable Counter m_ref_count;

protected:



 virtual ~ref_counted()
 {
  ((m_ref_count == 0) ? static_cast<void> (0) : __assert_fail ("m_ref_count == 0", "../libbase/ref_counted.h", 55, __PRETTY_FUNCTION__));
 }

public:
 ref_counted()
  :
  m_ref_count(0)
 {
 }

 ref_counted(const ref_counted&)
  :
  m_ref_count(0)
 {
 }

 void add_ref() const
 {
  ((m_ref_count >= 0) ? static_cast<void> (0) : __assert_fail ("m_ref_count >= 0", "../libbase/ref_counted.h", 73, __PRETTY_FUNCTION__));
  ++m_ref_count;
 }

 void drop_ref() const
 {
  ((m_ref_count > 0) ? static_cast<void> (0) : __assert_fail ("m_ref_count > 0", "../libbase/ref_counted.h", 79, __PRETTY_FUNCTION__));
  if (!--m_ref_count)
  {

   delete this;
  }
 }

 long get_ref_count() const { return m_ref_count; }
};

}
# 30 "../libbase/smart_ptr.h" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 1 3
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 3
       
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception" 1 3
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception" 3
       
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 118 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 141 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception" 3
  void __verbose_terminate_handler();

}

}

#pragma GCC visibility pop
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 79 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
# 114 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 135 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 31 "../libbase/smart_ptr.h" 2




namespace gnash {
    class GcResource;
}




namespace gnash {




inline void
intrusive_ptr_add_ref(const ref_counted* o)
{
 o->add_ref();
}

inline void
intrusive_ptr_release(const ref_counted* o)
{
 o->drop_ref();
}




inline void intrusive_ptr_add_ref(const GcResource* ) { }
inline void intrusive_ptr_release(const GcResource* ) { }

}
# 22 "asobj/Array_as.cpp" 2
# 1 "./as_value.h" 1
# 22 "./as_value.h"
# 1 "../libbase/dsodefs.h" 1
# 23 "./as_value.h" 2
# 1 "./CharacterProxy.h" 1
# 23 "./CharacterProxy.h"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stringfwd.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stringfwd.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
# 83 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stringfwd.h" 3
}
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 1 3
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/functexcept.h" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/functexcept.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/exception_defines.h" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));

}
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cpp_type_traits.h" 1 3
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cpp_type_traits.h" 3
       
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cpp_type_traits.h" 3
# 69 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 194 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 417 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    class __is_iterator_helper
    {
      typedef char __one;
      typedef struct { char __arr[2]; } __two;

      template<typename _Up>
        struct _Wrap_type
 { };

      template<typename _Up>
        static __one __test(_Wrap_type<typename _Up::iterator_category>*);

      template<typename _Up>
        static __two __test(...);

    public:
      static const bool __value = (sizeof(__test<_Tp>(0)) == 1
       || __is_pointer<_Tp>::__value);
    };

  template<typename _Tp>
    struct __is_iterator
    {
      enum { __value = __is_iterator_helper<_Tp>::__value };
      typedef typename __truth_type<__value>::__type __type;
    };

}
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/type_traits.h" 1 3
# 32 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/type_traits.h" 3
       
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 65 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/numeric_traits.h" 1 3
# 32 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/numeric_traits.h" 3
       
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 52 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 97 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 113) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 33);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 66 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 3
       
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 67 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 79 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 106 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 130 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }



}
# 68 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_funcs.h" 3
       
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 109 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 167 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 69 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 1 3
# 68 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 94 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 281 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 393 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 419 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 436 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 462 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 477 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 502 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 519 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 545 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 564 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 606 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 625 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 651 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }



}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 672 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 770 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 70 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/debug/debug.h" 1 3
# 47 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 72 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 115 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 156 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 184 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 207 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 251 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type
      _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type
      _S_base(_Iterator __it)
      { return __it.base(); }
    };



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 339 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 377 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 462 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 514 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 542 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 572 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 631 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 689 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 733 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 791 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 952 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 1028 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1060 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1091 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1125 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1165 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1202 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 1 3
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3
       
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 2 3


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 37 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 1 3 4
# 45 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 38 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 2 3 4


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stdarg.h" 1 3 4
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 2 3 4

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/wchar.h" 1 3 4
# 43 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 2 3 4
# 52 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 352 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 2 3 4
# 83 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 104 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 129 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
           __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 303 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
           size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 528 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
# 578 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 678 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 734 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 799 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 889 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 3 4
}
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 2 3
# 65 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 139 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  using ::wcstold;
# 258 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 2 3
# 70 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 90 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 239 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/postypes.h" 3
}
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 2 3


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 2 3
# 52 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 89 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 230 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/allocator.h" 1 3
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/allocator.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++allocator.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/new_allocator.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/new_allocator.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/new" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/new" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/new" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/new" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 93 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 50 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 114 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 85 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 204 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/allocator.h" 3
}
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++locale.h" 1 3
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++locale.h" 3
       
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++locale.h" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/clocale" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/clocale" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/clocale" 3


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 2 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/locale.h" 1 3 4
# 27 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 2 3 4

extern "C" {
# 51 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 187 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/clocale" 2 3
# 53 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/clocale" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++locale.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 85 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }

}
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iosfwd" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iosfwd" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 74 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;




  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 3 4
extern "C" {
# 48 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 96 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 247 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/ctype.h" 3 4
}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 2 3
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 55 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 46 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream_insert.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream_insert.h" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream_insert.h" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi-forced.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi-forced.h" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi-forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 47 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 134 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 262 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 345 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 416 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 523 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/binders.h" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 97 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 713 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_function.h" 2 3
# 51 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/atomicity.h" 1 3
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/atomicity.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr.h" 1 3
# 30 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 162 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 1 3 4
# 25 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 31 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 2 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 2 3 4
# 43 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sched.h" 1 3 4
# 74 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 116 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 199 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 118 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 2 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
extern "C" {







# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 39 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 2 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/time.h" 1 3 4
# 43 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 2 3 4
# 131 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 180 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
extern int getdate_err;
# 399 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 27 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/setjmp.h" 1 3 4
# 28 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/setjmp.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sgidefs.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/setjmp.h" 2 3 4

typedef struct __jmp_buf_internal_tag
  {
# 49 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/setjmp.h" 3 4
    __extension__ long long __pc;


    __extension__ long long __sp;


    __extension__ long long __regs[8];


    __extension__ long long __fp;


    __extension__ long long __gp;



    int __fpc_csr;





    double __fpregs[6];

  } __jmp_buf[1];
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 2 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/wordsize.h" 1 3 4
# 31 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 147 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 182 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 220 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 478 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 490 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 524 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 726 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 790 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 872 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 984 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1028 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1095 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1129 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 2 3


typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 118 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));
static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 237 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
# 675 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 818 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 163 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/atomicity.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/initializer_list" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/initializer_list" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/initializer_list" 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 141 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 166 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 469 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 517 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 550 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 590 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
# 696 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 725 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 738 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
# 758 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 779 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
# 808 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 825 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 846 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 865 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 921 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 936 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 968 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 990 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1046 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1062 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1074 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1090 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1102 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1130 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1145 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1176 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1198 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1221 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1239 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1262 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1279 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1303 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1319 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1339 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1358 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1380 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1404 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1423 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1446 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1464 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1482 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1503 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1524 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1546 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1621 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1702 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1712 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1722 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1754 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1767 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1781 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1798 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1811 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1826 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1839 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1856 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1869 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1884 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1897 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1916 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1930 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1945 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1958 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1977 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1991 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2006 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2020 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2037 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 2050 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2066 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2079 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2096 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 2111 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2129 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2159 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2183 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2201 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2224 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2249 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2261 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2332 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2378 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2415 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2452 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2489 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2526 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2563 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2580 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2598 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2621 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2639 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 54 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.tcc" 1 3
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.tcc" 3
       
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 240 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 57 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/string" 2 3
# 24 "./CharacterProxy.h" 2


namespace gnash {
 class DisplayObject;
}

namespace gnash {







class CharacterProxy {

 mutable DisplayObject* _ptr;

 mutable std::string _tgt;

 static DisplayObject* findDisplayObjectByTarget(const std::string& target);



 void checkDangling() const;

public:


 CharacterProxy(DisplayObject* sp)
  :
  _ptr(sp)
 {
  checkDangling();
 }
# 70 "./CharacterProxy.h"
 CharacterProxy(const CharacterProxy& sp)
 {
  sp.checkDangling();
  _ptr=sp._ptr;
  if ( ! _ptr ) _tgt=sp._tgt;
 }
# 87 "./CharacterProxy.h"
 CharacterProxy& operator=(const CharacterProxy& sp)
 {
  sp.checkDangling();
  _ptr=sp._ptr;
  if ( ! _ptr ) _tgt=sp._tgt;
  return *this;
 }





 DisplayObject* get(bool skipRebinding=false) const
 {
  if ( skipRebinding ) return _ptr;


  checkDangling();
  if ( _ptr ) return _ptr;
  else return findDisplayObjectByTarget(_tgt);
 }



 std::string getTarget() const;
# 120 "./CharacterProxy.h"
 bool isDangling() const
 {
  checkDangling();
  return !_ptr;
 }





 bool operator==(const CharacterProxy& sp) const
 {
  return get() == sp.get();
 }






 void setReachable() const;
};

}
# 24 "./as_value.h" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
# 148 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 190 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;






    static const bool is_signed = false;


    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 283 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }







      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }



      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };
# 334 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }




      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }





      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }





      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }





      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }





      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 744 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }





      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }





      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }





      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }





      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }





      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }





      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }





      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }





      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435082228750796873653722224568e-38F; }
      static float max() throw()
      { return 3.40282346638528859811704183484516925e+38F; }





      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209289550781250000000000000000000e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846432481707092372958328991613e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return ((double)2.22507385850720138309023271733240406e-308L); }
      static double max() throw()
      { return ((double)1.79769313486231570814527423731704357e+308L); }





      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return ((double)2.22044604925031308084726333618164062e-16L); }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return ((double)4.94065645841246544176568792868221372e-324L); }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626267781732175260e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176508575932662800702e+4932L; }





      static const int digits = 113;
      static const int digits10 = 33;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.92592994438723585305597794258492732e-34L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 6.47517511943802511092443895822764655e-4966L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 26 "./as_value.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/config.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/workaround.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/config.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/eti.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/eti.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/msvc.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/eti.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/workaround.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/eti.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/value_wknd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/value_wknd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/static_cast.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/value_wknd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/integral.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/value_wknd.hpp" 2
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/value_wknd.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/value_wknd.hpp"
}}}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank_fwd.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank_fwd.hpp"
namespace boost {

struct blank;

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/adl_barrier.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/adl_barrier.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/adl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/adl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/intel.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/adl.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/gcc.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/adl.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/adl_barrier.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/adl_barrier.hpp"
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/nttp_decl.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/nttp_decl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/nttp.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/nttp_decl.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg_fwd.hpp" 2

namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bool.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bool.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bool_fwd.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bool_fwd.hpp"
namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bool.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c_tag.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c_tag.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/static_constant.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c_tag.hpp" 2

namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bool.hpp" 2


namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_fwd.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_fwd.hpp"
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/ctps.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na.hpp" 2

namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na.hpp"
}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_assert.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_assert.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/nested_type_wknd.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/nested_type_wknd.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/void_fwd.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/void_fwd.hpp"
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/lambda.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/lambda.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/ttp.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/lambda.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/int.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/int.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/int_fwd.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/int_fwd.hpp"
namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/int.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/cat.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/cat.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/config/config.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/cat.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/int.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/lambda_arity_param.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity_fwd.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda_fwd.hpp" 2

namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arity.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arity.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/dtp.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arity.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/preprocessor.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/comma_if.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/comma_if.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/punctuation/comma_if.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/punctuation/comma_if.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/if.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/if.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/iif.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/bool.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/if.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/facilities/empty.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/punctuation/comma.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/comma_if.hpp" 2
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repeat.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repeat.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/debug/error.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/tuple/eat.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repeat.hpp" 2
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/inc.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/inc.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/inc.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/inc.hpp" 2
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/enum.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/limits/arity.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/and.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/and.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/bitand.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/and.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/identity.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/identity.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/facilities/identity.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/identity.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/empty.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 66 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/add.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/add.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/dec.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/add.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_left.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_left.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_left.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_left.hpp" 2
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_left.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_left.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_left.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/expr_iif.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_left.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/adt.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/adt.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/is_binary.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/is_binary.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/check.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/is_binary.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/adt.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/compl.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/adt.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_left.hpp" 2
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_left.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_right.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_right.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_right.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_right.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_right.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_right.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/reverse.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/detail/fold_right.hpp" 2
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/fold_right.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp" 2
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/detail/while.hpp" 1
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/while.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/add.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/tuple/elem.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/add.hpp" 2
# 67 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/sub.hpp" 1
# 68 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/overload_resolution.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_spec.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/lambda_support.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not.hpp" 2

namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/yes_no.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/yes_no.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/arrays.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/yes_no.hpp" 2




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/yes_no.hpp"
}}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/pp_counter.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp" 2





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp" 2
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp"
namespace mpl_ {

struct failed {};
# 75 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp"
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 123 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp"
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};






template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};

template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );

template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 212 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/assert.hpp"
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/na_assert.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arity_spec.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arg_typedef.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/compiler.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/stringize.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/tuple/rem.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum_params.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum_params.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum_params.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum_params.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum_shifted_params.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum_shifted_params.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum_shifted_params.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/enum_shifted_params.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/limits/list.hpp" 1
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2
# 67 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity.hpp" 1
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/type_wrapper.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/type_wrapper.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity.hpp" 2
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp"
namespace boost { namespace mpl { namespace aux {
template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) )

         ;
};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1

         ;
};

template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value )

          ;
    typedef mpl::int_<value> type;
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute_fwd.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute_fwd.hpp"
namespace boost {
namespace detail { namespace variant {
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute_fwd.hpp"
template <
      typename T, typename Dest, typename Source
      , typename Arity = mpl::int_< mpl::aux::template_arity<T>::value >


    >
struct substitute;



}}
}
# 68 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp" 2
# 104 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
namespace boost {

namespace detail { namespace variant {
# 120 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
struct void_;

template <typename T>
struct convert_void
{
    typedef T type;
};

template <>
struct convert_void< void_ >
{
    typedef mpl::na type;
};
# 169 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
}}
# 213 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
template < typename T0 = detail::variant::void_ , typename T1 = detail::variant::void_ , typename T2 = detail::variant::void_ , typename T3 = detail::variant::void_ , typename T4 = detail::variant::void_ , typename T5 = detail::variant::void_ , typename T6 = detail::variant::void_ , typename T7 = detail::variant::void_ , typename T8 = detail::variant::void_ , typename T9 = detail::variant::void_ , typename T10 = detail::variant::void_ , typename T11 = detail::variant::void_ , typename T12 = detail::variant::void_ , typename T13 = detail::variant::void_ , typename T14 = detail::variant::void_ , typename T15 = detail::variant::void_ , typename T16 = detail::variant::void_ , typename T17 = detail::variant::void_ , typename T18 = detail::variant::void_ , typename T19 = detail::variant::void_ > class variant;







template < typename T0 = detail::variant::void_ , typename T1 = detail::variant::void_ , typename T2 = detail::variant::void_ , typename T3 = detail::variant::void_ , typename T4 = detail::variant::void_ , typename T5 = detail::variant::void_ , typename T6 = detail::variant::void_ , typename T7 = detail::variant::void_ , typename T8 = detail::variant::void_ , typename T9 = detail::variant::void_ , typename T10 = detail::variant::void_ , typename T11 = detail::variant::void_ , typename T12 = detail::variant::void_ , typename T13 = detail::variant::void_ , typename T14 = detail::variant::void_ , typename T15 = detail::variant::void_ , typename T16 = detail::variant::void_ , typename T17 = detail::variant::void_ , typename T18 = detail::variant::void_ , typename T19 = detail::variant::void_ > struct make_recursive_variant;
# 232 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
    struct recursive_variant_;
# 242 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant_fwd.hpp"
template <typename Types> struct make_variant_over;






template <typename Types> struct make_recursive_variant_over;

}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/backup_holder.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/backup_holder.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/backup_holder.hpp" 2

namespace boost {
namespace detail { namespace variant {

template <typename T>
class backup_holder
{
private:

    T* backup_;

public:

    ~backup_holder()
    {
        delete backup_;
    }

    explicit backup_holder(T* backup)
        : backup_(backup)
    {
    }

    backup_holder(const backup_holder&);

public:

    backup_holder& operator=(const backup_holder& rhs)
    {
        *backup_ = rhs.get();
        return *this;
    }

    backup_holder& operator=(const T& rhs)
    {
        *backup_ = rhs;
        return *this;
    }

    void swap(backup_holder& rhs)
    {
        T* tmp = rhs.backup_;
        rhs.backup_ = this->backup_;
        this->backup_ = tmp;
    }

public:

    T& get()
    {
        return *backup_;
    }

    const T& get() const
    {
        return *backup_;
    }

};

template <typename T>
backup_holder<T>::backup_holder(const backup_holder&)
    : backup_(0)
{

    ((false) ? static_cast<void> (0) : __assert_fail ("false", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/backup_holder.hpp", 82, __PRETTY_FUNCTION__));
}

template <typename T>
void swap(backup_holder<T>& lhs, backup_holder<T>& rhs)
{
    lhs.swap(rhs);
}

}}
}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive_fwd.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive_fwd.hpp"
namespace boost {
namespace detail { namespace variant {
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive_fwd.hpp"
template <typename T>
struct recursive_flag
{
    typedef T type;
};
# 66 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive_fwd.hpp"
template <typename T>
struct is_recursive_flag
    : mpl::false_
{
};

template <typename T>
struct is_recursive_flag< recursive_flag<T> >
    : mpl::true_
{
};
# 95 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive_fwd.hpp"
template <
      typename T
    , typename RecursiveVariant
    , typename NoWrapper = mpl::false_
    >
struct enable_recursive;






template <
      typename RecursiveVariant
    , typename NoWrapper = mpl::false_
    >
struct quoted_enable_recursive;

}}
}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/generic_result_type.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/broken_compiler_spec.hpp" 1
# 95 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/broken_compiler_spec.hpp"















# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp" 2

namespace boost {



namespace detail{




template <class T>
struct remove_rvalue_ref
{
 typedef T type;
};
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp"
}

template< typename T > struct remove_reference { typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template< typename T > struct remove_reference<T&> { typedef T type; };
# 66 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 69 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_reference.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp" 2


namespace boost {
namespace detail { namespace variant {
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp"
template <typename T>
inline T forced_return( )
{

    ((false) ? static_cast<void> (0) : __assert_fail ("false", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp", 44, __PRETTY_FUNCTION__));

    typedef typename boost::remove_reference<T>::type basic_type;
    basic_type* dummy = 0;
    return *static_cast< basic_type* >(dummy);
}

template <>
inline void forced_return<void>( )
{

    ((false) ? static_cast<void> (0) : __assert_fail ("false", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp", 55, __PRETTY_FUNCTION__));
}
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/forced_return.hpp"
}}
}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/call_traits.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/call_traits.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/call_traits.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/call_traits.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/call_traits.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_integral.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_integral.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/integral_constant.hpp" 1
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/integral_constant.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c_fwd.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c_fwd.hpp"
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/integral_c.hpp" 2




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/integral_constant.hpp" 2

namespace boost{




template <class T, T val>

struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};

template<> struct integral_constant<bool,true> : public mpl::true_
{







   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{







   typedef integral_constant<bool,false> type;
};

typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;

}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_integral.hpp" 2

namespace boost {







template< typename T > struct is_integral : ::boost::integral_constant<bool,false> { };

template<> struct is_integral< unsigned char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< signed char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< bool > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const volatile > : ::boost::integral_constant<bool,true> { };





template<> struct is_integral< wchar_t > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const volatile > : ::boost::integral_constant<bool,true> { };
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_integral.hpp"
template<> struct is_integral< ::boost::ulong_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< ::boost::long_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const volatile > : ::boost::integral_constant<bool,true> { };







}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_integral.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_float.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_float.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_float.hpp" 2

namespace boost {


template< typename T > struct is_float : ::boost::integral_constant<bool,false> { };
template<> struct is_float< float > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< long double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const volatile > : ::boost::integral_constant<bool,true> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_float.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_or.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_or.hpp"
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};

template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};

}
}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp" 2

namespace boost {


namespace detail {

template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value)



                  ;
};

}






template< typename T > struct is_arithmetic : ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_arithmetic.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/call_traits.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/config.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp"
namespace boost {
namespace type_traits {

template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};





template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };



template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };


template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };



template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
# 776 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp"
}
}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/cv_traits_impl.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/cv_traits_impl.hpp"
namespace boost {
namespace detail {







template <typename T> struct cv_traits_imp {};

template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
# 92 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/cv_traits_impl.hpp"
}
}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp" 2

namespace boost {

namespace detail{

template <class T>
struct rvalue_ref_filter_rem_cv
{
 typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
};
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp"
}




template< typename T > struct remove_cv { typedef typename boost::detail::rvalue_ref_filter_rem_cv<T>::type type; };
template< typename T > struct remove_cv<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_cv<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { typedef T type[N]; };
# 79 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 82 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_cv.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp" 2

namespace boost {





template< typename T > struct is_member_function_pointer : ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value> { };
# 132 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 135 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_function_pointer.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp" 2
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp" 2

namespace boost {
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp"
template< typename T > struct is_member_pointer : ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { };
template< typename T, typename U > struct is_member_pointer< U T::* > : ::boost::integral_constant<bool,true> { };


template< typename T, typename U > struct is_member_pointer< U T::*const > : ::boost::integral_constant<bool,true> { };
template< typename T, typename U > struct is_member_pointer< U T::*volatile > : ::boost::integral_constant<bool,true> { };
template< typename T, typename U > struct is_member_pointer< U T::*const volatile > : ::boost::integral_constant<bool,true> { };
# 112 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 115 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_member_pointer.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_and.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_and.hpp"
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};

template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};

}
}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_not.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_not.hpp"
namespace boost {
namespace type_traits {

template <bool b>
struct ice_not
{
    static const bool value = true;
};

template <>
struct ice_not<true>
{
    static const bool value = false;
};

}
}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp" 2
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp" 2

namespace boost {





namespace detail {

template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp"
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };



template< typename T >
struct is_pointer_impl
{
# 80 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp"
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value)






         ;

};

}

template< typename T > struct is_pointer : ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { };
# 158 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 161 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pointer.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/call_traits.hpp" 2


namespace boost{

namespace detail{

template <typename T, bool small_>
struct ct_imp2
{
   typedef const T& param_type;
};

template <typename T>
struct ct_imp2<T, true>
{
   typedef const T param_type;
};

template <typename T, bool isp, bool b1>
struct ct_imp
{
   typedef const T& param_type;
};

template <typename T, bool isp>
struct ct_imp<T, isp, true>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};

template <typename T, bool b1>
struct ct_imp<T, true, b1>
{
   typedef const T param_type;
};

}

template <typename T>
struct call_traits
{
public:
   typedef T value_type;
   typedef T& reference;
   typedef const T& const_reference;






   typedef typename boost::detail::ct_imp<
      T,
      ::boost::is_pointer<T>::value,
      ::boost::is_arithmetic<T>::value
   >::param_type param_type;
};

template <typename T>
struct call_traits<T&>
{
   typedef T& value_type;
   typedef T& reference;
   typedef const T& const_reference;
   typedef T& param_type;
};
# 135 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/call_traits.hpp"
template <typename T, std::size_t N>
struct call_traits<T [N]>
{
private:
   typedef T array_type[N];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};

template <typename T, std::size_t N>
struct call_traits<const T [N]>
{
private:
   typedef const T array_type[N];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};


}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/call_traits.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/reference_content.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/reference_content.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_copy.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_copy.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_copy.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_copy.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/intrinsics.hpp" 1
# 131 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/intrinsics.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_same.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_same.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_same.hpp" 2

namespace boost {



template< typename T, typename U > struct is_same : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_same< T,T > : ::boost::integral_constant<bool,true> { };
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_same.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_same.hpp" 2
# 132 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/intrinsics.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_lvalue_reference.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_lvalue_reference.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_lvalue_reference.hpp" 2

namespace boost {





template< typename T > struct is_lvalue_reference : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_lvalue_reference< T& > : ::boost::integral_constant<bool,true> { };
# 113 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_lvalue_reference.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 116 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_lvalue_reference.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_rvalue_reference.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_rvalue_reference.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_rvalue_reference.hpp" 2

namespace boost {

template< typename T > struct is_rvalue_reference : ::boost::integral_constant<bool,false> { };




}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_rvalue_reference.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/ice.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/ice.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/yes_no_type.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/yes_no_type.hpp"
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/ice.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_eq.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/ice_eq.hpp"
namespace boost {
namespace type_traits {

template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};

template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};


template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;


}
}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/ice.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct is_reference_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value >::value)


                 ;
};

}

template< typename T > struct is_reference : ::boost::integral_constant<bool,::boost::detail::is_reference_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_reference.hpp" 2
# 133 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/intrinsics.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_volatile.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_volatile.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_volatile.hpp" 2

namespace boost {

namespace detail{
template <class T>
struct is_volatile_rval_filter
{



 static const bool value = ::boost::detail::cv_traits_imp<T*>::is_volatile;

};
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_volatile.hpp"
}






template< typename T > struct is_volatile : ::boost::integral_constant<bool,::boost::detail::is_volatile_rval_filter<T>::value> { };
template< typename T > struct is_volatile< T& > : ::boost::integral_constant<bool,false> { };
# 148 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_volatile.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 151 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_volatile.hpp" 2
# 134 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/intrinsics.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_copy.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_void.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_void.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_void.hpp" 2

namespace boost {





template< typename T > struct is_void : ::boost::integral_constant<bool,false> { };
template<> struct is_void< void > : ::boost::integral_constant<bool,true> { };


template<> struct is_void< void const > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void const volatile > : ::boost::integral_constant<bool,true> { };




}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_void.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_scalar.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_scalar.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_enum.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_enum.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_enum.hpp" 2

namespace boost {
# 181 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_enum.hpp"
template< typename T > struct is_enum : ::boost::integral_constant<bool,__is_enum(T)> { };



}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 188 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_enum.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_scalar.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_scalar.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value)





                ;
};



template <> struct is_scalar_impl<void>{ static const bool value = false; };

template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };


}

template< typename T > struct is_scalar : ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_scalar.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp" 2

namespace boost {


template< typename T > struct is_POD;

namespace detail {



template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, __is_pod(T) >::value)





                   ;
};


template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : is_pod_impl<T>
{
};
# 118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp"
template<> struct is_pod_impl< void > { static const bool value = (true); };


template<> struct is_pod_impl< void const > { static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { static const bool value = (true); };


}

template< typename T > struct is_POD : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };
template< typename T > struct is_pod : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 134 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_pod.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_copy.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_copy.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_copy_impl
{
   static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_pod<T>::value, (__has_trivial_copy(T) && !is_reference<T>::value) >::value, ::boost::type_traits::ice_not< ::boost::is_volatile<T>::value >::value >::value)






                ;
};

}

template< typename T > struct has_trivial_copy : ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { };
template< typename T > struct has_trivial_copy_constructor : ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_copy.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_copy.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_copy.hpp" 2

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_copy_imp{
   static const bool value = (::boost::type_traits::ice_or< ::boost::has_trivial_copy<T>::value, (__has_nothrow_copy(T) && !is_volatile<T>::value && !is_reference<T>::value) >::value)



                ;
};

}

template< typename T > struct has_nothrow_copy : ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { };
template< typename T > struct has_nothrow_copy_constructor : ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_copy.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/reference_content.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/void.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/void.hpp"
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/reference_content.hpp" 2

namespace boost {

namespace detail {






template <typename RefT>
class reference_content
{
private:

    RefT content_;

public:

    ~reference_content()
    {
    }

    reference_content(RefT r)
        : content_( r )
    {
    }

    reference_content(const reference_content& operand)
        : content_( operand.content_ )
    {
    }

private:

    reference_content& operator=(const reference_content&);

public:

    RefT get() const
    {
        return content_;
    }

};







template <typename T = mpl::void_> struct make_reference_content;



template <typename T>
struct make_reference_content
{
    typedef T type;
};

template <typename T>
struct make_reference_content< T& >
{
    typedef reference_content<T&> type;
};
# 109 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/reference_content.hpp"
template <>
struct make_reference_content< mpl::void_ >
{
    template <typename T>
    struct apply
        : make_reference_content<T>
    {
    };

    typedef mpl::void_ type;
};

}







template <typename T>
struct has_nothrow_copy<
      ::boost::detail::reference_content< T& >
    >
    : mpl::true_
{
};



}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp" 1
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp" 2

namespace boost {
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp"
template <typename T> class recursive_wrapper;







namespace detail {



template <typename T>
struct is_recursive_wrapper_impl
    : mpl::false_
{
};

template <typename T>
struct is_recursive_wrapper_impl< recursive_wrapper<T> >
    : mpl::true_
{
};
# 96 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp"
}

template< typename T > struct is_recursive_wrapper : ::boost::integral_constant<bool,(::boost::detail::is_recursive_wrapper_impl<T>::value)> { };
# 112 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp"
template <typename T>
struct unwrap_recursive
{
    typedef T type;

   
};

template <typename T>
struct unwrap_recursive< recursive_wrapper<T> >
{
    typedef T type;

   
};
# 143 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 146 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper_fwd.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;

template< typename Sequence > struct begin;
template< typename Sequence > struct end;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag_fwd.hpp"
namespace boost { namespace mpl {

struct nested_begin_end_tag;
struct non_sequence_tag;

template< typename Sequence > struct sequence_tag;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/eval_if.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/eval_if.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/if.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/if.hpp"
namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;

   
};
# 131 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/if.hpp"
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/eval_if.hpp" 2






namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;




   
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_begin.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_begin.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_xxx.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_xxx.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/has_xxx.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_xxx.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/msvc_typename.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_xxx.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/array/elem.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/array/elem.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/array/data.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/array/elem.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/array/size.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/array/elem.hpp" 2
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_xxx.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 1
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_xxx.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_begin.hpp" 2

namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/traits_lambda_spec.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp" 2


namespace boost { namespace mpl {


namespace aux {

template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};

}





template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};

template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
# 82 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/begin_end_impl.hpp"
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };




template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };







}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_tag.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_tag.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/is_msvc_eti_arg.hpp"
namespace boost { namespace mpl { namespace aux {
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/is_msvc_eti_arg.hpp"
}}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag.hpp" 2




namespace boost { namespace mpl {
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag.hpp"
namespace aux {

template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{


    template< typename Sequence > struct result2_;
};
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sequence_tag.hpp"
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };



}

template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};



template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/begin_end.hpp" 2



namespace boost { namespace mpl {




template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/O1_size.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/O1_size.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/O1_size_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/O1_size_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/O1_size.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/long.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/long.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/long_fwd.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/long_fwd.hpp"
namespace mpl_ {

template< long N > struct long_;

}
namespace boost { namespace mpl { using ::mpl_::long_; } }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/long.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< long N >
struct long_
{
    static const long value = N;





    typedef long_ type;

    typedef long value_type;
    typedef integral_c_tag tag;
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;






    operator long() const { return static_cast<long>(this->value); }
};


template< long N >
long const mpl_::long_< N >::value;


}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/long.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_size.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_size.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_size { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::size>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/forwarding.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp" 2




namespace boost { namespace mpl {
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp"
namespace aux {
template< typename Sequence > struct O1_size_impl
    : Sequence::size
{
};
}

template< typename Tag >
struct O1_size_impl
{
    template< typename Sequence > struct apply

        : if_<
              aux::has_size<Sequence>
            , aux::O1_size_impl<Sequence>
            , long_<-1>
            >::type
    {
# 69 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp"
    };
};
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/O1_size_impl.hpp"
}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/O1_size.hpp" 2



namespace boost { namespace mpl {


template<
      typename Sequence = na
    >
struct O1_size
    : O1_size_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct O1_size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : O1_size< T1 > { }; }; template< typename Tag > struct lambda< O1_size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef O1_size< na > result_; typedef O1_size< na > type; }; namespace aux { template< typename T1 > struct template_arity< O1_size< T1 > > : int_<1> { }; template<> struct template_arity< O1_size< na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind_fwd.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/bind.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind_fwd.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp"
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind_fwd.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp" 2
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp"
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/next.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/next.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/next_prior.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/next_prior.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/common_name_wknd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/next_prior.hpp" 2



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/next.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/protect.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/protect.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/protect.hpp"
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_apply.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_apply.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/has_apply.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_apply.hpp" 2

namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_never_true.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp"
namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 2
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp"
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind_fwd.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/quote.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/quote.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_type.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_type.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/quote.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/bcc.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/quote.hpp" 2
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/quote.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp"
namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/quote.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/template_arity.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp" 2
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp"
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/full_lambda.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/lambda.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_impl.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_fwd.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp"
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_fwd.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp"
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{
   




};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   




};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   




};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   




};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_impl.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,state3,iter3 >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl
{
    typedef iter_fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef iter_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,First,Last,State,ForwardOp >
    : iter_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2< ForwardOp,State,First >::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_impl.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct iter_fold
{
    typedef typename aux::iter_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , typename lambda<ForwardOp>::type
        >::state type;

   
};

template<> struct iter_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : iter_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< iter_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold< na , na , na > result_; typedef iter_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< iter_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< iter_fold< na , na , na > > : int_<-1> { }; }

}}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/deref.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/deref.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_type.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_type.hpp"
namespace boost { namespace mpl { namespace aux {
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_type.hpp"
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};

template<> struct msvc_type<int>
{
    typedef int type;
};



}}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/deref.hpp" 2




namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct deref
{

    typedef typename Iterator::type type;



   
};

template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }

}}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_eti_base.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_eti_base.hpp"
namespace boost { namespace mpl { namespace aux {
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/msvc_eti_base.hpp"
template< typename T > struct msvc_eti_base
    : T
{

    msvc_eti_base();

    typedef T type;
};



template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};

}}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair.hpp" 2




namespace boost { namespace mpl {

template<
      typename T1 = na
    , typename T2 = na
    >
struct pair
{
    typedef pair type;
    typedef T1 first;
    typedef T2 second;

   
};

template<
      typename P = na
    >
struct first
{

    typedef typename P::first type;



   
};

template<
      typename P = na
    >
struct second
{

    typedef typename P::second type;



   
};


template<> struct pair< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pair< T1 , T2 > { }; }; template< typename Tag > struct lambda< pair< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef pair< na , na > result_; typedef pair< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< pair< T1 , T2 > > : int_<2> { }; template<> struct template_arity< pair< na , na > > : int_<-1> { }; }
template<> struct first< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : first< T1 > { }; }; template< typename Tag > struct lambda< first< na > , Tag , int_<-1> > { typedef false_ is_le; typedef first< na > result_; typedef first< na > type; }; namespace aux { template< typename T1 > struct template_arity< first< T1 > > : int_<1> { }; template<> struct template_arity< first< na > > : int_<-1> { }; }
template<> struct second< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : second< T1 > { }; }; template< typename Tag > struct lambda< second< na > , Tag , int_<-1> > { typedef false_ is_le; typedef second< na > result_; typedef second< na > type; }; namespace aux { template< typename T1 > struct template_arity< second< T1 > > : int_<1> { }; template<> struct template_arity< second< na > > : int_<-1> { }; }

}}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp" 2
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp"
namespace boost {
namespace detail { namespace variant {
# 61 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp"
struct make_initializer_node
{
    template <typename BaseIndexPair, typename Iterator>
    struct apply
    {
    private:

        typedef typename BaseIndexPair::first
            base;
        typedef typename BaseIndexPair::second
            index;

        class initializer_node
            : public base
        {
        private:

            typedef typename mpl::deref<Iterator>::type
                recursive_enabled_T;
            typedef typename unwrap_recursive<recursive_enabled_T>::type
                public_T;
            typedef typename call_traits<public_T>::param_type
                param_T;

        public:

            using base::initialize;

            static int initialize(void* dest, param_T operand)
            {
                typedef typename boost::detail::make_reference_content<
                      recursive_enabled_T
                    >::type internal_T;

                new(dest) internal_T(operand);
                return index::value;
            }

        };

        friend class initializer_node;

    public:

        typedef mpl::pair<
              initializer_node
            , typename mpl::next< index >::type
            > type;

    };
};






class initializer_root
{
public:

    static void initialize();

};
# 204 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/initializer.hpp"
}}
}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/make_variant_list.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/make_variant_list.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list20.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list20.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list10.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list10.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_front.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_front.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_front_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_front_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_front.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/item.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/item.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/tag.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/tag.hpp"
namespace boost { namespace mpl { namespace aux {

struct list_tag;
struct l_iter_tag;

}}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/item.hpp" 2



namespace boost { namespace mpl {

template<
      typename Size
    , typename T
    , typename Next
    >
struct l_item
{




    typedef aux::list_tag tag;
    typedef l_item type;

    typedef Size size;
    typedef T item;
    typedef Next next;
};

struct l_end
{



    typedef aux::list_tag tag;
    typedef l_end type;
    typedef long_<0> size;
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_front.hpp" 2


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::list_tag >
{
    template< typename List, typename T > struct apply
    {
        typedef l_item<
              typename next<typename List::size>::type
            , T
            , typename List::type
            > type;
    };
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/pop_front.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/pop_front.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pop_front_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pop_front_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/pop_front.hpp" 2



namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename mpl::next<List>::type type;
    };
};

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_back.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_back.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_back_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_back_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/push_back.hpp" 2



namespace boost { namespace mpl {

template< typename Tag > struct has_push_back_impl;

template<>
struct has_push_back_impl< aux::list_tag >
{
    template< typename Seq > struct apply
        : false_
    {
    };
};

}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/front.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/front.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct front_impl;
template< typename Sequence > struct front;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/front.hpp" 2


namespace boost { namespace mpl {

template<>
struct front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename List::item type;
    };
};

}}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/clear.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/clear.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/clear_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/clear_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/clear.hpp" 2



namespace boost { namespace mpl {

template<>
struct clear_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_end type;
    };
};

}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/O1_size.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/O1_size.hpp"
namespace boost { namespace mpl {

template<>
struct O1_size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/size.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/size.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct size_impl;
template< typename Sequence > struct size;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/size.hpp" 2


namespace boost { namespace mpl {

template<>
struct size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/empty.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/empty.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/empty_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/empty_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/empty.hpp" 2



namespace boost { namespace mpl {

template<>
struct empty_impl< aux::list_tag >
{
    template< typename List > struct apply
        : not_<typename List::size>
    {
    };
};

}}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/begin_end.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/begin_end.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/iterator.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/iterator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iterator_tags.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iterator_tags.hpp"
namespace boost { namespace mpl {

struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/iterator.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/lambda_spec.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/iterator.hpp" 2


namespace boost { namespace mpl {



template< typename Node >
struct l_iter
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;
};

template< typename Node >
struct deref< l_iter<Node> >
{
    typedef typename Node::item type;
};

template< typename Node >
struct next< l_iter<Node> >
{
    typedef l_iter< typename Node::next > type;
};
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/iterator.hpp"
template<> struct l_iter<l_end>
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;




};

template< typename T1 , typename Tag > struct lambda< l_iter< T1 > , Tag , int_<1> > { typedef false_ is_le; typedef l_iter< T1 > result_; typedef result_ type; };

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/begin_end.hpp" 2



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_iter<typename List::type> type;
    };
};

template<>
struct end_impl< aux::list_tag >
{
    template< typename > struct apply
    {
        typedef l_iter<l_end> type;
    };
};

}}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list0.hpp" 2


namespace boost { namespace mpl {

template< typename Dummy = na > struct list0;

template<> struct list0<na>
    : l_end
{
    typedef l_end type;
};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list10.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list10.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp"
namespace boost { namespace mpl {

template<
      typename T0
    >
struct list1
    : l_item<
          long_<1>
        , T0
        , l_end
        >
{
    typedef list1 type;
};

template<
      typename T0, typename T1
    >
struct list2
    : l_item<
          long_<2>
        , T0
        , list1<T1>
        >
{
    typedef list2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list3
    : l_item<
          long_<3>
        , T0
        , list2< T1,T2 >
        >
{
    typedef list3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list4
    : l_item<
          long_<4>
        , T0
        , list3< T1,T2,T3 >
        >
{
    typedef list4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list5
    : l_item<
          long_<5>
        , T0
        , list4< T1,T2,T3,T4 >
        >
{
    typedef list5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list6
    : l_item<
          long_<6>
        , T0
        , list5< T1,T2,T3,T4,T5 >
        >
{
    typedef list6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list7
    : l_item<
          long_<7>
        , T0
        , list6< T1,T2,T3,T4,T5,T6 >
        >
{
    typedef list7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list8
    : l_item<
          long_<8>
        , T0
        , list7< T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef list8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list9
    : l_item<
          long_<9>
        , T0
        , list8< T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef list9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list10
    : l_item<
          long_<10>
        , T0
        , list9< T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef list10 type;
};

}}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list10.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list20.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list20.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp"
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list11
    : l_item<
          long_<11>
        , T0
        , list10< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef list11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list12
    : l_item<
          long_<12>
        , T0
        , list11< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef list12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list13
    : l_item<
          long_<13>
        , T0
        , list12< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef list13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list14
    : l_item<
          long_<14>
        , T0
        , list13< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef list14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list15
    : l_item<
          long_<15>
        , T0
        , list14< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef list15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list16
    : l_item<
          long_<16>
        , T0
        , list15< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef list16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list17
    : l_item<
          long_<17>
        , T0
        , list16< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef list17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list18
    : l_item<
          long_<18>
        , T0
        , list17< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef list18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list19
    : l_item<
          long_<19>
        , T0
        , list18< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef list19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list20
    : l_item<
          long_<20>
        , T0
        , list19< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef list20 type;
};

}}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list/list20.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list.hpp" 2
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/list.hpp"
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct list;

template<

    >
struct list<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list0< >
{
    typedef list0< >::type type;
};

template<
      typename T0
    >
struct list<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list1<T0>
{
    typedef typename list1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct list<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list2< T0,T1 >
{
    typedef typename list2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list3< T0,T1,T2 >
{
    typedef typename list3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list4< T0,T1,T2,T3 >
{
    typedef typename list4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list5< T0,T1,T2,T3,T4 >
{
    typedef typename list5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename list6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename list7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename list8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : list15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename list15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : list16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename list16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : list17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename list17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : list18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename list18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : list19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename list19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list
    : list20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename list20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/list.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/make_variant_list.hpp" 2



namespace boost {
namespace detail { namespace variant {
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/make_variant_list.hpp"
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
struct make_variant_list
{
public:






    typedef typename mpl::list<
         



 typename convert_void< T0 >::type , typename convert_void< T1 >::type , typename convert_void< T2 >::type , typename convert_void< T3 >::type , typename convert_void< T4 >::type , typename convert_void< T5 >::type , typename convert_void< T6 >::type , typename convert_void< T7 >::type , typename convert_void< T8 >::type , typename convert_void< T9 >::type , typename convert_void< T10 >::type , typename convert_void< T11 >::type , typename convert_void< T12 >::type , typename convert_void< T13 >::type , typename convert_void< T14 >::type , typename convert_void< T15 >::type , typename convert_void< T16 >::type , typename convert_void< T17 >::type , typename convert_void< T18 >::type , typename convert_void< T19 >::type
        >::type type;




};

}}
}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/over_sequence.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/over_sequence.hpp"
namespace boost {
namespace detail { namespace variant {






template <typename Types>
struct over_sequence
{
    typedef Types type;
};
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/over_sequence.hpp"
template <typename T>
struct is_over_sequence
    : mpl::false_
{
};

template <typename Types>
struct is_over_sequence< over_sequence<Types> >
    : mpl::true_
{
};
# 92 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/over_sequence.hpp"
}}
}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/cast_storage.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/cast_storage.hpp"
namespace boost {
namespace detail { namespace variant {







template <typename T>
inline T& cast_storage(
      void* storage
     
    )
{
    return *static_cast<T*>(storage);
}

template <typename T>
inline const T& cast_storage(
      const void* storage
     
    )
{
    return *static_cast<const T*>(storage);
}

}}
}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/identity.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/identity.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/or.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/or.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/or.hpp"
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct or_<



 na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/or.hpp" 2
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_assign.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_assign.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_const.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_const.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_const.hpp" 2

namespace boost {







namespace detail{




template <class T>
struct is_const_rvalue_filter
{



 static const bool value = ::boost::detail::cv_traits_imp<T*>::is_const;

};







}


template< typename T > struct is_const : ::boost::integral_constant<bool,::boost::detail::is_const_rvalue_filter<T>::value> { };
template< typename T > struct is_const< T& > : ::boost::integral_constant<bool,false> { };
# 160 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_const.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 163 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_const.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_assign.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_assign.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_assign_impl
{
   static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_assign(T) >::value, ::boost::type_traits::ice_not< ::boost::is_const<T>::value >::value, ::boost::type_traits::ice_not< ::boost::is_volatile<T>::value >::value >::value)







                ;
};

}

template< typename T > struct has_trivial_assign : ::boost::integral_constant<bool,::boost::detail::has_trivial_assign_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_assign.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/and.hpp" 1
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/and.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/and.hpp"
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct and_<



 na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/and.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_def.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_def.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp" 2

namespace boost {
namespace detail { namespace variant {



template <typename T>
struct has_trivial_move_impl
{
    static const bool value = ( ::boost::mpl::and_< has_trivial_copy<T> , has_trivial_assign<T> >::type::value )






         ;
};

template< typename T > struct has_trivial_move : ::boost::integral_constant<bool,(::boost::detail::variant::has_trivial_move_impl<T>::value)> { };
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp"
template <typename T>
struct has_trivial_move_constructor_impl
{
    static const bool value = ( ::boost::mpl::or_< has_trivial_move<T> , has_trivial_copy<T> >::type::value )






         ;
};

template< typename T > struct has_trivial_move_constructor : ::boost::integral_constant<bool,(::boost::detail::variant::has_trivial_move_constructor_impl<T>::value)> { };
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp"
template <typename T>
struct has_trivial_move_assign_impl
{
    static const bool value = ( ::boost::mpl::or_< has_trivial_move<T> , has_trivial_assign<T> >::type::value )






         ;
};

template< typename T > struct has_trivial_move_assign : ::boost::integral_constant<bool,(::boost::detail::variant::has_trivial_move_assign_impl<T>::value)> { };





}}





}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_undef.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_undef.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_undef.hpp" 2
# 99 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_trivial_move.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_assign.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_assign.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_assign.hpp" 2

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_assign_imp{
   static const bool value = (::boost::type_traits::ice_or< ::boost::has_trivial_assign<T>::value, (__has_nothrow_assign(T) && !is_volatile<T>::value) >::value)



                ;
};

}

template< typename T > struct has_nothrow_assign : ::boost::integral_constant<bool,::boost::detail::has_nothrow_assign_imp<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_assign.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_def.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_def.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp" 2

namespace boost {
namespace detail { namespace variant {



template <typename T>
struct has_nothrow_move_impl
{
    static const bool value = ( ::boost::mpl::or_< has_trivial_move<T> , ::boost::mpl::and_< has_nothrow_copy<T> , has_nothrow_assign<T> > >::type::value )
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp"
         ;
};

template< typename T > struct has_nothrow_move : ::boost::integral_constant<bool,(::boost::detail::variant::has_nothrow_move_impl<T>::value)> { };
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp"
template <typename T>
struct has_nothrow_move_constructor_impl
{
    static const bool value = ( ::boost::mpl::or_< has_nothrow_move<T> , has_trivial_move_constructor<T> , has_nothrow_copy<T> >::type::value )







         ;
};

template< typename T > struct has_nothrow_move_constructor : ::boost::integral_constant<bool,(::boost::detail::variant::has_nothrow_move_constructor_impl<T>::value)> { };
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp"
template <typename T>
struct has_nothrow_move_assign_impl
{
    static const bool value = ( ::boost::mpl::or_< has_nothrow_move<T> , has_trivial_move_assign<T> , has_nothrow_assign<T> >::type::value )







         ;
};

template< typename T > struct has_nothrow_move_assign : ::boost::integral_constant<bool,(::boost::detail::variant::has_nothrow_move_assign_impl<T>::value)> { };





}}





}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_undef.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_undef.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/bool_trait_undef.hpp" 2
# 105 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/has_nothrow_move.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp" 2
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp"
namespace boost {
namespace detail { namespace variant {






struct apply_visitor_unrolled {};
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp"
template <typename Iter, typename LastIter>
struct visitation_impl_step
{
    typedef typename mpl::deref<Iter>::type type;

    typedef typename mpl::next<Iter>::type next_iter;
    typedef visitation_impl_step<
          next_iter, LastIter
        > next;
};

template <typename LastIter>
struct visitation_impl_step< LastIter,LastIter >
{
    typedef apply_visitor_unrolled type;
    typedef visitation_impl_step next;
};
# 120 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp"
template <typename Visitor, typename VoidPtrCV, typename T>
inline
    typename Visitor::result_type
visitation_impl_invoke_impl(
      int, Visitor& visitor, VoidPtrCV storage, T*
    , mpl::true_
    )
{
    return visitor.internal_visit(
          cast_storage<T>(storage), 1L
        );
}

template <typename Visitor, typename VoidPtrCV, typename T>
inline
    typename Visitor::result_type
visitation_impl_invoke_impl(
      int internal_which, Visitor& visitor, VoidPtrCV storage, T*
    , mpl::false_
    )
{
    if (internal_which >= 0)
    {
        return visitor.internal_visit(
              cast_storage<T>(storage), 1L
            );
    }
    else
    {
        return visitor.internal_visit(
              cast_storage< backup_holder<T> >(storage), 1L
            );
    }
}

template <typename Visitor, typename VoidPtrCV, typename T, typename NoBackupFlag>
inline
    typename Visitor::result_type
visitation_impl_invoke(
      int internal_which, Visitor& visitor, VoidPtrCV storage, T* t
    , NoBackupFlag
    , int
    )
{
    typedef typename mpl::or_<
          NoBackupFlag
        , has_nothrow_move_constructor<T>
        , has_nothrow_copy<T>
        >::type never_uses_backup;

    return visitation_impl_invoke_impl(
          internal_which, visitor, storage, t
        , never_uses_backup()
        );
}

template <typename Visitor, typename VoidPtrCV, typename NBF>
inline
    typename Visitor::result_type
visitation_impl_invoke(int, Visitor&, VoidPtrCV, apply_visitor_unrolled*, NBF, long)
{

    ((false) ? static_cast<void> (0) : __assert_fail ("false", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp", 182, __PRETTY_FUNCTION__));
    typedef typename Visitor::result_type result_type;
    return ::boost::detail::variant::forced_return< result_type >();
}







template <
      typename W, typename S
    , typename Visitor, typename VPCV
    , typename NBF
    >
inline
    typename Visitor::result_type
visitation_impl(
      int, int, Visitor&, VPCV
    , mpl::true_
    , NBF, W* = 0, S* = 0
    )
{

    ((false) ? static_cast<void> (0) : __assert_fail ("false", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp", 207, __PRETTY_FUNCTION__));
    typedef typename Visitor::result_type result_type;
    return ::boost::detail::variant::forced_return< result_type >();
}

template <
      typename Which, typename step0
    , typename Visitor, typename VoidPtrCV
    , typename NoBackupFlag
    >
inline
    typename Visitor::result_type
visitation_impl(
      const int internal_which, const int logical_which
    , Visitor& visitor, VoidPtrCV storage
    , mpl::false_
    , NoBackupFlag no_backup_flag
    , Which* = 0, step0* = 0
    )
{







   



 typedef typename step0::type T0; typedef typename step0::next step1; typedef typename step1::type T1; typedef typename step1::next step2; typedef typename step2::type T2; typedef typename step2::next step3; typedef typename step3::type T3; typedef typename step3::next step4; typedef typename step4::type T4; typedef typename step4::next step5; typedef typename step5::type T5; typedef typename step5::next step6; typedef typename step6::type T6; typedef typename step6::next step7; typedef typename step7::type T7; typedef typename step7::next step8; typedef typename step8::type T8; typedef typename step8::next step9; typedef typename step9::type T9; typedef typename step9::next step10; typedef typename step10::type T10; typedef typename step10::next step11; typedef typename step11::type T11; typedef typename step11::next step12; typedef typename step12::type T12; typedef typename step12::next step13; typedef typename step13::type T13; typedef typename step13::next step14; typedef typename step14::type T14; typedef typename step14::next step15; typedef typename step15::type T15; typedef typename step15::next step16; typedef typename step16::type T16; typedef typename step16::next step17; typedef typename step17::type T17; typedef typename step17::next step18; typedef typename step18::type T18; typedef typename step18::next step19; typedef typename step19::type T19; typedef typename step19::next step20;




    switch (logical_which)
    {
# 256 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/visitation_impl.hpp"
   



 case (Which::value + (0)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T0*>(0) , no_backup_flag, 1L ); case (Which::value + (1)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T1*>(0) , no_backup_flag, 1L ); case (Which::value + (2)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T2*>(0) , no_backup_flag, 1L ); case (Which::value + (3)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T3*>(0) , no_backup_flag, 1L ); case (Which::value + (4)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T4*>(0) , no_backup_flag, 1L ); case (Which::value + (5)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T5*>(0) , no_backup_flag, 1L ); case (Which::value + (6)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T6*>(0) , no_backup_flag, 1L ); case (Which::value + (7)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T7*>(0) , no_backup_flag, 1L ); case (Which::value + (8)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T8*>(0) , no_backup_flag, 1L ); case (Which::value + (9)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T9*>(0) , no_backup_flag, 1L ); case (Which::value + (10)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T10*>(0) , no_backup_flag, 1L ); case (Which::value + (11)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T11*>(0) , no_backup_flag, 1L ); case (Which::value + (12)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T12*>(0) , no_backup_flag, 1L ); case (Which::value + (13)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T13*>(0) , no_backup_flag, 1L ); case (Which::value + (14)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T14*>(0) , no_backup_flag, 1L ); case (Which::value + (15)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T15*>(0) , no_backup_flag, 1L ); case (Which::value + (16)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T16*>(0) , no_backup_flag, 1L ); case (Which::value + (17)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T17*>(0) , no_backup_flag, 1L ); case (Which::value + (18)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T18*>(0) , no_backup_flag, 1L ); case (Which::value + (19)): return visitation_impl_invoke( internal_which, visitor, storage , static_cast<T19*>(0) , no_backup_flag, 1L );



    }


    typedef mpl::int_<
          Which::value + (20)
        > next_which;

    typedef step20
        next_step;

    typedef typename next_step::type next_type;
    typedef typename is_same< next_type,apply_visitor_unrolled >::type
        is_apply_visitor_unrolled;

    return visitation_impl(
          internal_which, logical_which
        , visitor, storage
        , is_apply_visitor_unrolled()
        , no_backup_flag
        , static_cast<next_which*>(0), static_cast<next_step*>(0)
        );
}

}}
}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 1 3
# 58 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 3
       
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 2 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ios" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ios" 3
       
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ios" 3





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    locale() throw();
# 126 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 164 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 176 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 190 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 205 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 224 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 252 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 268 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 303 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 337 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 368 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 432 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 575 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 592 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 609 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 636 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 650 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 667 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 686 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 700 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 729 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 745 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 758 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.tcc" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.tcc" 3
       
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);



}
# 816 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_classes.h" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 2 3
# 54 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 207 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 263 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 338 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 369 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 401 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 427 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 444 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 456 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 560 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 576 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 593 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 619 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 670 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 682 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 693 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 704 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 723 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 739 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 760 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 777 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ios" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
       
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
# 46 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 114 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 180 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 204 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 221 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 234 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 261 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 275 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 293 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 315 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 334 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 349 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 374 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 401 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 427 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 441 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 459 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 475 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 486 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 506 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 522 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 532 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 553 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 568 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 579 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 591 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 604 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual int
      sync() { return 0; }
# 626 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 642 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 664 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 677 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 701 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 719 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 745 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 760 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf.tcc" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf.tcc" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 800 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/streambuf" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ios" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 1 3
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
       
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 3




# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 1 3 4
# 34 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 2 3 4
# 50 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 72 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 172 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 214 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 47 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 2 3
# 76 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/ctype_base.h" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };

}
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 2 3






# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf_iterator.h" 1 3
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf_iterator.h" 3
       
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 49 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }



}
# 51 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 160 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 177 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 193 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 209 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 223 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 238 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 252 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 267 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 284 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 303 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 322 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 344 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 369 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 388 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 407 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 426 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 444 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 461 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 477 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 494 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 513 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 534 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 556 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 580 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 603 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 672 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 709 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 722 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 735 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 750 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 764 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 778 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 793 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 810 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 826 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 843 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 863 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 890 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 921 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 954 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1003 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1020 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1036 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1053 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1073 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1096 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1122 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1148 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1173 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1206 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1217 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1241 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1260 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1278 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1296 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1313 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1330 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1346 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1363 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1383 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1405 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1428 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1454 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

}
# 1510 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1635 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1672 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1686 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1700 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1713 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1744 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1757 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1770 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1787 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1799 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1812 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1825 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1838 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1908 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1929 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1955 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1991 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2050 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2092 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2163 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2228 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2246 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2267 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2285 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2327 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2390 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2415 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2463 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 1 3
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
       
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 136 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 730 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 966 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1027 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1189 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);



}
# 2602 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets.h" 2 3
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 126 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 137 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 190 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 211 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 246 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 284 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 296 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 336 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 350 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 379 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 399 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 419 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 438 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.tcc" 1 3
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.tcc" 3
       
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 145 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 472 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/basic_ios.h" 2 3
# 46 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ios" 2 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 81 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 164 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 249 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 282 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 310 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 323 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      flush();
# 334 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      pos_type
      tellp();
# 345 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 357 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 376 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 395 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 405 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 426 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 447 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 489 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 539 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 583 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 3
}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream.tcc" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream.tcc" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 587 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ostream" 2 3
# 66 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 90 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 166 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 238 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 248 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 280 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      int_type
      get();
# 294 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      get(char_type& __c);
# 321 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 332 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 355 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 365 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 394 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 405 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 429 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 446 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      int_type
      peek();
# 464 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 483 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 499 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      putback(char_type __c);
# 514 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      unget();
# 532 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      int
      sync();
# 546 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      pos_type
      tellg();
# 561 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      seekg(pos_type);
# 577 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 632 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 668 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 681 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
      operator bool() const
      { return _M_ok; }
    };
# 698 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 740 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 768 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 829 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 851 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 3
}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/istream.tcc" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/istream.tcc" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 855 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/istream" 2 3
# 67 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stream_iterator.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stream_iterator.h" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 150 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 181 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };



}
# 68 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iterator" 2 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_and_derived.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_and_derived.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_and_derived.hpp" 2

namespace boost {

namespace detail {
# 222 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_and_derived.hpp"
template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;

    static const bool value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value);
};

}

template< typename Base, typename Derived > struct is_base_and_derived : ::boost::integral_constant<bool,(::boost::detail::is_base_and_derived_impl<Base,Derived>::value)> { };







template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_and_derived< Base,Derived& > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived& > : ::boost::integral_constant<bool,false> { };






}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 253 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_and_derived.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp" 2

namespace boost {
namespace detail { namespace variant {






template <typename Deriving> class moveable;
template <typename T> class move_source;
template <typename T> class move_return;

namespace detail {







template <typename Deriving>
struct moveable_tag
{
};

}
# 64 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp"
namespace detail {





template <typename T>
struct move_type
{
public:

    typedef typename mpl::if_<
          is_base_and_derived<detail::moveable_tag<T>, T>
        , move_source<T>
        , T&
        >::type type;

};

}

template <typename T>
inline
    typename detail::move_type<T>::type
move(T& source)
{
    typedef typename detail::move_type<T>::type
        move_t;

    return move_t(source);
}






template <typename T>
struct return_t
{
public:

    typedef typename mpl::if_<
          is_base_and_derived<moveable<T>, T>
        , move_return<T>
        , T
        >::type type;

};
# 128 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp"
template <typename T>
inline void move_swap(T& lhs, T& rhs)
{
    T tmp( boost::detail::variant::move(lhs) );
    lhs = boost::detail::variant::move(rhs);
    rhs = boost::detail::variant::move(tmp);
}
# 160 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/move.hpp"
}}
}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/size_t_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/size_t_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/size_t_trait_def.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t_fwd.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t_fwd.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t_fwd.hpp" 2

namespace mpl_ {

template< std::size_t N > struct size_t;

}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;





    typedef size_t type;

    typedef std::size_t value_type;
    typedef integral_c_tag tag;
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;






    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};


template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;


}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size_t.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/size_t_trait_def.hpp" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/size_t_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp"
namespace boost {

template <typename T> struct alignment_of;


namespace detail {





template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};




template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp"
    static const std::size_t value = (::boost::detail::alignment_logic< sizeof(::boost::detail::alignment_of_hack<T>) - sizeof(T), sizeof(T) >::value)



                  ;
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp"
};

}

template< typename T > struct alignment_of : ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { };




template <typename T>
struct alignment_of<T&>
    : alignment_of<T*>
{
};
# 109 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp"
template<> struct alignment_of<void> : ::boost::integral_constant<std::size_t,0> { };

template<> struct alignment_of<void const> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void volatile> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void const volatile> : ::boost::integral_constant<std::size_t,0> { };


}
# 125 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1
# 126 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/alignment_of.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/for_each_i.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/for_each_i.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/for.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/for.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/for.hpp" 2
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/for.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/detail/for.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/for.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/for_each_i.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/tuple/to_list.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/transform.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/append.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/static_assert.hpp" 1
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/static_assert.hpp"
namespace boost{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };


template<int x> struct static_assert_test{};

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2






namespace boost {



namespace detail {

class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp"
template <bool found, std::size_t target, class TestType>
struct lower_alignment_helper
{
    typedef char type;
    enum { value = true };
};

template <std::size_t target, class TestType>
struct lower_alignment_helper<false,target,TestType>
{
    enum { value = (alignment_of<TestType>::value == target) };
    typedef typename mpl::if_c<value, TestType, char>::type type;
};
# 127 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp"
template <typename T>
struct has_one_T
{
  T data;
};

template <std::size_t target>
union lower_alignment
{
    enum { found0 = false };

   



 typename lower_alignment_helper< found0,target,char >::type t0; enum { found1 = lower_alignment_helper<found0,target,char >::value }; typename lower_alignment_helper< found1,target,short >::type t1; enum { found2 = lower_alignment_helper<found1,target,short >::value }; typename lower_alignment_helper< found2,target,int >::type t2; enum { found3 = lower_alignment_helper<found2,target,int >::value }; typename lower_alignment_helper< found3,target,long >::type t3; enum { found4 = lower_alignment_helper<found3,target,long >::value }; typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4; enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value }; typename lower_alignment_helper< found5,target,float >::type t5; enum { found6 = lower_alignment_helper<found5,target,float >::value }; typename lower_alignment_helper< found6,target,double >::type t6; enum { found7 = lower_alignment_helper<found6,target,double >::value }; typename lower_alignment_helper< found7,target,long double >::type t7; enum { found8 = lower_alignment_helper<found7,target,long double >::value }; typename lower_alignment_helper< found8,target,void* >::type t8; enum { found9 = lower_alignment_helper<found8,target,void* >::value }; typename lower_alignment_helper< found9,target,function_ptr >::type t9; enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value }; typename lower_alignment_helper< found10,target,member_ptr >::type t10; enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value }; typename lower_alignment_helper< found11,target,member_function_ptr >::type t11; enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value }; typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12; enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value }; typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13; enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value }; typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14; enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value }; typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15; enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value }; typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16; enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value }; typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17; enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value }; typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18; enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value }; typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19; enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value }; typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20; enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value }; typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21; enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value }; typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22; enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value }; typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23; enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };
};

union max_align
{
   



 char t0; short t1; int t2; long t3; ::boost::long_long_type t4; float t5; double t6; long double t7; void* t8; function_ptr t9; member_ptr t10; member_function_ptr t11; boost::detail::has_one_T< char > t12; boost::detail::has_one_T< short > t13; boost::detail::has_one_T< int > t14; boost::detail::has_one_T< long > t15; boost::detail::has_one_T< ::boost::long_long_type > t16; boost::detail::has_one_T< float > t17; boost::detail::has_one_T< double > t18; boost::detail::has_one_T< long double > t19; boost::detail::has_one_T< void* > t20; boost::detail::has_one_T< function_ptr > t21; boost::detail::has_one_T< member_ptr > t22; boost::detail::has_one_T< member_function_ptr > t23;
};
# 161 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp"
template<std::size_t TAlign, std::size_t Align>
struct is_aligned
{
    static const bool value = (TAlign >= Align) & (TAlign % Align == 0)

         ;
};
# 180 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp"
}


template<std::size_t Align>
struct is_pod< ::boost::detail::lower_alignment<Align> >
{
        static const std::size_t value = true;
};




namespace detail{

template <std::size_t Align>
class type_with_alignment_imp
{
    typedef ::boost::detail::lower_alignment<Align> t1;
    typedef typename mpl::if_c<
          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
        , t1
        , ::boost::detail::max_align
        >::type align_t;

    static const std::size_t found = alignment_of<align_t>::value;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found >= Align) == 0 ? false : true) >)> boost_static_assert_typedef_206;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found % Align == 0) == 0 ? false : true) >)> boost_static_assert_typedef_207;

 public:
    typedef align_t type;
};

}

template <std::size_t Align>
class type_with_alignment
  : public ::boost::detail::type_with_alignment_imp<Align>
{
};


namespace align {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
}

template<> class type_with_alignment<1> { public: typedef char type; };
template<> class type_with_alignment<2> { public: typedef align::a2 type; };
template<> class type_with_alignment<4> { public: typedef align::a4 type; };
template<> class type_with_alignment<8> { public: typedef align::a8 type; };
template<> class type_with_alignment<16> { public: typedef align::a16 type; };
template<> class type_with_alignment<32> { public: typedef align::a32 type; };

namespace detail {
template<> struct is_pod_impl< ::boost::align::a2 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a4 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a8 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a16 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a32 > { static const bool value = (true); };
}
# 383 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp"
}





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 390 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/type_with_alignment.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp" 2

namespace boost {

namespace detail { namespace aligned_storage {

static const std::size_t alignment_of_max_align = ::boost::alignment_of<max_align>::value


     ;




template <
      std::size_t size_
    , std::size_t alignment_
>
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];

        typename mpl::eval_if_c<
              alignment_ == std::size_t(-1)
            , mpl::identity<detail::max_align>
            , type_with_alignment<alignment_>
            >::type align_;
    } data_;
    void* address() const { return const_cast<aligned_storage_imp*>(this); }
};

template< std::size_t alignment_ >
struct aligned_storage_imp<0u,alignment_>
{

    void* address() const { return 0; }
};

}}

template <
      std::size_t size_
    , std::size_t alignment_ = std::size_t(-1)
>
class aligned_storage :

   private



   detail::aligned_storage::aligned_storage_imp<size_, alignment_>
{

public:

    typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;

    static const std::size_t size = size_


         ;
    static const std::size_t alignment = ( alignment_ == std::size_t(-1) ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_ )






         ;






private:

    aligned_storage(const aligned_storage&);
    aligned_storage& operator=(const aligned_storage&);
# 118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp"
public:

    aligned_storage()
    {
    }

    ~aligned_storage()
    {
    }

public:

    void* address()
    {
        return static_cast<type*>(this)->address();
    }



    const void* address() const
    {
        return static_cast<const type*>(this)->address();
    }







};
# 168 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp"
template <std::size_t size_, std::size_t alignment_>
struct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_,alignment_> >
   : ::boost::integral_constant<bool,true>
{
   
};



}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 180 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/aligned_storage.hpp" 2
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/templated_streams.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_array.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_array.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_array.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_array.hpp" 2

namespace boost {




template< typename T > struct is_array : ::boost::integral_constant<bool,false> { };

template< typename T, std::size_t N > struct is_array< T[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T volatile[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const volatile[N] > : ::boost::integral_constant<bool,true> { };

template< typename T > struct is_array< T[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T volatile[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const volatile[] > : ::boost::integral_constant<bool,true> { };
# 87 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_array.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 90 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_array.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_reference.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_reference.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_reference.hpp" 2

namespace boost {

namespace detail {
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_reference.hpp"
template <typename T>
struct add_reference_rvalue_layer
{
    typedef T& type;
};
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_reference.hpp"
template <typename T>
struct add_reference_impl
{
    typedef typename add_reference_rvalue_layer<T>::type type;
};


template< typename T > struct add_reference_impl<T&> { typedef T& type; };





template<> struct add_reference_impl<void> { typedef void type; };

template<> struct add_reference_impl<void const> { typedef void const type; };
template<> struct add_reference_impl<void volatile> { typedef void volatile type; };
template<> struct add_reference_impl<void const volatile> { typedef void const volatile type; };


}

template< typename T > struct add_reference { typedef typename boost::detail::add_reference_impl<T>::type type; };







}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 106 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_reference.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_abstract.hpp" 1
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_abstract.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_abstract.hpp" 2


namespace boost {
namespace detail{


template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
# 141 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_abstract.hpp"
}


template< typename T > struct is_abstract : ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { };




}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 152 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_abstract.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp" 2

namespace boost {
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
namespace detail {
# 119 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
struct any_conversion
{
    template <typename T> any_conversion(const volatile T&);
    template <typename T> any_conversion(T&);
};

template <typename T> struct checker
{
    static boost::type_traits::no_type _m_check(any_conversion ...);
    static boost::type_traits::yes_type _m_check(T, int);
};

template <typename From, typename To>
struct is_convertible_basic_impl
{
    static From _m_from;
    static bool const value = sizeof( boost::detail::checker<To>::_m_check(_m_from, 0) )
        == sizeof(::boost::type_traits::yes_type);
};
# 291 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
template <typename From, typename To>
struct is_convertible_impl
{
    typedef typename add_reference<From>::type ref_type;
    static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type,To>::value, ::boost::is_void<To>::value >::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value >::value >::value)
# 305 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
         ;
};


template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};

template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};

template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{

   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,

      ::boost::is_abstract<To>::value



   > selector;



   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};

template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
# 394 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
    template<> struct is_convertible_impl< void,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const volatile > { static const bool value = (true); };
# 404 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp"
template< typename To > struct is_convertible_impl< void,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void > { static const bool value = (true); };

template< typename To > struct is_convertible_impl< void const,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void volatile,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void const volatile,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void const > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void volatile > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void const volatile > { static const bool value = (true); };



}

template< typename From, typename To > struct is_convertible : ::boost::integral_constant<bool,(::boost::detail::is_convertible_impl_dispatch<From,To>::value)> { };







}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 429 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_convertible.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_class.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_class.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_class.hpp" 2

namespace boost {

namespace detail {
# 120 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_class.hpp"
template <typename T>
struct is_class_impl
{
    static const bool value = __is_class(T);
};


}





template< typename T > struct is_class : ::boost::integral_constant<bool,::boost::detail::is_class_impl<T>::value> { };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 139 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_class.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp" 2

namespace boost {

namespace detail {
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp"
template <typename T>
struct empty_helper_t1 : public T
{
    empty_helper_t1();
    int i[256];
private:

   empty_helper_t1(const empty_helper_t1&);
   empty_helper_t1& operator=(const empty_helper_t1&);
};





struct empty_helper_t2 { int i[256]; };



template <typename T, bool is_a_class = false>
struct empty_helper
{
    static const bool value = false;
};

template <typename T>
struct empty_helper<T, true>
{
    static const bool value = (sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2))

         ;
};

template <typename T>
struct is_empty_impl
{
    typedef typename remove_cv<T>::type cvt;
    static const bool value = ( ::boost::type_traits::ice_or< ::boost::detail::empty_helper<cvt,::boost::is_class<T>::value>::value , __is_empty(cvt) >::value )





              ;
};
# 205 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp"
template<> struct is_empty_impl< void > { static const bool value = (false); };

template<> struct is_empty_impl< void const > { static const bool value = (false); };
template<> struct is_empty_impl< void volatile > { static const bool value = (false); };
template<> struct is_empty_impl< void const volatile > { static const bool value = (false); };


}

template< typename T > struct is_empty : ::boost::integral_constant<bool,::boost::detail::is_empty_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 219 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_empty.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_stateless.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_stateless.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_constructor.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_constructor.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_constructor.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_ctor_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_constructor(T) >::value)



                ;
};

}

template< typename T > struct has_trivial_constructor : ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { };
template< typename T > struct has_trivial_default_constructor : ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_constructor.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_stateless.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_destructor.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_destructor.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_destructor.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_dtor_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_destructor(T) >::value)



                ;
};

}

template< typename T > struct has_trivial_destructor : ::boost::integral_constant<bool,::boost::detail::has_trivial_dtor_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_trivial_destructor.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_stateless.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_stateless.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct is_stateless_impl
{
  static const bool value = (::boost::type_traits::ice_and< ::boost::has_trivial_constructor<T>::value, ::boost::has_trivial_copy<T>::value, ::boost::has_trivial_destructor<T>::value, ::boost::is_class<T>::value, ::boost::is_empty<T>::value >::value)






               ;
};

}

template< typename T > struct is_stateless : ::boost::integral_constant<bool,::boost::detail::is_stateless_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_stateless.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/blank.hpp" 2

namespace boost {

struct blank
{
};




template <>
struct is_pod< blank >
    : mpl::true_
{
};

template <>
struct is_empty< blank >
    : mpl::true_
{
};

template <>
struct is_stateless< blank >
    : mpl::true_
{
};




inline bool operator==(const blank&, const blank&)
{
    return true;
}

inline bool operator<=(const blank&, const blank&)
{
    return true;
}

inline bool operator>=(const blank&, const blank&)
{
    return true;
}

inline bool operator!=(const blank&, const blank&)
{
    return false;
}

inline bool operator<(const blank&, const blank&)
{
    return false;
}

inline bool operator>(const blank&, const blank&)
{
    return false;
}





template < typename E , typename T >
inline std::basic_ostream< E , T >& operator<<(
      std::basic_ostream< E , T >& out
    , const blank&
    )
{

    return out;
}



}
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_const.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_const.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_const.hpp" 2

namespace boost {
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_const.hpp"
template< typename T > struct add_const { typedef T const type; };






template< typename T > struct add_const<T&> { typedef T& type; };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_const.hpp" 2
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_constructor.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_constructor.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_constructor.hpp" 2

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_constructor_imp{
   static const bool value = (::boost::type_traits::ice_or< ::boost::has_trivial_constructor<T>::value, __has_nothrow_constructor(T) >::value)



                ;
};

}

template< typename T > struct has_nothrow_constructor : ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { };
template< typename T > struct has_nothrow_default_constructor : ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/has_nothrow_constructor.hpp" 2
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/enable_if.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/enable_if.hpp"
namespace boost
{

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/static_visitor.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/static_visitor.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/static_visitor.hpp" 2

namespace boost {
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/static_visitor.hpp"
namespace detail {

    struct is_static_visitor_tag { };

    typedef void static_visitor_default_return;

}

template <typename R = ::boost::detail::static_visitor_default_return>
class static_visitor
    : public detail::is_static_visitor_tag
{
public:

    typedef R result_type;

protected:

    static_visitor() { }
    ~static_visitor() { }

};
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/static_visitor.hpp"
namespace detail {

template <typename T>
struct is_static_visitor_impl
{
    static const bool value = (::boost::is_base_and_derived< detail::is_static_visitor_tag, T >::value)



                  ;
};

}

template< typename T > struct is_static_visitor : ::boost::integral_constant<bool,(::boost::detail::is_static_visitor_impl<T>::value)> { };





}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 96 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/static_visitor.hpp" 2
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/empty.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/empty.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/empty_impl.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/empty_impl.hpp"
namespace boost { namespace mpl {




template< typename Tag >
struct empty_impl
{
    template< typename Sequence > struct apply
        : is_same<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {
    };
};

 template<> struct empty_impl<non_sequence_tag> {};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/empty.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct empty
    : empty_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct empty< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : empty< T1 > { }; }; template< typename Tag > struct lambda< empty< na > , Tag , int_<-1> > { typedef false_ is_le; typedef empty< na > result_; typedef empty< na > type; }; namespace aux { template< typename T1 > struct template_arity< empty< T1 > > : int_<1> { }; template<> struct template_arity< empty< na > > : int_<-1> { }; }

}}
# 61 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find_if.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find_if.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/find_if_pred.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/find_if_pred.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_apply.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_apply.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_apply.hpp" 2


namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Iterator
    >
struct iter_apply1
    : apply1< F,typename deref<Iterator>::type >
{
};

template<
      typename F
    , typename Iterator1
    , typename Iterator2
    >
struct iter_apply2
    : apply2<
          F
        , typename deref<Iterator1>::type
        , typename deref<Iterator2>::type
        >
{
};

}}}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/find_if_pred.hpp" 2


namespace boost { namespace mpl { namespace aux {

template< typename Predicate >
struct find_if_pred
{
    template< typename Iterator >
    struct apply
    {
        typedef not_< aux::iter_apply1<Predicate,Iterator> > type;
    };
};

}}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find_if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find_if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold_if.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold_if.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/logical.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold_if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/always.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/always.hpp"
namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
          typename T
        , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold_if.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold_if.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_if_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_if_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename Iterator, typename State >
struct iter_fold_if_null_step
{
    typedef State state;
    typedef Iterator iterator;
};

template< bool >
struct iter_fold_if_step_impl
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef typename apply2< StateOp,State,Iterator >::type state;
        typedef typename IteratorOp::type iterator;
    };
};

template<>
struct iter_fold_if_step_impl<false>
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef State state;
        typedef Iterator iterator;
    };
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename Predicate
    >
struct iter_fold_if_forward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,ForwardOp, mpl::next<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename BackwardOp
    , typename Predicate
    >
struct iter_fold_if_backward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,BackwardOp, identity<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename ForwardPredicate
    , typename BackwardOp
    , typename BackwardPredicate
    >
struct iter_fold_if_impl
{
 private:
    typedef iter_fold_if_null_step< Iterator,State > forward_step0;
    typedef iter_fold_if_forward_step< typename forward_step0::iterator, typename forward_step0::state, ForwardOp, ForwardPredicate > forward_step1;
    typedef iter_fold_if_forward_step< typename forward_step1::iterator, typename forward_step1::state, ForwardOp, ForwardPredicate > forward_step2;
    typedef iter_fold_if_forward_step< typename forward_step2::iterator, typename forward_step2::state, ForwardOp, ForwardPredicate > forward_step3;
    typedef iter_fold_if_forward_step< typename forward_step3::iterator, typename forward_step3::state, ForwardOp, ForwardPredicate > forward_step4;


    typedef typename if_<
          typename forward_step4::not_last
        , iter_fold_if_impl<
              typename forward_step4::iterator
            , typename forward_step4::state
            , ForwardOp
            , ForwardPredicate
            , BackwardOp
            , BackwardPredicate
            >
        , iter_fold_if_null_step<
              typename forward_step4::iterator
            , typename forward_step4::state
            >
        >::type backward_step4;

    typedef iter_fold_if_backward_step< typename forward_step3::iterator, typename backward_step4::state, BackwardOp, BackwardPredicate > backward_step3;
    typedef iter_fold_if_backward_step< typename forward_step2::iterator, typename backward_step3::state, BackwardOp, BackwardPredicate > backward_step2;
    typedef iter_fold_if_backward_step< typename forward_step1::iterator, typename backward_step2::state, BackwardOp, BackwardPredicate > backward_step1;
    typedef iter_fold_if_backward_step< typename forward_step0::iterator, typename backward_step1::state, BackwardOp, BackwardPredicate > backward_step0;


 public:
    typedef typename backward_step0::state state;
    typedef typename backward_step4::iterator iterator;
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iter_fold_if.hpp" 2







namespace boost { namespace mpl {

namespace aux {

template< typename Predicate, typename LastIterator >
struct iter_fold_if_pred
{
    template< typename State, typename Iterator > struct apply

        : and_<
              not_< is_same<Iterator,LastIterator> >
            , apply1<Predicate,Iterator>
            >
    {







    };
};

}

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    , typename ForwardPredicate = na
    , typename BackwardOp = na
    , typename BackwardPredicate = na
    >
struct iter_fold_if
{

    typedef typename begin<Sequence>::type first_;
    typedef typename end<Sequence>::type last_;

    typedef typename eval_if<
          is_na<BackwardPredicate>
        , if_< is_na<BackwardOp>, always<false_>, always<true_> >
        , identity<BackwardPredicate>
        >::type backward_pred_;



    struct result_ :



        aux::iter_fold_if_impl<
          first_
        , State
        , ForwardOp
        , protect< aux::iter_fold_if_pred< ForwardPredicate,last_ > >
        , BackwardOp
        , backward_pred_
        >

    { };




public:

    typedef pair<
          typename result_::state
        , typename result_::iterator
        > type;

   




};

template<> struct iter_fold_if< na , na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct apply : iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > { }; }; template< typename Tag > struct lambda< iter_fold_if< na , na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold_if< na , na , na , na , na , na > result_; typedef iter_fold_if< na , na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > > : int_<6> { }; template<> struct template_arity< iter_fold_if< na , na , na , na , na , na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find_if.hpp" 2




namespace boost { namespace mpl {



template<
      typename Sequence = na
    , typename Predicate = na
    >
struct find_if
{
    typedef typename iter_fold_if<
          Sequence
        , void
        , mpl::arg<1>
        , protect< aux::find_if_pred<Predicate> >
        >::type result_;

    typedef typename second<result_>::type type;

   
};

template<> struct find_if< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find_if< T1 , T2 > { }; }; template< typename Tag > struct lambda< find_if< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find_if< na , na > result_; typedef find_if< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find_if< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find_if< na , na > > : int_<-1> { }; }

}}
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/front_impl.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/front_impl.hpp"
namespace boost { namespace mpl {




template< typename Tag >
struct front_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename begin<Sequence>::type iter_;
        typedef typename deref<iter_>::type type;
    };
};

 template<> struct front_impl<non_sequence_tag> {};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct front
    : front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : front< T1 > { }; }; template< typename Tag > struct lambda< front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef front< na > result_; typedef front< na > type; }; namespace aux { template< typename T1 > struct template_arity< front< T1 > > : int_<1> { }; template<> struct template_arity< front< na > > : int_<-1> { }; }

}}
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/is_sequence.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/is_sequence.hpp"
namespace boost { namespace mpl {
# 90 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/is_sequence.hpp"
template<
      typename T = na
    >
struct is_sequence
    : not_< is_same< typename begin<T>::type, void_ > >
{
   
};
# 108 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/is_sequence.hpp"
template<> struct is_sequence< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_sequence< T1 > { }; }; template< typename Tag > struct lambda< is_sequence< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_sequence< na > result_; typedef is_sequence< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_sequence< T1 > > : int_<1> { }; template<> struct template_arity< is_sequence< na > > : int_<-1> { }; }

}}
# 67 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iterator_range.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iterator_range.hpp"
namespace boost { namespace mpl {

struct iterator_range_tag;

template<
      typename First = na
    , typename Last = na
    >
struct iterator_range
{
    typedef iterator_range_tag tag;
    typedef iterator_range type;
    typedef First begin;
    typedef Last end;

   
};

template<> struct iterator_range< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : iterator_range< T1 , T2 > { }; }; template< typename Tag > struct lambda< iterator_range< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iterator_range< na , na > result_; typedef iterator_range< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< iterator_range< T1 , T2 > > : int_<2> { }; template<> struct template_arity< iterator_range< na , na > > : int_<-1> { }; }

}}
# 68 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/max_element.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/max_element.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/less.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/less.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/numeric_cast.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/numeric_cast.hpp"
namespace boost { namespace mpl {



template< typename SourceTag, typename TargetTag > struct numeric_cast
{
    template< typename N > struct apply;
};

}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/tag.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/tag.hpp"
namespace boost { namespace mpl {

namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}

template< typename T, typename Default = void_ > struct tag

    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/tag.hpp"
};

}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_cast_utils.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_cast_utils.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2


namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast1st_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , typename apply_wrap1< numeric_cast<Tag1,Tag2>,N1 >::type
            , N2
            >
    {
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_cast_utils.hpp"
    };
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast2nd_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , N1
            , typename apply_wrap1< numeric_cast<Tag2,Tag1>,N2 >::type
            >
    {
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_cast_utils.hpp"
    };
};

}}}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/less.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less

    : less_impl<
          typename less_tag<N1>::type
        , typename less_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less< T1 , T2 > { }; }; template< typename Tag > struct lambda< less< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less< na , na > result_; typedef less< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N2::value > N1::value ) >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/less.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/max_element.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/max_element.hpp" 2



namespace boost { namespace mpl {



namespace aux {

template< typename Predicate >
struct select_max
{
    template< typename OldIterator, typename Iterator >
    struct apply
    {
        typedef typename apply2<
              Predicate
            , typename deref<OldIterator>::type
            , typename deref<Iterator>::type
            >::type condition_;

        typedef typename if_<
              condition_
            , Iterator
            , OldIterator
            >::type type;
    };
};

}


template<
      typename Sequence = na
    , typename Predicate = less<_,_>
    >
struct max_element
    : iter_fold<
          Sequence
        , typename begin<Sequence>::type
        , protect< aux::select_max<Predicate> >
        >
{
};

template<> struct max_element< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : max_element< T1 > { }; }; template< typename Tag > struct lambda< max_element< na > , Tag , int_<-1> > { typedef false_ is_le; typedef max_element< na > result_; typedef max_element< na > type; }; namespace aux { template< typename T1 > struct template_arity< max_element< T1 > > : int_<1> { }; template<> struct template_arity< max_element< na > > : int_<-1> { }; }

}}
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_front.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_front.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_front_impl.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_front_impl.hpp"
namespace boost { namespace mpl {

struct has_push_front_arg {};




template< typename Tag >
struct push_front_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct



 REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST45
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_front_impl.hpp"
        : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } }



 mpl_assert_arg45
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_front_impl.hpp"
        ; enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_front_arg >::value ))>( mpl_assert_arg45::assert_arg() ) ) }



             ;
    };
};

template< typename Tag >
struct has_push_front_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_front< Seq, has_push_front_arg > >
    {







    };
};

 template<> struct push_front_impl<non_sequence_tag> {};
 template<> struct has_push_front_impl<non_sequence_tag> {};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_front.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_front
    : push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};


template<
      typename Sequence = na
    >
struct has_push_front
    : has_push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct push_front< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_front< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_front< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_front< na , na > result_; typedef push_front< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_front< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_front< na , na > > : int_<-1> { }; }
template<> struct has_push_front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_front< T1 > { }; }; template< typename Tag > struct lambda< has_push_front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_front< na > result_; typedef has_push_front< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_front< T1 > > : int_<1> { }; template<> struct template_arity< has_push_front< na > > : int_<-1> { }; }

}}
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/same_as.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/same_as.hpp"
namespace boost { namespace mpl {

template< typename T1 >
struct same_as
{
    template< typename T2 > struct apply

        : is_same<T1,T2>
    {




    };
};

template< typename T1 >
struct not_same_as
{
    template< typename T2 > struct apply

        : not_< is_same<T1,T2> >
    {




    };
};

}}
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sizeof.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/sizeof.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct sizeof_
    : mpl::size_t< sizeof(T) >
{
   
};

template<> struct sizeof_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sizeof_< T1 > { }; }; template< typename Tag > struct lambda< sizeof_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sizeof_< na > result_; typedef sizeof_< na > type; }; namespace aux { template< typename T1 > struct template_arity< sizeof_< T1 > > : int_<1> { }; template<> struct template_arity< sizeof_< na > > : int_<-1> { }; }

}}
# 79 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/fold.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/fold.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/fold_impl.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/fold_impl.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, state3, typename deref<iter3>::type >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl
{
    typedef fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,First,Last,State,ForwardOp >
    : fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/fold_impl.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/fold.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct fold
{
    typedef typename aux::fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , ForwardOp
        >::state type;

   
};

template<> struct fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef fold< na , na , na > result_; typedef fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< fold< na , na , na > > : int_<-1> { }; }

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_fold.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_fold.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_fold.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_fold_impl.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_fold_impl.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 0,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef fwd_state0 bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef fwd_state1 bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 2,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef fwd_state2 bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 3,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef fwd_state3 bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 4,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef fwd_state4 bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter4 iterator;
};

template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef reverse_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , iter4
        , Last
        , fwd_state4
        , BackwardOp
        , ForwardOp
        > nested_chunk;

    typedef typename nested_chunk::state bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef typename nested_chunk::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef reverse_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , BackwardOp
        , ForwardOp
        > nested_step;

    typedef typename apply2<
          BackwardOp
        , typename nested_step::state
        , typename deref<First>::type
        >::type state;

    typedef typename nested_step::iterator iterator;
};

template<
      typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,Last,Last,State,BackwardOp,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_fold_impl.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_fold.hpp" 2


namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename BackwardOp = na
    , typename ForwardOp = arg<1>
    >
struct reverse_fold
{
    typedef typename aux::reverse_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , BackwardOp
        , ForwardOp
        >::state type;

   
};

template<> struct reverse_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_fold< na , na , na > result_; typedef reverse_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_fold< na , na , na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iterator_category.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/iterator_category.hpp"
namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct iterator_category
{
    typedef typename Iterator::category type;
   
};

template<> struct iterator_category< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : iterator_category< T1 > { }; }; template< typename Tag > struct lambda< iterator_category< na > , Tag , int_<-1> > { typedef false_ is_le; typedef iterator_category< na > result_; typedef iterator_category< na > type; }; namespace aux { template< typename T1 > struct template_arity< iterator_category< T1 > > : int_<1> { }; template<> struct template_arity< iterator_category< na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance_fwd.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance_fwd.hpp"
namespace boost { namespace mpl {



template< typename Tag > struct advance_impl;
template< typename Iterator, typename N > struct advance;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/negate.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/negate.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct negate_impl;

template< typename T > struct negate_tag
{
    typedef typename T::tag type;
};

template<
      typename N = na
    >
struct negate

    : negate_impl<
          typename negate_tag<N>::type
        >::template apply<N>::type






{
   
};

template<> struct negate< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : negate< T1 > { }; }; template< typename Tag > struct lambda< negate< na > , Tag , int_<-1> > { typedef false_ is_le; typedef negate< na > result_; typedef negate< na > type; }; namespace aux { template< typename T1 > struct template_arity< negate< T1 > > : int_<1> { }; template<> struct template_arity< negate< na > > : int_<-1> { }; }
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/negate.hpp"
template<>
struct negate_impl<integral_c_tag>
{




    template< typename N > struct apply
        : integral_c< typename N::value_type, (-N::value) >

    {
    };
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_forward.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_forward.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_forward.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_forward.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp"
namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_forward;
template<>
struct advance_forward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_forward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_forward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_forward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_forward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef typename next<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_forward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_forward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_forward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_forward.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_backward.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_backward.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/prior.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_backward.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_backward.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_backward.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp"
namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_backward;
template<>
struct advance_backward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_backward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_backward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_backward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_backward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef typename prior<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_backward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_backward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_backward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/advance_backward.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/advance.hpp" 2




namespace boost { namespace mpl {


template< typename Tag >
struct advance_impl
{
    template< typename Iterator, typename N > struct apply
    {
        typedef typename less< N,long_<0> >::type backward_;
        typedef typename if_< backward_, negate<N>, N >::type offset_;

        typedef typename if_<
              backward_
            , aux::advance_backward< offset_::value >
            , aux::advance_forward< offset_::value >
            >::type f_;

        typedef typename apply_wrap1<f_,Iterator>::type type;
    };
};


template<
      typename Iterator = na
    , typename N = na
    >
struct advance
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,N>
{
};

template<
      typename Iterator
    , long N
    >
struct advance_c
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,long_<N> >
{
};

template<> struct advance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : advance< T1 , T2 > { }; }; template< typename Tag > struct lambda< advance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef advance< na , na > result_; typedef advance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< advance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< advance< na , na > > : int_<-1> { }; }

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance_fwd.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance_fwd.hpp"
namespace boost { namespace mpl {



template< typename Tag > struct distance_impl;
template< typename First, typename Last > struct distance;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance.hpp" 2







namespace boost { namespace mpl {


template< typename Tag > struct distance_impl
{
    template< typename First, typename Last > struct apply

        : aux::msvc_eti_base< typename iter_fold<
              iterator_range<First,Last>
            , mpl::long_<0>
            , next<>
            >::type >
    {
# 60 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/distance.hpp"
    };
};

template<
      typename First = na
    , typename Last = na
    >
struct distance
    : distance_impl< typename tag<First>::type >
        ::template apply<First, Last>
{
   
};

template<> struct distance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : distance< T1 , T2 > { }; }; template< typename Tag > struct lambda< distance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef distance< na , na > result_; typedef distance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< distance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< distance< na , na > > : int_<-1> { }; }

}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/min_max.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/min_max.hpp"
namespace boost { namespace mpl {

template<
      typename N1 = na
    , typename N2 = na
    >
struct min
    : if_< less<N1,N2>,N1,N2 >
{
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct max
    : if_< less<N1,N2>,N2,N1 >
{
};

template<> struct min< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : min< T1 , T2 > { }; }; template< typename Tag > struct lambda< min< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef min< na , na > result_; typedef min< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< min< T1 , T2 > > : int_<2> { }; template<> struct template_arity< min< na , na > > : int_<-1> { }; }
template<> struct max< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : max< T1 , T2 > { }; }; template< typename Tag > struct lambda< max< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef max< na , na > result_; typedef max< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< max< T1 , T2 > > : int_<2> { }; template<> struct template_arity< max< na , na > > : int_<-1> { }; }

}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp" 2





namespace boost { namespace mpl {

namespace aux {
struct pair_iter_tag;
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp"
}

template<
      typename Iter1
    , typename Iter2
    , typename Category
    >
struct pair_iter
{
    typedef aux::pair_iter_tag tag;
    typedef Category category;
    typedef Iter1 first;
    typedef Iter2 second;
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pair_view.hpp"
};




template< typename Iter1, typename Iter2, typename C >
struct deref< pair_iter<Iter1,Iter2,C> >
{
    typedef pair<
          typename deref<Iter1>::type
        , typename deref<Iter2>::type
        > type;
};

template< typename Iter1, typename Iter2, typename C >
struct next< pair_iter<Iter1,Iter2,C> >
{
    typedef typename mpl::next<Iter1>::type i1_;
    typedef typename mpl::next<Iter2>::type i2_;
    typedef pair_iter<i1_,i2_,C> type;
};

template< typename Iter1, typename Iter2, typename C >
struct prior< pair_iter<Iter1,Iter2,C> >
{
    typedef typename mpl::prior<Iter1>::type i1_;
    typedef typename mpl::prior<Iter2>::type i2_;
    typedef pair_iter<i1_,i2_,C> type;
};




template<> struct advance_impl<aux::pair_iter_tag>
{
    template< typename Iter, typename D > struct apply
    {
        typedef typename mpl::advance< typename Iter::first,D >::type i1_;
        typedef typename mpl::advance< typename Iter::second,D >::type i2_;
        typedef pair_iter<i1_,i2_,typename Iter::category> type;
    };
};

template<> struct distance_impl<aux::pair_iter_tag>
{
    template< typename Iter1, typename Iter2 > struct apply
    {

        typedef typename mpl::distance<
              typename first<Iter1>::type
            , typename first<Iter2>::type
            >::type type;
    };
};


template<
      typename Sequence1 = na
    , typename Sequence2 = na
    >
struct pair_view
{
    typedef nested_begin_end_tag tag;

    typedef typename begin<Sequence1>::type iter1_;
    typedef typename begin<Sequence2>::type iter2_;
    typedef typename min<
          typename iterator_category<iter1_>::type
        , typename iterator_category<iter2_>::type
        >::type category_;

    typedef pair_iter<iter1_,iter2_,category_> begin;

    typedef pair_iter<
          typename end<Sequence1>::type
        , typename end<Sequence2>::type
        , category_
        > end;
};

template<> struct pair_view< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pair_view< T1 , T2 > { }; }; template< typename Tag > struct lambda< pair_view< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef pair_view< na , na > result_; typedef pair_view< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< pair_view< T1 , T2 > > : int_<2> { }; template<> struct template_arity< pair_view< na , na > > : int_<-1> { }; }

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/inserter_algorithm.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/inserter_algorithm.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/back_inserter.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/back_inserter.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_back.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_back.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_back_impl.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_back_impl.hpp"
namespace boost { namespace mpl {

struct has_push_back_arg {};



template< typename Tag >
struct push_back_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct



 REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST44
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_back_impl.hpp"
        : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } }



 mpl_assert_arg44
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/push_back_impl.hpp"
        ; enum { mpl_assertion_in_line_44 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_back_arg >::value ))>( mpl_assert_arg44::assert_arg() ) ) }



             ;
    };
};

template< typename Tag >
struct has_push_back_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_back< Seq, has_push_back_arg > >
    {







    };
};

 template<> struct push_back_impl<non_sequence_tag> {};
 template<> struct has_push_back_impl<non_sequence_tag> {};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/push_back.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_back
    : push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};


template<
      typename Sequence = na
    >
struct has_push_back
    : has_push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};


template<> struct push_back< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_back< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_back< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_back< na , na > result_; typedef push_back< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_back< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_back< na , na > > : int_<-1> { }; }
template<> struct has_push_back< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_back< T1 > { }; }; template< typename Tag > struct lambda< has_push_back< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_back< na > result_; typedef has_push_back< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_back< T1 > > : int_<1> { }; template<> struct template_arity< has_push_back< na > > : int_<-1> { }; }

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/back_inserter.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/inserter.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/inserter.hpp"
namespace boost { namespace mpl {

template<
      typename Sequence
    , typename Operation
    >
struct inserter
{
    typedef Sequence state;
    typedef Operation operation;
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/back_inserter.hpp" 2

namespace boost {
namespace mpl {

template<
      typename Sequence
    >
struct back_inserter
    : inserter< Sequence,push_back<> >
{
};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/inserter_algorithm.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front_inserter.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/front_inserter.hpp"
namespace boost { namespace mpl {

template<
      typename Sequence
    >
struct front_inserter
    : inserter< Sequence,push_front<> >
{
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/inserter_algorithm.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/clear.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/clear.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/clear_impl.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/clear_impl.hpp"
namespace boost { namespace mpl {



template< typename Tag >
struct clear_impl
{
    template< typename Sequence > struct apply;
};

 template<> struct clear_impl<non_sequence_tag> {};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/clear.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct clear
    : clear_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct clear< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : clear< T1 > { }; }; template< typename Tag > struct lambda< clear< na > , Tag , int_<-1> > { typedef false_ is_le; typedef clear< na > result_; typedef clear< na > type; }; namespace aux { template< typename T1 > struct template_arity< clear< T1 > > : int_<1> { }; template<> struct template_arity< clear< na > > : int_<-1> { }; }

}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/inserter_algorithm.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/default_params.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/inserter_algorithm.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp" 2

namespace boost { namespace mpl {

namespace aux {

template<
      typename Seq
    , typename Op
    , typename In
    >
struct transform1_impl
    : fold<
          Seq
        , typename In::state
        , bind2< typename lambda< typename In::operation >::type
            , _1
            , bind1< typename lambda<Op>::type, _2>
            >
        >
{
};

template<
      typename Seq
    , typename Op
    , typename In
    >
struct reverse_transform1_impl
    : reverse_fold<
          Seq
        , typename In::state
        , bind2< typename lambda< typename In::operation >::type
            , _1
            , bind1< typename lambda<Op>::type, _2>
            >
        >
{
};

template<
      typename Seq1
    , typename Seq2
    , typename Op
    , typename In
    >
struct transform2_impl
    : fold<
          pair_view<Seq1,Seq2>
        , typename In::state
        , bind2< typename lambda< typename In::operation >::type
            , _1
            , bind2<
                  typename lambda<Op>::type
                , bind1<first<>,_2>
                , bind1<second<>,_2>
                >
            >
        >
{
};

template<
      typename Seq1
    , typename Seq2
    , typename Op
    , typename In
    >
struct reverse_transform2_impl
    : reverse_fold<
          pair_view<Seq1,Seq2>
        , typename In::state
        , bind2< typename lambda< typename In::operation >::type
            , _1
            , bind2< typename lambda< Op >::type
                , bind1<first<>,_2>
                , bind1<second<>,_2>
                >
            >
        >
{
};

}

 template< typename P1 = na , typename P2 = na , typename P3 = na > struct transform1 : aux::transform1_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct transform1< P1 , P2,na > : if_< has_push_back< typename clear<P1>::type> , aux::transform1_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::reverse_transform1_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template< typename P1 = na , typename P2 = na , typename P3 = na > struct reverse_transform1 : aux::reverse_transform1_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct reverse_transform1< P1 , P2,na > : if_< has_push_back<P1> , aux::reverse_transform1_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::transform1_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template<> struct transform1< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : transform1< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< transform1< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef transform1< na , na , na > result_; typedef transform1< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< transform1< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< transform1< na , na , na > > : int_<-1> { }; } template<> struct reverse_transform1< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_transform1< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_transform1< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_transform1< na , na , na > result_; typedef reverse_transform1< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_transform1< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_transform1< na , na , na > > : int_<-1> { }; }
 template< typename P1 = na , typename P2 = na , typename P3 = na , typename P4 = na > struct transform2 : aux::transform2_impl< P1 , P2 , P3 , P4> { }; template< typename P1 , typename P2 , typename P3 > struct transform2< P1 , P2 , P3,na > : if_< has_push_back< typename clear<P1>::type> , aux::transform2_impl< P1 , P2 , P3 , back_inserter< typename clear<P1>::type > > , aux::reverse_transform2_impl< P1 , P2 , P3 , front_inserter< typename clear<P1>::type > > >::type { }; template< typename P1 = na , typename P2 = na , typename P3 = na , typename P4 = na > struct reverse_transform2 : aux::reverse_transform2_impl< P1 , P2 , P3 , P4> { }; template< typename P1 , typename P2 , typename P3 > struct reverse_transform2< P1 , P2 , P3,na > : if_< has_push_back<P1> , aux::reverse_transform2_impl< P1 , P2 , P3 , back_inserter< typename clear<P1>::type > > , aux::transform2_impl< P1 , P2 , P3 , front_inserter< typename clear<P1>::type > > >::type { }; template<> struct transform2< na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 =na > struct apply : transform2< T1 , T2 , T3 , T4 > { }; }; template< typename Tag > struct lambda< transform2< na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef transform2< na , na , na , na > result_; typedef transform2< na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< transform2< T1 , T2 , T3 , T4 > > : int_<4> { }; template<> struct template_arity< transform2< na , na , na , na > > : int_<-1> { }; } template<> struct reverse_transform2< na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 =na > struct apply : reverse_transform2< T1 , T2 , T3 , T4 > { }; }; template< typename Tag > struct lambda< reverse_transform2< na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_transform2< na , na , na , na > result_; typedef reverse_transform2< na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< reverse_transform2< T1 , T2 , T3 , T4 > > : int_<4> { }; template<> struct template_arity< reverse_transform2< na , na , na , na > > : int_<-1> { }; }
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/transform.hpp"
template< typename Seq1 = na , typename Seq2OrOperation = na , typename OperationOrInserter = na , typename Inserter = na > struct transform { typedef typename eval_if< or_< is_na<OperationOrInserter> , is_lambda_expression< Seq2OrOperation > , not_< is_sequence<Seq2OrOperation> > > , transform1<Seq1,Seq2OrOperation,OperationOrInserter> , transform2<Seq1,Seq2OrOperation,OperationOrInserter,Inserter> >::type type; }; template<> struct transform< na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 =na > struct apply : transform< T1 , T2 , T3 , T4 > { }; }; template< typename Tag > struct lambda< transform< na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef transform< na , na , na , na > result_; typedef transform< na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< transform< T1 , T2 , T3 , T4 > > : int_<4> { }; template<> struct template_arity< transform< na , na , na , na > > : int_<-1> { }; }
template< typename Seq1 = na , typename Seq2OrOperation = na , typename OperationOrInserter = na , typename Inserter = na > struct reverse_transform { typedef typename eval_if< or_< is_na<OperationOrInserter> , is_lambda_expression< Seq2OrOperation > , not_< is_sequence<Seq2OrOperation> > > , reverse_transform1<Seq1,Seq2OrOperation,OperationOrInserter> , reverse_transform2<Seq1,Seq2OrOperation,OperationOrInserter,Inserter> >::type type; }; template<> struct reverse_transform< na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 =na > struct apply : reverse_transform< T1 , T2 , T3 , T4 > { }; }; template< typename Tag > struct lambda< reverse_transform< na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_transform< na , na , na , na > result_; typedef reverse_transform< na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< reverse_transform< T1 , T2 , T3 , T4 > > : int_<4> { }; template<> struct template_arity< reverse_transform< na , na , na , na > > : int_<-1> { }; }



}}
# 80 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 107 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
namespace boost {

namespace detail { namespace variant {






template <typename Sequence, typename F>
struct max_value
{
private:

    typedef typename mpl::transform1<Sequence, F>::type transformed_;
    typedef typename mpl::max_element<transformed_

        >::type max_it;

public:

    typedef typename mpl::deref<max_it>::type
        type;

};
# 143 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
class no_fallback_type;

struct find_fallback_type_pred
{
    template <typename Iterator>
    struct apply
    {
    private:
        typedef typename mpl::deref<Iterator>::type t_;

    public:
        typedef mpl::not_< has_nothrow_constructor<t_> > type;
    };
};

template <typename Types>
struct find_fallback_type
{
private:

    typedef typename mpl::end<Types>::type end_it;



    typedef typename mpl::iter_fold_if<
          Types
        , mpl::int_<0>, mpl::protect< mpl::next<> >
        , mpl::protect< find_fallback_type_pred >
        >::type first_result_;

    typedef typename first_result_::first first_result_index;
    typedef typename first_result_::second first_result_it;



    typedef typename mpl::iter_fold_if<
          mpl::iterator_range< first_result_it,end_it >
        , first_result_index, mpl::protect< mpl::next<> >
        , mpl::protect< mpl::not_same_as<boost::blank> >
        >::type second_result_;

    typedef typename second_result_::second second_result_it;

public:


    typedef typename mpl::eval_if<
          is_same< second_result_it,end_it >
        , mpl::if_<
              is_same< first_result_it,end_it >
            , mpl::pair< no_fallback_type,no_fallback_type >
            , first_result_
            >
        , mpl::identity< second_result_ >
        >::type type;

};
# 218 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename Types, typename NeverUsesBackupFlag>
struct make_storage
{
private:

    typedef typename mpl::eval_if<
          NeverUsesBackupFlag
        , mpl::identity< Types >
        , mpl::push_front<
              Types, backup_holder<void*>
            >
        >::type types;

    typedef typename max_value<
          types, mpl::sizeof_<mpl::_1>
        >::type max_size;



    typedef typename max_value<
          types, alignment_of<mpl::_1>
        >::type max_alignment;
# 248 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
public:



    typedef ::boost::aligned_storage<
          max_size::value
        , max_alignment::value
        > type;
# 269 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
};
# 286 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
struct destroyer
    : public static_visitor<>
{
public:

    template <typename T>
        void
    internal_visit(T& operand, int) const
    {
        operand.~T();






        ;
    }

};
# 314 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename T>
class known_get
    : public static_visitor<T&>
{



public:

    T& operator()(T& operand) const
    {
        return operand;
    }

    template <typename U>
    T& operator()(U&) const
    {

        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp", 332, __PRETTY_FUNCTION__));
        return ::boost::detail::variant::forced_return< T& >();
    }
# 366 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
};






class copy_into
    : public static_visitor<>
{
private:

    void* storage_;

public:

    explicit copy_into(void* storage)
        : storage_(storage)
    {
    }

public:

    template <typename T>
        void
    internal_visit(boost::detail::variant::backup_holder<T>& operand, long) const
    {
        new(storage_) T( operand.get() );
        ;
    }

    template <typename T>
        void
    internal_visit(const boost::detail::variant::backup_holder<T>& operand, long) const
    {
        new(storage_) T( operand.get() );
        ;
    }

    template <typename T>
        void
    internal_visit(const T& operand, int) const
    {
        new(storage_) T(operand);
        ;
    }

};







struct assign_storage
    : public static_visitor<>
{
private:

    const void* rhs_storage_;

public:

    explicit assign_storage(const void* rhs_storage)
        : rhs_storage_(rhs_storage)
    {
    }

public:

    template <typename T>
        void
    internal_visit(backup_holder<T>& lhs_content, long) const
    {
        lhs_content.get()
            = static_cast< const backup_holder<T>* >(rhs_storage_)->get();
        ;
    }

    template <typename T>
        void
    internal_visit(const backup_holder<T>& lhs_content, long) const
    {
        lhs_content.get()
            = static_cast< const backup_holder<T>* >(rhs_storage_)->get();
        ;
    }

    template <typename T>
        void
    internal_visit(T& lhs_content, int) const
    {







        lhs_content = *static_cast< const T* >(rhs_storage_);
        ;
    }

};
# 479 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename T>
class direct_assigner
    : public static_visitor<bool>
{
private:

    const T& rhs_;

public:

    explicit direct_assigner(const T& rhs)
        : rhs_(rhs)
    {
    }



public:

    bool operator()(T& lhs)
    {
        lhs = rhs_;
        return true;
    }

    template <typename U>
    bool operator()(U&)
    {
        return false;
    }
# 542 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
};
# 553 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename Variant, typename RhsT>
class backup_assigner
    : public static_visitor<>
{
private:

    Variant& lhs_;
    int rhs_which_;
    const RhsT& rhs_content_;

public:

    backup_assigner(Variant& lhs, int rhs_which, const RhsT& rhs_content)
        : lhs_(lhs)
        , rhs_which_(rhs_which)
        , rhs_content_(rhs_content)
    {
    }

private:

    template <typename LhsT>
    void backup_assign_impl(
          LhsT& lhs_content
        , mpl::true_
        )
    {

        LhsT backup_lhs_content(
              ::boost::detail::variant::move(lhs_content)
            );


        lhs_content.~LhsT();

        try
        {

            new(lhs_.storage_.address()) RhsT(rhs_content_);
        }
        catch (...)
        {

            new(lhs_.storage_.address())
                LhsT(
                      ::boost::detail::variant::move(backup_lhs_content)
                    );


            throw;
        }


        lhs_.indicate_which(rhs_which_);
    }

    template <typename LhsT>
    void backup_assign_impl(
          LhsT& lhs_content
        , mpl::false_
        )
    {

        LhsT* backup_lhs_ptr = new LhsT(lhs_content);


        lhs_content.~LhsT();

        try
        {

            new(lhs_.storage_.address()) RhsT(rhs_content_);
        }
        catch (...)
        {

            new(lhs_.storage_.address())
                backup_holder<LhsT>( backup_lhs_ptr );


            lhs_.indicate_backup_which( lhs_.which() );


            throw;
        }


        lhs_.indicate_which(rhs_which_);


        delete backup_lhs_ptr;
    }

public:

    template <typename LhsT>
        void
    internal_visit(LhsT& lhs_content, int)
    {
        typedef typename has_nothrow_move_constructor<LhsT>::type
            nothrow_move;

        backup_assign_impl( lhs_content, nothrow_move() );

        ;
    }






};
# 674 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename Variant>
struct swap_with
    : public static_visitor<>
{
private:

    Variant& toswap_;

public:

    explicit swap_with(Variant& toswap)
        : toswap_(toswap)
    {
    }

public:

    template <typename T>
    void operator()(T& operand) const
    {

        known_get<T> getter;
        T& other = toswap_.apply_visitor(getter);


        ::boost::detail::variant::move_swap( operand, other );
    }

private:
    swap_with& operator=(const swap_with&);

};
# 715 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
class reflect
    : public static_visitor<const std::type_info&>
{
public:

    template <typename T>
    const std::type_info& operator()(const T&) const
    {
        return typeid(T);
    }

};
# 738 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename Variant, typename Comp>
class comparer
    : public static_visitor<bool>
{
private:

    const Variant& lhs_;

public:

    explicit comparer(const Variant& lhs)
        : lhs_(lhs)
    {
    }

public:

    template <typename T>
    bool operator()(const T& rhs_content) const
    {

        known_get<const T> getter;
        const T& lhs_content = lhs_.apply_visitor(getter);


        return Comp()(lhs_content, rhs_content);
    }

private:
    comparer& operator=(const comparer&);

};






struct equal_comp
{
    template <typename T>
    bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs == rhs;
    }
};






struct less_comp
{
    template <typename T>
    bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs < rhs;
    }
};
# 806 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
template <typename Visitor>
class invoke_visitor
{
private:

    Visitor& visitor_;

public:

    typedef typename Visitor::result_type
        result_type;

public:

    explicit invoke_visitor(Visitor& visitor)
        : visitor_(visitor)
    {
    }



public:

    template <typename T>
    result_type internal_visit(T& operand, int)
    {
        return visitor_(operand);
    }
# 876 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
public:

    template <typename T>
        result_type
    internal_visit(boost::recursive_wrapper<T>& operand, long)
    {
        return internal_visit( operand.get(), 1L );
    }

    template <typename T>
        result_type
    internal_visit(const boost::recursive_wrapper<T>& operand, long)
    {
        return internal_visit( operand.get(), 1L );
    }

    template <typename T>
        result_type
    internal_visit(boost::detail::reference_content<T>& operand, long)
    {
        return internal_visit( operand.get(), 1L );
    }

    template <typename T>
        result_type
    internal_visit(const boost::detail::reference_content<T>& operand, long)
    {
        return internal_visit( operand.get(), 1L );
    }

    template <typename T>
        result_type
    internal_visit(boost::detail::variant::backup_holder<T>& operand, long)
    {
        return internal_visit( operand.get(), 1L );
    }

    template <typename T>
        result_type
    internal_visit(const boost::detail::variant::backup_holder<T>& operand, long)
    {
        return internal_visit( operand.get(), 1L );
    }






};

}}






template <
      typename T0_
    , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19
    >
class variant
{
private:

    typedef variant wknd_self_t;

    struct is_recursive_
        : detail::variant::is_recursive_flag<T0_>
    {
    };

    typedef typename mpl::eval_if<
          is_recursive_
        , T0_
        , mpl::identity< T0_ >
        >::type unwrapped_T0_;

    struct is_sequence_based_
        : detail::variant::is_over_sequence<unwrapped_T0_>
    {
    };



private:

    typedef typename mpl::eval_if<
          is_sequence_based_
        , unwrapped_T0_
        , detail::variant::make_variant_list<
              unwrapped_T0_
            , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19
            >
        >::type specified_types;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( ::boost::mpl::not_< mpl::empty<specified_types> >::value )) == 0 ? false : true) >)>

 boost_static_assert_typedef_975;

    typedef typename mpl::eval_if<
          is_recursive_
        , mpl::transform<
              specified_types
            , mpl::protect<
                  detail::variant::quoted_enable_recursive<wknd_self_t>
                >
            >
        , mpl::identity< specified_types >
        >::type recursive_enabled_types;

public:

    typedef typename mpl::transform<
          recursive_enabled_types
        , unwrap_recursive<mpl::_1>
        >::type types;

private:

    typedef typename mpl::transform<
          recursive_enabled_types
        , mpl::protect< detail::make_reference_content<> >
        >::type internal_types;

    typedef typename mpl::front<
          internal_types
        >::type internal_T0;
# 1082 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
private:

    typedef typename detail::variant::find_fallback_type<
          internal_types
        >::type fallback_type_result_;

    typedef typename fallback_type_result_::first
        fallback_type_index_;
    typedef typename fallback_type_result_::second
        fallback_type_;

    struct has_fallback_type_
        : mpl::not_<
              is_same< fallback_type_, detail::variant::no_fallback_type >
            >
    {
    };

    typedef has_fallback_type_
        never_uses_backup_flag;

    typedef typename detail::variant::make_storage<
          internal_types, never_uses_backup_flag
        >::type storage_t;

private:
# 1118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
    typedef int which_t;
# 1138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
    private:




    which_t which_;
    storage_t storage_;

    void indicate_which(int which)
    {
        which_ = static_cast<which_t>( which );
    }

    void indicate_backup_which(int which)
    {
        which_ = static_cast<which_t>( -(which + 1) );
    }

private:

    bool using_backup() const
    {
        return which_ < 0;
    }

public:

    int which() const
    {

        if (using_backup())

            return -(which_ + 1);


        return which_;
    }

private:

    struct initializer
        : ::boost::mpl::iter_fold< recursive_enabled_types , ::boost::mpl::pair< ::boost::detail::variant::initializer_root , ::boost::mpl::int_<0> > , ::boost::mpl::protect< ::boost::detail::variant::make_initializer_node > >::type::first


    {
    };

    void destroy_content()
    {
        detail::variant::destroyer visitor;
        this->internal_apply_visitor(visitor);
    }

public:

    ~variant()
    {
        destroy_content();
    }

    variant()
    {





        new( storage_.address() ) internal_T0();
        indicate_which(0);
    }

private:

    class convert_copy_into
        : public static_visitor<int>
    {
    private:

        void* storage_;

    public:

        explicit convert_copy_into(void* storage)
            : storage_(storage)
        {
        }

    public:

        template <typename T>
        int internal_visit(T& operand, int) const
        {





            return initializer::initialize(storage_, operand);
        }
# 1246 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
        template <typename T>
        int internal_visit(boost::detail::reference_content<T>& operand, long) const
        {
            return internal_visit( operand.get(), 1L );
        }

        template <typename T>
        int internal_visit(const boost::detail::reference_content<T>& operand, long) const
        {
            return internal_visit( operand.get(), 1L );
        }

        template <typename T>
        int internal_visit(boost::detail::variant::backup_holder<T>& operand, long) const
        {
            return internal_visit( operand.get(), 1L );
        }

        template <typename T>
        int internal_visit(const boost::detail::variant::backup_holder<T>& operand, long) const
        {
            return internal_visit( operand.get(), 1L );
        }

        template <typename T>
        int internal_visit(boost::recursive_wrapper<T>& operand, long) const
        {
            return internal_visit( operand.get(), 1L );
        }

        template <typename T>
        int internal_visit(const boost::recursive_wrapper<T>& operand, long) const
        {
            return internal_visit( operand.get(), 1L );
        }

    };

    friend class convert_copy_into;

private:

    template <typename T>
    void convert_construct(
          T& operand
        , int
        , mpl::false_ = mpl::false_()
        )
    {





        indicate_which(
              initializer::initialize(
                  storage_.address()
                , operand
                )
            );
    }

    template <typename Variant>
    void convert_construct(
          Variant& operand
        , long
        , mpl::true_
        )
    {
        convert_copy_into visitor(storage_.address());
        indicate_which(
              operand.internal_apply_visitor(visitor)
            );
    }

    template <typename Variant>
    void convert_construct_variant(Variant& operand)
    {




        typedef typename mpl::find_if<
              types
            , is_same<
                  add_const<mpl::_1>
                , const Variant
                >
            >::type found_it;

        typedef typename mpl::end<types>::type not_found;
        typedef typename is_same<
              found_it, not_found
            >::type is_foreign_variant;


        convert_construct(
              operand, 1L
            , is_foreign_variant()
            );
    }

    template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19>
    void convert_construct(
          boost::variant< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19>& operand
        , long
        )
    {
        convert_construct_variant(operand);
    }

    template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19>
    void convert_construct(
          const boost::variant< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19>& operand
        , long
        )
    {
        convert_construct_variant(operand);
    }

public:



    template <typename T>
    variant(const T& operand)
    {
        convert_construct(operand, 1L);
    }

    template <typename T>
    variant(T& operand)
    {
        convert_construct(operand, 1L);
    }
# 1418 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
public:


    variant(const variant& operand)
    {

        detail::variant::copy_into visitor( storage_.address() );
        operand.internal_apply_visitor(visitor);


        indicate_which(operand.which());
    }

private:


    template <typename Variant, typename RhsT>
    friend class detail::variant::backup_assigner;
# 1444 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
    class assigner
        : public static_visitor<>
    {
    private:

        variant& lhs_;
        int rhs_which_;

    public:

        assigner(variant& lhs, int rhs_which)
            : lhs_(lhs)
            , rhs_which_(rhs_which)
        {
        }

    private:

        template <typename RhsT, typename B1, typename B2>
        void assign_impl(
              const RhsT& rhs_content
            , mpl::true_
            , B1
            , B2
            )
        {

            lhs_.destroy_content();


            new(lhs_.storage_.address())
                RhsT( rhs_content );


            lhs_.indicate_which(rhs_which_);
        }

        template <typename RhsT, typename B>
        void assign_impl(
              const RhsT& rhs_content
            , mpl::false_
            , mpl::true_
            , B
            )
        {

            RhsT temp(rhs_content);


            lhs_.destroy_content();


            new(lhs_.storage_.address())
                RhsT( detail::variant::move(temp) );


            lhs_.indicate_which(rhs_which_);
        }

        template <typename RhsT>
        void assign_impl(
              const RhsT& rhs_content
            , mpl::false_
            , mpl::false_
            , mpl::true_
            )
        {

            lhs_.destroy_content();

            try
            {

                new(lhs_.storage_.address())
                    RhsT( rhs_content );
            }
            catch (...)
            {

                new (lhs_.storage_.address())
                    fallback_type_;


                lhs_.indicate_which(
                      fallback_type_index_::value
                    );


                throw;
            }


            lhs_.indicate_which(rhs_which_);
        }

        template <typename RhsT>
        void assign_impl(
              const RhsT& rhs_content
            , mpl::false_
            , mpl::false_
            , mpl::false_
            )
        {
            detail::variant::backup_assigner<wknd_self_t, RhsT>
                visitor(lhs_, rhs_which_, rhs_content);
            lhs_.internal_apply_visitor(visitor);
        }

    public:

        template <typename RhsT>
            void
        internal_visit(const RhsT& rhs_content, int)
        {
            typedef typename has_nothrow_copy<RhsT>::type
                nothrow_copy;
            typedef typename mpl::or_<
                  nothrow_copy
                , detail::variant::has_nothrow_move_constructor<RhsT>
                >::type nothrow_move_constructor;

            assign_impl(
                  rhs_content
                , nothrow_copy()
                , nothrow_move_constructor()
                , has_fallback_type_()
                );

            ;
        }






    };

    friend class assigner;

    void variant_assign(const variant& rhs)
    {

        if (which_ == rhs.which_)
        {

            detail::variant::assign_storage visitor(rhs.storage_.address());
            this->internal_apply_visitor(visitor);
        }
        else
        {

            assigner visitor(*this, rhs.which());
            rhs.internal_apply_visitor(visitor);
        }
    }

private:

    template <typename T>
    void assign(const T& rhs)
    {

        detail::variant::direct_assigner<T> direct_assign(rhs);
        if (this->apply_visitor(direct_assign) == false)
        {






            variant temp(rhs);
            variant_assign( detail::variant::move(temp) );
        }
    }

public:

    template <typename T>
    variant& operator=(const T& rhs)
    {
        assign(rhs);
        return *this;
    }


    variant& operator=(const variant& rhs)
    {
        variant_assign(rhs);
        return *this;
    }

    void swap(variant& rhs)
    {

        if (which() == rhs.which())
        {

            detail::variant::swap_with<variant> visitor(rhs);
            this->apply_visitor(visitor);
        }
        else
        {

            variant tmp( detail::variant::move(rhs) );
            rhs = detail::variant::move(*this);
            *this = detail::variant::move(tmp);
        }
    }

public:





    bool empty() const
    {
        return false;
    }


    const std::type_info& type() const
    {
        detail::variant::reflect visitor;
        return this->apply_visitor(visitor);
    }


public:
# 1693 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp"
    template <typename U>
        void
    operator==(const U&) const
    {
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((false && sizeof(U)) == 0 ? false : true) >)> boost_static_assert_typedef_1697;
    }

    template <typename U>
        void
    operator<(const U&) const
    {
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((false && sizeof(U)) == 0 ? false : true) >)> boost_static_assert_typedef_1704;
    }

public:



    bool operator==(const variant& rhs) const
    {
        if (this->which() != rhs.which())
            return false;

        detail::variant::comparer<
              variant, detail::variant::equal_comp
            > visitor(*this);
        return rhs.apply_visitor(visitor);
    }

    bool operator<(const variant& rhs) const
    {




        if (this->which() != rhs.which())
            return this->which() < rhs.which();

        detail::variant::comparer<
              variant, detail::variant::less_comp
            > visitor(*this);
        return rhs.apply_visitor(visitor);
    }




    template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 >
    friend class variant;

private:







    template <typename Visitor, typename VoidPtrCV>
    static
        typename Visitor::result_type


    internal_apply_visitor_impl(
          int internal_which
        , int logical_which
        , Visitor& visitor
        , VoidPtrCV storage
        )
    {
        typedef mpl::int_<0> first_which;
        typedef typename mpl::begin<internal_types>::type first_it;
        typedef typename mpl::end<internal_types>::type last_it;

        typedef detail::variant::visitation_impl_step<
              first_it, last_it
            > first_step;

        return detail::variant::visitation_impl(
              internal_which, logical_which
            , visitor, storage, mpl::false_()
            , never_uses_backup_flag()
            , static_cast<first_which*>(0), static_cast<first_step*>(0)
            );
    }

    template <typename Visitor>
        typename Visitor::result_type


    internal_apply_visitor(Visitor& visitor)
    {
        return internal_apply_visitor_impl(
              which_, which(), visitor, storage_.address()
            );
    }

    template <typename Visitor>
        typename Visitor::result_type


    internal_apply_visitor(Visitor& visitor) const
    {
        return internal_apply_visitor_impl(
              which_, which(), visitor, storage_.address()
            );
    }

public:

    template <typename Visitor>
        typename Visitor::result_type


    apply_visitor(Visitor& visitor)
    {
        detail::variant::invoke_visitor<Visitor> invoker(visitor);
        return this->internal_apply_visitor(invoker);
    }

    template <typename Visitor>
        typename Visitor::result_type


    apply_visitor(Visitor& visitor) const
    {
        detail::variant::invoke_visitor<Visitor> invoker(visitor);
        return this->internal_apply_visitor(invoker);
    }

};






template <typename Types>
struct make_variant_over
{
private:


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( ::boost::mpl::is_sequence<Types>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_1836;


public:

    typedef variant<
          detail::variant::over_sequence< Types >
        > type;

};






template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
inline void swap(
      variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >& lhs
    , variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >& rhs
    )
{
    lhs.swap(rhs);
}

}




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/variant_io.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/variant_io.hpp"
namespace boost {
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/variant_io.hpp"
template <
      typename E , typename T
    ,
      typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19
    >
inline std::basic_ostream< E , T >& operator<<(
      std::basic_ostream< E , T >& out
    , const variant< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 >& rhs
    );

namespace detail { namespace variant {

template <typename OStream>
class printer
    : public boost::static_visitor<>
{
private:

    OStream& out_;

public:

    explicit printer(OStream& out)
        : out_( out )
    {
    }

public:

    template <typename T>
    void operator()(const T& operand) const
    {
        out_ << operand;
    }

private:
    printer& operator=(const printer&);

};

}}

template <
      typename E , typename T
    ,
      typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19
    >
inline std::basic_ostream< E , T >& operator<<(
      std::basic_ostream< E , T >& out
    , const variant< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 >& rhs
    )
{
    detail::variant::printer<
          std::basic_ostream< E , T >
        > visitor(out);

    rhs.apply_visitor(visitor);

    return out;
}

}
# 1867 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/variant.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessor/repeat.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iterate.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/iterate.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/slot.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/slot.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/detail/def.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/slot.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/iterate.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iterate.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 2

namespace boost {
namespace detail { namespace variant {
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      typename T, typename Dest, typename Source
      , typename Arity


    >
struct substitute
{
    typedef T type;
};
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <typename Dest, typename Source> struct substitute< Source , Dest , Source , mpl::int_<-1> > { typedef Dest type; };
template <typename Dest, typename Source> struct substitute< const Source , Dest , Source , mpl::int_<-1> > { typedef const Dest type; };
template <typename Dest, typename Source> struct substitute< volatile Source , Dest , Source , mpl::int_<-1> > { typedef volatile Dest type; };
template <typename Dest, typename Source> struct substitute< const volatile Source , Dest , Source , mpl::int_<-1> > { typedef const volatile Dest type; };
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <typename T, typename Dest, typename Source> struct substitute< T * , Dest , Source , mpl::int_<-1> > { typedef typename substitute< T, Dest, Source >::type * type; };
template <typename T, typename Dest, typename Source> struct substitute< T * const , Dest , Source , mpl::int_<-1> > { typedef typename substitute< T, Dest, Source >::type * const type; };
template <typename T, typename Dest, typename Source> struct substitute< T * volatile , Dest , Source , mpl::int_<-1> > { typedef typename substitute< T, Dest, Source >::type * volatile type; };
template <typename T, typename Dest, typename Source> struct substitute< T * const volatile , Dest , Source , mpl::int_<-1> > { typedef typename substitute< T, Dest, Source >::type * const volatile type; };






template <typename T, typename Dest, typename Source>
struct substitute<
      T&
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
    typedef typename substitute<
          T, Dest, Source
        >::type & type;
};
# 140 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/detail/shared.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/detail/shared.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 211 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      typename R, typename Dest, typename Source
    >
struct substitute<
      R (*)( void )
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
private:
    typedef typename substitute< R, Dest, Source >::type r;

public:
    typedef r (*type)( void );
};
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 162 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      template < typename P1 > class T
    , typename U1
    , typename Dest
    , typename Source
    >
struct substitute<
      T< U1 >
    , Dest
    , Source
      , mpl::int_<( 1 )>
    >
{
private:
    typedef typename substitute< U1, Dest, Source >::type u1;

public:
    typedef T< u1 > type;
};




template <
      typename R
    , typename U1
    , typename Dest
    , typename Source
    >
struct substitute<
      R (*)( U1 )
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
private:
    typedef typename substitute< R, Dest, Source >::type r;
    typedef typename substitute< U1, Dest, Source >::type u1;

public:
    typedef r (*type)( u1 );
};
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 162 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      template < typename P1 , typename P2 > class T
    , typename U1 , typename U2
    , typename Dest
    , typename Source
    >
struct substitute<
      T< U1 , U2 >
    , Dest
    , Source
      , mpl::int_<( 2 )>
    >
{
private:
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2;

public:
    typedef T< u1 , u2 > type;
};




template <
      typename R
    , typename U1 , typename U2
    , typename Dest
    , typename Source
    >
struct substitute<
      R (*)( U1 , U2 )
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
private:
    typedef typename substitute< R, Dest, Source >::type r;
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2;

public:
    typedef r (*type)( u1 , u2 );
};
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 162 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      template < typename P1 , typename P2 , typename P3 > class T
    , typename U1 , typename U2 , typename U3
    , typename Dest
    , typename Source
    >
struct substitute<
      T< U1 , U2 , U3 >
    , Dest
    , Source
      , mpl::int_<( 3 )>
    >
{
private:
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2; typedef typename substitute< U3, Dest, Source >::type u3;

public:
    typedef T< u1 , u2 , u3 > type;
};




template <
      typename R
    , typename U1 , typename U2 , typename U3
    , typename Dest
    , typename Source
    >
struct substitute<
      R (*)( U1 , U2 , U3 )
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
private:
    typedef typename substitute< R, Dest, Source >::type r;
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2; typedef typename substitute< U3, Dest, Source >::type u3;

public:
    typedef r (*type)( u1 , u2 , u3 );
};
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 162 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      template < typename P1 , typename P2 , typename P3 , typename P4 > class T
    , typename U1 , typename U2 , typename U3 , typename U4
    , typename Dest
    , typename Source
    >
struct substitute<
      T< U1 , U2 , U3 , U4 >
    , Dest
    , Source
      , mpl::int_<( 4 )>
    >
{
private:
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2; typedef typename substitute< U3, Dest, Source >::type u3; typedef typename substitute< U4, Dest, Source >::type u4;

public:
    typedef T< u1 , u2 , u3 , u4 > type;
};




template <
      typename R
    , typename U1 , typename U2 , typename U3 , typename U4
    , typename Dest
    , typename Source
    >
struct substitute<
      R (*)( U1 , U2 , U3 , U4 )
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
private:
    typedef typename substitute< R, Dest, Source >::type r;
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2; typedef typename substitute< U3, Dest, Source >::type u3; typedef typename substitute< U4, Dest, Source >::type u4;

public:
    typedef r (*type)( u1 , u2 , u3 , u4 );
};
# 68 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 1
# 162 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp"
template <
      template < typename P1 , typename P2 , typename P3 , typename P4 , typename P5 > class T
    , typename U1 , typename U2 , typename U3 , typename U4 , typename U5
    , typename Dest
    , typename Source
    >
struct substitute<
      T< U1 , U2 , U3 , U4 , U5 >
    , Dest
    , Source
      , mpl::int_<( 5 )>
    >
{
private:
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2; typedef typename substitute< U3, Dest, Source >::type u3; typedef typename substitute< U4, Dest, Source >::type u4; typedef typename substitute< U5, Dest, Source >::type u5;

public:
    typedef T< u1 , u2 , u3 , u4 , u5 > type;
};




template <
      typename R
    , typename U1 , typename U2 , typename U3 , typename U4 , typename U5
    , typename Dest
    , typename Source
    >
struct substitute<
      R (*)( U1 , U2 , U3 , U4 , U5 )
    , Dest
    , Source
      , mpl::int_<-1>
    >
{
private:
    typedef typename substitute< R, Dest, Source >::type r;
    typedef typename substitute< U1, Dest, Source >::type u1; typedef typename substitute< U2, Dest, Source >::type u2; typedef typename substitute< U3, Dest, Source >::type u3; typedef typename substitute< U4, Dest, Source >::type u4; typedef typename substitute< U5, Dest, Source >::type u5;

public:
    typedef r (*type)( u1 , u2 , u3 , u4 , u5 );
};
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2
# 141 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/substitute.hpp" 2






}}
}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/checked_delete.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/checked_delete.hpp"
namespace boost
{



template<class T> inline void checked_delete(T * x)
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_wrapper.hpp" 2

namespace boost {







template <typename T>
class recursive_wrapper
{
public:

    typedef T type;

private:

    T* p_;

public:

    ~recursive_wrapper();
    recursive_wrapper();

    recursive_wrapper(const recursive_wrapper& operand);
    recursive_wrapper(const T& operand);

private:

    void assign(const T& rhs);

public:

    recursive_wrapper& operator=(const recursive_wrapper& rhs)
    {
        assign( rhs.get() );
        return *this;
    }

    recursive_wrapper& operator=(const T& rhs)
    {
        assign( rhs );
        return *this;
    }

    void swap(recursive_wrapper& operand)
    {
        T* temp = operand.p_;
        operand.p_ = p_;
        p_ = temp;
    }

public:

    T& get() { return *get_pointer(); }
    const T& get() const { return *get_pointer(); }

    T* get_pointer() { return p_; }
    const T* get_pointer() const { return p_; }

};

template <typename T>
recursive_wrapper<T>::~recursive_wrapper()
{
    boost::checked_delete(p_);
}

template <typename T>
recursive_wrapper<T>::recursive_wrapper()
    : p_(new T)
{
}

template <typename T>
recursive_wrapper<T>::recursive_wrapper(const recursive_wrapper& operand)
    : p_(new T( operand.get() ))
{
}

template <typename T>
recursive_wrapper<T>::recursive_wrapper(const T& operand)
    : p_(new T(operand))
{
}

template <typename T>
void recursive_wrapper<T>::assign(const T& rhs)
{
    this->get() = rhs;
}





template <typename T>
inline void swap(recursive_wrapper<T>& lhs, recursive_wrapper<T>& rhs)
{
    lhs.swap(rhs);
}

}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp" 2

namespace boost {
namespace detail { namespace variant {
# 83 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp"
template <typename T, typename RecursiveVariant, typename NoWrapper>
struct enable_recursive
    : substitute< T , RecursiveVariant , ::boost::recursive_variant_ >


{
};

template <typename T, typename RecursiveVariant>
struct enable_recursive< T,RecursiveVariant,mpl::false_ >
{
private:

    typedef typename substitute< T , RecursiveVariant , ::boost::recursive_variant_ >

         ::type t_;

public:


    typedef typename mpl::if_<
          mpl::or_<
              is_same< t_,T >
            , is_reference<t_>
            , is_pointer<t_>
            >
        , t_
        , boost::recursive_wrapper<t_>
        >::type type;

};
# 149 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/enable_recursive.hpp"
template <typename RecursiveVariant, typename NoWrapper>
struct quoted_enable_recursive
{
    template <typename T>
    struct apply
        : enable_recursive<T, RecursiveVariant, NoWrapper>
    {
    };
};

}}
}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp" 2
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp"
namespace boost {

namespace detail { namespace variant {
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp"
template <
      typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19
    , typename RecursiveVariant
      , typename Arity
    >
struct substitute<
      ::boost::variant<
          recursive_flag< T0 >
        , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19
        >
    , RecursiveVariant
    , ::boost::recursive_variant_
      , Arity
    >
{
    typedef ::boost::variant<
          recursive_flag< T0 >
        , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19
        > type;
};

template <
      typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19
    , typename RecursiveVariant
      , typename Arity
    >
struct substitute<
      ::boost::variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >
    , RecursiveVariant
    , ::boost::recursive_variant_
      , Arity
    >
{



private:

    typedef typename mpl::eval_if<
          ::boost::detail::variant::is_over_sequence<T0>
        , mpl::identity< T0 >
        , make_variant_list< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >
        >::type initial_types;

    typedef typename mpl::transform<
          initial_types
        , mpl::protect< quoted_enable_recursive<RecursiveVariant,mpl::true_> >
        >::type types;

public:

    typedef ::boost::variant< types > type;
# 129 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp"
};
# 139 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/recursive_variant.hpp"
}}






template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
struct make_recursive_variant
{
public:

    typedef boost::variant<
          detail::variant::recursive_flag< T0 >
        , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19
        > type;

};






template <typename Types>
struct make_recursive_variant_over
{
private:


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( ::boost::mpl::is_sequence<Types>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_169;


public:

    typedef typename make_recursive_variant<
          detail::variant::over_sequence< Types >
        >::type type;

};

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/addressof.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/addressof.hpp"
namespace boost
{

namespace detail
{

template<class T> struct addr_impl_ref
{
    T & v_;

    inline addr_impl_ref( T & v ): v_( v ) {}
    inline operator T& () const { return v_; }

private:
    addr_impl_ref & operator=(const addr_impl_ref &);
};

template<class T> struct addressof_impl
{
    static inline T * f( T & v, long )
    {
        return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }

    static inline T * f( T * v, int )
    {
        return v;
    }
};

}

template<class T> T * addressof( T & v )
{






    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );


}
# 100 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/addressof.hpp"
}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_pointer.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_pointer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_pointer.hpp" 2

namespace boost {

namespace detail {
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_pointer.hpp"
template <typename T>
struct add_pointer_impl
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};



}

template< typename T > struct add_pointer { typedef typename boost::detail::add_pointer_impl<T>::type type; };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_pointer.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp" 2







namespace boost {






class bad_get
    : public std::exception
{
public:

    virtual const char * what() const throw()
    {
        return "boost::bad_get: "
               "failed value get using boost::get";
    }

};
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp"
namespace detail { namespace variant {






template <typename T>
struct get_visitor
{
private:

    typedef typename add_pointer<T>::type pointer;
    typedef typename add_reference<T>::type reference;

public:

    typedef pointer result_type;

public:



    pointer operator()(reference operand) const
    {
        return boost::addressof(operand);
    }

    template <typename U>
    pointer operator()(const U&) const
    {
        return static_cast<pointer>(0);
    }
# 126 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp"
};

}}
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/get.hpp"
template <typename U, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
inline
    typename add_pointer<U>::type
get(
      boost::variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >* operand
     
    )
{
    typedef typename add_pointer<U>::type U_ptr;
    if (!operand) return static_cast<U_ptr>(0);

    detail::variant::get_visitor<U> v;
    return operand->apply_visitor(v);
}

template <typename U, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
inline
    typename add_pointer<const U>::type
get(
      const boost::variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >* operand
     
    )
{
    typedef typename add_pointer<const U>::type U_ptr;
    if (!operand) return static_cast<U_ptr>(0);

    detail::variant::get_visitor<const U> v;
    return operand->apply_visitor(v);
}

template <typename U, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
inline
    typename add_reference<U>::type
get(
      boost::variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >& operand
     
    )
{
    typedef typename add_pointer<U>::type U_ptr;
    U_ptr result = get<U>(&operand);

    if (!result)
        throw bad_get();
    return *result;
}

template <typename U, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 >
inline
    typename add_reference<const U>::type
get(
      const boost::variant< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 >& operand
     
    )
{
    typedef typename add_pointer<const U>::type U_ptr;
    U_ptr result = get<const U>(&operand);

    if (!result)
        throw bad_get();
    return *result;
}

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/apply_visitor.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/apply_visitor.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_unary.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_unary.hpp"
namespace boost {
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_unary.hpp"
template <typename Visitor, typename Visitable>
inline
    typename Visitor::result_type
apply_visitor(Visitor& visitor, Visitable& visitable)
{
    return visitable.apply_visitor(visitor);
}
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_unary.hpp"
template <typename Visitor, typename Visitable>
inline
    typename Visitor::result_type
apply_visitor(const Visitor& visitor, Visitable& visitable)
{
    return visitable.apply_visitor(visitor);
}



}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/apply_visitor.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_binary.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_binary.hpp"
namespace boost {
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_binary.hpp"
namespace detail { namespace variant {

template <typename Visitor, typename Value1>
class apply_visitor_binary_invoke
{
public:

    typedef typename Visitor::result_type
        result_type;

private:

    Visitor& visitor_;
    Value1& value1_;

public:

    apply_visitor_binary_invoke(Visitor& visitor, Value1& value1)
        : visitor_(visitor)
        , value1_(value1)
    {
    }

public:

    template <typename Value2>
        result_type
    operator()(Value2& value2)
    {
        return visitor_(value1_, value2);
    }

private:
    apply_visitor_binary_invoke& operator=(const apply_visitor_binary_invoke&);

};

template <typename Visitor, typename Visitable2>
class apply_visitor_binary_unwrap
{
public:

    typedef typename Visitor::result_type
        result_type;

private:

    Visitor& visitor_;
    Visitable2& visitable2_;

public:

    apply_visitor_binary_unwrap(Visitor& visitor, Visitable2& visitable2)
        : visitor_(visitor)
        , visitable2_(visitable2)
    {
    }

public:

    template <typename Value1>
        result_type
    operator()(Value1& value1)
    {
        apply_visitor_binary_invoke<
              Visitor
            , Value1
            > invoker(visitor_, value1);

        return boost::apply_visitor(invoker, visitable2_);
    }

private:
    apply_visitor_binary_unwrap& operator=(const apply_visitor_binary_unwrap&);

};

}}
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_binary.hpp"
template <typename Visitor, typename Visitable1, typename Visitable2>
inline
    typename Visitor::result_type
apply_visitor(
      Visitor& visitor
    , Visitable1& visitable1, Visitable2& visitable2
    )
{
    ::boost::detail::variant::apply_visitor_binary_unwrap<
          Visitor, Visitable2
        > unwrapper(visitor, visitable2);

    return boost::apply_visitor(unwrapper, visitable1);
}
# 161 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_binary.hpp"
template <typename Visitor, typename Visitable1, typename Visitable2>
inline
    typename Visitor::result_type


apply_visitor(
      const Visitor& visitor
    , Visitable1& visitable1, Visitable2& visitable2
    )
{
    ::boost::detail::variant::apply_visitor_binary_unwrap<
          const Visitor, Visitable2
        > unwrapper(visitor, visitable2);

    return boost::apply_visitor(unwrapper, visitable1);
}



}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/apply_visitor.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_delayed.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_delayed.hpp"
namespace boost {
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/detail/apply_visitor_delayed.hpp"
template <typename Visitor>
class apply_visitor_delayed_t
{
public:

    typedef typename Visitor::result_type
        result_type;

private:

    Visitor& visitor_;

public:

    explicit apply_visitor_delayed_t(Visitor& visitor)
      : visitor_(visitor)
    {
    }

public:

    template <typename Visitable>
        result_type
    operator()(Visitable& visitable)
    {
        return apply_visitor(visitor_, visitable);
    }

public:

    template <typename Visitable1, typename Visitable2>
        result_type
    operator()(Visitable1& visitable1, Visitable2& visitable2)
    {
        return apply_visitor(visitor_, visitable1, visitable2);
    }

private:
    apply_visitor_delayed_t& operator=(const apply_visitor_delayed_t&);

};

template <typename Visitor>
inline apply_visitor_delayed_t<Visitor> apply_visitor(Visitor& visitor)
{
    return apply_visitor_delayed_t<Visitor>(visitor);
}

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/apply_visitor.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/visitor_ptr.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/visitor_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/bad_visit.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/bad_visit.hpp"
namespace boost {







struct bad_visit
    : std::exception
{
public:

    virtual const char * what() const throw()
    {
        return "boost::bad_visit: "
               "failed visitation using boost::apply_visitor";
    }

};

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/visitor_ptr.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/visitor_ptr.hpp"
namespace boost {







template <typename T, typename R>
class visitor_ptr_t
    : public static_visitor<R>
{
private:

    typedef R (*visitor_t)(T);

    visitor_t visitor_;

public:

    typedef R result_type;

private:

    typedef typename mpl::eval_if<
          is_reference<T>
        , mpl::identity<T>
        , add_reference<const T>
        >::type argument_fwd_type;

public:

    explicit visitor_ptr_t(visitor_t visitor)
      : visitor_(visitor)
    {
    }

public:

    template <typename U>
    result_type operator()(const U&) const
    {
        throw bad_visit();
    }



public:

    result_type operator()(argument_fwd_type operand) const
    {
        return visitor_(operand);
    }
# 106 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant/visitor_ptr.hpp"
};

template <typename R, typename T>
inline visitor_ptr_t<T,R> visitor_ptr(R (*visitor)(T))
{
    return visitor_ptr_t<T,R>(visitor);
}

}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/variant.hpp" 2
# 28 "./as_value.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_floating_point.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_floating_point.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_floating_point.hpp" 2

namespace boost {


template< typename T > struct is_floating_point : ::boost::integral_constant<bool,false> { };
template<> struct is_floating_point< float > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< float const > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< float volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< float const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_floating_point< double > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< double const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_floating_point< long double > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< long double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< long double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_floating_point< long double const volatile > : ::boost::integral_constant<bool,true> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_floating_point.hpp" 2
# 30 "./as_value.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 57 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stdint.h" 1 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdint.h" 1 3 4
# 28 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdint.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/wordsize.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdint.h" 2 3 4
# 49 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 129 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 138 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 4 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stdint.h" 2 3 4
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 2
# 100 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp"
namespace boost
{

  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;

  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;

  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;



  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;



  using ::intmax_t;
  using ::uintmax_t;

}
# 32 "./as_value.h" 2

# 1 "../libbase/utility.h" 1
# 25 "../libbase/utility.h"
# 1 "../gnashconfig.h" 1
# 26 "../libbase/utility.h" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 29 "../libbase/utility.h" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 30 "../libbase/utility.h" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 2 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 3 4
extern "C" {




# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const void *
memchr (__const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 165 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strchr (__const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strrchr (__const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strpbrk (char *__s, __const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strpbrk (__const char *__s, __const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strstr (char *__haystack, __const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strstr (__const char *__haystack, __const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 3 4
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
index (__const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
rindex (__const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 646 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/string.h" 3 4
}
# 46 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 2 3
# 74 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 121 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
}
# 31 "../libbase/utility.h" 2
# 39 "../libbase/utility.h"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 1 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
       
# 46 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3

#pragma GCC visibility push(default)

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 50 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/cxxabi_tweaks.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/cxxabi_tweaks.h" 3
namespace __cxxabiv1
{
  extern "C"
  {
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/cxxabi_tweaks.h" 3
  __extension__ typedef int __guard __attribute__((mode (__DI__)));


  typedef void __cxa_vec_ctor_return_type;


  typedef void __cxa_cdtor_return_type;


  }
}
# 51 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 2 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
namespace __cxxabiv1
{
  extern "C"
  {


  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);


  void*
  __cxa_vec_new(size_t __element_count, size_t __element_size,
  size_t __padding_size, __cxa_cdtor_type constructor,
  __cxa_cdtor_type destructor);

  void*
  __cxa_vec_new2(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type constructor,
   __cxa_cdtor_type destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*));

  void*
  __cxa_vec_new3(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type constructor,
   __cxa_cdtor_type destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*, size_t));


  __cxa_vec_ctor_return_type
  __cxa_vec_ctor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type constructor,
   __cxa_cdtor_type destructor);

  __cxa_vec_ctor_return_type
  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count,
    size_t element_size,
    __cxa_cdtor_return_type (*constructor) (void*, void*),
    __cxa_cdtor_type destructor);


  void
  __cxa_vec_dtor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type destructor);

  void
  __cxa_vec_cleanup(void* __array_address, size_t __element_count,
      size_t __s, __cxa_cdtor_type destructor) throw();


  void
  __cxa_vec_delete(void* __array_address, size_t __element_size,
     size_t __padding_size, __cxa_cdtor_type destructor);

  void
  __cxa_vec_delete2(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type destructor,
      void (*__dealloc) (void*));

  void
  __cxa_vec_delete3(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type destructor,
      void (*__dealloc) (void*, size_t));

  int
  __cxa_guard_acquire(__guard*);

  void
  __cxa_guard_release(__guard*) throw();

  void
  __cxa_guard_abort(__guard*) throw();


  void
  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));


  void
  __cxa_bad_cast();

  void
  __cxa_bad_typeid();


  int
  __cxa_atexit(void (*)(void*), void*, void*) throw();

  int
  __cxa_finalize(void*);
# 190 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
  char*
  __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   size_t* __length, int* __status);

  }
}






namespace __cxxabiv1
{

  class __fundamental_type_info : public std::type_info
  {
  public:
    explicit
    __fundamental_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__fundamental_type_info();
  };


  class __array_type_info : public std::type_info
  {
  public:
    explicit
    __array_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__array_type_info();
  };


  class __function_type_info : public std::type_info
  {
  public:
    explicit
    __function_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__function_type_info();

  protected:

    virtual bool
    __is_function_p() const;
  };


  class __enum_type_info : public std::type_info
  {
  public:
    explicit
    __enum_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__enum_type_info();
  };


  class __pbase_type_info : public std::type_info
  {
  public:
    unsigned int __flags;
    const std::type_info* __pointee;

    explicit
    __pbase_type_info(const char* __n, int __quals,
        const std::type_info* __type)
    : std::type_info(__n), __flags(__quals), __pointee(__type)
    { }

    virtual
    ~__pbase_type_info();


    enum __masks
      {
 __const_mask = 0x1,
 __volatile_mask = 0x2,
 __restrict_mask = 0x4,
 __incomplete_mask = 0x8,
 __incomplete_class_mask = 0x10
      };

  protected:
    __pbase_type_info(const __pbase_type_info&);

    __pbase_type_info&
    operator=(const __pbase_type_info&);


    virtual bool
    __do_catch(const std::type_info* __thr_type, void** __thr_obj,
        unsigned int __outer) const;

    inline virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __pointer_type_info : public __pbase_type_info
  {
  public:
    explicit
    __pointer_type_info(const char* __n, int __quals,
   const std::type_info* __type)
    : __pbase_type_info (__n, __quals, __type) { }


    virtual
    ~__pointer_type_info();

  protected:

    virtual bool
    __is_pointer_p() const;

    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  class __class_type_info;


  class __pointer_to_member_type_info : public __pbase_type_info
  {
  public:
    __class_type_info* __context;

    explicit
    __pointer_to_member_type_info(const char* __n, int __quals,
      const std::type_info* __type,
      __class_type_info* __klass)
    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }

    virtual
    ~__pointer_to_member_type_info();

  protected:
    __pointer_to_member_type_info(const __pointer_to_member_type_info&);

    __pointer_to_member_type_info&
    operator=(const __pointer_to_member_type_info&);


    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __base_class_type_info
  {
  public:
    const __class_type_info* __base_type;
    long __offset_flags;

    enum __offset_flags_masks
      {
 __virtual_mask = 0x1,
 __public_mask = 0x2,
 __hwm_bit = 2,
 __offset_shift = 8
      };


    bool
    __is_virtual_p() const
    { return __offset_flags & __virtual_mask; }

    bool
    __is_public_p() const
    { return __offset_flags & __public_mask; }

    ptrdiff_t
    __offset() const
    {



      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
    }
  };


  class __class_type_info : public std::type_info
  {
  public:
    explicit
    __class_type_info (const char *__n) : type_info(__n) { }

    virtual
    ~__class_type_info ();






    enum __sub_kind
      {

 __unknown = 0,



 __not_contained,


 __contained_ambig,


 __contained_virtual_mask = __base_class_type_info::__virtual_mask,


 __contained_public_mask = __base_class_type_info::__public_mask,


 __contained_mask = 1 << __base_class_type_info::__hwm_bit,

 __contained_private = __contained_mask,
 __contained_public = __contained_mask | __contained_public_mask
      };

    struct __upcast_result;
    struct __dyncast_result;

  protected:

    virtual bool
    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;

    virtual bool
    __do_catch(const type_info* __thr_type, void** __thr_obj,
        unsigned __outer) const;

  public:


    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;







    inline __sub_kind
    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
        const __class_type_info* __src_type,
        const void* __src_ptr) const;
# 458 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;





    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
  };


  class __si_class_type_info : public __class_type_info
  {
  public:
    const __class_type_info* __base_type;

    explicit
    __si_class_type_info(const char *__n, const __class_type_info *__base)
    : __class_type_info(__n), __base_type(__base) { }

    virtual
    ~__si_class_type_info();

  protected:
    __si_class_type_info(const __si_class_type_info&);

    __si_class_type_info&
    operator=(const __si_class_type_info&);


    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __sub_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info*__dst, const void*__obj,
  __upcast_result& __restrict __result) const;
  };


  class __vmi_class_type_info : public __class_type_info
  {
  public:
    unsigned int __flags;
    unsigned int __base_count;




    __base_class_type_info __base_info[1];

    explicit
    __vmi_class_type_info(const char* __n, int ___flags)
    : __class_type_info(__n), __flags(___flags), __base_count(0) { }

    virtual
    ~__vmi_class_type_info();


    enum __flags_masks
      {
 __non_diamond_repeat_mask = 0x1,
 __diamond_shaped_mask = 0x2,
 __flags_unknown_mask = 0x10
      };

  protected:

    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;
  };
# 562 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
  extern "C" void*
  __dynamic_cast(const void* __src_ptr,
   const __class_type_info* __src_type,
   const __class_type_info* __dst_type,
   ptrdiff_t __src2dst);




  extern "C" std::type_info*
  __cxa_current_exception_type() throw() __attribute__ ((__pure__));



  class __foreign_exception
  {
    virtual ~__foreign_exception() throw();
    virtual void __pure_dummy() = 0;
  };

}
# 604 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
namespace abi = __cxxabiv1;

namespace __gnu_cxx
{
# 620 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cxxabi.h" 3
  class recursive_init_error: public std::exception
  {
  public:
    recursive_init_error() throw() { }
    virtual ~recursive_init_error() throw ();
  };
}


#pragma GCC visibility pop
# 40 "../libbase/utility.h" 2
# 88 "../libbase/utility.h"
namespace gnash {



template <class T>
std::string typeName(const T& inst)
{
 std::string typeName = typeid(inst).name();

 int status;
 char* typeNameUnmangled =
  abi::__cxa_demangle (typeName.c_str(), __null, __null,
         &status);
 if (status == 0)
 {
  typeName = typeNameUnmangled;
  std::free(typeNameUnmangled);
 }

 return typeName;
}
# 124 "../libbase/utility.h"
inline unsigned long int get_thread_id(void)
{
# 137 "../libbase/utility.h"
    return (unsigned long int)pthread_self();
# 147 "../libbase/utility.h"
}

}
# 34 "./as_value.h" 2


namespace gnash {
    class VM;
 class as_object;
 class Global_as;
 class fn_call;
 class as_function;
 class MovieClip;
 class DisplayObject;
    namespace amf {
        class Writer;
    }
}

namespace gnash {



static const double NaN = std::numeric_limits<double>::quiet_NaN();



template <typename T>
inline bool
isNaN(const T& num, typename boost::enable_if<boost::is_floating_point<T> >::
        type* dummy = 0)
{
 (dummy) = (dummy);
 return num != num;
}

template <typename T>
inline bool
isInf(const T& num)
{
 return isNaN(num - num);
}



enum primitive_types
{
 PTYPE_STRING,
 PTYPE_NUMBER,
 PTYPE_BOOLEAN
};
# 106 "./as_value.h"
class as_value
{

public:


    enum AsType
    {
        UNDEFINED,
        UNDEFINED_EXCEPT,
        NULLTYPE,
        NULLTYPE_EXCEPT,
        BOOLEAN,
        BOOLEAN_EXCEPT,
        STRING,
        STRING_EXCEPT,
        NUMBER,
        NUMBER_EXCEPT,
        OBJECT,
        OBJECT_EXCEPT,
        DISPLAYOBJECT,
        DISPLAYOBJECT_EXCEPT
    };


    as_value();


    as_value(const char* str);
    as_value(const std::string& str);


    template <typename T>
    as_value(T val, typename boost::enable_if<boost::is_same<bool, T> >::type*
             dummy = 0)
        :
        _type(BOOLEAN),
        _value(val)
 {
            (dummy) = (dummy);
 }


    as_value(double val);


    as_value(as_object* obj);


    as_value(const as_value& value);


    const char* typeOf() const;




    primitive_types ptype() const;


    bool is_function() const;


    bool is_string() const {
        return _type == STRING;
    }


    bool is_number() const {
        return _type == NUMBER;
    }




    bool is_object() const {
        return _type == OBJECT || _type == DISPLAYOBJECT;
    }


    bool is_sprite() const {
        return _type == DISPLAYOBJECT;
    }
# 198 "./as_value.h"
    std::string to_string(int version = 7) const;




    double to_number() const;




    bool to_bool() const;
# 224 "./as_value.h"
    as_object* to_object(Global_as& global) const;
# 233 "./as_value.h"
    MovieClip* toMovieClip(bool skipRebinding = false) const;
# 250 "./as_value.h"
    DisplayObject* toDisplayObject(bool skipRebinding = false) const;





    as_function* to_function() const;



    std::string toDebugString() const;

    AsType defaultPrimitive(int version) const;
# 276 "./as_value.h"
    as_value to_primitive(AsType hint) const;


    void set_string(const std::string& str);


    void set_double(double val);


    void set_bool(bool val);


    void set_as_object(as_object* obj);


    void set_undefined();


    void set_null();

    void operator=(const as_value& v);

    bool is_undefined() const {
        return (_type == UNDEFINED);
    }

    bool is_null() const {
        return (_type == NULLTYPE);
    }

    bool is_bool() const {
        return (_type == BOOLEAN);
    }

    bool is_exception() const {
        return (_type == UNDEFINED_EXCEPT || _type == NULLTYPE_EXCEPT
                || _type == BOOLEAN_EXCEPT || _type == NUMBER_EXCEPT
                || _type == OBJECT_EXCEPT || _type == DISPLAYOBJECT_EXCEPT
                || _type == STRING_EXCEPT);
    }



    void flag_exception() {
        if (!is_exception()) {
            _type = static_cast<AsType>(static_cast<int>(_type) + 1);
        }
    }

    void unflag_exception() {
        if (is_exception()) {
            _type = static_cast<AsType>(static_cast<int>(_type) - 1);
        }
    }





    bool strictly_equals(const as_value& v) const;
# 348 "./as_value.h"
    bool equals(const as_value& v) const;




    void setReachable() const;
# 371 "./as_value.h"
    bool writeAMF0(amf::Writer& w) const;

private:
# 383 "./as_value.h"
    typedef boost::variant<boost::blank,
                           double,
                           bool,
                           as_object*,
                           CharacterProxy,
                           std::string>
    AsValueType;


    bool operator==(const as_value& v) const;


    bool operator!=(const as_value& v) const;





    bool equalsSameType(const as_value& v) const;


    bool to_bool_v7() const;


    bool to_bool_v6() const;


    bool to_bool_v5() const;

    AsType _type;

    AsValueType _value;




    as_object* getObj() const;




    DisplayObject* getCharacter(bool skipRebinding = false) const;




    CharacterProxy getCharacterProxy() const;




    double getNum() const {
        ((_type == NUMBER) ? static_cast<void> (0) : __assert_fail ("_type == NUMBER", "./as_value.h", 435, __PRETTY_FUNCTION__));
        return boost::get<double>(_value);
    }




    bool getBool() const {
        ((_type == BOOLEAN) ? static_cast<void> (0) : __assert_fail ("_type == BOOLEAN", "./as_value.h", 443, __PRETTY_FUNCTION__));
        return boost::get<bool>(_value);
    }




    const std::string& getStr() const {
        ((_type == STRING) ? static_cast<void> (0) : __assert_fail ("_type == STRING", "./as_value.h", 451, __PRETTY_FUNCTION__));
        return boost::get<std::string>(_value);
    }

};


as_value& convertToNumber(as_value& v, VM& vm);


as_value& convertToString(as_value& v, VM& vm);


as_value& convertToBoolean(as_value& v, VM& vm);


as_value& convertToPrimitive(as_value& v, VM& vm);

inline std::ostream& operator<< (std::ostream& os, const as_value& v) {
 return os << v.toDebugString();
}
# 489 "./as_value.h"
std::string doubleToString(double val, int radix = 10);
# 504 "./as_value.h"
bool parseNonDecimalInt(const std::string& s, double& d, bool whole = true);
# 513 "./as_value.h"
boost::int32_t toInt(const as_value& val);


inline void
setNaN(as_value& v) {
    v.set_double(NaN);
}

}
# 23 "asobj/Array_as.cpp" 2
# 1 "asobj/Array_as.h" 1
# 22 "asobj/Array_as.h"
# 1 "./as_object.h" 1
# 23 "./as_object.h"
# 1 "../gnashconfig.h" 1
# 24 "./as_object.h" 2


# 1 "../libbase/string_table.h" 1
# 27 "../libbase/string_table.h"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/algorithm" 1 3
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/algorithm" 3
       
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/algorithm" 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3






namespace std __attribute__ ((__visibility__ ("default"))) {
# 199 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);
# 228 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
# 267 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
# 321 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
# 406 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);
# 423 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
# 444 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 527 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&)[_Nm], _Tp (&)[_Nm]);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,



     _Generator&);


  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

}
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 1 3
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 152 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 201 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
# 274 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
# 348 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
# 371 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 411 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 450 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 479 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 576 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_heap.h" 3
}
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tempbuf.h" 1 3
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tempbuf.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_construct.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template<typename _T1, typename _T2>
    inline void




    _Construct(_T1* __p, const _T2& __value)

    {


      ::new(static_cast<void*>(__p)) _T1((__value));
    }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(&*__first);
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

}
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tempbuf.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(&*__cur, *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }


  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 161 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }


  template<bool>
    struct __uninitialized_construct_range_dispatch
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator __first, _ForwardIterator __last,
       _Tp& __value)
        {
   if(__first == __last)
     return;

   _ForwardIterator __cur = __first;
   try
     {
       std::_Construct(&*__first, (__value));
       _ForwardIterator __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(&*__cur, (*__prev));
       __value = (*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_range_dispatch<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator, _ForwardIterator, _Tp&) { }
    };
# 221 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_construct_range(_ForwardIterator __first,
        _ForwardIterator __last,
        _Tp& __value)
    {
      typedef typename std::iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_construct_range_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __value);
    }


  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 277 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 391 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 537 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_uninitialized.h" 3
}
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if(_M_buffer)
     std::__uninitialized_construct_range(_M_buffer, _M_buffer + _M_len,
       *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 2 3







namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Iterator>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
    {

     


      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__a, __b);
   else if (*__a < *__c)
     std::iter_swap(__a, __c);
 }
      else if (*__a < *__c)
 return;
      else if (*__b < *__c)
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }


  template<typename _Iterator, typename _Compare>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c,
   _Compare __comp)
    {

     



      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__a, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__a, __c);
 }
      else if (__comp(*__a, *__c))
 return;
      else if (__comp(*__b, *__c))
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 322 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 407 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 645 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 691 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 870 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 907 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1082 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1125 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1165 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
# 1205 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1433 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1460 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      _RandomAccessIterator __p = __first;

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*__p);
    std::copy(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*(__p + __n - 1));
    std::copy_backward(__p, __p + __n - 1, __p + __n);
    *__p = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
# 1664 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1698 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = (*__first);
  ++__result1;
       }
     else
       {
  *__result2 = (*__first);
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1856 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1938 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2004 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1));
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1), __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2388 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     
                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2437 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2488 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     
                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2543 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
     
      ;
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2605 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

     
                    ;
     
                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2666 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     
      ;
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2699 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     

     
                    ;
     
                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge((__buffer),
    (__buffer_end),
    (__middle),
    (__last),
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward((__first),
    (__middle),
    (__buffer),
    (__buffer_end),
    __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge((__buffer),
    (__buffer_end),
    (__middle),
    (__last),
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward((__first),
    (__middle),
    (__buffer),
    (__buffer_end),
    __last,__comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3059 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3114 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(
   (__first),
   (__first + __step_size),
   (__first + __step_size),
   (__first + __two_step),
   __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge((__first),
       (__first + __step_size)
                   ,
       (__first + __step_size)
                   ,
       (__last),
       __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(
   (__first),
   (__first + __step_size),
   (__first + __step_size),
   (__first + __two_step),
   __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge((__first),
       (__first + __step_size)
                   ,
       (__first + __step_size)
                   ,
       (__last),
       __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3412 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3461 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3516 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3573 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3629 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3686 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3746 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3783 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 4161 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 4177 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return (__f);
    }
# 4198 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4222 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4251 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4290 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4322 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4354 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4386 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4411 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4451 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4522 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4596 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4632 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4674 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4710 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4743 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4775 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4807 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4838 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 4874 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4913 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4945 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 4973 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



     _RandomNumberGenerator& __rand)

    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 5009 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5043 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5082 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5120 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5159 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5197 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5233 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5274 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5337 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5397 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5439 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5485 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5552 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5619 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5676 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5734 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5795 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5853 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 5919 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5976 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6004 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6032 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6060 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }

}
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/algorithm" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 1 3
# 47 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 3
       
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 3
# 68 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_raw_storage_iter.h" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 69 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 2 3
# 103 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 1 3
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
# 84 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 110 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 122 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 133 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 150 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 168 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 178 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 208 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 222 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 237 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 258 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;

}
# 104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/memory" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp" 2


namespace boost{

namespace detail{






namespace allocator{






template<typename Type>
class partial_std_allocator_wrapper:public std::allocator<Type>
{
public:





  typedef Type value_type;

  partial_std_allocator_wrapper(){};

  template<typename Other>
  partial_std_allocator_wrapper(const partial_std_allocator_wrapper<Other>&){}

  partial_std_allocator_wrapper(const std::allocator<Type>& x):
    std::allocator<Type>(x)
  {
  };
# 70 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp"
};
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp"
template<typename Allocator>
struct is_partial_std_allocator
{
  static const bool value=false;
};





template<typename Allocator,typename Type>
struct partial_std_allocator_rebind_to
{
  typedef partial_std_allocator_wrapper<Type> type;
};
# 142 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp"
template<typename Allocator>
struct rebinder
{
  template<typename Type>
  struct result
  {
      typedef typename Allocator::template
          rebind<Type>::other other;
  };
};


template<typename Allocator,typename Type>
struct compliant_allocator_rebind_to
{
  typedef typename rebinder<Allocator>::
      template result<Type>::other type;
};



template<typename Allocator,typename Type>
struct rebind_to:
  mpl::eval_if_c<
    is_partial_std_allocator<Allocator>::value,
    partial_std_allocator_rebind_to<Allocator,Type>,
    compliant_allocator_rebind_to<Allocator,Type>
  >
{
};



template<typename Type>
void construct(void* p,const Type& t)
{
  new (p) Type(t);
}
# 190 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/allocator_utilities.hpp"
template<typename Type>
void destroy(const Type* p)
{




  p->~Type();


}





}

}

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/no_exceptions_support.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/at.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/at.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/at_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/at_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct at_impl;
template< typename Sequence, typename N > struct at;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/at.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/at_impl.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/at_impl.hpp"
namespace boost { namespace mpl {




template< typename Tag >
struct at_impl
{
    template< typename Sequence, typename N > struct apply
    {
        typedef typename advance<
              typename begin<Sequence>::type
            , N
            >::type iter_;

        typedef typename deref<iter_>::type type;
    };
};

 template<> struct at_impl<non_sequence_tag> {};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/at.hpp" 2






namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename N = na
    >
struct at
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,N >
{
   
};

template<
      typename Sequence
    , long N
    >
struct at_c
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,mpl::long_<N> >
{
};

template<> struct at< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : at< T1 , T2 > { }; }; template< typename Tag > struct lambda< at< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef at< na , na > result_; typedef at< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< at< T1 , T2 > > : int_<2> { }; template<> struct template_arity< at< na , na > > : int_<-1> { }; }

}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/contains.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/contains.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/contains_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/contains_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct contains_impl;
template< typename Sequence, typename T > struct contains;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/contains.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/contains_impl.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/contains_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/find.hpp"
namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct find
    : find_if< Sequence,same_as<T> >
{
   
};

template<> struct find< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find< T1 , T2 > { }; }; template< typename Tag > struct lambda< find< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find< na , na > result_; typedef find< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find< na , na > > : int_<-1> { }; }

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/contains_impl.hpp" 2







namespace boost { namespace mpl {

template< typename Tag >
struct contains_impl
{
    template< typename Sequence, typename T > struct apply

        : not_< is_same<
              typename find<Sequence,T>::type
            , typename end<Sequence>::type
            > >
    {
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/contains_impl.hpp"
    };
};

 template<> struct contains_impl<non_sequence_tag> {};

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/contains.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct contains
    : contains_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};

template<> struct contains< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : contains< T1 , T2 > { }; }; template< typename Tag > struct lambda< contains< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef contains< na , na > result_; typedef contains< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< contains< T1 , T2 > > : int_<2> { }; template<> struct template_arity< contains< na , na > > : int_<-1> { }; }

}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/size_impl.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/size_impl.hpp"
namespace boost { namespace mpl {




template< typename Tag >
struct size_impl
{
    template< typename Sequence > struct apply

        : distance<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {







    };
};

 template<> struct size_impl<non_sequence_tag> {};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/size.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct size
    : aux::msvc_eti_base<
        typename size_impl< typename sequence_tag<Sequence>::type >
            ::template apply< Sequence >::type
      >::type
{
   
};

template<> struct size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : size< T1 > { }; }; template< typename Tag > struct lambda< size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef size< na > result_; typedef size< na > type; }; namespace aux { template< typename T1 > struct template_arity< size< T1 > > : int_<1> { }; template<> struct template_arity< size< na > > : int_<-1> { }; }

}}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity_fwd.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity_fwd.hpp"
namespace boost{

namespace multi_index{

template<class Type> struct identity;

}

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp" 2

namespace boost {



namespace detail {

template <typename T, bool is_vol>
struct remove_const_helper
{
    typedef T type;
};

template <typename T>
struct remove_const_helper<T, true>
{
    typedef T volatile type;
};


template <typename T>
struct remove_const_impl
{
    typedef typename remove_const_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_volatile<T>::value
        >::type type;
};
# 69 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp"
}



template< typename T > struct remove_const { typedef typename boost::detail::remove_const_impl<T>::type type; };
template< typename T > struct remove_const<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_const<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_const<T const volatile[N]> { typedef T volatile type[N]; };
# 86 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 89 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_const.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity.hpp" 2






namespace boost{

template<class Type> class reference_wrapper;

namespace multi_index{

namespace detail{
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/identity.hpp"
template<typename Type>
struct const_identity_base
{
  typedef Type result_type;

  template<typename ChainedPtr>


  typename disable_if<is_convertible<const ChainedPtr&,Type&>,Type&>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type& operator()(Type& x)const
  {
    return x;
  }

  Type& operator()(const reference_wrapper<Type>& x)const
  {
    return x.get();
  }

  Type& operator()(
    const reference_wrapper<typename remove_const<Type>::type>& x,int=0)const
  {
    return x.get();
  }
};

template<typename Type>
struct non_const_identity_base
{
  typedef Type result_type;



  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Type&>,Type&>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  const Type& operator()(const Type& x,int=0)const
  {
    return x;
  }

  Type& operator()(Type& x)const
  {
    return x;
  }

  const Type& operator()(const reference_wrapper<const Type>& x,int=0)const
  {
    return x.get();
  }

  Type& operator()(const reference_wrapper<Type>& x)const
  {
    return x.get();
  }
};

}

template<class Type>
struct identity:
  mpl::if_c<
    is_const<Type>::value,
    detail::const_identity_base<Type>,detail::non_const_identity_base<Type>
  >::type
{
};

}

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/indexed_by.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/indexed_by.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/limits/vector.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector20.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector20.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector10.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector10.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/at.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/at.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/tag.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/tag.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/typeof.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/tag.hpp" 2


namespace boost { namespace mpl { namespace aux {

struct v_iter_tag;


struct vector_tag;




}}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/at.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/at.hpp"
namespace boost { namespace mpl {



template< typename Vector, long n_ >
struct v_at_impl
{
    typedef long_< (Vector::lower_bound_::value + n_) > index_;
    typedef __typeof__( Vector::item_(index_()) ) type;
};


template< typename Vector, long n_ >
struct v_at
    : aux::wrapped_type< typename v_at_impl<Vector,n_>::type >
{
};

template<>
struct at_impl< aux::vector_tag >
{
    template< typename Vector, typename N > struct apply
        : v_at<
              Vector
            , N::value
            >
    {
    };
};
# 114 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/at.hpp"
}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/front.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/front.hpp"
namespace boost { namespace mpl {



template<>
struct front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<Vector,0>
    {
    };
};
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/front.hpp"
}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/push_front.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/push_front.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/item.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/item.hpp"
namespace boost { namespace mpl {



template<
      typename T
    , typename Base
    , int at_front = 0
    >
struct v_item
    : Base
{
    typedef typename Base::upper_bound_ index_;
    typedef typename next<index_>::type upper_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;



    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};

template<
      typename T
    , typename Base
    >
struct v_item<T,Base,1>
    : Base
{
    typedef typename prior<typename Base::lower_bound_>::type index_;
    typedef index_ lower_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;

    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};


template<
      typename Base
    , int at_front
    >
struct v_mask
    : Base
{
    typedef typename prior<typename Base::upper_bound_>::type index_;
    typedef index_ upper_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};

template<
      typename Base
    >
struct v_mask<Base,1>
    : Base
{
    typedef typename Base::lower_bound_ index_;
    typedef typename next<index_>::type lower_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};



}}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/push_front.hpp" 2


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,1> type;
    };
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/pop_front.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/pop_front.hpp"
namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,1> type;
    };
};

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/push_back.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/push_back.hpp"
namespace boost { namespace mpl {

template<>
struct push_back_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,0> type;
    };
};

}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/pop_back.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/pop_back.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pop_back_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/pop_back_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct pop_back_impl;
template< typename Sequence > struct pop_back;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/pop_back.hpp" 2







namespace boost { namespace mpl {

template<>
struct pop_back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,0> type;
    };
};

}}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/back.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/back.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/back_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/back_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct back_impl;
template< typename Sequence > struct back;

}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/back.hpp" 2






namespace boost { namespace mpl {



template<>
struct back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<
              Vector
            , prior<typename Vector::size>::type::value
            >
    {
    };
};
# 57 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/back.hpp"
}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/clear.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/clear.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/vector0.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/vector0.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/plus.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/plus.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/largest_int.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/largest_int.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct integral_rank;

template<> struct integral_rank<bool> : int_<1> {};
template<> struct integral_rank<signed char> : int_<2> {};
template<> struct integral_rank<char> : int_<3> {};
template<> struct integral_rank<unsigned char> : int_<4> {};

template<> struct integral_rank<wchar_t> : int_<5> {};

template<> struct integral_rank<short> : int_<6> {};
template<> struct integral_rank<unsigned short> : int_<7> {};
template<> struct integral_rank<int> : int_<8> {};
template<> struct integral_rank<unsigned int> : int_<9> {};
template<> struct integral_rank<long> : int_<10> {};
template<> struct integral_rank<unsigned long> : int_<11> {};


template<> struct integral_rank<long_long_type> : int_<12> {};
template<> struct integral_rank<ulong_long_type>: int_<13> {};


template< typename T1, typename T2 > struct largest_int

    : if_c<
          ( integral_rank<T1>::value >= integral_rank<T2>::value )
        , T1
        , T2
        >
{






};

}}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct plus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< plus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< plus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct plus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct plus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct plus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct plus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct plus
    : plus< plus< plus< plus< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct plus< N1,N2,N3,N4,na >

    : plus< plus< plus< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct plus< N1,N2,N3,na,na >

    : plus< plus< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct plus< N1,N2,na,na,na >
    : plus_impl<
          typename plus_tag<N1>::type
        , typename plus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct plus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : plus< T1 , T2 > { }; }; template< typename Tag > struct lambda< plus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef plus< na , na > result_; typedef plus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< plus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< plus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct plus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  + N2::value
                )
            >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/plus.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/minus.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/minus.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct minus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< minus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< minus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct minus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct minus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct minus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct minus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct minus
    : minus< minus< minus< minus< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct minus< N1,N2,N3,N4,na >

    : minus< minus< minus< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct minus< N1,N2,N3,na,na >

    : minus< minus< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct minus< N1,N2,na,na,na >
    : minus_impl<
          typename minus_tag<N1>::type
        , typename minus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct minus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : minus< T1 , T2 > { }; }; template< typename Tag > struct lambda< minus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef minus< na , na > result_; typedef minus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< minus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< minus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct minus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  - N2::value
                )
            >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/minus.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp"
namespace boost { namespace mpl {

template<
      typename Vector
    , long n_
    >
struct v_iter
{
    typedef aux::v_iter_tag tag;
    typedef random_access_iterator_tag category;
    typedef typename v_at<Vector,n_>::type type;

    typedef Vector vector_;
    typedef mpl::long_<n_> pos;
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp"
};




template<
      typename Vector
    , long n_
    >
struct next< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ + 1)> type;
};

template<
      typename Vector
    , long n_
    >
struct prior< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ - 1)> type;
};

template<
      typename Vector
    , long n_
    , typename Distance
    >
struct advance< v_iter<Vector,n_>,Distance>
{
    typedef v_iter<
          Vector
        , (n_ + Distance::value)
        > type;
};

template<
      typename Vector
    , long n_
    , long m_
    >
struct distance< v_iter<Vector,n_>, v_iter<Vector,m_> >
    : mpl::long_<(m_ - n_)>
{
};
# 128 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/iterator.hpp"
}}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/vector0.hpp" 2



namespace boost { namespace mpl {

template< typename Dummy = na > struct vector0;

template<> struct vector0<na>
{

    typedef aux::vector_tag tag;
    typedef vector0 type;
    typedef long_<32768> lower_bound_;
    typedef lower_bound_ upper_bound_;
    typedef long_<0> size;

    static aux::type_wrapper<void_> item_(...);
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/vector0.hpp"
};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/clear.hpp" 2




namespace boost { namespace mpl {



template<>
struct clear_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef vector0<> type;
    };
};
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/clear.hpp"
}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/O1_size.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/O1_size.hpp"
namespace boost { namespace mpl {



template<>
struct O1_size_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : Vector::size
    {
    };
};
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/O1_size.hpp"
}}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/size.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/size.hpp"
namespace boost { namespace mpl {



template<>
struct size_impl< aux::vector_tag >
    : O1_size_impl< aux::vector_tag >
{
};
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/size.hpp"
}}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/empty.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/empty.hpp"
namespace boost { namespace mpl {



template<>
struct empty_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : is_same<
              typename Vector::lower_bound_
            , typename Vector::upper_bound_
            >
    {
    };
};
# 66 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/empty.hpp"
}}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/begin_end.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/begin_end.hpp"
namespace boost { namespace mpl {

template<>
struct begin_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,0> type;
    };
};

template<>
struct end_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,Vector::size::value> type;
    };
};

}}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector0.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector10.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector10.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 1
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp"
namespace boost { namespace mpl {

template<
      typename T0
    >
struct vector1
    : v_item<
          T0
        , vector0< >
        >
{
    typedef vector1 type;
};

template<
      typename T0, typename T1
    >
struct vector2
    : v_item<
          T1
        , vector1<T0>
        >
{
    typedef vector2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector3
    : v_item<
          T2
        , vector2< T0,T1 >
        >
{
    typedef vector3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector4
    : v_item<
          T3
        , vector3< T0,T1,T2 >
        >
{
    typedef vector4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector5
    : v_item<
          T4
        , vector4< T0,T1,T2,T3 >
        >
{
    typedef vector5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector6
    : v_item<
          T5
        , vector5< T0,T1,T2,T3,T4 >
        >
{
    typedef vector6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector7
    : v_item<
          T6
        , vector6< T0,T1,T2,T3,T4,T5 >
        >
{
    typedef vector7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector8
    : v_item<
          T7
        , vector7< T0,T1,T2,T3,T4,T5,T6 >
        >
{
    typedef vector8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector9
    : v_item<
          T8
        , vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef vector9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector10
    : v_item<
          T9
        , vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef vector10 type;
};

}}
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector10.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector20.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector20.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 1
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp"
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector11
    : v_item<
          T10
        , vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef vector11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector12
    : v_item<
          T11
        , vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef vector12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector13
    : v_item<
          T12
        , vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef vector13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector14
    : v_item<
          T13
        , vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef vector14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector15
    : v_item<
          T14
        , vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef vector15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector16
    : v_item<
          T15
        , vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef vector16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector17
    : v_item<
          T16
        , vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef vector17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector18
    : v_item<
          T17
        , vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef vector18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector19
    : v_item<
          T18
        , vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef vector19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector20
    : v_item<
          T19
        , vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef vector20 type;
};

}}
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector/vector20.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp" 2
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp"
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct vector;

template<

    >
struct vector<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector0< >
{
    typedef vector0< >::type type;
};

template<
      typename T0
    >
struct vector<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector1<T0>
{
    typedef typename vector1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct vector<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector2< T0,T1 >
{
    typedef typename vector2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector3< T0,T1,T2 >
{
    typedef typename vector3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector4< T0,T1,T2,T3 >
{
    typedef typename vector4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector5< T0,T1,T2,T3,T4 >
{
    typedef typename vector5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename vector6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename vector7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename vector8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : vector15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : vector16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : vector17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : vector18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : vector19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector
    : vector20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename vector20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/vector.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/indexed_by.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/expr_if.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/indexed_by.hpp" 2
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/indexed_by.hpp"
namespace boost{

namespace multi_index{

template<
 

 typename T0 , typename T1 =mpl::na , typename T2 =mpl::na , typename T3 =mpl::na , typename T4 =mpl::na , typename T5 =mpl::na , typename T6 =mpl::na , typename T7 =mpl::na , typename T8 =mpl::na , typename T9 =mpl::na , typename T10 =mpl::na , typename T11 =mpl::na , typename T12 =mpl::na , typename T13 =mpl::na , typename T14 =mpl::na , typename T15 =mpl::na , typename T16 =mpl::na , typename T17 =mpl::na , typename T18 =mpl::na , typename T19 =mpl::na
>
struct indexed_by:
  mpl::vector< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19>
{
};

}

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container_fwd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index_fwd.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_args.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_args.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/tag.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/tag.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/no_duplicate_tags.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/no_duplicate_tags.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/at_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/at_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/has_key_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/has_key_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/tag.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/tag.hpp"
namespace boost { namespace mpl { namespace aux {

struct set_tag;

}}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/has_key_impl.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_key_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_key_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct has_key_impl;
template< typename AssociativeSequence, typename Key > struct has_key;

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/has_key_impl.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/overload_names.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/overload_names.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/ptr_to_ref.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/ptr_to_ref.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > static T const& ptr_to_ref(T*);

}}}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/overload_names.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/config/operators.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/overload_names.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/has_key_impl.hpp" 2






namespace boost { namespace mpl {

template<>
struct has_key_impl< aux::set_tag >
{
    template< typename Set, typename T > struct apply
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/has_key_impl.hpp"
        : bool_<
              ( sizeof( Set::is_masked_( aux::ptr_to_ref(static_cast<Set*>(0)), static_cast<aux::type_wrapper<T>*>(0) )


                    ) == sizeof(aux::no_tag) )
            >
    {

    };
};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/at_impl.hpp" 2




namespace boost { namespace mpl {

template<>
struct at_impl< aux::set_tag >
{
    template< typename Set, typename T > struct apply
    {
        typedef typename if_<
              has_key_impl<aux::set_tag>::apply<Set,T>
            , T
            , void_
            >::type type;
    };
};

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/clear_impl.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/clear_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/set0.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/set0.hpp"
namespace boost { namespace mpl {
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/set0.hpp"
template< typename Dummy = na > struct set0
{
    typedef set0<> item_;
    typedef item_ type;
    typedef aux::set_tag tag;
    typedef void_ last_masked_;
    typedef void_ item_type_;
    typedef long_<0> size;
    typedef long_<1> order;

    static aux::no_tag order_by_key_(set0<> const&, void const volatile*);
    static aux::yes_tag is_masked_(set0<> const&, void const volatile*);
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/clear_impl.hpp" 2


namespace boost { namespace mpl {

template<>
struct clear_impl< aux::set_tag >
{
    template< typename Set > struct apply
    {
        typedef set0<> type;
    };
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/size_impl.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/size_impl.hpp"
namespace boost { namespace mpl {

template<>
struct size_impl< aux::set_tag >
{
    template< typename Set > struct apply
        : Set::size
    {
    };
};

}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/empty_impl.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/empty_impl.hpp"
namespace boost { namespace mpl {

template<>
struct empty_impl< aux::set_tag >
{
    template< typename Set > struct apply
        : not_< typename Set::size >
    {
    };
};

}}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/insert_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/insert_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/insert_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/insert_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct insert_impl;
template< typename Sequence, typename Pos_or_T, typename T > struct insert;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/insert_impl.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/item.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/item.hpp"
namespace boost { namespace mpl {

template< typename T, typename Base >
struct s_item
    : Base
{
    typedef s_item<T,Base> item_;
    typedef void_ last_masked_;
    typedef T item_type_;
    typedef Base base;

    typedef typename next< typename Base::size >::type size;
    typedef typename next< typename Base::order >::type order;




    typedef char (&order_tag_)[order::value];


    static order_tag_ order_by_key_(s_item const&, aux::type_wrapper<T>*); using Base::order_by_key_;
    static aux::no_tag is_masked_(s_item const&, aux::type_wrapper<T>*); using Base::is_masked_;
};


template< typename T, typename Base >
struct s_mask
    : Base
{
    typedef s_mask<T,Base> item_;
    typedef T last_masked_;
    typedef void_ item_type_;
    typedef Base base;
    typedef typename prior< typename Base::size >::type size;

    static aux::yes_tag is_masked_(s_mask const&, aux::type_wrapper<T>*); using Base::is_masked_;
};


template< typename T, typename Base >
struct s_unmask
    : Base
{
    typedef s_unmask<T,Base> item_;
    typedef void_ last_masked_;
    typedef T item_type_;
    typedef Base base;
    typedef typename next< typename Base::size >::type size;

    static aux::no_tag is_masked_(s_unmask const&, aux::type_wrapper<T>*); using Base::is_masked_;
};

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/insert_impl.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/base.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/base.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct base
{
    typedef typename T::base type;
   
};

template<> struct base< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : base< T1 > { }; }; template< typename Tag > struct lambda< base< na > , Tag , int_<-1> > { typedef false_ is_le; typedef base< na > result_; typedef base< na > type; }; namespace aux { template< typename T1 > struct template_arity< base< T1 > > : int_<1> { }; template<> struct template_arity< base< na > > : int_<-1> { }; }

}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/insert_impl.hpp" 2





namespace boost { namespace mpl {

namespace aux {
template< typename Set, typename T > struct set_insert_impl
    : eval_if<
          has_key_impl<aux::set_tag>::apply<Set,T>
        , identity<Set>
        , eval_if<
              is_same< T,typename Set::last_masked_ >
            , base<Set>
            , identity< s_item<T,typename Set::item_> >
            >
        >
{
};
}

template<>
struct insert_impl< aux::set_tag >
{
    template<
          typename Set
        , typename PosOrKey
        , typename KeyOrNA
        >
    struct apply
        : aux::set_insert_impl<
              Set
            , typename if_na<KeyOrNA,PosOrKey>::type
            >
    {
    };
};

}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/erase_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/erase_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct erase_impl;
template< typename Sequence, typename First, typename Last > struct erase;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_impl.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_key_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_key_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/erase_key_fwd.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/erase_key_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct erase_key_impl;
template< typename Sequence, typename Key > struct erase_key;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_key_impl.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_key_impl.hpp"
namespace boost { namespace mpl {

template<>
struct erase_key_impl< aux::set_tag >
{
    template<
          typename Set
        , typename T
        >
    struct apply
        : eval_if<
              has_key_impl<aux::set_tag>::apply<Set,T>
            , eval_if<
                  is_same< T,typename Set::item_type_ >
                , base<Set>
                , identity< s_mask<T,typename Set::item_> >
                >
            , identity<Set>
            >
    {
    };
};

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/erase_impl.hpp" 2


namespace boost { namespace mpl {

template<>
struct erase_impl< aux::set_tag >
{
    template<
          typename Set
        , typename Pos
        , typename unused_
        >
    struct apply
        : erase_key_impl<aux::set_tag>
            ::apply<Set,typename Pos::type>
    {
    };
};

}}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/key_type_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/key_type_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/key_type_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/key_type_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct key_type_impl;
template< typename AssociativeSequence, typename T > struct key_type;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/key_type_impl.hpp" 2


namespace boost { namespace mpl {

template<>
struct key_type_impl< aux::set_tag >
{
    template< typename Set, typename T > struct apply
    {
        typedef T type;
    };
};

}}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/value_type_impl.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/value_type_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/value_type_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/value_type_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct value_type_impl;
template< typename AssociativeSequence, typename T > struct value_type;

}}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/value_type_impl.hpp" 2


namespace boost { namespace mpl {

template<>
struct value_type_impl< aux::set_tag >
{
    template< typename Set, typename T > struct apply
    {
        typedef T type;
    };
};

}}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/begin_end_impl.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/begin_end_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/iterator.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/iterator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_key.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_key.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_key_impl.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/has_key_impl.hpp"
namespace boost { namespace mpl {



template< typename Tag > struct has_key_impl
{
    template< typename AssociativeSequence, typename Key > struct apply;
};

 template<> struct has_key_impl<non_sequence_tag> {};

}}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/has_key.hpp" 2



namespace boost { namespace mpl {

template<
      typename AssociativeSequence = na
    , typename Key = na
    >
struct has_key
    : has_key_impl< typename sequence_tag<AssociativeSequence>::type >
        ::template apply<AssociativeSequence,Key>
{
   
};

template<> struct has_key< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_key< T1 , T2 > { }; }; template< typename Tag > struct lambda< has_key< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_key< na , na > result_; typedef has_key< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< has_key< T1 , T2 > > : int_<2> { }; template<> struct template_arity< has_key< na , na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/iterator.hpp" 2







namespace boost { namespace mpl {


template< typename Set, typename Tail > struct s_iter;

template< typename Set, typename Tail > struct s_iter_get
    : eval_if<
          has_key< Set,typename Tail::item_type_ >
        , identity< s_iter<Set,Tail> >
        , next< s_iter<Set,Tail> >
        >
{
};

template< typename Set, typename Tail > struct s_iter_impl
{
    typedef Tail tail_;
    typedef forward_iterator_tag category;
    typedef typename Tail::item_type_ type;




};



template< typename Set, typename Tail >
struct next< s_iter<Set,Tail> >
    : s_iter_get< Set,typename Tail::base >
{
};

template< typename Set >
struct next< s_iter<Set,set0<> > >
{
    typedef s_iter<Set,set0<> > type;
};

template< typename Set, typename Tail > struct s_iter
    : s_iter_impl<Set,Tail>
{
};

template< typename Set > struct s_iter<Set, set0<> >
{
    typedef forward_iterator_tag category;
};
# 96 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/iterator.hpp"
}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/aux_/begin_end_impl.hpp" 2

namespace boost { namespace mpl {

template<>
struct begin_impl< aux::set_tag >
{
    template< typename Set > struct apply
        : s_iter_get<Set,typename Set::item_>
    {
    };
};

template<>
struct end_impl< aux::set_tag >
{
    template< typename Set > struct apply
    {
        typedef s_iter< Set,set0<> > type;
    };
};

}}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/set/set0.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/no_duplicate_tags.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/no_duplicate_tags.hpp"
struct duplicate_tag_mark{};

struct duplicate_tag_marker
{
  template <typename MplSet,typename Tag>
  struct apply
  {
    typedef mpl::s_item<
      typename mpl::if_<mpl::has_key<MplSet,Tag>,duplicate_tag_mark,Tag>::type,
      MplSet
    > type;
  };
};

template<typename TagList>
struct no_duplicate_tags
{
  typedef typename mpl::fold<
    TagList,
    mpl::set0<>,
    duplicate_tag_marker
  >::type aux;

  static const bool value=!(mpl::has_key<aux,duplicate_tag_mark>::value)
                                                              ;
};





struct duplicate_tag_list_marker
{
  template <typename MplSet,typename Index>
  struct apply:mpl::fold<
    typename Index::tag_list,
    MplSet,
    duplicate_tag_marker>
  {
  };
};

template<typename IndexList>
struct no_duplicate_tags_in_index_list
{
  typedef typename mpl::fold<
    IndexList,
    mpl::set0<>,
    duplicate_tag_list_marker
  >::type aux;

  static const bool value=!(mpl::has_key<aux,duplicate_tag_mark>::value)
                                                              ;
};

}

}

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/tag.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/facilities/intercept.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/tag.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/tag.hpp" 2
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/tag.hpp"
namespace boost{

namespace multi_index{

namespace detail{

struct tag_marker{};

template<typename T>
struct is_tag
{
  static const bool value=(is_base_and_derived<tag_marker,T>::value);
};

}

template<
 


 typename T0 =mpl::na , typename T1 =mpl::na , typename T2 =mpl::na , typename T3 =mpl::na , typename T4 =mpl::na , typename T5 =mpl::na , typename T6 =mpl::na , typename T7 =mpl::na , typename T8 =mpl::na , typename T9 =mpl::na , typename T10 =mpl::na , typename T11 =mpl::na , typename T12 =mpl::na , typename T13 =mpl::na , typename T14 =mpl::na , typename T15 =mpl::na , typename T16 =mpl::na , typename T17 =mpl::na , typename T18 =mpl::na , typename T19 =mpl::na
>
struct tag:private detail::tag_marker
{




  typedef typename mpl::transform<
    mpl::vector< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19>,
    mpl::identity<mpl::_1>
  >::type type;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((detail::no_duplicate_tags<type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_83;
};

}

}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_args.hpp" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/functional" 1 3
# 47 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/functional" 3
       
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/functional" 3
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_args.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_args.hpp"
template<typename KeyFromValue>
struct index_args_default_compare
{
  typedef std::less<typename KeyFromValue::result_type> type;
};

template<typename Arg1,typename Arg2,typename Arg3>
struct ordered_index_args
{
  typedef is_tag<Arg1> full_form;

  typedef typename mpl::if_<
    full_form,
    Arg1,
    tag< > >::type tag_list_type;
  typedef typename mpl::if_<
    full_form,
    Arg2,
    Arg1>::type key_from_value_type;
  typedef typename mpl::if_<
    full_form,
    Arg3,
    Arg2>::type supplied_compare_type;
  typedef typename mpl::eval_if<
    mpl::is_na<supplied_compare_type>,
    index_args_default_compare<key_from_value_type>,
    mpl::identity<supplied_compare_type>
  >::type compare_type;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((is_tag<tag_list_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_72;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!mpl::is_na<key_from_value_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_73;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!mpl::is_na<compare_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_74;
};

}

}

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index_fwd.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{

template<
  typename KeyFromValue,typename Compare,
  typename SuperMeta,typename TagList,typename Category
>
class ordered_index;

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator==(
  const ordered_index<
    KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<
    KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y);

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator<(
  const ordered_index<
    KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<
    KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y);

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator!=(
  const ordered_index<
    KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<
    KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y);

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator>(
  const ordered_index<
    KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<
    KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y);

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator>=(
  const ordered_index<
    KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<
    KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y);

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator<=(
  const ordered_index<
    KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<
    KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y);

template<
  typename KeyFromValue,typename Compare,
  typename SuperMeta,typename TagList,typename Category
>
void swap(
  ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x,
  ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& y);

}



template<typename Arg1,typename Arg2=mpl::na,typename Arg3=mpl::na>
struct ordered_unique;

template<typename Arg1,typename Arg2=mpl::na,typename Arg3=mpl::na>
struct ordered_non_unique;

}

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container_fwd.hpp" 2


namespace boost{

namespace multi_index{





template<
  typename Value,
  typename IndexSpecifierList=indexed_by<ordered_unique<identity<Value> > >,
  typename Allocator=std::allocator<Value> >
class multi_index_container;

template<typename MultiIndexContainer,int N>
struct nth_index;

template<typename MultiIndexContainer,typename Tag>
struct index;

template<typename MultiIndexContainer,int N>
struct nth_index_iterator;

template<typename MultiIndexContainer,int N>
struct nth_index_const_iterator;

template<typename MultiIndexContainer,typename Tag>
struct index_iterator;

template<typename MultiIndexContainer,typename Tag>
struct index_const_iterator;





template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator==(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y);

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator<(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y);

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator!=(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y);

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator>(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y);

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator>=(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y);

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator<=(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y);

template<typename Value,typename IndexSpecifierList,typename Allocator>
void swap(
  multi_index_container<Value,IndexSpecifierList,Allocator>& x,
  multi_index_container<Value,IndexSpecifierList,Allocator>& y);

}





using multi_index::multi_index_container;

}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/access_specifier.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/adl_swap.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/adl_swap.hpp"
namespace boost{

namespace multi_index{

namespace detail{

template<typename T>
void adl_swap(T& x,T& y)
{


  using std::swap;
  swap(x,y);




}

}

}

}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/base_type.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/base_type.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/base_type.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/copy_map.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/copy_map.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/auto_space.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/auto_space.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/prevent_eti.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/prevent_eti.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/prevent_eti.hpp"
template<typename Type,typename Construct>
struct prevent_eti
{
  typedef Construct type;
};


}

}

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/auto_space.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/noncopyable.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/noncopyable.hpp"
namespace boost {






namespace noncopyable_
{
  class noncopyable
  {
   protected:
      noncopyable() {}
      ~noncopyable() {}
   private:
      noncopyable( const noncopyable& );
      const noncopyable& operator=( const noncopyable& );
  };
}

typedef noncopyable_::noncopyable noncopyable;

}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/auto_space.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/auto_space.hpp"
template<typename T,typename Allocator=std::allocator<T> >
struct auto_space:private noncopyable
{
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,T
    >::type
  >::type::pointer pointer;

  explicit auto_space(const Allocator& al=Allocator(),std::size_t n=1):
  al_(al),n_(n),data_(n_?al_.allocate(n_):pointer(0))
  {}

  ~auto_space()
  {
    if(n_)al_.deallocate(data_,n_);
  }

  Allocator get_allocator()const{return al_;}

  pointer data()const{return data_;}

  void swap(auto_space& x)
  {
    if(al_!=x.al_)adl_swap(al_,x.al_);
    std::swap(n_,x.n_);
    std::swap(data_,x.data_);
  }

private:
  typename boost::detail::allocator::rebind_to<
    Allocator,T>::type al_;
  std::size_t n_;
  pointer data_;
};

template<typename T,typename Allocator>
void swap(auto_space<T,Allocator>& x,auto_space<T,Allocator>& y)
{
  x.swap(y);
}

}

}

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/copy_map.hpp" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/copy_map.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/copy_map.hpp"
template <typename Node>
struct copy_map_entry
{
  copy_map_entry(Node* f,Node* s):first(f),second(s){}

  Node* first;
  Node* second;

  bool operator<(const copy_map_entry<Node>& x)const
  {
    return std::less<Node*>()(first,x.first);
  }
};

template <typename Node,typename Allocator>
class copy_map:private noncopyable
{
public:
  typedef const copy_map_entry<Node>* const_iterator;

  copy_map(
    const Allocator& al,std::size_t size,Node* header_org,Node* header_cpy):
    al_(al),size_(size),spc(al_,size_),n(0),
    header_org_(header_org),header_cpy_(header_cpy),released(false)
  {}

  ~copy_map()
  {
    if(!released){
      for(std::size_t i=0;i<n;++i){
        boost::detail::allocator::destroy(&(spc.data()+i)->second->value());
        deallocate((spc.data()+i)->second);
      }
    }
  }

  const_iterator begin()const{return &*spc.data();}
  const_iterator end()const{return &*(spc.data()+n);}

  void clone(Node* node)
  {
    (spc.data()+n)->first=node;
    (spc.data()+n)->second=&*al_.allocate(1);
    { try{
      boost::detail::allocator::construct(
        &(spc.data()+n)->second->value(),node->value());
    }
    catch(...){
      deallocate((spc.data()+n)->second);
      throw;;
    }
    }
    ++n;

    if(n==size_)std::sort(&*spc.data(),&*spc.data()+size_);
  }

  Node* find(Node* node)const
  {
    if(node==header_org_)return header_cpy_;
    return std::lower_bound(
      begin(),end(),copy_map_entry<Node>(node,0))->second;
  }

  void release()
  {
    released=true;
  }

private:
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,Node>::type
  >::type allocator_type;
  typedef typename allocator_type::pointer allocator_pointer;

  allocator_type al_;
  std::size_t size_;
  auto_space<copy_map_entry<Node>,Allocator> spc;
  std::size_t n;
  Node* header_org_;
  Node* header_cpy_;
  bool released;

  void deallocate(Node* node)
  {
    al_.deallocate(static_cast<allocator_pointer>(node),1);
  }
};

}

}

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/bind.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_iter_fold.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_iter_fold.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/arg.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_iter_fold.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_iter_fold_impl.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_iter_fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_iter_fold_impl.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_iter_fold_impl.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/reverse_iter_fold_impl.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/reverse_iter_fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< 0,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef fwd_state0 bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< 1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp,fwd_state0,iter0 >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef fwd_state1 bkwd_state1;
    typedef typename apply2< BackwardOp,bkwd_state1,iter0 >::type bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< 2,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp,fwd_state0,iter0 >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,fwd_state1,iter1 >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef fwd_state2 bkwd_state2;
    typedef typename apply2< BackwardOp,bkwd_state2,iter1 >::type bkwd_state1;
    typedef typename apply2< BackwardOp,bkwd_state1,iter0 >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< 3,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp,fwd_state0,iter0 >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,fwd_state1,iter1 >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,fwd_state2,iter2 >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef fwd_state3 bkwd_state3;
    typedef typename apply2< BackwardOp,bkwd_state3,iter2 >::type bkwd_state2;
    typedef typename apply2< BackwardOp,bkwd_state2,iter1 >::type bkwd_state1;
    typedef typename apply2< BackwardOp,bkwd_state1,iter0 >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< 4,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp,fwd_state0,iter0 >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,fwd_state1,iter1 >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,fwd_state2,iter2 >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,fwd_state3,iter3 >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef fwd_state4 bkwd_state4;
    typedef typename apply2< BackwardOp,bkwd_state4,iter3 >::type bkwd_state3;
    typedef typename apply2< BackwardOp,bkwd_state3,iter2 >::type bkwd_state2;
    typedef typename apply2< BackwardOp,bkwd_state2,iter1 >::type bkwd_state1;
    typedef typename apply2< BackwardOp,bkwd_state1,iter0 >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter4 iterator;
};

template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp,fwd_state0,iter0 >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,fwd_state1,iter1 >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,fwd_state2,iter2 >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,fwd_state3,iter3 >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef reverse_iter_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , iter4
        , Last
        , fwd_state4
        , BackwardOp
        , ForwardOp
        > nested_chunk;

    typedef typename nested_chunk::state bkwd_state4;
    typedef typename apply2< BackwardOp,bkwd_state4,iter3 >::type bkwd_state3;
    typedef typename apply2< BackwardOp,bkwd_state3,iter2 >::type bkwd_state2;
    typedef typename apply2< BackwardOp,bkwd_state2,iter1 >::type bkwd_state1;
    typedef typename apply2< BackwardOp,bkwd_state1,iter0 >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef typename nested_chunk::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< -1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef reverse_iter_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2< ForwardOp,State,First >::type
        , BackwardOp
        , ForwardOp
        > nested_step;

    typedef typename apply2<
          BackwardOp
        , typename nested_step::state
        , First
        >::type state;

    typedef typename nested_step::iterator iterator;
};

template<
      typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_iter_fold_impl< -1,Last,Last,State,BackwardOp,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/reverse_iter_fold_impl.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/reverse_iter_fold.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename BackwardOp = na
    , typename ForwardOp = arg<1>
    >
struct reverse_iter_fold
{
    typedef typename aux::reverse_iter_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , typename lambda<BackwardOp>::type
        , typename lambda<ForwardOp>::type
        >::state type;

   




};

template<> struct reverse_iter_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_iter_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_iter_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_iter_fold< na , na , na > result_; typedef reverse_iter_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_iter_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_iter_fold< na , na , na > > : int_<-1> { }; }

}}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/header_holder.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/header_holder.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/header_holder.hpp"
template<typename NodeTypePtr,typename Final>
struct header_holder:private noncopyable
{
  header_holder():member(final().allocate_node()){}
  ~header_holder(){final().deallocate_node(&*member);}

  NodeTypePtr member;

private:
  Final& final(){return *static_cast<Final*>(this);}
};

}

}

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/aligned_storage.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/decl.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_prefix.hpp" 1
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_prefix.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_prefix.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp" 2

namespace boost {
namespace archive {




class archive_exception :
    public virtual std::exception
{
public:
    typedef enum {
        no_exception,
        other_exception,
        unregistered_class,

        invalid_signature,

        unsupported_version,

        pointer_conflict,




        incompatible_native_format,

        array_size_too_short,
        input_stream_error,
        invalid_class_name,


        unregistered_cast,

        unsupported_class_version,


        multiple_code_instantiation,

        output_stream_error
    } exception_code;
protected:
    std::string m_msg;
public:
    exception_code code;
    archive_exception(
        exception_code c,
        const char * e1 = __null,
        const char * e2 = __null
    );
    ~archive_exception() throw ();
    virtual const char *what( ) const throw();
protected:
    archive_exception();
};

}
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_suffix.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_suffix.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_suffix.hpp" 2
# 96 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/archive_exception.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/access.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/access.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/pfto.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/pfto.hpp"
namespace boost {
namespace serialization {

template<class T>
struct pfto_wrapper {
    const T & t;
    operator const T & (){
        return t;
    }
    pfto_wrapper (const T & rhs) : t(rhs) {}
};

template<class T>
pfto_wrapper<T> make_pfto_wrapper(const T & t, int){
    return pfto_wrapper<T>(t);
}

template<class T>
pfto_wrapper<T> make_pfto_wrapper(const pfto_wrapper<T> & t, int){
    return t;
}

}
}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/access.hpp" 2

namespace boost {

namespace archive {
namespace detail {
    template<class Archive, class T>
    class iserializer;
    template<class Archive, class T>
    class oserializer;
}
}

namespace serialization {


template<class Archive, class T>
inline void serialize_adl(Archive &, T &, const unsigned int);
namespace detail {
    template<class Archive, class T>
    struct member_saver;
    template<class Archive, class T>
    struct member_loader;
}






class access {
public:




    template<class Archive, class T>
    friend struct detail::member_saver;
    template<class Archive, class T>
    friend struct detail::member_loader;
    template<class Archive, class T>
    friend class archive::detail::iserializer;
    template<class Archive, class T>
    friend class archive::detail::oserializer;
    template<class Archive, class T>
    friend inline void serialize(
        Archive & ar,
        T & t,
        const unsigned int file_version
    );
    template<class Archive, class T>
    friend inline void save_construct_data(
        Archive & ar,
        const T * t,
        const unsigned int file_version
    );
    template<class Archive, class T>
    friend inline void load_construct_data(
        Archive & ar,
        T * t,
        const unsigned int file_version
    );



    template<class Archive, class T>
    static void member_save(
        Archive & ar,

        T & t,
        const unsigned int file_version
    ){
        t.save(ar, file_version);
    }
    template<class Archive, class T>
    static void member_load(
        Archive & ar,
        T & t,
        const unsigned int file_version
    ){
        t.load(ar, file_version);
    }
    template<class Archive, class T>
    static void serialize(
        Archive & ar,
        T & t,
        const unsigned int file_version
    ){
# 118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/access.hpp"
        t.serialize(ar, file_version);
    }
    template<class T>
    static void destroy( const T * t)
    {


        delete const_cast<T *>(t);
    }
    template<class T>
    static void construct(T * t){



        ::new(t)T;
    }
    template<class T, class U>
    static T & cast_reference(U & u){
        return static_cast<T &>(u);
    }
    template<class T, class U>
    static T * cast_pointer(U * u){
        return static_cast<T *>(u);
    }
};

}
}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/throw_exception.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/throw_exception.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/attribute_noreturn.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/throw_exception.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/throw_exception.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/exception.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/exception.hpp"
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/exception.hpp" 3





namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    class exception;

    template <class T>
    class shared_ptr;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

            protected:

            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        char const * get_diagnostic_information( exception const &, char const * );

        void copy_boost_exception( exception *, exception const * );

        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );

        template <class E>
        E const & set_info( E const &, throw_function const & );

        template <class E>
        E const & set_info( E const &, throw_file const & );

        template <class E>
        E const & set_info( E const &, throw_line const & );
        }

    class
    exception
        {
        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
# 216 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/exception.hpp" 3
        virtual ~exception() throw()

            = 0

            ;




        private:

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );

        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );

        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };

    inline
    exception::
    ~exception() throw()
        {
        }

    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }



    namespace
    exception_detail
        {
        template <class T>
        struct
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };

        struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );

        struct small_size { };
        small_size dispatch_boost_exception( void const * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception((T*)0))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {
        class
        clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };

        inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        clone_impl:
            public T,
            public clone_base
            {
            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this);
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }
    }
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/throw_exception.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/current_function.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/current_function.hpp"
namespace boost
{

namespace detail
{

inline void current_function_helper()
{
# 61 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/current_function.hpp"
}

}

}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/throw_exception.hpp" 2





namespace boost
{






inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__((noreturn)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw enable_current_exception(enable_error_info(e));



}




    namespace
    exception_detail
    {
        template <class E>
        __attribute__((noreturn))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }

}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{





template<typename Value>
struct pod_value_holder
{
  typename aligned_storage<
    sizeof(Value),
    alignment_of<Value>::value
  >::type space;
};

template<typename Value,typename Allocator>
struct index_node_base:private pod_value_holder<Value>
{
  typedef index_node_base base_type;
  typedef Value value_type;
  typedef Allocator allocator_type;

  value_type& value()
  {
    return *static_cast<value_type*>(
      static_cast<void*>(&this->space));
  }

  const value_type& value()const
  {
    return *static_cast<const value_type*>(
      static_cast<const void*>(&this->space));
  }

  static index_node_base* from_value(const value_type* p)
  {
    return static_cast<index_node_base *>(
      reinterpret_cast<pod_value_holder<Value>*>(
        const_cast<value_type*>(p)));
  }

private:

  friend class boost::serialization::access;






  template<class Archive>
  void serialize(Archive&,const unsigned int)
  {
  }

};

template<typename Node,typename Value>
Node* node_from_value(
  const Value* p
  )
{
  typedef typename Node::allocator_type allocator_type;
  return static_cast<Node*>(
    index_node_base<Value,allocator_type>::from_value(p));
}

}

}
# 111 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_node_base.hpp"
namespace multi_index{
namespace detail{


template<class Archive,typename Value,typename Allocator>
inline void load_construct_data(
  Archive&,boost::multi_index::detail::index_node_base<Value,Allocator>*,
  const unsigned int)
{
  throw_exception(
    archive::archive_exception(archive::archive_exception::other_exception));
}




}
}




}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/is_index_list.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/is_index_list.hpp"
namespace boost{

namespace multi_index{

namespace detail{

template<typename T>
struct is_index_list
{
  static const bool mpl_sequence=mpl::is_sequence<T>::value;
  static const bool non_empty=!mpl::empty<T>::value;
  static const bool value=mpl_sequence&&non_empty;
};

}

}

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/msvc_index_specifier.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/node_type.hpp"
struct index_node_applier
{
  template<typename IndexSpecifierIterator,typename Super>
  struct apply
  {
    typedef typename mpl::deref<IndexSpecifierIterator>::type index_specifier;
    typedef typename index_specifier::
      template node_class<Super>::type type;
  };
};


template<typename Value,typename IndexSpecifierList,typename Allocator>
struct multi_index_node_type
{
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((detail::is_index_list<IndexSpecifierList>::value) == 0 ? false : true) >)> boost_static_assert_typedef_64;

  typedef typename mpl::reverse_iter_fold<
    IndexSpecifierList,
    index_node_base<Value,Allocator>,
    mpl::bind2<index_node_applier,mpl::_2,mpl::_1>
  >::type type;
};

}

}

}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/tuple.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/tuple.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/ref.hpp" 1
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/ref.hpp"
namespace boost
{

template<class T> class reference_wrapper
{
public:
    typedef T type;







    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}



    operator T& () const { return *t_; }

    T& get() const { return *t_; }

    T* get_pointer() const { return t_; }

private:

    T* t_;
};







template<class T> inline reference_wrapper<T> const ref(T & t)
{
    return reference_wrapper<T>(t);
}

template<class T> inline reference_wrapper<T const> const cref(T const & t)
{
    return reference_wrapper<T const>(t);
}





template<typename T>
class is_reference_wrapper
    : public mpl::false_
{
};

template<typename T>
class unwrap_reference
{
 public:
    typedef T type;
};
# 106 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/ref.hpp"
template<typename T> class is_reference_wrapper< reference_wrapper<T> > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> > { public: typedef T type; };

template<typename T> class is_reference_wrapper< reference_wrapper<T> const > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> volatile > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const volatile > { public: typedef T type; };
# 176 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/ref.hpp"
template <class T> inline typename unwrap_reference<T>::type&
unwrap_ref(T& t)
{
    return t;
}

template<class T> inline T* get_pointer( reference_wrapper<T> const & r )
{
    return r.get_pointer();
}

}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/tuple.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp" 1
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/cv_traits.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/cv_traits.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_volatile.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_volatile.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_volatile.hpp" 2

namespace boost {
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_volatile.hpp"
template< typename T > struct add_volatile { typedef T volatile type; };






template< typename T > struct add_volatile<T&> { typedef T& type; };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_volatile.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/cv_traits.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_cv.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_cv.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_cv.hpp" 2

namespace boost {
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_cv.hpp"
template< typename T > struct add_cv { typedef T const volatile type; };






template< typename T > struct add_cv<T&> { typedef T& type; };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/add_cv.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/cv_traits.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp" 2

namespace boost {



namespace detail {

template <typename T, bool is_const>
struct remove_volatile_helper
{
    typedef T type;
};

template <typename T>
struct remove_volatile_helper<T,true>
{
    typedef T const type;
};

template <typename T>
struct remove_volatile_impl
{
    typedef typename remove_volatile_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_const<T>::value
        >::type type;
};
# 67 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp"
}



template< typename T > struct remove_volatile { typedef typename boost::detail::remove_volatile_impl<T>::type type; };
template< typename T > struct remove_volatile<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_volatile<T volatile[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_volatile<T const volatile[N]> { typedef T const type[N]; };
# 84 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 87 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_volatile.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/cv_traits.hpp" 2
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/function_traits.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/function_traits.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/false_result.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/false_result.hpp"
namespace boost {
namespace type_traits {


struct false_result
{
    template <typename T> struct result_
    {
        static const bool value = false;
    };
};

}}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/is_function_ptr_helper.hpp"
namespace boost {
namespace type_traits {

template <class R>
struct is_function_ptr_helper
{
    static const bool value = false;
};




template <class R >
struct is_function_ptr_helper<R (*)()> { static const bool value = true; };

template <class R >
struct is_function_ptr_helper<R (*)( ...)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0 ...)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { static const bool value = true; };
# 203 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/is_function_ptr_helper.hpp"
}
}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp" 2







namespace boost {



namespace detail {


template<bool is_ref = true>
struct is_function_chooser
    : ::boost::type_traits::false_result
{
};

template <>
struct is_function_chooser<false>
{
    template< typename T > struct result_
        : ::boost::type_traits::is_function_ptr_helper<T*>
    {
    };
};

template <typename T>
struct is_function_impl
    : is_function_chooser< ::boost::is_reference<T>::value >
        ::template result_<T>
{
};
# 90 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp"
}






template< typename T > struct is_function : ::boost::integral_constant<bool,::boost::detail::is_function_impl<T>::value> { };




}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 105 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_function.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/function_traits.hpp" 2


namespace boost {


namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const unsigned arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
 public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};
# 234 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/function_traits.hpp"
}
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp" 2



namespace boost {
namespace tuples {


struct null_type {};


namespace detail {
  inline const null_type cnull() { return null_type(); }





template <bool If, class Then, class Else> struct IF { typedef Then RET; };

template <class Then, class Else> struct IF<false, Then, Else> {
  typedef Else RET;
};

}


template <class HT, class TT> struct cons;



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type>
class tuple;


template<class T> struct length;



namespace detail {



template<class T>
class generate_error;




template< int N >
struct get_class {
  template<class RET, class HT, class TT >
  inline static RET get(const cons<HT, TT>& t)
  {





    return get_class<N-1>::template get<RET>(t.tail);

  }
  template<class RET, class HT, class TT >
  inline static RET get(cons<HT, TT>& t)
  {



    return get_class<N-1>::template get<RET>(t.tail);

  }
};

template<>
struct get_class<0> {
  template<class RET, class HT, class TT>
  inline static RET get(const cons<HT, TT>& t)
  {
    return t.head;
  }
  template<class RET, class HT, class TT>
  inline static RET get(cons<HT, TT>& t)
  {
    return t.head;
  }
};

}
# 140 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp"
template<int N, class T>
struct element
{
private:
  typedef typename T::tail_type Next;
public:
  typedef typename element<N-1, Next>::type type;
};
template<class T>
struct element<0,T>
{
  typedef typename T::head_type type;
};

template<int N, class T>
struct element<N, const T>
{
private:
  typedef typename T::tail_type Next;
  typedef typename element<N-1, Next>::type unqualified_type;
public:



  typedef typename boost::add_const<unqualified_type>::type type;


};
template<class T>
struct element<0,const T>
{



  typedef typename boost::add_const<typename T::head_type>::type type;

};
# 233 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp"
template <class T> struct access_traits {
  typedef const T& const_type;
  typedef T& non_const_type;

  typedef const typename boost::remove_cv<T>::type& parameter_type;






};

template <class T> struct access_traits<T&> {

  typedef T& const_type;
  typedef T& non_const_type;

  typedef T& parameter_type;
};



template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::non_const_type
get(cons<HT, TT>& c ) {



  return detail::get_class<N>::template

         get<
           typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type,
           HT,TT
         >(c);
}




template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::const_type
get(const cons<HT, TT>& c ) {



  return detail::get_class<N>::template

         get<
           typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type,
           HT,TT
         >(c);
}


namespace detail {







template <class T> class non_storeable_type {
  non_storeable_type();
};

template <class T> struct wrap_non_storeable_type {
  typedef typename IF<
    ::boost::is_function<T>::value, non_storeable_type<T>, T
  >::RET type;
};
template <> struct wrap_non_storeable_type<void> {
  typedef non_storeable_type<void> type;
};

}

template <class HT, class TT>
struct cons {

  typedef HT head_type;
  typedef TT tail_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;

  stored_head_type head;
  tail_type tail;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  typename access_traits<tail_type>::non_const_type
  get_tail() { return tail; }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  typename access_traits<tail_type>::const_type
  get_tail() const { return tail; }

  cons() : head(), tail() {}







  cons(typename access_traits<stored_head_type>::parameter_type h,
       const tail_type& t)
    : head (h), tail(t) {}

  template <class T1, class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (t1),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}

  template <class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( const null_type& , T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}


  template <class HT2, class TT2>
  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u ) {
    head=u.head; tail=u.tail; return *this;
  }



  cons& operator=(const cons& u) {
    head = u.head; tail = u.tail; return *this;
  }

  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u ) {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((length<cons>::value == 2) == 0 ? false : true) >)> boost_static_assert_typedef_388;
    head = u.first; tail.head = u.second; return *this;
  }


  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }
};

template <class HT>
struct cons<HT, null_type> {

  typedef HT head_type;
  typedef null_type tail_type;
  typedef cons<HT, null_type> self_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  null_type get_tail() { return null_type(); }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  const null_type get_tail() const { return null_type(); }


  cons() : head() {}

  cons(typename access_traits<stored_head_type>::parameter_type h,
       const null_type& = null_type())
    : head (h) {}

  template<class T1>
  cons(T1& t1, const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head (t1) {}

  cons(const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head () {}

  template <class HT2>
  cons( const cons<HT2, null_type>& u ) : head(u.head) {}

  template <class HT2>
  cons& operator=(const cons<HT2, null_type>& u )
  { head = u.head; return *this; }



  cons& operator=(const cons& u) { head = u.head; return *this; }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
            >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }

};



template<class T>
struct length {
  static const int value = 1 + length<typename T::tail_type>::value;
};

template<>
struct length<tuple<> > {
  static const int value = 0;
};

template<>
struct length<tuple<> const> {
  static const int value = 0;
};

template<>
struct length<null_type> {
  static const int value = 0;
};

template<>
struct length<null_type const> {
  static const int value = 0;
};

namespace detail {


template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
struct map_tuple_to_cons
{
  typedef cons<T0,
               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
                                          T6, T7, T8, T9, null_type>::type
              > type;
};


template <>
struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
{
  typedef null_type type;
};

}



template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>

class tuple :
  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
{
public:
  typedef typename
    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
  typedef typename inherited::head_type head_type;
  typedef typename inherited::tail_type tail_type;



  tuple() {}

  tuple(typename access_traits<T0>::parameter_type t0)
    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1)
    : inherited(t0, t1, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2)
    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3)
    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4)
    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5)
    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6)
    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8,
        typename access_traits<T9>::parameter_type t9)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}


  template<class U1, class U2>
  tuple(const cons<U1, U2>& p) : inherited(p) {}

  template <class U1, class U2>
  tuple& operator=(const cons<U1, U2>& k) {
    inherited::operator=(k);
    return *this;
  }

  template <class U1, class U2>
  tuple& operator=(const std::pair<U1, U2>& k) {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((length<tuple>::value == 2) == 0 ? false : true) >)> boost_static_assert_typedef_645;
    this->head = k.first;
    this->tail.head = k.second;
    return *this;
  }

};


template <>
class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> :
  public null_type
{
public:
  typedef null_type inherited;
};



namespace detail {

struct swallow_assign {

  template<typename T>
  swallow_assign const& operator=(const T&) const {
    return *this;
  }
};

}


detail::swallow_assign const ignore = detail::swallow_assign();
# 696 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp"
template<class T>
struct make_tuple_traits {
  typedef T type;







};
# 720 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/detail/tuple_basic.hpp"
template<class T>
struct make_tuple_traits<T&> {
  typedef typename
     detail::generate_error<T&>::
       do_not_use_with_reference_type error;
};





template<class T, int n> struct make_tuple_traits <T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n> struct make_tuple_traits<volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T>
struct make_tuple_traits<reference_wrapper<T> >{
  typedef T& type;
};

template<class T>
struct make_tuple_traits<const reference_wrapper<T> >{
  typedef T& type;
};




namespace detail {



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type
>
struct make_tuple_mapper {
  typedef
    tuple<typename make_tuple_traits<T0>::type,
          typename make_tuple_traits<T1>::type,
          typename make_tuple_traits<T2>::type,
          typename make_tuple_traits<T3>::type,
          typename make_tuple_traits<T4>::type,
          typename make_tuple_traits<T5>::type,
          typename make_tuple_traits<T6>::type,
          typename make_tuple_traits<T7>::type,
          typename make_tuple_traits<T8>::type,
          typename make_tuple_traits<T9>::type> type;
};

}


inline tuple<> make_tuple() {
  return tuple<>();
}

template<class T0>
inline typename detail::make_tuple_mapper<T0>::type
make_tuple(const T0& t0) {
  typedef typename detail::make_tuple_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
inline typename detail::make_tuple_mapper<T0, T1>::type
make_tuple(const T0& t0, const T1& t1) {
  typedef typename detail::make_tuple_mapper<T0, T1>::type t;
  return t(t0, t1);
}

template<class T0, class T1, class T2>
inline typename detail::make_tuple_mapper<T0, T1, T2>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}

template<class T0, class T1, class T2, class T3>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}

template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8, const T9& t9) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}




template<class T1>
inline tuple<T1&> tie(T1& t1) {
  return tuple<T1&> (t1);
}

template<class T1, class T2>
inline tuple<T1&, T2&> tie(T1& t1, T2& t2) {
  return tuple<T1&, T2&> (t1, t2);
}

template<class T1, class T2, class T3>
inline tuple<T1&, T2&, T3&> tie(T1& t1, T2& t2, T3& t3) {
  return tuple<T1&, T2&, T3&> (t1, t2, t3);
}

template<class T1, class T2, class T3, class T4>
inline tuple<T1&, T2&, T3&, T4&> tie(T1& t1, T2& t2, T3& t3, T4& t4) {
  return tuple<T1&, T2&, T3&, T4&> (t1, t2, t3, t4);
}

template<class T1, class T2, class T3, class T4, class T5>
inline tuple<T1&, T2&, T3&, T4&, T5&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5) {
  return tuple<T1&, T2&, T3&, T4&, T5&> (t1, t2, t3, t4, t5);
}

template<class T1, class T2, class T3, class T4, class T5, class T6>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&> (t1, t2, t3, t4, t5, t6);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&> (t1, t2, t3, t4, t5, t6, t7);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7,
         class T8>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7, T8& t8) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&>
           (t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7,
         class T8, class T9>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7, T8& t8,
           T9& t9) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&>
            (t1, t2, t3, t4, t5, t6, t7, t8, t9);
}

template<class T1, class T2, class T3, class T4, class T5, class T6, class T7,
         class T8, class T9, class T10>
inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&, T10&>
tie(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5, T6& t6, T7& t7, T8& t8,
           T9& t9, T10& t10) {
  return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&, T10&>
           (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
}

}
}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/tuple.hpp" 2



namespace boost {

using tuples::tuple;
using tuples::make_tuple;
using tuples::tie;

using tuples::get;
# 87 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tuple/tuple.hpp"
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_loader.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_loader.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_fundamental.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_fundamental.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_fundamental.hpp" 2

namespace boost {

namespace detail {

template <typename T>
struct is_fundamental_impl
    : ::boost::type_traits::ice_or<
          ::boost::is_arithmetic<T>::value
        , ::boost::is_void<T>::value
        >
{
};

}





template< typename T > struct is_fundamental : ::boost::integral_constant<bool,::boost::detail::is_fundamental_impl<T>::value> { };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_fundamental.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level_enum.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level_enum.hpp"
namespace boost {
namespace serialization {





enum level_type
{


    not_serializable = 0,






    primitive_type = 1,



    object_serializable = 2,







    object_class_info = 3
};

}
}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/level.hpp" 2

namespace boost {
namespace serialization {

struct basic_traits;


template<class T>
struct implementation_level_impl {
    template<class U>
    struct traits_class_level {
        typedef typename U::level type;
    };

    typedef mpl::integral_c_tag tag;


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits, T>,
            traits_class_level<T>,

        typename mpl::eval_if<
            is_fundamental<T>,
            mpl::int_<primitive_type>,

        typename mpl::eval_if<
            is_class<T>,
            mpl::int_<object_class_info>,

        typename mpl::eval_if<
            is_array<T>,



                mpl::int_<object_serializable>,


        typename mpl::eval_if<
            is_enum<T>,



                mpl::int_<primitive_type>,


            mpl::int_<not_serializable>
        >
        >
        >
        >
        >::type type;

    static const int value = type::value;
};

template<class T>
struct implementation_level :
    public implementation_level_impl<const T>
{
};

template<class T, int L >
inline bool operator>=(implementation_level<T> t, enum level_type l)
{
    return t.value >= (int)l;
}

}
}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/equal_to.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/equal_to.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct equal_to

    : equal_to_impl<
          typename equal_to_tag<N1>::type
        , typename equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef equal_to< na , na > result_; typedef equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value == N2::value ) >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/equal_to.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/greater.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/greater.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater

    : greater_impl<
          typename greater_tag<N1>::type
        , typename greater_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater< na , na > result_; typedef greater< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value > N2::value ) >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/greater.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking_enum.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking_enum.hpp"
namespace boost {
namespace serialization {






enum tracking_type
{

    track_never = 0,


    track_selectively = 1,

    track_always = 2
};

}
}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/type_info_implementation.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/type_info_implementation.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/traits.hpp" 1
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/traits.hpp"
namespace boost {
namespace serialization {


struct basic_traits {};

template <class T>
struct extended_type_info_impl;

template<
    class T,
    int Level,
    int Tracking,
    unsigned int Version = 0,
    class ETII = extended_type_info_impl< T >,
    class Wrapper = mpl::false_
>
struct traits : public basic_traits {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((Version == 0 || Level >= object_class_info) == 0 ? false : true) >)> boost_static_assert_typedef_53;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((Tracking == track_never || Level >= object_serializable) == 0 ? false : true) >)> boost_static_assert_typedef_54;
    typedef typename mpl::int_<Level> level;
    typedef typename mpl::int_<Tracking> tracking;
    typedef typename mpl::int_<Version> version;
    typedef ETII type_info_implementation;
    typedef Wrapper is_wrapper;
};

}
}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/type_info_implementation.hpp" 2

namespace boost {
namespace serialization {



template<class T>
struct type_info_implementation {
    template<class U>
    struct traits_class_typeinfo_implementation {
      typedef typename U::type_info_implementation::type type;
    };


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits, T>,
            traits_class_typeinfo_implementation<T>,

            mpl::identity<
                typename extended_type_info_impl<T>::type
            >
        >::type type;
};

}
}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/tracking.hpp" 2

namespace boost {
namespace serialization {

struct basic_traits;


template<class T>
struct tracking_level_impl {
    template<class U>
    struct traits_class_tracking {
        typedef typename U::tracking type;
    };
    typedef mpl::integral_c_tag tag;


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits, T>,
            traits_class_tracking<T>,

        typename mpl::eval_if<
            is_pointer<T>,

            mpl::int_<track_never>,

        typename mpl::eval_if<

            typename mpl::equal_to<
                implementation_level<T>,
                mpl::int_<primitive_type>
            >,

            mpl::int_<track_never>,

            mpl::int_<track_selectively>
    > > >::type type;
    static const int value = type::value;
};

template<class T>
struct tracking_level :
    public tracking_level_impl<const T>
{
};

template<class T, enum tracking_type L>
inline bool operator>=(tracking_level<T> t, enum tracking_type l)
{
    return t.value >= (int)l;
}

}
}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/split_member.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/split_member.hpp"
namespace boost {
namespace archive {
    namespace detail {
        template<class Archive> class interface_oarchive;
        template<class Archive> class interface_iarchive;
    }
}

namespace serialization {
namespace detail {

    template<class Archive, class T>
    struct member_saver {
        static void invoke(
            Archive & ar,
            const T & t,
            const unsigned int file_version
        ){
            access::member_save(ar, t, file_version);
        }
    };

    template<class Archive, class T>
    struct member_loader {
        static void invoke(
            Archive & ar,
            T & t,
            const unsigned int file_version
        ){
            access::member_load(ar, t, file_version);
        }
    };

}

template<class Archive, class T>
inline void split_member(
    Archive & ar, T & t, const unsigned int file_version
){
    typedef typename mpl::eval_if<
        typename Archive::is_saving,
        mpl::identity<detail::member_saver<Archive, T> >,
        mpl::identity<detail::member_loader<Archive, T> >
    >::type typex;
    typex::invoke(ar, t, file_version);
}

}
}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/base_object.hpp" 1
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/base_object.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_polymorphic.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_polymorphic.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_polymorphic.hpp" 2


namespace boost{
# 106 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_polymorphic.hpp"
template< typename T > struct is_polymorphic : ::boost::integral_constant<bool,__is_polymorphic(T)> { };



}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 113 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_polymorphic.hpp" 2
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/base_object.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/force_include.hpp" 1
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/base_object.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/void_cast_fwd.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/void_cast_fwd.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/void_cast_fwd.hpp" 2


namespace boost {
namespace serialization {
namespace void_cast_detail{
class void_caster;
}
template<class Derived, class Base>

inline const void_cast_detail::void_caster & void_cast_register(
    const Derived * dnull = __null,
    const Base * bnull = __null
) __attribute__ ((used));
}
}
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/base_object.hpp" 2

namespace boost {
namespace serialization {

namespace detail
{


    template<class B, class D>
    struct base_cast
    {
        typedef typename
        mpl::if_<
            is_const<D>,
            const B,
            B
        >::type type;
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((is_const<type>::value == is_const<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_57;
    };


    template<class Base, class Derived>
    struct base_register
    {
        struct polymorphic {
            static void const * invoke(){
                Base const * const b = 0;
                Derived const * const d = 0;
                return & void_cast_register(d, b);
            }
        };
        struct non_polymorphic {
            static void const * invoke(){
                return 0;
            }
        };
        static void const * invoke(){
            typedef typename mpl::eval_if<
                is_polymorphic<Base>,
                mpl::identity<polymorphic>,
                mpl::identity<non_polymorphic>
            >::type type;
            return type::invoke();
        }
    };

}
# 97 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/base_object.hpp"
template<class Base, class Derived>
typename detail::base_cast<Base, Derived>::type &
base_object(Derived &d)
{
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_base_and_derived<Base,Derived>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_101;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((! is_pointer<Derived>::value) == 0 ? false : true) >)> boost_static_assert_typedef_102;
    typedef typename detail::base_cast<Base, Derived>::type type;
    detail::base_register<type, Derived>::invoke();
    return access::cast_reference<type, Derived>(d);
}


}
}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/wrapper.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/wrapper.hpp"
namespace boost { namespace serialization {







template<
    class T,
    int Level = object_serializable,
    int Tracking = track_never,
    unsigned int Version = 0,
    class ETII = extended_type_info_impl< T >
>
struct wrapper_traits :
    public traits<T,Level,Tracking,Version,ETII,mpl::true_>
{};

template<class T>
struct is_wrapper_impl :
    boost::mpl::eval_if<
      boost::is_base_and_derived<basic_traits,T>,
      boost::mpl::true_,
      boost::mpl::false_
    >::type
{};

template<class T>
struct is_wrapper {
    typedef typename is_wrapper_impl<const T>::type type;
};

}
}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp" 2

namespace boost {
namespace serialization {

template<class T>
struct nvp :
    public std::pair<const char *, T *>,
    public wrapper_traits<const nvp<T> >
{
    explicit nvp(const char * name_, T & t) :


        std::pair<const char *, T *>(name_, (T*)(& t))
    {}
    nvp(const nvp & rhs) :

        std::pair<const char *, T *>(rhs.first, (T*)rhs.second)
    {}

    const char * name() const {
        return this->first;
    }
    T & value() const {
        return *(this->second);
    }

    const T & const_value() const {
        return *(this->second);
    }







    template<class Archivex>
    void save(
        Archivex & ar,
        const unsigned int
    ) const {

        ar.operator<<(const_value());
    }
    template<class Archivex>
    void load(
        Archivex & ar,
        const unsigned int
    ){

        ar.operator>>(value());
    }
    template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }
};

template<class T>
inline

const

nvp<T> make_nvp(const char * name, T & t){
    return nvp<T>(name, t);
}
# 128 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/nvp.hpp"
}
}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_loader.hpp" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_loader.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{







template<typename Node,typename FinalNode,typename Allocator>
class index_loader:private noncopyable
{
public:
  index_loader(const Allocator& al,std::size_t size):
    spc(al,size),size_(size),n(0),sorted(false)
  {
  }

  template<class Archive>
  void add(Node* node,Archive& ar,const unsigned int)
  {
    ar>>serialization::make_nvp("position",*node);
    entries()[n++]=node;
  }

  template<class Archive>
  void add_track(Node* node,Archive& ar,const unsigned int)
  {
    ar>>serialization::make_nvp("position",*node);
  }







  template<typename Rearranger,class Archive>
  void load(Rearranger r,Archive& ar,const unsigned int)const
  {
    FinalNode* prev=unchecked_load_node(ar);
    if(!prev)return;

    if(!sorted){
      std::sort(entries(),entries()+size_);
      sorted=true;
    }

    check_node(prev);

    for(;;){
      for(;;){
        FinalNode* node=load_node(ar);
        if(!node)break;

        if(node==prev)prev=0;
        r(prev,node);

        prev=node;
      }
      prev=load_node(ar);
      if(!prev)break;
    }
  }

private:
  Node** entries()const{return &*spc.data();}





  template<class Archive>
  FinalNode* unchecked_load_node(Archive& ar)const
  {
    Node* node=0;
    ar>>serialization::make_nvp("pointer",node);
    return static_cast<FinalNode*>(node);
  }

  template<class Archive>
  FinalNode* load_node(Archive& ar)const
  {
    Node* node=0;
    ar>>serialization::make_nvp("pointer",node);
    check_node(node);
    return static_cast<FinalNode*>(node);
  }

  void check_node(Node* node)const
  {
    if(node!=0&&!std::binary_search(entries(),entries()+size_,node)){
      throw_exception(
        archive::archive_exception(
          archive::archive_exception::other_exception));
    }
  }

  auto_space<Node*,Allocator> spc;
  std::size_t size_;
  std::size_t n;
  mutable bool sorted;
};

}

}

}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_saver.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_saver.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_matcher.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_matcher.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_matcher.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_matcher.hpp"
namespace index_matcher{
# 67 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_matcher.hpp"
struct entry
{
  entry(void* node_,std::size_t pos_=0):node(node_),pos(pos_){}



  void* node;
  std::size_t pos;
  entry* previous;
  bool ordered;

  struct less_by_node
  {
    bool operator()(
      const entry& x,const entry& y)const
    {
      return std::less<void*>()(x.node,y.node);
    }
  };



  std::size_t pile_top;
  entry* pile_top_entry;

  struct less_by_pile_top
  {
    bool operator()(
      const entry& x,const entry& y)const
    {
      return x.pile_top<y.pile_top;
    }
  };
};



template<typename Allocator>
class algorithm_base:private noncopyable
{
protected:
  algorithm_base(const Allocator& al,std::size_t size):
    spc(al,size),size_(size),n(0),sorted(false)
  {
  }

  void add(void* node)
  {
    entries()[n]=entry(node,n);
    ++n;
  }

  void begin_algorithm()const
  {
    if(!sorted){
      std::sort(entries(),entries()+size_,entry::less_by_node());
      sorted=true;
    }
    num_piles=0;
  }

  void add_node_to_algorithm(void* node)const
  {
    entry* ent=
      std::lower_bound(
        entries(),entries()+size_,
        entry(node),entry::less_by_node());
    ent->ordered=false;
    std::size_t n=ent->pos;

    entry dummy(0);
    dummy.pile_top=n;

    entry* pile_ent=
      std::lower_bound(
        entries(),entries()+num_piles,
        dummy,entry::less_by_pile_top());

    pile_ent->pile_top=n;
    pile_ent->pile_top_entry=ent;


    if(pile_ent>&entries()[0]){
      ent->previous=(pile_ent-1)->pile_top_entry;
    }

    if(pile_ent==&entries()[num_piles]){
      ++num_piles;
    }
  }

  void finish_algorithm()const
  {
    if(num_piles>0){





      entry* ent=entries()[num_piles-1].pile_top_entry;
      for(std::size_t n=num_piles;n--;){
        ent->ordered=true;
        ent=ent->previous;
      }
    }
  }

  bool is_ordered(void * node)const
  {
    return std::lower_bound(
      entries(),entries()+size_,
      entry(node),entry::less_by_node())->ordered;
  }

private:
  entry* entries()const{return &*spc.data();}

  auto_space<entry,Allocator> spc;
  std::size_t size_;
  std::size_t n;
  mutable bool sorted;
  mutable std::size_t num_piles;
};







template<typename Node,typename Allocator>
class algorithm:private algorithm_base<Allocator>
{
  typedef algorithm_base<Allocator> super;

public:
  algorithm(const Allocator& al,std::size_t size):super(al,size){}

  void add(Node* node)
  {
    super::add(node);
  }

  template<typename IndexIterator>
  void execute(IndexIterator first,IndexIterator last)const
  {
    super::begin_algorithm();

    for(IndexIterator it=first;it!=last;++it){
      add_node_to_algorithm(get_node(it));
    }

    super::finish_algorithm();
  }

  bool is_ordered(Node* node)const
  {
    return super::is_ordered(node);
  }

private:
  void add_node_to_algorithm(Node* node)const
  {
    super::add_node_to_algorithm(node);
  }

  template<typename IndexIterator>
  static Node* get_node(IndexIterator it)
  {
    return static_cast<Node*>(it.get_node());
  }
};

}

}

}

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_saver.hpp" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_saver.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_saver.hpp"
template<typename Node,typename Allocator>
class index_saver:private noncopyable
{
public:
  index_saver(const Allocator& al,std::size_t size):alg(al,size){}

  template<class Archive>
  void add(Node* node,Archive& ar,const unsigned int)
  {
    ar<<serialization::make_nvp("position",*node);
    alg.add(node);
  }

  template<class Archive>
  void add_track(Node* node,Archive& ar,const unsigned int)
  {
    ar<<serialization::make_nvp("position",*node);
  }

  template<typename IndexIterator,class Archive>
  void save(
    IndexIterator first,IndexIterator last,Archive& ar,
    const unsigned int)const
  {


    alg.execute(first,last);
# 95 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_saver.hpp"
    std::size_t last_saved=3;
    for(IndexIterator it=first,prev=first;it!=last;prev=it++,++last_saved){
      if(!alg.is_ordered(get_node(it))){
        if(last_saved>1)save_node(get_node(prev),ar);
        save_node(get_node(it),ar);
        last_saved=0;
      }
      else if(last_saved==2)save_node(null_node(),ar);
    }
    if(last_saved<=2)save_node(null_node(),ar);



    save_node(null_node(),ar);
  }

private:
  template<typename IndexIterator>
  static Node* get_node(IndexIterator it)
  {
    return it.get_node();
  }

  static Node* null_node(){return 0;}

  template<typename Archive>
  static void save_node(Node* node,Archive& ar)
  {
    ar<<serialization::make_nvp("pointer",node);
  }

  index_matcher::algorithm<Node,Allocator> alg;
};

}

}

}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp"
template<typename Value,typename IndexSpecifierList,typename Allocator>
class index_base
{
protected:
  typedef index_node_base<Value,Allocator> node_type;
  typedef typename multi_index_node_type<
    Value,IndexSpecifierList,Allocator>::type final_node_type;
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> final_type;
  typedef tuples::null_type ctor_args_list;
  typedef typename
    boost::detail::allocator::rebind_to<
      Allocator,
      typename Allocator::value_type>::type final_allocator_type;
  typedef mpl::vector0<> index_type_list;
  typedef mpl::vector0<> iterator_type_list;
  typedef mpl::vector0<> const_iterator_type_list;
  typedef copy_map<
    final_node_type,
    final_allocator_type> copy_map_type;


  typedef index_saver<
    node_type,
    final_allocator_type> index_saver_type;
  typedef index_loader<
    node_type,
    final_node_type,
    final_allocator_type> index_loader_type;


private:
  typedef typename call_traits<Value>::param_type value_param_type;

protected:
  explicit index_base(const ctor_args_list&,const Allocator&){}

  void copy_(
    const index_base<Value,IndexSpecifierList,Allocator>&,const copy_map_type&)
  {}

  node_type* insert_(value_param_type v,node_type* x)
  {
    boost::detail::allocator::construct(&x->value(),v);
    return x;
  }

  node_type* insert_(value_param_type v,node_type*,node_type* x)
  {
    boost::detail::allocator::construct(&x->value(),v);
    return x;
  }

  void erase_(node_type* x)
  {
    boost::detail::allocator::destroy(&x->value());
  }

  void delete_node_(node_type* x)
  {
    boost::detail::allocator::destroy(&x->value());
  }

  void clear_(){}

  void swap_(index_base<Value,IndexSpecifierList,Allocator>&){}

  bool replace_(value_param_type v,node_type* x)
  {
    x->value()=v;
    return true;
  }

  bool modify_(node_type*){return true;}

  bool modify_rollback_(node_type*){return true;}




  template<typename Archive>
  void save_(Archive&,const unsigned int,const index_saver_type&)const{}

  template<typename Archive>
  void load_(Archive&,const unsigned int,const index_loader_type&){}
# 140 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/index_base.hpp"
  final_type& final(){return *static_cast<final_type*>(this);}
  const final_type& final()const{return *static_cast<const final_type*>(this);}

  final_node_type* final_header()const{return final().header();}

  bool final_empty_()const{return final().empty_();}
  std::size_t final_size_()const{return final().size_();}
  std::size_t final_max_size_()const{return final().max_size_();}

  std::pair<final_node_type*,bool> final_insert_(value_param_type x)
    {return final().insert_(x);}
  std::pair<final_node_type*,bool> final_insert_(
    value_param_type x,final_node_type* position)
    {return final().insert_(x,position);}

  void final_erase_(final_node_type* x){final().erase_(x);}

  void final_delete_node_(final_node_type* x){final().delete_node_(x);}
  void final_delete_all_nodes_(){final().delete_all_nodes_();}
  void final_clear_(){final().clear_();}

  void final_swap_(final_type& x){final().swap_(x);}
  bool final_replace_(
    value_param_type k,final_node_type* x)
    {return final().replace_(k,x);}

  template<typename Modifier>
  bool final_modify_(Modifier& mod,final_node_type* x)
    {return final().modify_(mod,x);}

  template<typename Modifier,typename Rollback>
  bool final_modify_(Modifier& mod,Rollback& back,final_node_type* x)
    {return final().modify_(mod,back,x);}




};

}

}

}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/base_type.hpp" 2




namespace boost{

namespace multi_index{

namespace detail{
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/base_type.hpp"
struct index_applier
{
  template<typename IndexSpecifierMeta,typename SuperMeta>
  struct apply
  {
    typedef typename IndexSpecifierMeta::type index_specifier;
    typedef typename index_specifier::
      template index_class<SuperMeta>::type type;
  };
};


template<int N,typename Value,typename IndexSpecifierList,typename Allocator>
struct nth_layer
{
  static const int length=mpl::size<IndexSpecifierList>::value;

  typedef typename mpl::eval_if_c<
    N==length,
    mpl::identity<index_base<Value,IndexSpecifierList,Allocator> >,
    mpl::apply2<
      index_applier,
      mpl::at_c<IndexSpecifierList,N>,
      nth_layer<N+1,Value,IndexSpecifierList,Allocator>
    >
  >::type type;
};

template<typename Value,typename IndexSpecifierList,typename Allocator>
struct multi_index_base_type:nth_layer<0,Value,IndexSpecifierList,Allocator>
{
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((detail::is_index_list<IndexSpecifierList>::value) == 0 ? false : true) >)> boost_static_assert_typedef_78;
};

}

}

}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/converter.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/converter.hpp"
namespace boost{

namespace multi_index{

namespace detail{






template<typename MultiIndexContainer,typename Index>
struct converter
{
  static const Index& index(const MultiIndexContainer& x){return x;}
  static Index& index(MultiIndexContainer& x){return x;}

  static typename Index::const_iterator const_iterator(
    const MultiIndexContainer& x,typename MultiIndexContainer::node_type* node)
  {
    return x.Index::make_iterator(node);
  }

  static typename Index::iterator iterator(
    MultiIndexContainer& x,typename MultiIndexContainer::node_type* node)
  {
    return x.Index::make_iterator(node);
  }
};

}

}

}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/has_tag.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/has_tag.hpp"
namespace boost{

namespace multi_index{

namespace detail{



template<typename Tag>
struct has_tag
{
  template<typename Index>
  struct apply:mpl::contains<typename Index::tag_list,Tag>
  {
  };
};

}

}

}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/safe_mode.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/scope_guard.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/scope_guard.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/scope_guard.hpp"
class scope_guard_impl_base
{
public:
  scope_guard_impl_base():dismissed_(false){}
  void dismiss()const{dismissed_=true;}




  void touch()const{}

protected:
  ~scope_guard_impl_base(){}

  scope_guard_impl_base(const scope_guard_impl_base& other):
    dismissed_(other.dismissed_)
  {
    other.dismiss();
  }

  template<typename J>
  static void safe_execute(J& j){if(!j.dismissed_)j.execute();}

  mutable bool dismissed_;

private:
  scope_guard_impl_base& operator=(const scope_guard_impl_base&);
};

typedef const scope_guard_impl_base& scope_guard;

template<typename F>
class scope_guard_impl0:public scope_guard_impl_base
{
public:
  scope_guard_impl0(F fun):fun_(fun){}
  ~scope_guard_impl0(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){fun_();}

protected:

  F fun_;
};

template<typename F>
inline scope_guard_impl0<F> make_guard(F fun)
{
  return scope_guard_impl0<F>(fun);
}

template<typename F,typename P1>
class scope_guard_impl1:public scope_guard_impl_base
{
public:
  scope_guard_impl1(F fun,P1 p1):fun_(fun),p1_(p1){}
  ~scope_guard_impl1(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){fun_(p1_);}

protected:
  F fun_;
  const P1 p1_;
};

template<typename F,typename P1>
inline scope_guard_impl1<F,P1> make_guard(F fun,P1 p1)
{
  return scope_guard_impl1<F,P1>(fun,p1);
}

template<typename F,typename P1,typename P2>
class scope_guard_impl2:public scope_guard_impl_base
{
public:
  scope_guard_impl2(F fun,P1 p1,P2 p2):fun_(fun),p1_(p1),p2_(p2){}
  ~scope_guard_impl2(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){fun_(p1_,p2_);}

protected:
  F fun_;
  const P1 p1_;
  const P2 p2_;
};

template<typename F,typename P1,typename P2>
inline scope_guard_impl2<F,P1,P2> make_guard(F fun,P1 p1,P2 p2)
{
  return scope_guard_impl2<F,P1,P2>(fun,p1,p2);
}

template<typename F,typename P1,typename P2,typename P3>
class scope_guard_impl3:public scope_guard_impl_base
{
public:
  scope_guard_impl3(F fun,P1 p1,P2 p2,P3 p3):fun_(fun),p1_(p1),p2_(p2),p3_(p3){}
  ~scope_guard_impl3(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){fun_(p1_,p2_,p3_);}

protected:
  F fun_;
  const P1 p1_;
  const P2 p2_;
  const P3 p3_;
};

template<typename F,typename P1,typename P2,typename P3>
inline scope_guard_impl3<F,P1,P2,P3> make_guard(F fun,P1 p1,P2 p2,P3 p3)
{
  return scope_guard_impl3<F,P1,P2,P3>(fun,p1,p2,p3);
}

template<typename F,typename P1,typename P2,typename P3,typename P4>
class scope_guard_impl4:public scope_guard_impl_base
{
public:
  scope_guard_impl4(F fun,P1 p1,P2 p2,P3 p3,P4 p4):
    fun_(fun),p1_(p1),p2_(p2),p3_(p3),p4_(p4){}
  ~scope_guard_impl4(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){fun_(p1_,p2_,p3_,p4_);}

protected:
  F fun_;
  const P1 p1_;
  const P2 p2_;
  const P3 p3_;
  const P4 p4_;
};

template<typename F,typename P1,typename P2,typename P3,typename P4>
inline scope_guard_impl4<F,P1,P2,P3,P4> make_guard(
  F fun,P1 p1,P2 p2,P3 p3,P4 p4)
{
  return scope_guard_impl4<F,P1,P2,P3,P4>(fun,p1,p2,p3,p4);
}

template<class Obj,typename MemFun>
class obj_scope_guard_impl0:public scope_guard_impl_base
{
public:
  obj_scope_guard_impl0(Obj& obj,MemFun mem_fun):obj_(obj),mem_fun_(mem_fun){}
  ~obj_scope_guard_impl0(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){(obj_.*mem_fun_)();}

protected:
  Obj& obj_;
  MemFun mem_fun_;
};

template<class Obj,typename MemFun>
inline obj_scope_guard_impl0<Obj,MemFun> make_obj_guard(Obj& obj,MemFun mem_fun)
{
  return obj_scope_guard_impl0<Obj,MemFun>(obj,mem_fun);
}

template<class Obj,typename MemFun,typename P1>
class obj_scope_guard_impl1:public scope_guard_impl_base
{
public:
  obj_scope_guard_impl1(Obj& obj,MemFun mem_fun,P1 p1):
    obj_(obj),mem_fun_(mem_fun),p1_(p1){}
  ~obj_scope_guard_impl1(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){(obj_.*mem_fun_)(p1_);}

protected:
  Obj& obj_;
  MemFun mem_fun_;
  const P1 p1_;
};

template<class Obj,typename MemFun,typename P1>
inline obj_scope_guard_impl1<Obj,MemFun,P1> make_obj_guard(
  Obj& obj,MemFun mem_fun,P1 p1)
{
  return obj_scope_guard_impl1<Obj,MemFun,P1>(obj,mem_fun,p1);
}

template<class Obj,typename MemFun,typename P1,typename P2>
class obj_scope_guard_impl2:public scope_guard_impl_base
{
public:
  obj_scope_guard_impl2(Obj& obj,MemFun mem_fun,P1 p1,P2 p2):
    obj_(obj),mem_fun_(mem_fun),p1_(p1),p2_(p2)
  {}
  ~obj_scope_guard_impl2(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){(obj_.*mem_fun_)(p1_,p2_);}

protected:
  Obj& obj_;
  MemFun mem_fun_;
  const P1 p1_;
  const P2 p2_;
};

template<class Obj,typename MemFun,typename P1,typename P2>
inline obj_scope_guard_impl2<Obj,MemFun,P1,P2>
make_obj_guard(Obj& obj,MemFun mem_fun,P1 p1,P2 p2)
{
  return obj_scope_guard_impl2<Obj,MemFun,P1,P2>(obj,mem_fun,p1,p2);
}

template<class Obj,typename MemFun,typename P1,typename P2,typename P3>
class obj_scope_guard_impl3:public scope_guard_impl_base
{
public:
  obj_scope_guard_impl3(Obj& obj,MemFun mem_fun,P1 p1,P2 p2,P3 p3):
    obj_(obj),mem_fun_(mem_fun),p1_(p1),p2_(p2),p3_(p3)
  {}
  ~obj_scope_guard_impl3(){scope_guard_impl_base::safe_execute(*this);}
  void execute(){(obj_.*mem_fun_)(p1_,p2_,p3_);}

protected:
  Obj& obj_;
  MemFun mem_fun_;
  const P1 p1_;
  const P2 p2_;
  const P3 p3_;
};

template<class Obj,typename MemFun,typename P1,typename P2,typename P3>
inline obj_scope_guard_impl3<Obj,MemFun,P1,P2,P3>
make_obj_guard(Obj& obj,MemFun mem_fun,P1 p1,P2 p2,P3 p3)
{
  return obj_scope_guard_impl3<Obj,MemFun,P1,P2,P3>(obj,mem_fun,p1,p2,p3);
}

}

}

}
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/base_from_member.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/base_from_member.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat_from_to.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/base_from_member.hpp" 2
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/base_from_member.hpp"
namespace boost
{
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/base_from_member.hpp"
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;

    base_from_member()
        : member()
        {}

   
 template < typename T0 > explicit base_from_member( T0 x0 ) : member( x0 ) {} template < typename T0 , typename T1 > explicit base_from_member( T0 x0 , T1 x1 ) : member( x0 , x1 ) {} template < typename T0 , typename T1 , typename T2 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 ) : member( x0 , x1 , x2 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 ) : member( x0 , x1 , x2 , x3 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 ) : member( x0 , x1 , x2 , x3 , x4 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 ) : member( x0 , x1 , x2 , x3 , x4 , x5 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 , T9 x9 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 ) {}

};

}
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/archive_constructed.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/archive_constructed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/limits.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 1 3 4
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/syslimits.h" 1 3 4






# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 1 3 4
# 169 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/limits.h" 1 3 4
# 145 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/limits.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/posix1_lim.h" 1 3 4
# 157 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/posix1_lim.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/local_lim.h" 1 3 4
# 40 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/local_lim.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/linux/limits.h" 1 3 4
# 41 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/local_lim.h" 2 3 4
# 158 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/posix1_lim.h" 2 3 4
# 146 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/limits.h" 2 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/posix2_lim.h" 1 3 4
# 150 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/limits.h" 2 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/xopen_lim.h" 1 3 4
# 34 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/xopen_lim.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/stdio_lim.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/xopen_lim.h" 2 3 4
# 154 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/limits.h" 2 3 4
# 170 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 2 3 4
# 8 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/syslimits.h" 2 3 4
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 2 3 4
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 2



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 2
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp"
       
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 3


namespace boost {
template<class T>
class integer_traits : public std::numeric_limits<T>
{
public:
  static const bool is_integral = false;
};

namespace detail {
template<class T, T min_val, T max_val>
class integer_traits_base
{
public:
  static const bool is_integral = true;
  static const T const_min = min_val;
  static const T const_max = max_val;
};



template<class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;


}

template<>
class integer_traits<bool>
  : public std::numeric_limits<bool>,
    public detail::integer_traits_base<bool, false, true>
{ };

template<>
class integer_traits<char>
  : public std::numeric_limits<char>,
    public detail::integer_traits_base<char, (-127 - 1), 127>
{ };

template<>
class integer_traits<signed char>
  : public std::numeric_limits<signed char>,
    public detail::integer_traits_base<signed char, (-127 - 1), 127>
{ };

template<>
class integer_traits<unsigned char>
  : public std::numeric_limits<unsigned char>,
    public detail::integer_traits_base<unsigned char, 0, (127 * 2 + 1)>
{ };


template<>
class integer_traits<wchar_t>
  : public std::numeric_limits<wchar_t>,



    public detail::integer_traits_base<wchar_t, (-2147483647 - 1), (2147483647)>
# 130 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 3
{ };


template<>
class integer_traits<short>
  : public std::numeric_limits<short>,
    public detail::integer_traits_base<short, (-32767 - 1), 32767>
{ };

template<>
class integer_traits<unsigned short>
  : public std::numeric_limits<unsigned short>,
    public detail::integer_traits_base<unsigned short, 0, (32767 * 2 + 1)>
{ };

template<>
class integer_traits<int>
  : public std::numeric_limits<int>,
    public detail::integer_traits_base<int, (-2147483647 - 1), 2147483647>
{ };

template<>
class integer_traits<unsigned int>
  : public std::numeric_limits<unsigned int>,
    public detail::integer_traits_base<unsigned int, 0, (2147483647 * 2U + 1U)>
{ };

template<>
class integer_traits<long>
  : public std::numeric_limits<long>,
    public detail::integer_traits_base<long, (-2147483647L - 1L), 2147483647L>
{ };

template<>
class integer_traits<unsigned long>
  : public std::numeric_limits<unsigned long>,
    public detail::integer_traits_base<unsigned long, 0, (2147483647L * 2UL + 1UL)>
{ };




template<>
class integer_traits< ::boost::long_long_type>
  : public std::numeric_limits< ::boost::long_long_type>,
    public detail::integer_traits_base< ::boost::long_long_type, (-9223372036854775807LL -1), 9223372036854775807LL>
{ };

template<>
class integer_traits< ::boost::ulong_long_type>
  : public std::numeric_limits< ::boost::ulong_long_type>,
    public detail::integer_traits_base< ::boost::ulong_long_type, 0, (9223372036854775807LL * 2ULL + 1)>
{ };
# 256 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_traits.hpp" 3
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/auto_link_archive.hpp" 1
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/auto_link_archive.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/auto_link.hpp" 1
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/auto_link_archive.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_prefix.hpp" 1
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_prefix.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_prefix.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 2

namespace boost {
namespace archive {
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp"
class library_version_type {
private:
    typedef uint_least16_t base_type;
    base_type t;
public:
    library_version_type(): t(0) {};
    explicit library_version_type(const unsigned int & t_) : t(t_){
        ((t_ <= boost::integer_traits<base_type>::const_max) ? static_cast<void> (0) : __assert_fail ("t_ <= boost::integer_traits<base_type>::const_max", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp", 47, __PRETTY_FUNCTION__));
    }
    library_version_type(const library_version_type & t_) :
        t(t_.t)
    {}
    library_version_type & operator=(const library_version_type & rhs){
        t = rhs.t;
        return *this;
    }

    operator const base_type () const {
        return t;
    }

    operator base_type & (){
        return t;
    }
    bool operator==(const library_version_type & rhs) const {
        return t == rhs.t;
    }
    bool operator<(const library_version_type & rhs) const {
        return t < rhs.t;
    }
};

library_version_type
BOOST_ARCHIVE_VERSION();

class version_type {
private:
    typedef uint_least32_t base_type;
    base_type t;
public:

    version_type(): t(0) {};
    explicit version_type(const unsigned int & t_) : t(t_){
        ((t_ <= boost::integer_traits<base_type>::const_max) ? static_cast<void> (0) : __assert_fail ("t_ <= boost::integer_traits<base_type>::const_max", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp", 83, __PRETTY_FUNCTION__));
    }
    version_type(const version_type & t_) :
        t(t_.t)
    {}
    version_type & operator=(const version_type & rhs){
        t = rhs.t;
        return *this;
    }

    operator const base_type () const {
        return t;
    }

    operator base_type & (){
        return t;
    }
    bool operator==(const version_type & rhs) const {
        return t == rhs.t;
    }
    bool operator<(const version_type & rhs) const {
        return t < rhs.t;
    }
};

class class_id_type {
private:
    typedef int_least16_t base_type;
    base_type t;
public:

    class_id_type() : t(0) {};
    explicit class_id_type(const int t_) : t(t_){
        ((t_ <= boost::integer_traits<base_type>::const_max) ? static_cast<void> (0) : __assert_fail ("t_ <= boost::integer_traits<base_type>::const_max", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp", 116, __PRETTY_FUNCTION__));
    }
    explicit class_id_type(const std::size_t t_) : t(t_){

    }
    class_id_type(const class_id_type & t_) :
        t(t_.t)
    {}
    class_id_type & operator=(const class_id_type & rhs){
        t = rhs.t;
        return *this;
    }


    operator const int () const {
        return t;
    }

    operator int_least16_t &() {
        return t;
    }
    bool operator==(const class_id_type & rhs) const {
        return t == rhs.t;
    }
    bool operator<(const class_id_type & rhs) const {
        return t < rhs.t;
    }
};



class object_id_type {
private:
    typedef uint_least32_t base_type;
    base_type t;
public:
    object_id_type(): t(0) {};
    explicit object_id_type(const unsigned int & t_) : t(t_){
        ((t_ <= boost::integer_traits<base_type>::const_max) ? static_cast<void> (0) : __assert_fail ("t_ <= boost::integer_traits<base_type>::const_max", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp", 154, __PRETTY_FUNCTION__));
    }
    object_id_type(const object_id_type & t_) :
        t(t_.t)
    {}
    object_id_type & operator=(const object_id_type & rhs){
        t = rhs.t;
        return *this;
    }

    operator const uint_least32_t () const {
        return t;
    }

    operator uint_least32_t & () {
        return t;
    }
    bool operator==(const object_id_type & rhs) const {
        return t == rhs.t;
    }
    bool operator<(const object_id_type & rhs) const {
        return t < rhs.t;
    }
};





struct tracking_type {
    bool t;
    explicit tracking_type(const bool t_ = false)
        : t(t_)
    {};
    tracking_type(const tracking_type & t_)
        : t(t_.t)
    {}
    operator bool () const {
        return t;
    };
    operator bool & () {
        return t;
    };
    tracking_type & operator=(const bool t_){
        t = t_;
        return *this;
    }
    bool operator==(const tracking_type & rhs) const {
        return t == rhs.t;
    }
    bool operator==(const bool & rhs) const {
        return t == rhs;
    }
    tracking_type & operator=(const tracking_type & rhs){
        t = rhs.t;
        return *this;
    }
};

struct class_name_type :
    private boost::noncopyable
{
    char *t;
    operator const char * & () const {
        return const_cast<const char * &>(t);
    }
    operator char * () {
        return t;
    }
    explicit class_name_type(const char *key_)
    : t(const_cast<char *>(key_)){}
    explicit class_name_type(char *key_)
    : t(key_){}
    class_name_type & operator=(const class_name_type & rhs){
        t = rhs.t;
        return *this;
    }
};

enum archive_flags {
    no_header = 1,
    no_codecvt = 2,
    no_xml_tag_checking = 4,
    no_tracking = 8,
    flags_last = 8
};

const char *
BOOST_ARCHIVE_SIGNATURE();
# 261 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp"
class class_id_reference_type : public class_id_type { public: explicit class_id_reference_type(const class_id_type t) : class_id_type(t){} };
class class_id_optional_type : public class_id_type { public: explicit class_id_optional_type(const class_id_type t) : class_id_type(t){} };
class object_reference_type : public object_id_type { public: explicit object_reference_type(const object_id_type t) : object_id_type(t){} };

}
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_suffix.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_suffix.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/detail/abi_suffix.hpp" 2
# 269 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/archive/basic_archive.hpp" 2






namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::library_version_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::version_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::class_id_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::class_id_reference_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::class_id_optional_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::class_name_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::object_id_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::object_reference_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level_impl< const boost::archive::tracking_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/strong_typedef.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/strong_typedef.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp" 1
# 84 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator.hpp" 2


namespace boost
{
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator.hpp"
  namespace detail {
   template <class Category, class T, class Distance, class Pointer, class Reference>

   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator.hpp"
  }

  template <class Category, class T, class Distance = std::ptrdiff_t,
            class Pointer = T*, class Reference = T&>
  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};

}
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp" 2
# 95 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
namespace boost {
namespace detail {

template <typename T> class empty_base {






};

}
}
# 118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
namespace boost
{







template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable2 : B
{
     friend bool operator<=(const T& x, const U& y) { return !static_cast<bool>(x > y); }
     friend bool operator>=(const T& x, const U& y) { return !static_cast<bool>(x < y); }
     friend bool operator>(const U& x, const T& y) { return y < x; }
     friend bool operator<(const U& x, const T& y) { return y > x; }
     friend bool operator<=(const U& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const U& x, const T& y) { return !static_cast<bool>(y > x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable1 : B
{
     friend bool operator>(const T& x, const T& y) { return y < x; }
     friend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }
};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equality_comparable2 : B
{
     friend bool operator==(const U& y, const T& x) { return x == y; }
     friend bool operator!=(const U& y, const T& x) { return !static_cast<bool>(x == y); }
     friend bool operator!=(const T& y, const U& x) { return !static_cast<bool>(y == x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct equality_comparable1 : B
{
     friend bool operator!=(const T& x, const T& y) { return !static_cast<bool>(x == y); }
};
# 254 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct multipliable2 : B { friend T operator *( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } friend T operator *( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv *= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct multipliable1 : B { friend T operator *( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct addable2 : B { friend T operator +( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } friend T operator +( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv += lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct addable1 : B { friend T operator +( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2 : B { friend T operator -( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2_left : B { friend T operator -( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct subtractable1 : B { friend T operator -( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2 : B { friend T operator /( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2_left : B { friend T operator /( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct dividable1 : B { friend T operator /( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2 : B { friend T operator %( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2_left : B { friend T operator %( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct modable1 : B { friend T operator %( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct xorable2 : B { friend T operator ^( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } friend T operator ^( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv ^= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct xorable1 : B { friend T operator ^( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct andable2 : B { friend T operator &( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } friend T operator &( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv &= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct andable1 : B { friend T operator &( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct orable2 : B { friend T operator |( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } friend T operator |( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv |= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct orable1 : B { friend T operator |( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } };







template <class T, class B = ::boost::detail::empty_base<T> >
struct incrementable : B
{
  friend T operator++(T& x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private:
  typedef T incrementable_type;
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct decrementable : B
{
  friend T operator--(T& x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private:
  typedef T decrementable_type;
};



template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct dereferenceable : B
{
  P operator->() const
  {
    return &*static_cast<const T&>(*this);
  }
};

template <class T, class I, class R, class B = ::boost::detail::empty_base<T> >
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast<const T&>(*this) + n);
  }
};
# 352 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct left_shiftable2 : B { friend T operator <<( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct left_shiftable1 : B { friend T operator <<( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct right_shiftable2 : B { friend T operator >>( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct right_shiftable1 : B { friend T operator >>( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } };



template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equivalent2 : B
{
  friend bool operator==(const T& x, const U& y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
  }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct equivalent1 : B
{
  friend bool operator==(const T&x, const T&y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
  }
};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct partially_ordered2 : B
{
  friend bool operator<=(const T& x, const U& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const U& y)
    { return static_cast<bool>(x > y) || static_cast<bool>(x == y); }
  friend bool operator>(const U& x, const T& y)
    { return y < x; }
  friend bool operator<(const U& x, const T& y)
    { return y > x; }
  friend bool operator<=(const U& x, const T& y)
    { return static_cast<bool>(y > x) || static_cast<bool>(y == x); }
  friend bool operator>=(const U& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(y == x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct partially_ordered1 : B
{
  friend bool operator>(const T& x, const T& y)
    { return y < x; }
  friend bool operator<=(const T& x, const T& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(x == y); }
};



template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct totally_ordered2
    : less_than_comparable2<T, U
    , equality_comparable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct totally_ordered1
    : less_than_comparable1<T
    , equality_comparable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct additive2
    : addable2<T, U
    , subtractable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct additive1
    : addable1<T
    , subtractable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct multiplicative2
    : multipliable2<T, U
    , dividable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct multiplicative1
    : multipliable1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative2
    : multiplicative2<T, U
    , modable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative1
    : multiplicative1<T
    , modable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct arithmetic2
    : additive2<T, U
    , multiplicative2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct arithmetic1
    : additive1<T
    , multiplicative1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic2
    : additive2<T, U
    , integer_multiplicative2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic1
    : additive1<T
    , integer_multiplicative1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct bitwise2
    : xorable2<T, U
    , andable2<T, U
    , orable2<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct bitwise1
    : xorable1<T
    , andable1<T
    , orable1<T, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct unit_steppable
    : incrementable<T
    , decrementable<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct shiftable2
    : left_shiftable2<T, U
    , right_shiftable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct shiftable1
    : left_shiftable1<T
    , right_shiftable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ring_operators2
    : additive2<T, U
    , subtractable2_left<T, U
    , multipliable2<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ring_operators1
    : additive1<T
    , multipliable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators2
    : ring_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators1
    : ring_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct field_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct field_operators1
    : ring_operators1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators2
    : field_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators1
    : field_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U
    , euclidian_ring_operators2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T
    , euclidian_ring_operators1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidean_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidean_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidean_ring_operators2
    : totally_ordered2<T, U
    , euclidean_ring_operators2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidean_ring_operators1
    : totally_ordered1<T
    , euclidean_ring_operators1<T, B
      > > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct input_iteratable
    : equality_comparable1<T
    , incrementable<T
    , dereferenceable<T, P, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct output_iteratable
    : incrementable<T, B
      > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct forward_iteratable
    : input_iteratable<T, P, B
      > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct bidirectional_iteratable
    : forward_iteratable<T, P
    , decrementable<T, B
      > > {};





template <class T, class P, class D, class R, class B = ::boost::detail::empty_base<T> >
struct random_access_iteratable
    : bidirectional_iteratable<T, P
    , less_than_comparable1<T
    , additive2<T, D
    , indexable<T, D, R, B
      > > > > {};


}
# 718 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
namespace boost {


namespace detail {
  struct true_t {};
  struct false_t {};
}




template<class T> struct is_chained_base {
  typedef ::boost::detail::false_t value;
};

}
# 829 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
namespace boost {

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct less_than_comparable : less_than_comparable2<T, U, B> {}; template<class T, class U, class B> struct less_than_comparable<T, U, B, ::boost::detail::true_t> : less_than_comparable1<T, U> {}; template <class T, class B> struct less_than_comparable<T, T, B, ::boost::detail::false_t> : less_than_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::less_than_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::less_than_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::less_than_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equality_comparable : equality_comparable2<T, U, B> {}; template<class T, class U, class B> struct equality_comparable<T, U, B, ::boost::detail::true_t> : equality_comparable1<T, U> {}; template <class T, class B> struct equality_comparable<T, T, B, ::boost::detail::false_t> : equality_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equality_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equality_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equality_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multipliable : multipliable2<T, U, B> {}; template<class T, class U, class B> struct multipliable<T, U, B, ::boost::detail::true_t> : multipliable1<T, U> {}; template <class T, class B> struct multipliable<T, T, B, ::boost::detail::false_t> : multipliable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multipliable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multipliable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multipliable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct addable : addable2<T, U, B> {}; template<class T, class U, class B> struct addable<T, U, B, ::boost::detail::true_t> : addable1<T, U> {}; template <class T, class B> struct addable<T, T, B, ::boost::detail::false_t> : addable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::addable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::addable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::addable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct subtractable : subtractable2<T, U, B> {}; template<class T, class U, class B> struct subtractable<T, U, B, ::boost::detail::true_t> : subtractable1<T, U> {}; template <class T, class B> struct subtractable<T, T, B, ::boost::detail::false_t> : subtractable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::subtractable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::subtractable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct dividable : dividable2<T, U, B> {}; template<class T, class U, class B> struct dividable<T, U, B, ::boost::detail::true_t> : dividable1<T, U> {}; template <class T, class B> struct dividable<T, T, B, ::boost::detail::false_t> : dividable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::dividable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::dividable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::dividable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::dividable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct modable : modable2<T, U, B> {}; template<class T, class U, class B> struct modable<T, U, B, ::boost::detail::true_t> : modable1<T, U> {}; template <class T, class B> struct modable<T, T, B, ::boost::detail::false_t> : modable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::modable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::modable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::modable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::modable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct xorable : xorable2<T, U, B> {}; template<class T, class U, class B> struct xorable<T, U, B, ::boost::detail::true_t> : xorable1<T, U> {}; template <class T, class B> struct xorable<T, T, B, ::boost::detail::false_t> : xorable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::xorable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::xorable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::xorable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct andable : andable2<T, U, B> {}; template<class T, class U, class B> struct andable<T, U, B, ::boost::detail::true_t> : andable1<T, U> {}; template <class T, class B> struct andable<T, T, B, ::boost::detail::false_t> : andable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::andable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::andable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::andable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct orable : orable2<T, U, B> {}; template<class T, class U, class B> struct orable<T, U, B, ::boost::detail::true_t> : orable1<T, U> {}; template <class T, class B> struct orable<T, T, B, ::boost::detail::false_t> : orable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::orable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::orable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::orable1<T, B> > { typedef ::boost::detail::true_t value; };

 template<class T, class B> struct is_chained_base< ::boost::incrementable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::decrementable<T, B> > { typedef ::boost::detail::true_t value; };

 template<class T, class U, class B> struct is_chained_base< ::boost::dereferenceable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class B> struct is_chained_base< ::boost::indexable<T, U, V, B> > { typedef ::boost::detail::true_t value; };

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct left_shiftable : left_shiftable2<T, U, B> {}; template<class T, class U, class B> struct left_shiftable<T, U, B, ::boost::detail::true_t> : left_shiftable1<T, U> {}; template <class T, class B> struct left_shiftable<T, T, B, ::boost::detail::false_t> : left_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::left_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::left_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::left_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct right_shiftable : right_shiftable2<T, U, B> {}; template<class T, class U, class B> struct right_shiftable<T, U, B, ::boost::detail::true_t> : right_shiftable1<T, U> {}; template <class T, class B> struct right_shiftable<T, T, B, ::boost::detail::false_t> : right_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::right_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::right_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::right_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equivalent : equivalent2<T, U, B> {}; template<class T, class U, class B> struct equivalent<T, U, B, ::boost::detail::true_t> : equivalent1<T, U> {}; template <class T, class B> struct equivalent<T, T, B, ::boost::detail::false_t> : equivalent1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equivalent<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equivalent2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equivalent1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct partially_ordered : partially_ordered2<T, U, B> {}; template<class T, class U, class B> struct partially_ordered<T, U, B, ::boost::detail::true_t> : partially_ordered1<T, U> {}; template <class T, class B> struct partially_ordered<T, T, B, ::boost::detail::false_t> : partially_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::partially_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::partially_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::partially_ordered1<T, B> > { typedef ::boost::detail::true_t value; };

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct totally_ordered : totally_ordered2<T, U, B> {}; template<class T, class U, class B> struct totally_ordered<T, U, B, ::boost::detail::true_t> : totally_ordered1<T, U> {}; template <class T, class B> struct totally_ordered<T, T, B, ::boost::detail::false_t> : totally_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::totally_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::totally_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::totally_ordered1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct additive : additive2<T, U, B> {}; template<class T, class U, class B> struct additive<T, U, B, ::boost::detail::true_t> : additive1<T, U> {}; template <class T, class B> struct additive<T, T, B, ::boost::detail::false_t> : additive1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::additive<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::additive2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::additive1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multiplicative : multiplicative2<T, U, B> {}; template<class T, class U, class B> struct multiplicative<T, U, B, ::boost::detail::true_t> : multiplicative1<T, U> {}; template <class T, class B> struct multiplicative<T, T, B, ::boost::detail::false_t> : multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_multiplicative : integer_multiplicative2<T, U, B> {}; template<class T, class U, class B> struct integer_multiplicative<T, U, B, ::boost::detail::true_t> : integer_multiplicative1<T, U> {}; template <class T, class B> struct integer_multiplicative<T, T, B, ::boost::detail::false_t> : integer_multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct arithmetic : arithmetic2<T, U, B> {}; template<class T, class U, class B> struct arithmetic<T, U, B, ::boost::detail::true_t> : arithmetic1<T, U> {}; template <class T, class B> struct arithmetic<T, T, B, ::boost::detail::false_t> : arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_arithmetic : integer_arithmetic2<T, U, B> {}; template<class T, class U, class B> struct integer_arithmetic<T, U, B, ::boost::detail::true_t> : integer_arithmetic1<T, U> {}; template <class T, class B> struct integer_arithmetic<T, T, B, ::boost::detail::false_t> : integer_arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct bitwise : bitwise2<T, U, B> {}; template<class T, class U, class B> struct bitwise<T, U, B, ::boost::detail::true_t> : bitwise1<T, U> {}; template <class T, class B> struct bitwise<T, T, B, ::boost::detail::false_t> : bitwise1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::bitwise<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::bitwise2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::bitwise1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::unit_steppable<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct shiftable : shiftable2<T, U, B> {}; template<class T, class U, class B> struct shiftable<T, U, B, ::boost::detail::true_t> : shiftable1<T, U> {}; template <class T, class B> struct shiftable<T, T, B, ::boost::detail::false_t> : shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ring_operators : ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ring_operators<T, U, B, ::boost::detail::true_t> : ring_operators1<T, U> {}; template <class T, class B> struct ring_operators<T, T, B, ::boost::detail::false_t> : ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_ring_operators : ordered_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_ring_operators1<T, U> {}; template <class T, class B> struct ordered_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct field_operators : field_operators2<T, U, B> {}; template<class T, class U, class B> struct field_operators<T, U, B, ::boost::detail::true_t> : field_operators1<T, U> {}; template <class T, class B> struct field_operators<T, T, B, ::boost::detail::false_t> : field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_field_operators : ordered_field_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_field_operators<T, U, B, ::boost::detail::true_t> : ordered_field_operators1<T, U> {}; template <class T, class B> struct ordered_field_operators<T, T, B, ::boost::detail::false_t> : ordered_field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidian_ring_operators : euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : euclidian_ring_operators1<T, U> {}; template <class T, class B> struct euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidian_ring_operators : ordered_euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidian_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidean_ring_operators : euclidean_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : euclidean_ring_operators1<T, U> {}; template <class T, class B> struct euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidean_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidean_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidean_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidean_ring_operators : ordered_euclidean_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidean_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidean_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidean_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidean_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::input_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::output_iteratable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::forward_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::bidirectional_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class W, class B> struct is_chained_base< ::boost::random_access_iteratable<T, U, V, W, B> > { typedef ::boost::detail::true_t value; };
# 891 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/operators.hpp"
template <class T, class U>
struct operators2
    : totally_ordered2<T,U
    , integer_arithmetic2<T,U
    , bitwise2<T,U
      > > > {};


template <class T, class U = T>
struct operators : operators2<T, U> {};

template <class T> struct operators<T, T>



    : totally_ordered<T
    , integer_arithmetic<T
    , bitwise<T
    , unit_steppable<T
      > > > > {};




template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
  : input_iteratable<T, P
  , boost::iterator<std::input_iterator_tag, V, D, P, R
    > > {};

template<class T>
struct output_iterator_helper
  : output_iteratable<T
  , boost::iterator<std::output_iterator_tag, void, void, void, void
  > >
{
  T& operator*() { return static_cast<T&>(*this); }
  T& operator++() { return static_cast<T&>(*this); }
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct forward_iterator_helper
  : forward_iteratable<T, P
  , boost::iterator<std::forward_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct bidirectional_iterator_helper
  : bidirectional_iteratable<T, P
  , boost::iterator<std::bidirectional_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct random_access_iterator_helper
  : random_access_iteratable<T, P, D, R
  , boost::iterator<std::random_access_iterator_tag, V, D, P, R
    > >
{
  friend D requires_difference_operator(const T& x, const T& y) {
    return x - y;
  }
};

}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/strong_typedef.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp" 2
# 60 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp"
namespace boost {
namespace serialization {

struct version_type : boost::totally_ordered1< version_type , boost::totally_ordered2< version_type, unsigned int > > { unsigned int t; explicit version_type(const unsigned int t_) : t(t_) {}; version_type(){}; version_type(const version_type & t_) : t(t_.t){} version_type & operator=(const version_type & rhs) { t = rhs.t; return *this;} version_type & operator=(const unsigned int & rhs) { t = rhs; return *this;} operator const unsigned int & () const {return t; } operator unsigned int & () { return t; } bool operator==(const version_type & rhs) const { return t == rhs.t; } bool operator<(const version_type & rhs) const { return t < rhs.t; } };


template<class Archive, class T>
inline void serialize(
    Archive & ar, T & t, const unsigned int file_version
){
    access::serialize(ar, t, static_cast<unsigned int>(file_version));
}


template<class Archive, class T>
inline void save_construct_data(
    Archive & ,
    const T * ,
    const unsigned int
){


}


template<class Archive, class T>
inline void load_construct_data(
    Archive & ,
    T * t,
    const unsigned int
){



    access::construct(t);
}
# 113 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp"
template<class Archive, class T>
inline void serialize_adl(
    Archive & ar,
    T & t,
    const unsigned int file_version
){
# 128 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/serialization.hpp"
        const version_type v(file_version);
        serialize(ar, t, v);



}

template<class Archive, class T>
inline void save_construct_data_adl(
    Archive & ar,
    const T * t,
    const unsigned int file_version
){


        const version_type v(file_version);
        save_construct_data(ar, t, v);



}

template<class Archive, class T>
inline void load_construct_data_adl(
    Archive & ar,
    T * t,
    const unsigned int file_version
){


        const version_type v(file_version);
        load_construct_data(ar, t, v);



}

}
}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/archive_constructed.hpp" 2



namespace boost{

namespace multi_index{

namespace detail{



template<typename T>
struct archive_constructed:private noncopyable
{
  template<class Archive>
  archive_constructed(Archive& ar,const unsigned int version)
  {
    serialization::load_construct_data_adl(ar,&get(),version);
    { try{
      ar>>get();
    }
    catch(...){
      (&get())->~T();
      throw;;
    }
    }
  }

  template<class Archive>
  archive_constructed(const char* name,Archive& ar,const unsigned int version)
  {
    serialization::load_construct_data_adl(ar,&get(),version);
    { try{
      ar>>serialization::make_nvp(name,get());
    }
    catch(...){
      (&get())->~T();
      throw;;
    }
    }
  }

  ~archive_constructed()
  {
    (&get())->~T();
  }

  T& get(){return *static_cast<T*>(static_cast<void*>(&space));}

private:
  typename aligned_storage<sizeof(T),alignment_of<T>::value>::type space;
};

}

}

}
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/serialization_version.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/serialization_version.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/version.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/version.hpp"
namespace boost {
namespace serialization {

struct basic_traits;



template<class T>
struct version
{
    template<class U>
    struct traits_class_version {
        typedef typename U::version type;
    };

    typedef mpl::integral_c_tag tag;


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits,T>,
            traits_class_version<T>,
            mpl::int_<0>
        >::type type;
    static const int value = version::type::value;
};

}
}
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/version.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/comparison.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/comparison.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not_equal_to.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not_equal_to.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct not_equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< not_equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< not_equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct not_equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct not_equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct not_equal_to

    : not_equal_to_impl<
          typename not_equal_to_tag<N1>::type
        , typename not_equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct not_equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< not_equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_equal_to< na , na > result_; typedef not_equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< not_equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< not_equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct not_equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value != N2::value ) >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/not_equal_to.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/comparison.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/less_equal.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/less_equal.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less_equal

    : less_equal_impl<
          typename less_equal_tag<N1>::type
        , typename less_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< less_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less_equal< na , na > result_; typedef less_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value <= N2::value ) >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/less_equal.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/comparison.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/greater_equal.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/greater_equal.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater_equal

    : greater_equal_impl<
          typename greater_equal_tag<N1>::type
        , typename greater_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater_equal< na , na > result_; typedef greater_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value >= N2::value ) >
    {
    };
};

}}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/greater_equal.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/comparison.hpp" 2
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/version.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/serialization_version.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{







template<typename T>
struct serialization_version
{
  serialization_version():
    value(boost::serialization::version<serialization_version>::value){}

  serialization_version& operator=(unsigned int x){value=x;return *this;};

  operator unsigned int()const{return value;}

private:
  friend class boost::serialization::access;

  template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }

  template<class Archive>
  void save(Archive&,const unsigned int)const{}

  template<class Archive>
  void load(Archive&,const unsigned int version)
  {
    this->value=version;
  }

  unsigned int value;
};

}

}


namespace serialization {
template<typename T>
struct version<boost::multi_index::detail::serialization_version<T> >
{
  static const int value=version<T>::value;
};
}


}
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/collection_size_type.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/collection_size_type.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/collection_size_type.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/split_free.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/split_free.hpp"
namespace boost {
namespace archive {
    namespace detail {
        template<class Archive> class interface_oarchive;
        template<class Archive> class interface_iarchive;
    }
}

namespace serialization {


template<class Archive, class T>
struct free_saver {
    static void invoke(
        Archive & ar,
        const T & t,
        const unsigned int file_version
    ){


        const version_type v(file_version);
        save(ar, t, v);
    }
};
template<class Archive, class T>
struct free_loader {
    static void invoke(
        Archive & ar,
        T & t,
        const unsigned int file_version
    ){


        const version_type v(file_version);
        load(ar, t, v);
    }
};


template<class Archive, class T>
inline void split_free(
    Archive & ar,
    T & t,
    const unsigned int file_version
){
    typedef typename mpl::eval_if<
        typename Archive::is_saving,
        mpl::identity< free_saver<Archive, T> >,
        mpl::identity< free_loader<Archive, T> >
    >::type typex;
    typex::invoke(ar, t, file_version);
}

}
}
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/serialization/collection_size_type.hpp" 2

namespace boost {
namespace serialization {



class collection_size_type {
private:
    typedef std::size_t base_type;
    base_type t;
public:
    collection_size_type(): t(0) {};
    explicit collection_size_type(const std::size_t & t_) :
        t(t_)
    {}
    collection_size_type(const collection_size_type & t_) :
        t(t_.t)
    {}
    collection_size_type & operator=(const collection_size_type & rhs){
        t = rhs.t;
        return *this;
    }
    collection_size_type & operator=(const unsigned int & rhs){
        t = rhs;
        return *this;
    }

    operator const base_type () const {
        return t;
    }

    operator base_type & () {
        return t;
    }
    bool operator==(const collection_size_type & rhs) const {
        return t == rhs.t;
    }
    bool operator<(const collection_size_type & rhs) const {
        return t < rhs.t;
    }
};


} }

namespace boost { namespace serialization { template <> struct implementation_level_impl< const collection_size_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level_impl::type::value; }; } }
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp" 2
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
namespace boost{

namespace multi_index{

template<typename Value,typename IndexSpecifierList,typename Allocator>
class multi_index_container:
  private ::boost::base_from_member<
    typename boost::detail::allocator::rebind_to<
      Allocator,
      typename detail::multi_index_node_type<
        Value,IndexSpecifierList,Allocator>::type
    >::type>,
  private detail::header_holder<
    typename detail::prevent_eti<
      Allocator,
      typename boost::detail::allocator::rebind_to<
        Allocator,
        typename detail::multi_index_node_type<
          Value,IndexSpecifierList,Allocator>::type
      >::type
    >::type::pointer,
    multi_index_container<Value,IndexSpecifierList,Allocator> >,
  public detail::multi_index_base_type<
    Value,IndexSpecifierList,Allocator>::type
{
# 100 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
private:

  template <typename,typename,typename> friend class detail::index_base;
  template <typename,typename> friend struct detail::header_holder;
  template <typename,typename> friend struct detail::converter;


  typedef typename detail::multi_index_base_type<
      Value,IndexSpecifierList,Allocator>::type super;
  typedef typename
  boost::detail::allocator::rebind_to<
      Allocator,
      typename super::node_type
  >::type node_allocator;
  typedef ::boost::base_from_member<
    node_allocator> bfm_allocator;
  typedef detail::header_holder<
    typename detail::prevent_eti<
      Allocator,
      node_allocator
    >::type::pointer,
    multi_index_container> bfm_header;






public:




  typedef typename super::ctor_args_list ctor_args_list;
  typedef IndexSpecifierList index_specifier_type_list;
# 155 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
  typedef typename super::index_type_list index_type_list;


  typedef typename super::iterator_type_list iterator_type_list;
  typedef typename super::const_iterator_type_list const_iterator_type_list;
  typedef typename super::value_type value_type;
  typedef typename super::final_allocator_type allocator_type;
  typedef typename super::iterator iterator;
  typedef typename super::const_iterator const_iterator;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((detail::no_duplicate_tags_in_index_list<index_type_list>::value) == 0 ? false : true) >)>
 boost_static_assert_typedef_166;



  typedef typename super::node_type node_type;



  explicit multi_index_container(
# 188 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
    const ctor_args_list& args_list=ctor_args_list(),
    const allocator_type& al=allocator_type()):


    bfm_allocator(al),
    super(args_list,bfm_allocator::member),
    node_count(0)
  {
    ;
  }

  explicit multi_index_container(const allocator_type& al):
    bfm_allocator(al),
    super(ctor_args_list(),bfm_allocator::member),
    node_count(0)
  {
    ;
  }

  template<typename InputIterator>
  multi_index_container(
    InputIterator first,InputIterator last,
# 223 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
    const ctor_args_list& args_list=ctor_args_list(),
    const allocator_type& al=allocator_type()):


    bfm_allocator(al),
    super(args_list,bfm_allocator::member),
    node_count(0)
  {
    ;
    { try{
      iterator hint=super::end();
      for(;first!=last;++first){
        hint=super::make_iterator(insert_(*first,hint.get_node()).first);
      }
    }
    catch(...){
      clear_();
      throw;;
    }
    }
  }

  multi_index_container(
    const multi_index_container<Value,IndexSpecifierList,Allocator>& x):
    bfm_allocator(x.bfm_allocator::member),
    bfm_header(),
    super(x),
    node_count(0)
  {
    copy_map_type map(bfm_allocator::member,x.size(),x.header(),header());
    for(const_iterator it=x.begin(),it_end=x.end();it!=it_end;++it){
      map.clone(it.get_node());
    }
    super::copy_(x,map);
    map.release();
    node_count=x.size();





    ;
  }

  ~multi_index_container()
  {
    delete_all_nodes_();
  }

  multi_index_container<Value,IndexSpecifierList,Allocator>& operator=(
    multi_index_container<Value,IndexSpecifierList,Allocator> x)
  {
    ;
    this->swap(x);
    return *this;
  }

  allocator_type get_allocator()const
  {
    return allocator_type(bfm_allocator::member);
  }




  template<int N>
  struct nth_index
  {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((N>=0&&N<mpl::size<index_type_list>::type::value) == 0 ? false : true) >)> boost_static_assert_typedef_291;
    typedef typename mpl::at_c<index_type_list,N>::type type;
  };

  template<int N>
  typename nth_index<N>::type& get()
  {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((N>=0&&N<mpl::size<index_type_list>::type::value) == 0 ? false : true) >)> boost_static_assert_typedef_298;
    return *this;
  }

  template<int N>
  const typename nth_index<N>::type& get(
    )const
  {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((N>=0&&N<mpl::size<index_type_list>::type::value) == 0 ? false : true) >)> boost_static_assert_typedef_306;
    return *this;
  }





  template<typename Tag>
  struct index
  {
    typedef typename mpl::find_if<
      index_type_list,
      detail::has_tag<Tag>
    >::type iter;

    static const bool index_found=!(is_same<iter,typename mpl::end<index_type_list>::type >::value)
                                                                                         ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((index_found) == 0 ? false : true) >)> boost_static_assert_typedef_324;

    typedef typename mpl::deref<iter>::type type;
  };

  template<typename Tag>
  typename index<Tag>::type& get()
  {
    return *this;
  }

  template<typename Tag>
  const typename index<Tag>::type& get(
    )const
  {
    return *this;
  }





  template<int N>
  struct nth_index_iterator
  {
    typedef typename nth_index<N>::type::iterator type;
  };

  template<int N>
  struct nth_index_const_iterator
  {
    typedef typename nth_index<N>::type::const_iterator type;
  };

  template<int N,typename IteratorType>
  typename nth_index_iterator<N>::type project(
    IteratorType it
    )
  {
    typedef typename nth_index<N>::type index;


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((mpl::contains<iterator_type_list,IteratorType>::value)) == 0 ? false : true) >)>
 boost_static_assert_typedef_367;


    ((void)0);;
    ((void)0);
                                                                    ;

    return index::make_iterator(static_cast<node_type*>(it.get_node()));
  }

  template<int N,typename IteratorType>
  typename nth_index_const_iterator<N>::type project(
    IteratorType it
    )const
  {
    typedef typename nth_index<N>::type index;


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::contains<iterator_type_list,IteratorType>::value|| mpl::contains<const_iterator_type_list,IteratorType>::value)) == 0 ? false : true) >)>

 boost_static_assert_typedef_387;


    ((void)0);;
    ((void)0);
                                                                          ;
    return index::make_iterator(static_cast<node_type*>(it.get_node()));
  }





  template<typename Tag>
  struct index_iterator
  {
    typedef typename index<Tag>::type::iterator type;
  };

  template<typename Tag>
  struct index_const_iterator
  {
    typedef typename index<Tag>::type::const_iterator type;
  };

  template<typename Tag,typename IteratorType>
  typename index_iterator<Tag>::type project(
    IteratorType it
    )
  {
    typedef typename index<Tag>::type index;


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((mpl::contains<iterator_type_list,IteratorType>::value)) == 0 ? false : true) >)>
 boost_static_assert_typedef_421;


    ((void)0);;
    ((void)0);
                                                                    ;
    return index::make_iterator(static_cast<node_type*>(it.get_node()));
  }

  template<typename Tag,typename IteratorType>
  typename index_const_iterator<Tag>::type project(
    IteratorType it
    )const
  {
    typedef typename index<Tag>::type index;


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::contains<iterator_type_list,IteratorType>::value|| mpl::contains<const_iterator_type_list,IteratorType>::value)) == 0 ? false : true) >)>

 boost_static_assert_typedef_440;


    ((void)0);;
    ((void)0);
                                                                          ;
    return index::make_iterator(static_cast<node_type*>(it.get_node()));
  }


protected:
  typedef typename super::copy_map_type copy_map_type;

  node_type* header()const
  {
    return &*bfm_header::member;
  }

  node_type* allocate_node()
  {
    return &*bfm_allocator::member.allocate(1);
  }

  void deallocate_node(node_type* x)
  {
    typedef typename node_allocator::pointer node_pointer;
    bfm_allocator::member.deallocate(static_cast<node_pointer>(x),1);
  }

  bool empty_()const
  {
    return node_count==0;
  }

  std::size_t size_()const
  {
    return node_count;
  }

  std::size_t max_size_()const
  {
    return static_cast<std::size_t >(-1);
  }

  std::pair<node_type*,bool> insert_(const Value& v)
  {
    node_type* x=allocate_node();
    { try{
      node_type* res=super::insert_(v,x);
      if(res==x){
        ++node_count;
        return std::pair<node_type*,bool>(res,true);
      }
      else{
        deallocate_node(x);
        return std::pair<node_type*,bool>(res,false);
      }
    }
    catch(...){
      deallocate_node(x);
      throw;;
    }
    }
  }

  std::pair<node_type*,bool> insert_(const Value& v,node_type* position)
  {
    node_type* x=allocate_node();
    { try{
      node_type* res=super::insert_(v,position,x);
      if(res==x){
        ++node_count;
        return std::pair<node_type*,bool>(res,true);
      }
      else{
        deallocate_node(x);
        return std::pair<node_type*,bool>(res,false);
      }
    }
    catch(...){
      deallocate_node(x);
      throw;;
    }
    }
  }

  void erase_(node_type* x)
  {
    --node_count;
    super::erase_(x);
    deallocate_node(x);
  }

  void delete_node_(node_type* x)
  {
    super::delete_node_(x);
    deallocate_node(x);
  }

  void delete_all_nodes_()
  {
    super::delete_all_nodes_();
  }

  void clear_()
  {
    delete_all_nodes_();
    super::clear_();
    node_count=0;
  }

  void swap_(multi_index_container<Value,IndexSpecifierList,Allocator>& x)
  {
    if(bfm_allocator::member!=x.bfm_allocator::member){
      detail::adl_swap(bfm_allocator::member,x.bfm_allocator::member);
    }
    std::swap(bfm_header::member,x.bfm_header::member);
    super::swap_(x);
    std::swap(node_count,x.node_count);
  }

  bool replace_(const Value& k,node_type* x)
  {
    return super::replace_(k,x);
  }

  template<typename Modifier>
  bool modify_(Modifier& mod,node_type* x)
  {
    mod(const_cast<value_type&>(x->value()));

    { try{
      if(!super::modify_(x)){
        deallocate_node(x);
        --node_count;
        return false;
      }
      else return true;
    }
    catch(...){
      deallocate_node(x);
      --node_count;
      throw;;
    }
    }
  }

  template<typename Modifier,typename Rollback>
  bool modify_(Modifier& mod,Rollback& back,node_type* x)
  {
    mod(const_cast<value_type&>(x->value()));

    bool b;
    { try{
      b=super::modify_rollback_(x);
    }
    catch(...){
      { try{
        back(const_cast<value_type&>(x->value()));
        throw;;
      }
      catch(...){
        this->erase_(x);
        throw;;
      }
      }
    }
    }

    { try{
      if(!b){
        back(const_cast<value_type&>(x->value()));
        return false;
      }
      else return true;
    }
    catch(...){
      this->erase_(x);
      throw;;
    }
    }
  }




  friend class boost::serialization::access;

  template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }

  typedef typename super::index_saver_type index_saver_type;
  typedef typename super::index_loader_type index_loader_type;

  template<class Archive>
  void save(Archive& ar,const unsigned int version)const
  {


    const serialization::collection_size_type s(size_());
    const detail::serialization_version<value_type> value_version;
    ar<<serialization::make_nvp("count",s);
    ar<<serialization::make_nvp("value_version",value_version);






    index_saver_type sm(bfm_allocator::member,s);

    for(iterator it=super::begin(),it_end=super::end();it!=it_end;++it){
      serialization::save_construct_data_adl(ar,&*it,value_version);
      ar<<serialization::make_nvp("item",*it);
      sm.add(it.get_node(),ar,version);
    }
    sm.add_track(header(),ar,version);

    super::save_(ar,version,sm);
  }

  template<class Archive>
  void load(Archive& ar,const unsigned int version)
  {
    ;

    clear_();


    serialization::collection_size_type s;
    detail::serialization_version<value_type> value_version;
    if(version<1){
      std::size_t sz;
      ar>>serialization::make_nvp("count",sz);
      s=sz;
    }
    else{
      ar>>serialization::make_nvp("count",s);
    }
    if(version<2){
      value_version=0;
    }
    else{
      ar>>serialization::make_nvp("value_version",value_version);
    }






    index_loader_type lm(bfm_allocator::member,s);

    for(std::size_t n=0;n<s;++n){
      detail::archive_constructed<Value> value("item",ar,value_version);
      std::pair<node_type*,bool> p=insert_(
        value.get(),super::end().get_node());
      if(!p.second)throw_exception(
        archive::archive_exception(
          archive::archive_exception::other_exception));
      ar.reset_object_address(&p.first->value(),&value.get());
      lm.add(p.first,ar,version);
    }
    lm.add_track(header(),ar,version);

    super::load_(ar,version,lm);
  }
# 722 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
private:
  std::size_t node_count;





};



template<typename MultiIndexContainer,int N>
struct nth_index
{
  static const int M=mpl::size<typename MultiIndexContainer::index_type_list>::type::value

                                                                            ;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((N>=0&&N<M) == 0 ? false : true) >)> boost_static_assert_typedef_739;
  typedef typename mpl::at_c<
    typename MultiIndexContainer::index_type_list,N>::type type;
};

template<int N,typename Value,typename IndexSpecifierList,typename Allocator>
typename nth_index<
  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type&
get(
  multi_index_container<Value,IndexSpecifierList,Allocator>& m
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename nth_index<
    multi_index_container<
      Value,IndexSpecifierList,Allocator>,
    N
  >::type index;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((N>=0&& N< mpl::size< typename multi_index_type::index_type_list >::type::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_763;

  return detail::converter<multi_index_type,index>::index(m);
}

template<int N,typename Value,typename IndexSpecifierList,typename Allocator>
const typename nth_index<
  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type&
get(
  const multi_index_container<Value,IndexSpecifierList,Allocator>& m
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename nth_index<
    multi_index_container<
      Value,IndexSpecifierList,Allocator>,
    N
  >::type index;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((N>=0&& N< mpl::size< typename multi_index_type::index_type_list >::type::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_787;

  return detail::converter<multi_index_type,index>::index(m);
}



template<typename MultiIndexContainer,typename Tag>
struct index
{
  typedef typename MultiIndexContainer::index_type_list index_type_list;

  typedef typename mpl::find_if<
    index_type_list,
    detail::has_tag<Tag>
  >::type iter;

  static const bool index_found=!(is_same<iter,typename mpl::end<index_type_list>::type >::value)
                                                                                       ;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((index_found) == 0 ? false : true) >)> boost_static_assert_typedef_806;

  typedef typename mpl::deref<iter>::type type;
};

template<
  typename Tag,typename Value,typename IndexSpecifierList,typename Allocator
>
typename ::boost::multi_index::index<
  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type&
get(
  multi_index_container<Value,IndexSpecifierList,Allocator>& m
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename ::boost::multi_index::index<
    multi_index_container<
      Value,IndexSpecifierList,Allocator>,
    Tag
  >::type index;

  return detail::converter<multi_index_type,index>::index(m);
}

template<
  typename Tag,typename Value,typename IndexSpecifierList,typename Allocator
>
const typename ::boost::multi_index::index<
  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type&
get(
  const multi_index_container<Value,IndexSpecifierList,Allocator>& m
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename ::boost::multi_index::index<
    multi_index_container<
      Value,IndexSpecifierList,Allocator>,
    Tag
  >::type index;

  return detail::converter<multi_index_type,index>::index(m);
}



template<typename MultiIndexContainer,int N>
struct nth_index_iterator
{
  typedef typename detail::prevent_eti<
    nth_index<MultiIndexContainer,N>,
    typename nth_index<MultiIndexContainer,N>::type>::type::iterator type;
};

template<typename MultiIndexContainer,int N>
struct nth_index_const_iterator
{
  typedef typename detail::prevent_eti<
    nth_index<MultiIndexContainer,N>,
    typename nth_index<MultiIndexContainer,N>::type
  >::type::const_iterator type;
};

template<
  int N,typename IteratorType,
  typename Value,typename IndexSpecifierList,typename Allocator>
typename nth_index_iterator<
  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type
project(
  multi_index_container<Value,IndexSpecifierList,Allocator>& m,
  IteratorType it
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename nth_index<multi_index_type,N>::type index;



  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::contains< typename multi_index_type::iterator_type_list, IteratorType>::value)) == 0 ? false : true) >)>


 boost_static_assert_typedef_889;


  ((void)0);;
# 901 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
  return detail::converter<multi_index_type,index>::iterator(
    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));
}

template<
  int N,typename IteratorType,
  typename Value,typename IndexSpecifierList,typename Allocator>
typename nth_index_const_iterator<
  multi_index_container<Value,IndexSpecifierList,Allocator>,N>::type
project(
  const multi_index_container<Value,IndexSpecifierList,Allocator>& m,
  IteratorType it
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename nth_index<multi_index_type,N>::type index;



  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::contains< typename multi_index_type::iterator_type_list, IteratorType>::value|| mpl::contains< typename multi_index_type::const_iterator_type_list, IteratorType>::value)) == 0 ? false : true) >)>





 boost_static_assert_typedef_927;


  ((void)0);;
# 939 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
  return detail::converter<multi_index_type,index>::const_iterator(
    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));
}



template<typename MultiIndexContainer,typename Tag>
struct index_iterator
{
  typedef typename ::boost::multi_index::index<
    MultiIndexContainer,Tag>::type::iterator type;
};

template<typename MultiIndexContainer,typename Tag>
struct index_const_iterator
{
  typedef typename ::boost::multi_index::index<
    MultiIndexContainer,Tag>::type::const_iterator type;
};

template<
  typename Tag,typename IteratorType,
  typename Value,typename IndexSpecifierList,typename Allocator>
typename index_iterator<
  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type
project(
  multi_index_container<Value,IndexSpecifierList,Allocator>& m,
  IteratorType it
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename ::boost::multi_index::index<
    multi_index_type,Tag>::type index;



  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::contains< typename multi_index_type::iterator_type_list, IteratorType>::value)) == 0 ? false : true) >)>


 boost_static_assert_typedef_979;


  ((void)0);;
# 991 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
  return detail::converter<multi_index_type,index>::iterator(
    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));
}

template<
  typename Tag,typename IteratorType,
  typename Value,typename IndexSpecifierList,typename Allocator>
typename index_const_iterator<
  multi_index_container<Value,IndexSpecifierList,Allocator>,Tag>::type
project(
  const multi_index_container<Value,IndexSpecifierList,Allocator>& m,
  IteratorType it
  )
{
  typedef multi_index_container<
    Value,IndexSpecifierList,Allocator> multi_index_type;
  typedef typename ::boost::multi_index::index<
    multi_index_type,Tag>::type index;



  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::contains< typename multi_index_type::iterator_type_list, IteratorType>::value|| mpl::contains< typename multi_index_type::const_iterator_type_list, IteratorType>::value)) == 0 ? false : true) >)>





 boost_static_assert_typedef_1018;


  ((void)0);;
# 1030 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
  return detail::converter<multi_index_type,index>::const_iterator(
    m,static_cast<typename multi_index_type::node_type*>(it.get_node()));
}



template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator==(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)
{
  return get<0>(x)==get<0>(y);
}

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator<(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)
{
  return get<0>(x)<get<0>(y);
}

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator!=(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)
{
  return get<0>(x)!=get<0>(y);
}

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator>(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)
{
  return get<0>(x)>get<0>(y);
}

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator>=(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)
{
  return get<0>(x)>=get<0>(y);
}

template<
  typename Value1,typename IndexSpecifierList1,typename Allocator1,
  typename Value2,typename IndexSpecifierList2,typename Allocator2
>
bool operator<=(
  const multi_index_container<Value1,IndexSpecifierList1,Allocator1>& x,
  const multi_index_container<Value2,IndexSpecifierList2,Allocator2>& y)
{
  return get<0>(x)<=get<0>(y);
}



template<typename Value,typename IndexSpecifierList,typename Allocator>
void swap(
  multi_index_container<Value,IndexSpecifierList,Allocator>& x,
  multi_index_container<Value,IndexSpecifierList,Allocator>& y)
{
  x.swap(y);
}

}
# 1121 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index_container.hpp"
namespace serialization {
template<typename Value,typename IndexSpecifierList,typename Allocator>
struct version<
  boost::multi_index_container<Value,IndexSpecifierList,Allocator>
>
{
  static const int value=2;
};
}






using multi_index::get;
using multi_index::project;

}
# 28 "../libbase/string_table.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_node.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_node.hpp"
namespace boost{

namespace multi_index{

namespace detail{



template<typename Allocator>
struct hashed_index_node_impl
{
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,hashed_index_node_impl
    >::type
  >::type::pointer pointer;
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,hashed_index_node_impl
    >::type
  >::type::const_pointer const_pointer;

  pointer& next(){return next_;}
  pointer next()const{return next_;}



  static void increment(pointer& x,pointer bbegin,pointer bend)
  {
    std::less_equal<pointer> leq;

    x=x->next();
    if(leq(bbegin,x)&&leq(x,bend)){
      do{
        ++x;
      }while(x->next()==x);
      x=x->next();
    }
  }

  static void link(pointer x,pointer pos)
  {
    x->next()=pos->next();
    pos->next()=x;
  };

  static void unlink(pointer x)
  {
    pointer y=x->next();
    while(y->next()!=x){y=y->next();}
    y->next()=x->next();
  }

  static pointer prev(pointer x)
  {
    pointer y=x->next();
    while(y->next()!=x){y=y->next();}
    return y;
  }

  static void unlink_next(pointer x)
  {
    x->next()=x->next()->next();
  }

private:
  pointer next_;
};

template<typename Super>
struct hashed_index_node_trampoline:
  prevent_eti<
    Super,
    hashed_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        typename Super::allocator_type,
        char
      >::type
    >
  >::type
{
  typedef typename prevent_eti<
    Super,
    hashed_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        typename Super::allocator_type,
        char
      >::type
    >
  >::type impl_type;
};

template<typename Super>
struct hashed_index_node:Super,hashed_index_node_trampoline<Super>
{
private:
  typedef hashed_index_node_trampoline<Super> trampoline;

public:
  typedef typename trampoline::impl_type impl_type;
  typedef typename trampoline::pointer impl_pointer;
  typedef typename trampoline::const_pointer const_impl_pointer;

  impl_pointer impl()
  {
    return static_cast<impl_pointer>(
      static_cast<impl_type*>(static_cast<trampoline*>(this)));
  }

  const_impl_pointer impl()const
  {
    return static_cast<const_impl_pointer>(
      static_cast<const impl_type*>(static_cast<const trampoline*>(this)));
  }

  static hashed_index_node* from_impl(impl_pointer x)
  {
    return static_cast<hashed_index_node*>(
      static_cast<trampoline*>(&*x));
  }

  static const hashed_index_node* from_impl(const_impl_pointer x)
  {
    return static_cast<const hashed_index_node*>(
      static_cast<const trampoline*>(&*x));
  }

  static void increment(
    hashed_index_node*& x,impl_pointer bbegin,impl_pointer bend)
  {
    impl_pointer xi=x->impl();
    trampoline::increment(xi,bbegin,bend);
    x=from_impl(xi);
  }
};

}

}

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 1 3 4
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp" 2







namespace boost{

namespace multi_index{

namespace detail{



class bucket_array_base:private noncopyable
{
protected:
  inline static std::size_t next_prime(std::size_t n)
  {
    static const std::size_t prime_list[]={
      53ul, 97ul, 193ul, 389ul, 769ul,
      1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
      49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
      1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul,
      50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul,
      1610612741ul, 3221225473ul,


      4294967291ul
# 74 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp"
    };
    static const std::size_t prime_list_size=
      sizeof(prime_list)/sizeof(prime_list[0]);

    std::size_t const *bound=
      std::lower_bound(prime_list,prime_list+prime_list_size,n);
    if(bound==prime_list+prime_list_size)bound--;
    return *bound;
  }
};

template<typename Allocator>
class bucket_array:public bucket_array_base
{
  typedef typename prevent_eti<
    Allocator,
    hashed_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        Allocator,
        char
      >::type
    >
  >::type node_impl_type;

public:
  typedef typename node_impl_type::pointer pointer;

  bucket_array(const Allocator& al,pointer end_,std::size_t size):
    size_(bucket_array_base::next_prime(size)),
    spc(al,size_+1)
  {
    clear();
    end()->next()=end_;
    end_->next()=end();
  }

  std::size_t size()const
  {
    return size_;
  }

  std::size_t position(std::size_t hash)const
  {
    return hash%size_;
  }

  pointer begin()const{return buckets();}
  pointer end()const{return buckets()+size_;}
  pointer at(std::size_t n)const{return buckets()+n;}

  std::size_t first_nonempty(std::size_t n)const
  {
    for(;;++n){
      pointer x=at(n);
      if(x->next()!=x)return n;
    }
  }

  void clear()
  {
    for(pointer x=begin(),y=end();x!=y;++x)x->next()=x;
  }

  void swap(bucket_array& x)
  {
    std::swap(size_,x.size_);
    spc.swap(x.spc);
  }

private:
  std::size_t size_;
  auto_space<node_impl_type,Allocator> spc;

  pointer buckets()const
  {
    return spc.data();
  }


  friend class boost::serialization::access;






  template<class Archive>
  void serialize(Archive&,const unsigned int)
  {
  }

};

template<typename Allocator>
void swap(bucket_array<Allocator>& x,bucket_array<Allocator>& y)
{
  x.swap(y);
}

}

}
# 187 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bucket_array.hpp"
namespace multi_index{
namespace detail{


template<class Archive,typename Allocator>
inline void load_construct_data(
  Archive&,boost::multi_index::detail::bucket_array<Allocator>*,
  const unsigned int)
{
  throw_exception(
    archive::archive_exception(archive::archive_exception::other_exception));
}




}
}




}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_iterator.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_iterator.hpp"
namespace boost{

namespace multi_index{

namespace detail{




template<typename Node,typename BucketArray>
class hashed_index_iterator:
  public forward_iterator_helper<
    hashed_index_iterator<Node,BucketArray>,
    typename Node::value_type,
    std::ptrdiff_t,
    const typename Node::value_type*,
    const typename Node::value_type&>
{
public:
  hashed_index_iterator(){}
  hashed_index_iterator(Node* node_,BucketArray* buckets_):
    node(node_),buckets(buckets_)
  {}

  const typename Node::value_type& operator*()const
  {
    return node->value();
  }

  hashed_index_iterator& operator++()
  {
    Node::increment(node,buckets->begin(),buckets->end());
    return *this;
  }






  template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }

  typedef typename Node::base_type node_base_type;

  template<class Archive>
  void save(Archive& ar,const unsigned int)const
  {
    node_base_type* bnode=node;
    ar<<serialization::make_nvp("pointer",bnode);
    ar<<serialization::make_nvp("pointer",buckets);
  }

  template<class Archive>
  void load(Archive& ar,const unsigned int)
  {
    node_base_type* bnode;
    ar>>serialization::make_nvp("pointer",bnode);
    node=static_cast<Node*>(bnode);
    ar>>serialization::make_nvp("pointer",buckets);
  }




  typedef Node node_type;

  Node* get_node()const{return node;}

private:
  Node* node;
  BucketArray* buckets;
};

template<typename Node,typename BucketArray>
bool operator==(
  const hashed_index_iterator<Node,BucketArray>& x,
  const hashed_index_iterator<Node,BucketArray>& y)
{
  return x.get_node()==y.get_node();
}

}

}

}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/modify_key_adaptor.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/modify_key_adaptor.hpp"
namespace boost{

namespace multi_index{

namespace detail{






template<typename Fun,typename Value,typename KeyFromValue>
struct modify_key_adaptor
{

  modify_key_adaptor(Fun f_,KeyFromValue kfv_):f(f_),kfv(kfv_){}

  void operator()(Value& x)
  {
    f(kfv(x));
  }

private:
  Fun f;
  KeyFromValue kfv;
};

}

}

}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/safe_ctr_proxy.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index_fwd.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index_fwd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_args.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_args.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash.hpp" 1





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash_fwd.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash_fwd.hpp" 2


namespace boost
{
    template <class T> struct hash;




    template <class T> void hash_combine(std::size_t& seed, T const& v);


    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);





}
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/float_functions.hpp" 1
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/float_functions.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/cmath.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/cmath.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3




# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
extern "C" {



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/huge_val.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/huge_valf.h" 1 3 4
# 37 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/huge_vall.h" 1 3 4
# 38 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/inf.h" 1 3 4
# 41 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/nan.h" 1 3 4
# 44 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathdef.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathdef.h" 3 4
typedef float float_t;

typedef double double_t;
# 48 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4
# 71 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 1 3 4
# 53 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4
# 94 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 1 3 4
# 53 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void
 sincosf
# 82 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4
 (float __x, float *__sinx, float *__cosx) throw (); extern void
 __sincosf
# 82 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4
 (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4
# 141 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 1 3 4
# 53 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void
 sincosl
# 82 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4
 (long double __x, long double *__sinx, long double *__cosx) throw (); extern void
 __sincosl
# 82 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathcalls.h" 3 4
 (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 142 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4
# 157 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
extern int signgam;
# 198 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 291 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 314 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 416 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/mathinline.h" 1 3 4
# 417 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 2 3 4
# 472 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/math.h" 3 4
}
# 47 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 2 3
# 77 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Tp>
    _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }

}
# 498 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }

}





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cmath.tcc" 1 3
# 35 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/cmath.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : _Tp(1);

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }

}
# 616 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 2 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/cmath.hpp" 2
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/float_functions.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/float_functions.hpp"
namespace boost {
    namespace hash_detail {



        struct not_found {



            inline operator float() const { return 0; }
            inline operator long double() const { return 0; }
        };



        template <typename T> struct is;
        template <> struct is<float> { char x[10]; };
        template <> struct is<double> { char x[20]; };
        template <> struct is<long double> { char x[30]; };
        template <> struct is<boost::hash_detail::not_found> { char x[40]; };



        template <typename T> is<T> float_type(T);





        template <typename Float> struct call_ldexp
        {
            typedef double float_type;

            inline double operator()(double a, int b) const
            {
                using namespace std;
                return ldexp(a, b);
            }
        };





        template <typename Float> struct call_frexp
        {
            typedef double float_type;

            inline double operator()(double a, int* b) const
            {
                using namespace std;
                return frexp(a, b);
            }
        };
    }
}
# 87 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/float_functions.hpp"
namespace boost_hash_detect_float_functions {
    template <class Float> boost::hash_detail::not_found ldexp(Float, int);
    template <class Float> boost::hash_detail::not_found frexp(Float, int*);
}
# 188 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/float_functions.hpp"
namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found ldexpf(Float, int); } namespace boost { namespace hash_detail { namespace ldexpf_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static float x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(ldexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_ldexpf : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexpf(a, b); } }; template <bool x> struct call_cpp_ldexpf : call_c99_ldexpf< ::boost::hash_detail::ldexpf_detect::check::c99 > {}; template <> struct call_cpp_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<float> : call_cpp_ldexpf< ::boost::hash_detail::ldexpf_detect::check::cpp > {}; } }





namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found ldexpl(Float, int); } namespace boost { namespace hash_detail { namespace ldexpl_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static long double x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(ldexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_ldexpl : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexpl(a, b); } }; template <bool x> struct call_cpp_ldexpl : call_c99_ldexpl< ::boost::hash_detail::ldexpl_detect::check::c99 > {}; template <> struct call_cpp_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<long double> : call_cpp_ldexpl< ::boost::hash_detail::ldexpl_detect::check::cpp > {}; } }





namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found frexpf(Float, int*); } namespace boost { namespace hash_detail { namespace frexpf_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static float x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(frexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_frexpf : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexpf(a, b); } }; template <bool x> struct call_cpp_frexpf : call_c99_frexpf< ::boost::hash_detail::frexpf_detect::check::c99 > {}; template <> struct call_cpp_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<float> : call_cpp_frexpf< ::boost::hash_detail::frexpf_detect::check::cpp > {}; } }





namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found frexpl(Float, int*); } namespace boost { namespace hash_detail { namespace frexpl_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static long double x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(frexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_frexpl : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexpl(a, b); } }; template <bool x> struct call_cpp_frexpl : call_c99_frexpl< ::boost::hash_detail::frexpl_detect::check::c99 > {}; template <> struct call_cpp_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<long double> : call_cpp_frexpl< ::boost::hash_detail::frexpl_detect::check::cpp > {}; } }






namespace boost
{
    namespace hash_detail
    {
        template <typename Float1, typename Float2>
        struct select_hash_type_impl {
            typedef double type;
        };

        template <>
        struct select_hash_type_impl<float, float> {
            typedef float type;
        };

        template <>
        struct select_hash_type_impl<long double, long double> {
            typedef long double type;
        };







        template <typename Float>
        struct select_hash_type : select_hash_type_impl<
                typename call_ldexp<Float>::float_type,
                typename call_frexp<Float>::float_type
            > {};
    }
}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/limits.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/limits.hpp"
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        struct limits : std::numeric_limits<T> {};
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/limits.hpp"
    }
}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer/static_log2.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer/static_log2.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 1 3 4
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 2 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp" 2


namespace boost
{







     typedef boost::uintmax_t static_min_max_unsigned_type;
     typedef boost::intmax_t static_min_max_signed_type;
     typedef boost::uintmax_t static_log2_argument_type;
     typedef int static_log2_result_type;
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp"
template < class T >
    class integer_traits;

template < >
    class integer_traits< bool >;

template < >
    class integer_traits< char >;

template < >
    class integer_traits< signed char >;

template < >
    class integer_traits< unsigned char >;


template < >
    class integer_traits< wchar_t >;


template < >
    class integer_traits< short >;

template < >
    class integer_traits< unsigned short >;

template < >
    class integer_traits< int >;

template < >
    class integer_traits< unsigned int >;

template < >
    class integer_traits< long >;

template < >
    class integer_traits< unsigned long >;


template < >
class integer_traits< ::boost::long_long_type>;

template < >
class integer_traits< ::boost::ulong_long_type >;
# 97 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp"
template < typename LeastInt >
    struct int_fast_t;

template< int Bits >
    struct int_t;

template< int Bits >
    struct uint_t;


    template< boost::long_long_type MaxValue >



    struct int_max_value_t;


  template< boost::long_long_type MinValue >



    struct int_min_value_t;


  template< boost::ulong_long_type MaxValue >



    struct uint_value_t;




template < std::size_t Bit >
    struct high_bit_mask_t;

template < std::size_t Bits >
    struct low_bits_mask_t;

template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits >;


template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned short>::digits >;



template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned int>::digits >;
# 157 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer_fwd.hpp"
template <static_log2_argument_type Value >
    struct static_log2;

template <> struct static_log2<0u>;




template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;

template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer/static_log2.hpp" 2

namespace boost {

 namespace detail {

     namespace static_log2_impl {
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer/static_log2.hpp"
     typedef boost::static_log2_argument_type argument_type;
     typedef boost::static_log2_result_type result_type;

     template <result_type n>
     struct choose_initial_n {

         static const bool c = (argument_type(1) << n << n) != 0;
         static const result_type value = !c*n + choose_initial_n<2*c*n>::value


          ;

     };

     template <>
     struct choose_initial_n<0> {
         static const result_type value = 0;
     };




     const result_type n_zero = 16;
     const result_type initial_n = choose_initial_n<n_zero>::value;
# 84 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer/static_log2.hpp"
     template <argument_type x, result_type n = initial_n>
     struct static_log2_impl {

         static const bool c = (x >> n) > 0;
         static const result_type value = c*n + (static_log2_impl< (x>>c*n), n/2 >::value)


          ;

     };

     template <>
     struct static_log2_impl<1, 0> {
        static const result_type value = 0;
     };

     }
 }







 template <static_log2_argument_type x>
 struct static_log2 {

     static const static_log2_result_type value = detail::static_log2_impl::static_log2_impl<x>::value


      ;

 };


 template <>
 struct static_log2<0> { };

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float_generic.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float_generic.hpp"
namespace boost
{
    namespace hash_detail
    {
        inline void hash_float_combine(std::size_t& seed, std::size_t value)
        {
            seed ^= value + (seed<<6) + (seed>>2);
        }

        template <class T>
        inline std::size_t float_hash_impl2(T v)
        {
            boost::hash_detail::call_frexp<T> frexp;
            boost::hash_detail::call_ldexp<T> ldexp;

            int exp = 0;

            v = frexp(v, &exp);



            if(v < 0) {
                v = -v;
                exp += limits<T>::max_exponent -
                    limits<T>::min_exponent;
            }

            v = ldexp(v, limits<std::size_t>::digits);
            std::size_t seed = static_cast<std::size_t>(v);
            v -= seed;


            std::size_t const length
                = (limits<T>::digits *
                        boost::static_log2<limits<T>::radix>::value
                        + limits<std::size_t>::digits - 1)
                / limits<std::size_t>::digits;

            for(std::size_t i = 0; i != length; ++i)
            {
                v = ldexp(v, limits<std::size_t>::digits);
                std::size_t part = static_cast<std::size_t>(v);
                v -= part;
                hash_float_combine(seed, part);
            }

            hash_float_combine(seed, exp);

            return seed;
        }

        template <class T>
        inline std::size_t float_hash_impl(T v)
        {
            typedef typename select_hash_type<T>::type type;
            return float_hash_impl2(static_cast<type>(v));
        }
    }
}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp" 2
# 57 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp"
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        inline std::size_t float_hash_value(T v)
        {
            using namespace std;
            switch (fpclassify(v)) {
            case FP_ZERO:
                return 0;
            case FP_INFINITE:
                return (std::size_t)(v > 0 ? -1 : -2);
            case FP_NAN:
                return (std::size_t)(-3);
            case FP_NORMAL:
            case FP_SUBNORMAL:
                return float_hash_impl(v);
            default:
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/detail/hash_float.hpp", 76, __PRETTY_FUNCTION__));
                return 0;
            }
        }
    }
}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
namespace boost
{
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
    std::size_t hash_value(bool);
    std::size_t hash_value(char);
    std::size_t hash_value(unsigned char);
    std::size_t hash_value(signed char);
    std::size_t hash_value(short);
    std::size_t hash_value(unsigned short);
    std::size_t hash_value(int);
    std::size_t hash_value(unsigned int);
    std::size_t hash_value(long);
    std::size_t hash_value(unsigned long);


    std::size_t hash_value(wchar_t);



    std::size_t hash_value(boost::long_long_type);
    std::size_t hash_value(boost::ulong_long_type);



    template <class T> std::size_t hash_value(T* const&);





    template< class T, unsigned N >
    std::size_t hash_value(const T (&x)[N]);

    template< class T, unsigned N >
    std::size_t hash_value(T (&x)[N]);


    std::size_t hash_value(float v);
    std::size_t hash_value(double v);
    std::size_t hash_value(long double v);

    template <class Ch, class A>
    std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const&);



    namespace hash_detail
    {
        template <class T>
        inline std::size_t hash_value_signed(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;
             T positive = val < 0 ? -1 - val : val;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }

        template <class T>
        inline std::size_t hash_value_unsigned(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }
    }

    inline std::size_t hash_value(bool v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(signed char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(short v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned short v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(int v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned int v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(long v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned long v)
    {
        return static_cast<std::size_t>(v);
    }


    inline std::size_t hash_value(wchar_t v)
    {
        return static_cast<std::size_t>(v);
    }



    inline std::size_t hash_value(boost::long_long_type v)
    {
        return hash_detail::hash_value_signed(v);
    }

    inline std::size_t hash_value(boost::ulong_long_type v)
    {
        return hash_detail::hash_value_unsigned(v);
    }




    template <class T> std::size_t hash_value(T* const& v)



    {
        std::size_t x = static_cast<std::size_t>(
           reinterpret_cast<std::ptrdiff_t>(v));

        return x + (x >> 3);
    }
# 232 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
    template <class T>
    inline void hash_combine(std::size_t& seed, T const& v)

    {
        boost::hash<T> hasher;
        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }





    template <class It>
    inline std::size_t hash_range(It first, It last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }

        return seed;
    }

    template <class It>
    inline void hash_range(std::size_t& seed, It first, It last)
    {
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
    }
# 293 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
    template< class T, unsigned N >
    inline std::size_t hash_value(const T (&x)[N])
    {
        return hash_range(x, x + N);
    }

    template< class T, unsigned N >
    inline std::size_t hash_value(T (&x)[N])
    {
        return hash_range(x, x + N);
    }


    template <class Ch, class A>
    inline std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    inline std::size_t hash_value(float v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    inline std::size_t hash_value(double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    inline std::size_t hash_value(long double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }
# 404 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
    template <> struct hash<bool> : public std::unary_function<bool, std::size_t> { std::size_t operator()(bool v) const { return boost::hash_value(v); } };
    template <> struct hash<char> : public std::unary_function<char, std::size_t> { std::size_t operator()(char v) const { return boost::hash_value(v); } };
    template <> struct hash<signed char> : public std::unary_function<signed char, std::size_t> { std::size_t operator()(signed char v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned char> : public std::unary_function<unsigned char, std::size_t> { std::size_t operator()(unsigned char v) const { return boost::hash_value(v); } };

    template <> struct hash<wchar_t> : public std::unary_function<wchar_t, std::size_t> { std::size_t operator()(wchar_t v) const { return boost::hash_value(v); } };

    template <> struct hash<short> : public std::unary_function<short, std::size_t> { std::size_t operator()(short v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned short> : public std::unary_function<unsigned short, std::size_t> { std::size_t operator()(unsigned short v) const { return boost::hash_value(v); } };
    template <> struct hash<int> : public std::unary_function<int, std::size_t> { std::size_t operator()(int v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned int> : public std::unary_function<unsigned int, std::size_t> { std::size_t operator()(unsigned int v) const { return boost::hash_value(v); } };
    template <> struct hash<long> : public std::unary_function<long, std::size_t> { std::size_t operator()(long v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned long> : public std::unary_function<unsigned long, std::size_t> { std::size_t operator()(unsigned long v) const { return boost::hash_value(v); } };

    template <> struct hash<float> : public std::unary_function<float, std::size_t> { std::size_t operator()(float v) const { return boost::hash_value(v); } };
    template <> struct hash<double> : public std::unary_function<double, std::size_t> { std::size_t operator()(double v) const { return boost::hash_value(v); } };
    template <> struct hash<long double> : public std::unary_function<long double, std::size_t> { std::size_t operator()(long double v) const { return boost::hash_value(v); } };

    template <> struct hash<std::string> : public std::unary_function<std::string, std::size_t> { std::size_t operator()(std::string const& v) const { return boost::hash_value(v); } };

    template <> struct hash<std::wstring> : public std::unary_function<std::wstring, std::size_t> { std::size_t operator()(std::wstring const& v) const { return boost::hash_value(v); } };



    template <> struct hash<boost::long_long_type> : public std::unary_function<boost::long_long_type, std::size_t> { std::size_t operator()(boost::long_long_type v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::ulong_long_type> : public std::unary_function<boost::ulong_long_type, std::size_t> { std::size_t operator()(boost::ulong_long_type v) const { return boost::hash_value(v); } };
# 439 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
    template <class T>
    struct hash<T*>
        : public std::unary_function<T*, std::size_t>
    {
        std::size_t operator()(T* v) const
        {

            return boost::hash_value(v);






        }
    };
# 498 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
}
# 510 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/container_fwd.hpp" 1
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/container_fwd.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/container_fwd.hpp" 2
# 60 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/container_fwd.hpp"
namespace std
{
    template <class T> class allocator;
    template <class charT, class traits, class Allocator> class basic_string;




    template <class charT> struct char_traits;


    template <class T> class complex;
}


namespace std
{

    template <class T, class Allocator> class deque;


    template <class T, class Allocator> class list;
    template <class T, class Allocator> class vector;
    template <class Key, class T, class Compare, class Allocator> class map;
    template <class Key, class T, class Compare, class Allocator>
    class multimap;
    template <class Key, class Compare, class Allocator> class set;
    template <class Key, class Compare, class Allocator> class multiset;


    template <size_t N> class bitset;

    template <class T1, class T2> struct pair;
}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp" 2
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp"
namespace boost
{
    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const&);
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const&);
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v);
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v);

    template <class T>
    std::size_t hash_value(std::complex<T> const&);

    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const& v)
    {
        std::size_t seed = 0;
        hash_combine(seed, v.first);
        hash_combine(seed, v.second);
        return seed;
    }

    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T>
    std::size_t hash_value(std::complex<T> const& v)
    {
        boost::hash<T> hasher;
        std::size_t seed = hasher(v.imag());
        seed ^= hasher(v.real()) + (seed<<6) + (seed>>2);
        return seed;
    }
# 170 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp"
    template <class T> struct hash
        : std::unary_function<T, std::size_t>
    {

        std::size_t operator()(T const& val) const
        {
            return hash_value(val);
        }






    };
# 284 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/extensions.hpp"
}
# 511 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash/hash.hpp" 2
# 7 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_args.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_args.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/hash_index_args.hpp"
template<typename KeyFromValue>
struct index_args_default_hash
{
  typedef ::boost::hash<typename KeyFromValue::result_type> type;
};

template<typename KeyFromValue>
struct index_args_default_pred
{
  typedef std::equal_to<typename KeyFromValue::result_type> type;
};

template<typename Arg1,typename Arg2,typename Arg3,typename Arg4>
struct hashed_index_args
{
  typedef is_tag<Arg1> full_form;

  typedef typename mpl::if_<
    full_form,
    Arg1,
    tag< > >::type tag_list_type;
  typedef typename mpl::if_<
    full_form,
    Arg2,
    Arg1>::type key_from_value_type;
  typedef typename mpl::if_<
    full_form,
    Arg3,
    Arg2>::type supplied_hash_type;
  typedef typename mpl::eval_if<
    mpl::is_na<supplied_hash_type>,
    index_args_default_hash<key_from_value_type>,
    mpl::identity<supplied_hash_type>
  >::type hash_type;
  typedef typename mpl::if_<
    full_form,
    Arg4,
    Arg3>::type supplied_pred_type;
  typedef typename mpl::eval_if<
    mpl::is_na<supplied_pred_type>,
    index_args_default_pred<key_from_value_type>,
    mpl::identity<supplied_pred_type>
  >::type pred_type;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((is_tag<tag_list_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_93;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!mpl::is_na<key_from_value_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_94;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!mpl::is_na<hash_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_95;
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!mpl::is_na<pred_type>::value) == 0 ? false : true) >)> boost_static_assert_typedef_96;
};

}

}

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index_fwd.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{

template<
  typename KeyFromValue,typename Hash,typename Pred,
  typename SuperMeta,typename TagList,typename Category
>
class hashed_index;

template<
  typename KeyFromValue,typename Hash,typename Pred,
  typename SuperMeta,typename TagList,typename Category
>
void swap(
  hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x,
  hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& y);

}



template<
  typename Arg1,typename Arg2=mpl::na,
  typename Arg3=mpl::na,typename Arg4=mpl::na
>
struct hashed_unique;

template<
  typename Arg1,typename Arg2=mpl::na,
  typename Arg3=mpl::na,typename Arg4=mpl::na
>
struct hashed_non_unique;

}

}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp" 2
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
struct hashed_unique_tag{};
struct hashed_non_unique_tag{};

template<
  typename KeyFromValue,typename Hash,typename Pred,
  typename SuperMeta,typename TagList,typename Category
>
class hashed_index:
  protected SuperMeta::type
# 88 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
{
# 99 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
  typedef typename SuperMeta::type super;

protected:
  typedef hashed_index_node<
    typename super::node_type> node_type;

private:
  typedef typename node_type::impl_type node_impl_type;
  typedef typename node_impl_type::pointer node_impl_pointer;
  typedef bucket_array<
    typename super::final_allocator_type> bucket_array_type;

public:


  typedef typename KeyFromValue::result_type key_type;
  typedef typename node_type::value_type value_type;
  typedef KeyFromValue key_from_value;
  typedef Hash hasher;
  typedef Pred key_equal;
  typedef tuple<std::size_t,
    key_from_value,hasher,key_equal> ctor_args;
  typedef typename super::final_allocator_type allocator_type;
  typedef typename allocator_type::pointer pointer;
  typedef typename allocator_type::const_pointer const_pointer;
  typedef typename allocator_type::reference reference;
  typedef typename allocator_type::const_reference const_reference;
  typedef std::size_t size_type;
  typedef std::ptrdiff_t difference_type;
# 144 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
  typedef hashed_index_iterator<
    node_type,bucket_array_type> iterator;


  typedef iterator const_iterator;

  typedef iterator local_iterator;
  typedef const_iterator const_local_iterator;
  typedef TagList tag_list;

protected:
  typedef typename super::final_node_type final_node_type;
  typedef tuples::cons<
    ctor_args,
    typename super::ctor_args_list> ctor_args_list;
  typedef typename mpl::push_front<
    typename super::index_type_list,
    hashed_index>::type index_type_list;
  typedef typename mpl::push_front<
    typename super::iterator_type_list,
    iterator>::type iterator_type_list;
  typedef typename mpl::push_front<
    typename super::const_iterator_type_list,
    const_iterator>::type const_iterator_type_list;
  typedef typename super::copy_map_type copy_map_type;


  typedef typename super::index_saver_type index_saver_type;
  typedef typename super::index_loader_type index_loader_type;


private:
# 188 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
  typedef typename call_traits<value_type>::param_type value_param_type;
  typedef typename call_traits<
    key_type>::param_type key_param_type;

public:






  hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& operator=(
    const hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x)
  {
    this->final()=x.final();
    return *this;
  }

  allocator_type get_allocator()const
  {
    return this->final().get_allocator();
  }



  bool empty()const{return this->final_empty_();}
  size_type size()const{return this->final_size_();}
  size_type max_size()const{return this->final_max_size_();}



  iterator begin()
  {
    return make_iterator(
      node_type::from_impl(buckets.at(first_bucket)->next()));
  }

  const_iterator begin()const
  {
    return make_iterator(
      node_type::from_impl(buckets.at(first_bucket)->next()));
  }

  iterator end(){return make_iterator(header());}
  const_iterator end()const{return make_iterator(header());}

  const_iterator cbegin()const{return begin();}
  const_iterator cend()const{return end();}

  iterator iterator_to(const value_type& x)
  {
    return make_iterator(node_from_value<node_type>(&x));
  }

  const_iterator iterator_to(const value_type& x)const
  {
    return make_iterator(node_from_value<node_type>(&x));
  }



  std::pair<iterator,bool> insert(value_param_type x)
  {
    ;
    std::pair<final_node_type*,bool> p=this->final_insert_(x);
    return std::pair<iterator,bool>(make_iterator(p.first),p.second);
  }

  iterator insert(iterator position,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ;
    std::pair<final_node_type*,bool> p=this->final_insert_(
      x,static_cast<final_node_type*>(position.get_node()));
    return make_iterator(p.first);
  }

  template<typename InputIterator>
  void insert(InputIterator first,InputIterator last)
  {
    ;
    iterator hint=end();
    for(;first!=last;++first)hint=insert(hint,*first);
  }

  iterator erase(iterator position)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    this->final_erase_(static_cast<final_node_type*>(position++.get_node()));
    return position;
  }

  size_type erase(key_param_type k)
  {
    ;

    size_type s=0;
    std::size_t buc=buckets.position(hash(k));
    node_impl_pointer x=buckets.at(buc);
    node_impl_pointer y=x->next();
    while(y!=x){
      if(eq(k,key(node_type::from_impl(y)->value()))){
        bool b;
        do{
          node_impl_pointer z=y->next();
          b=z!=x&&eq(
            key(node_type::from_impl(y)->value()),
            key(node_type::from_impl(z)->value()));
          this->final_erase_(
            static_cast<final_node_type*>(node_type::from_impl(y)));
          y=z;
          ++s;
        }while(b);
        break;
      }
      y=y->next();
    }
    return s;
  }

  iterator erase(iterator first,iterator last)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    while(first!=last){
      first=erase(first);
    }
    return first;
  }

  bool replace(iterator position,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return this->final_replace_(
      x,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier>
  bool modify(iterator position,Modifier mod)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
# 353 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
    return this->final_modify_(
      mod,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier,typename Rollback>
  bool modify(iterator position,Modifier mod,Rollback back)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
# 374 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
    return this->final_modify_(
      mod,back,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier>
  bool modify_key(iterator position,Modifier mod)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return modify(
      position,modify_key_adaptor<Modifier,value_type,KeyFromValue>(mod,key));
  }

  template<typename Modifier,typename Rollback>
  bool modify_key(iterator position,Modifier mod,Rollback back)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return modify(
      position,
      modify_key_adaptor<Modifier,value_type,KeyFromValue>(mod,key),
      modify_key_adaptor<Rollback,value_type,KeyFromValue>(back,key));
  }

  void clear()
  {
    ;
    this->final_clear_();
  }

  void swap(hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x)
  {
    ;
    this->final_swap_(x.final());
  }



  key_from_value key_extractor()const{return key;}
  hasher hash_function()const{return hash;}
  key_equal key_eq()const{return eq;}







  template<typename CompatibleKey>
  iterator find(const CompatibleKey& k)const
  {
    return find(k,hash,eq);
  }

  template<
    typename CompatibleKey,typename CompatibleHash,typename CompatiblePred
  >
  iterator find(
    const CompatibleKey& k,
    const CompatibleHash& hash,const CompatiblePred& eq)const
  {
    std::size_t buc=buckets.position(hash(k));
    node_impl_pointer x=buckets.at(buc);
    node_impl_pointer y=x->next();
    while(y!=x){
      if(eq(k,key(node_type::from_impl(y)->value()))){
        return make_iterator(node_type::from_impl(y));
      }
      y=y->next();
    }
    return end();
  }

  template<typename CompatibleKey>
  size_type count(const CompatibleKey& k)const
  {
    return count(k,hash,eq);
  }

  template<
    typename CompatibleKey,typename CompatibleHash,typename CompatiblePred
  >
  size_type count(
    const CompatibleKey& k,
    const CompatibleHash& hash,const CompatiblePred& eq)const
  {
    size_type res=0;
    std::size_t buc=buckets.position(hash(k));
    node_impl_pointer x=buckets.at(buc);
    node_impl_pointer y=x->next();
    while(y!=x){
      if(eq(k,key(node_type::from_impl(y)->value()))){
        do{
          ++res;
          y=y->next();
        }while(y!=x&&eq(k,key(node_type::from_impl(y)->value())));
        break;
      }
      y=y->next();
    }
    return res;
  }

  template<typename CompatibleKey>
  std::pair<iterator,iterator> equal_range(const CompatibleKey& k)const
  {
    return equal_range(k,hash,eq);
  }

  template<
    typename CompatibleKey,typename CompatibleHash,typename CompatiblePred
  >
  std::pair<iterator,iterator> equal_range(
    const CompatibleKey& k,
    const CompatibleHash& hash,const CompatiblePred& eq)const
  {
    std::size_t buc=buckets.position(hash(k));
    node_impl_pointer x=buckets.at(buc);
    node_impl_pointer y=x->next();
    while(y!=x){
      if(eq(k,key(node_type::from_impl(y)->value()))){
        node_impl_pointer y0=y;
        do{
          y=y->next();
        }while(y!=x&&eq(k,key(node_type::from_impl(y)->value())));
        if(y==x){
          do{
            ++y;
          }while(y==y->next());
          y=y->next();
        }
        return std::pair<iterator,iterator>(
          make_iterator(node_type::from_impl(y0)),
          make_iterator(node_type::from_impl(y)));
      }
      y=y->next();
    }
    return std::pair<iterator,iterator>(end(),end());
  }



  size_type bucket_count()const{return buckets.size();}
  size_type max_bucket_count()const{return static_cast<size_type>(-1);}

  size_type bucket_size(size_type n)const
  {
    size_type res=0;
    node_impl_pointer x=buckets.at(n);
    node_impl_pointer y=x->next();
    while(y!=x){
      ++res;
      y=y->next();
    }
    return res;
  }

  size_type bucket(key_param_type k)const
  {
    return buckets.position(hash(k));
  }

  local_iterator begin(size_type n)
  {
    return const_cast<const hashed_index*>(this)->begin(n);
  }

  const_local_iterator begin(size_type n)const
  {
    node_impl_pointer x=buckets.at(n);
    node_impl_pointer y=x->next();
    if(y==x)return end();
    return make_iterator(node_type::from_impl(y));
  }

  local_iterator end(size_type n)
  {
    return const_cast<const hashed_index*>(this)->end(n);
  }

  const_local_iterator end(size_type n)const
  {
    node_impl_pointer x=buckets.at(n);
    if(x==x->next())return end();
    do{
      ++x;
    }while(x==x->next());
    return make_iterator(node_type::from_impl(x->next()));
  }

  const_local_iterator cbegin(size_type n)const{return begin(n);}
  const_local_iterator cend(size_type n)const{return end(n);}

  local_iterator local_iterator_to(const value_type& x)
  {
    return make_iterator(node_from_value<node_type>(&x));
  }

  const_local_iterator local_iterator_to(const value_type& x)const
  {
    return make_iterator(node_from_value<node_type>(&x));
  }



  float load_factor()const{return static_cast<float>(size())/bucket_count();}
  float max_load_factor()const{return mlf;}
  void max_load_factor(float z){mlf=z;calculate_max_load();}

  void rehash(size_type n)
  {
    ;
    if(size()<max_load&&n<=bucket_count())return;

    size_type bc =(std::numeric_limits<size_type>::max)();
    float fbc=static_cast<float>(1+size()/mlf);
    if(bc>fbc){
      bc=static_cast<size_type>(fbc);
      if(bc<n)bc=n;
    }
    unchecked_rehash(bc);
  }

protected:
  hashed_index(const ctor_args_list& args_list,const allocator_type& al):
    super(args_list.get_tail(),al),
    key(tuples::get<1>(args_list.get_head())),
    hash(tuples::get<2>(args_list.get_head())),
    eq(tuples::get<3>(args_list.get_head())),
    buckets(al,header()->impl(),tuples::get<0>(args_list.get_head())),
    mlf(1.0),
    first_bucket(buckets.size())
  {
    calculate_max_load();
  }

  hashed_index(
    const hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x):
    super(x),





    key(x.key),
    hash(x.hash),
    eq(x.eq),
    buckets(x.get_allocator(),header()->impl(),x.buckets.size()),
    mlf(x.mlf),
    max_load(x.max_load),
    first_bucket(x.first_bucket)
  {



  }

  ~hashed_index()
  {

  }
# 654 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
  iterator make_iterator(node_type* node)
  {
    return iterator(node,&buckets);
  }

  const_iterator make_iterator(node_type* node)const
  {
    return const_iterator(node,&const_cast<bucket_array_type&>(buckets));
  }


  void copy_(
    const hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x,
    const copy_map_type& map)
  {
    for(node_impl_pointer begin_org=x.buckets.begin(),
                          begin_cpy=buckets.begin(),
                          end_org=x.buckets.end();
        begin_org!=end_org;++begin_org,++begin_cpy){

      node_impl_pointer next_org=begin_org->next();
      node_impl_pointer cpy=begin_cpy;
      while(next_org!=begin_org){
        cpy->next()=
          static_cast<node_type*>(
            map.find(
              static_cast<final_node_type*>(
                node_type::from_impl(next_org))))->impl();
        next_org=next_org->next();
        cpy=cpy->next();
      }
      cpy->next()=begin_cpy;
    }

    super::copy_(x,map);
  }

  node_type* insert_(value_param_type v,node_type* x)
  {
    reserve(size()+1);

    std::size_t buc=find_bucket(v);
    node_impl_pointer pos=buckets.at(buc);
    if(!link_point(v,pos,Category()))return node_type::from_impl(pos);

    node_type* res=static_cast<node_type*>(super::insert_(v,x));
    if(res==x){
      link(x,pos);
      if(first_bucket>buc)first_bucket=buc;
    }
    return res;
  }

  node_type* insert_(value_param_type v,node_type* position,node_type* x)
  {
    reserve(size()+1);

    std::size_t buc=find_bucket(v);
    node_impl_pointer pos=buckets.at(buc);
    if(!link_point(v,pos,Category()))return node_type::from_impl(pos);

    node_type* res=static_cast<node_type*>(super::insert_(v,position,x));
    if(res==x){
      link(x,pos);
      if(first_bucket>buc)first_bucket=buc;
    }
    return res;
  }

  void erase_(node_type* x)
  {
    unlink(x);
    first_bucket=buckets.first_nonempty(first_bucket);
    super::erase_(x);




  }

  void delete_all_nodes_()
  {
    for(node_impl_pointer x=buckets.begin(),x_end=buckets.end();
        x!=x_end;++x){
      node_impl_pointer y=x->next();
      while(y!=x){
        node_impl_pointer z=y->next();
        this->final_delete_node_(
          static_cast<final_node_type*>(node_type::from_impl(y)));
        y=z;
      }
    }
  }

  void clear_()
  {
    super::clear_();
    buckets.clear();
    first_bucket=buckets.size();




  }

  void swap_(
    hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x)
  {
    std::swap(key,x.key);
    std::swap(hash,x.hash);
    std::swap(eq,x.eq);
    buckets.swap(x.buckets);
    std::swap(mlf,x.mlf);
    std::swap(max_load,x.max_load);
    std::swap(first_bucket,x.first_bucket);





    super::swap_(x);
  }

  bool replace_(value_param_type v,node_type* x)
  {
    if(eq(key(v),key(x->value()))){
      return super::replace_(v,x);
    }

    node_impl_pointer y=prev(x);
    unlink_next(y);

    { try{
      std::size_t buc=find_bucket(v);
      node_impl_pointer pos=buckets.at(buc);
      if(link_point(v,pos,Category())&&super::replace_(v,x)){
        link(x,pos);
        if(first_bucket>buc){
          first_bucket=buc;
        }
        else if(first_bucket<buc){
          first_bucket=buckets.first_nonempty(first_bucket);
        }
        return true;
      }
      link(x,y);
      return false;
    }
    catch(...){
      link(x,y);
      throw;;
    }
    }
  }

  bool modify_(node_type* x)
  {
    std::size_t buc;
    bool b;
    { try{
      buc=find_bucket(x->value());
      b=in_place(x->impl(),key(x->value()),buc,Category());
    }
    catch(...){
      erase_(x);
      throw;;
    }
    }
    if(!b){
      unlink(x);
      { try{
        node_impl_pointer pos=buckets.at(buc);
        if(!link_point(x->value(),pos,Category())){
          first_bucket=buckets.first_nonempty(first_bucket);
          super::erase_(x);




          return false;
        }
        link(x,pos);
        if(first_bucket>buc){
          first_bucket=buc;
        }
        else if(first_bucket<buc){
          first_bucket=buckets.first_nonempty(first_bucket);
        }
      }
      catch(...){
        first_bucket=buckets.first_nonempty(first_bucket);
        super::erase_(x);





        throw;;
      }
      }
    }

    { try{
      if(!super::modify_(x)){
        unlink(x);
        first_bucket=buckets.first_nonempty(first_bucket);



        return false;
      }
      else return true;
    }
    catch(...){
      unlink(x);
      first_bucket=buckets.first_nonempty(first_bucket);





      throw;;
    }
    }
  }

  bool modify_rollback_(node_type* x)
  {
    std::size_t buc=find_bucket(x->value());
    if(in_place(x->impl(),key(x->value()),buc,Category())){
      return super::modify_rollback_(x);
    }

    node_impl_pointer y=prev(x);
    unlink_next(y);

    { try{
      node_impl_pointer pos=buckets.at(buc);
      if(link_point(x->value(),pos,Category())&&super::modify_rollback_(x)){
        link(x,pos);
        if(first_bucket>buc){
          first_bucket=buc;
        }
        else if(first_bucket<buc){
          first_bucket=buckets.first_nonempty(first_bucket);
        }
        return true;
      }
      link(x,y);
      return false;
    }
    catch(...){
      link(x,y);
      throw;;
    }
    }
  }




  template<typename Archive>
  void save_(
    Archive& ar,const unsigned int version,const index_saver_type& sm)const
  {
    ar<<serialization::make_nvp("position",buckets);
    super::save_(ar,version,sm);
  }

  template<typename Archive>
  void load_(Archive& ar,const unsigned int version,const index_loader_type& lm)
  {
    ar>>serialization::make_nvp("position",buckets);
    super::load_(ar,version,lm);
  }
# 969 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
private:
  node_type* header()const{return this->final_header();}

  std::size_t find_bucket(value_param_type v)const
  {
    return bucket(key(v));
  }

  bool link_point(
    value_param_type v,node_impl_pointer& pos,hashed_unique_tag)
  {
    node_impl_pointer x=pos->next();
    while(x!=pos){
      if(eq(key(v),key(node_type::from_impl(x)->value()))){
        pos=x;
        return false;
      }
      x=x->next();
    }
    return true;
  }

  bool link_point(
    value_param_type v,node_impl_pointer& pos,hashed_non_unique_tag)
  {
    node_impl_pointer prev=pos;
    node_impl_pointer x=pos->next();
    while(x!=pos){
      if(eq(key(v),key(node_type::from_impl(x)->value()))){
        pos=prev;
        return true;
      }
      prev=x;
      x=x->next();
    }
    return true;
  }

  static void link(node_type* x,node_impl_pointer pos)
  {
    node_impl_type::link(x->impl(),pos);
  };

  static void link(node_impl_pointer x,node_impl_pointer pos)
  {
    node_impl_type::link(x,pos);
  };

  static void unlink(node_type* x)
  {
    node_impl_type::unlink(x->impl());
  };

  static node_impl_pointer prev(node_type* x)
  {
    return node_impl_type::prev(x->impl());
  }

  static node_impl_pointer prev_from(node_type* x,node_impl_pointer y)
  {
    return node_impl_type::prev_from(x->impl(),y);
  }

  static void unlink_next(node_impl_pointer x)
  {
    node_impl_type::unlink_next(x);
  }

  void calculate_max_load()
  {
    float fml=static_cast<float>(mlf*bucket_count());
    max_load=(std::numeric_limits<size_type>::max)();
    if(max_load>fml)max_load=static_cast<size_type>(fml);
  }

  void reserve(size_type n)
  {
    if(n>max_load){
      size_type bc =(std::numeric_limits<size_type>::max)();
      float fbc=static_cast<float>(1+n/mlf);
      if(bc>fbc)bc =static_cast<size_type>(fbc);
      unchecked_rehash(bc);
    }
  }

  void unchecked_rehash(size_type n)
  {
    bucket_array_type buckets1(get_allocator(),header()->impl(),n);
    auto_space<std::size_t,allocator_type> hashes(get_allocator(),size());

    std::size_t i=0;
    node_impl_pointer x=buckets.begin();
    node_impl_pointer x_end=buckets.end();
    for(;x!=x_end;++x){
      node_impl_pointer y=x->next();
      while(y!=x){
        hashes.data()[i++]=hash(key(node_type::from_impl(y)->value()));
        y=y->next();
      }
    }

    i=0;
    x=buckets.begin();
    for(;x!=x_end;++x){
      node_impl_pointer y=x->next();
      while(y!=x){
        node_impl_pointer z=y->next();
        std::size_t buc1=buckets1.position(hashes.data()[i++]);
        node_impl_pointer x1=buckets1.at(buc1);
        link(y,x1);
        y=z;
      }
    }

    buckets.swap(buckets1);
    calculate_max_load();
    first_bucket=buckets.first_nonempty(0);
  }

  bool in_place(
    node_impl_pointer x,key_param_type k,std::size_t buc,
    hashed_unique_tag)const
  {
    std::less_equal<node_impl_pointer> leq;
    node_impl_pointer bbegin=buckets.begin();
    node_impl_pointer bend=buckets.end();
    node_impl_pointer pbuc=x->next();

    while(!leq(bbegin,pbuc)||!leq(pbuc,bend))pbuc=pbuc->next();
    if(buc!=static_cast<std::size_t>(pbuc-bbegin))return false;

    node_impl_pointer y=x;
    while(y->next()!=x){
      y=y->next();
      if(y==pbuc)continue;
      if(eq(k,key(node_type::from_impl(y)->value())))return false;
    }
    return true;
  }

  bool in_place(
    node_impl_pointer x,key_param_type k,std::size_t buc,
    hashed_non_unique_tag)const
  {
    std::less_equal<node_impl_pointer> leq;
    node_impl_pointer bbegin=buckets.begin();
    node_impl_pointer bend=buckets.end();
    node_impl_pointer pbuc=x->next();

    while(!leq(bbegin,pbuc)||!leq(pbuc,bend))pbuc=pbuc->next();
    if(buc!=static_cast<std::size_t>(pbuc-bbegin))return false;

    node_impl_pointer y=x->next();
    if(y!=pbuc){
      if(eq(k,key(node_type::from_impl(y)->value()))){

        return true;
      }
      else{
        y=y->next();
        while(y!=pbuc){
          if(eq(k,key(node_type::from_impl(y)->value())))return false;
          y=y->next();
        }
      }
    }
    while(y->next()!=x){
      y=y->next();
      if(eq(k,key(node_type::from_impl(y)->value()))){
        while(y->next()!=x){
          y=y->next();
          if(!eq(k,key(node_type::from_impl(y)->value())))return false;
        }

        return true;
      }
    }
    return true;
  }
# 1158 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/hashed_index.hpp"
  key_from_value key;
  hasher hash;
  key_equal eq;
  bucket_array_type buckets;
  float mlf;
  size_type max_load;
  std::size_t first_bucket;





};



template<
  typename KeyFromValue,typename Hash,typename Pred,
  typename SuperMeta,typename TagList,typename Category
>
void swap(
  hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& x,
  hashed_index<KeyFromValue,Hash,Pred,SuperMeta,TagList,Category>& y)
{
  x.swap(y);
}

}



template<typename Arg1,typename Arg2,typename Arg3,typename Arg4>
struct hashed_unique
{
  typedef typename detail::hashed_index_args<
    Arg1,Arg2,Arg3,Arg4> index_args;
  typedef typename index_args::tag_list_type::type tag_list_type;
  typedef typename index_args::key_from_value_type key_from_value_type;
  typedef typename index_args::hash_type hash_type;
  typedef typename index_args::pred_type pred_type;

  template<typename Super>
  struct node_class
  {
    typedef detail::hashed_index_node<Super> type;
  };

  template<typename SuperMeta>
  struct index_class
  {
    typedef detail::hashed_index<
      key_from_value_type,hash_type,pred_type,
      SuperMeta,tag_list_type,detail::hashed_unique_tag> type;
  };
};

template<typename Arg1,typename Arg2,typename Arg3,typename Arg4>
struct hashed_non_unique
{
  typedef typename detail::hashed_index_args<
    Arg1,Arg2,Arg3,Arg4> index_args;
  typedef typename index_args::tag_list_type::type tag_list_type;
  typedef typename index_args::key_from_value_type key_from_value_type;
  typedef typename index_args::hash_type hash_type;
  typedef typename index_args::pred_type pred_type;

  template<typename Super>
  struct node_class
  {
    typedef detail::hashed_index_node<Super> type;
  };

  template<typename SuperMeta>
  struct index_class
  {
    typedef detail::hashed_index<
      key_from_value_type,hash_type,pred_type,
      SuperMeta,tag_list_type,detail::hashed_non_unique_tag> type;
  };
};

}

}
# 29 "../libbase/string_table.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/member.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/member.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/member.hpp" 2





namespace boost{

template<class T> class reference_wrapper;

namespace multi_index{

namespace detail{
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/member.hpp"
template<class Class,typename Type,Type Class::*PtrToMember>
struct const_member_base
{
  typedef Type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Class&>,Type&>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type& operator()(const Class& x)const
  {
    return x.*PtrToMember;
  }

  Type& operator()(const reference_wrapper<const Class>& x)const
  {
    return operator()(x.get());
  }

  Type& operator()(const reference_wrapper<Class>& x,int=0)const
  {
    return operator()(x.get());
  }
};

template<class Class,typename Type,Type Class::*PtrToMember>
struct non_const_member_base
{
  typedef Type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Class&>,Type&>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  const Type& operator()(const Class& x,int=0)const
  {
    return x.*PtrToMember;
  }

  Type& operator()(Class& x)const
  {
    return x.*PtrToMember;
  }

  const Type& operator()(const reference_wrapper<const Class>& x,int=0)const
  {
    return operator()(x.get());
  }

  Type& operator()(const reference_wrapper<Class>& x)const
  {
    return operator()(x.get());
  }
};

}

template<class Class,typename Type,Type Class::*PtrToMember>
struct member:
  mpl::if_c<
    is_const<Type>::value,
    detail::const_member_base<Class,Type,PtrToMember>,
    detail::non_const_member_base<Class,Type,PtrToMember>
  >::type
{
};

namespace detail{
# 157 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/member.hpp"
template<class Class,typename Type,std::size_t OffsetOfMember>
struct const_member_offset_base
{
  typedef Type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Class&>,Type&>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type& operator()(const Class& x)const
  {
    return *static_cast<const Type*>(
      static_cast<const void*>(
        static_cast<const char*>(
          static_cast<const void *>(&x))+OffsetOfMember));
  }

  Type& operator()(const reference_wrapper<const Class>& x)const
  {
    return operator()(x.get());
  }

  Type& operator()(const reference_wrapper<Class>& x,int=0)const
  {
    return operator()(x.get());
  }
};

template<class Class,typename Type,std::size_t OffsetOfMember>
struct non_const_member_offset_base
{
  typedef Type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Class&>,Type&>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  const Type& operator()(const Class& x,int=0)const
  {
    return *static_cast<const Type*>(
      static_cast<const void*>(
        static_cast<const char*>(
          static_cast<const void *>(&x))+OffsetOfMember));
  }

  Type& operator()(Class& x)const
  {
    return *static_cast<Type*>(
      static_cast<void*>(
        static_cast<char*>(static_cast<void *>(&x))+OffsetOfMember));
  }

  const Type& operator()(const reference_wrapper<const Class>& x,int=0)const
  {
    return operator()(x.get());
  }

  Type& operator()(const reference_wrapper<Class>& x)const
  {
    return operator()(x.get());
  }
};

}

template<class Class,typename Type,std::size_t OffsetOfMember>
struct member_offset:
  mpl::if_c<
    is_const<Type>::value,
    detail::const_member_offset_base<Class,Type,OffsetOfMember>,
    detail::non_const_member_offset_base<Class,Type,OffsetOfMember>
  >::type
{
};
# 265 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/member.hpp"
}

}
# 31 "../libbase/string_table.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/platform.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/platform.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/requires_threads.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/platform.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 1







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/config.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/platform.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/config.hpp" 2
# 91 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/auto_link.hpp" 1
# 92 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/config.hpp" 2
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/exceptions.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/exceptions.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/stdexcept" 1 3
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/stdexcept" 3
       
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 53 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/stdexcept" 3
  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual
    ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual
    ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };



}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/exceptions.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/exceptions.hpp" 2

namespace boost
{

    class thread_interrupted
    {};

    class thread_exception:
        public std::exception
    {
    protected:
        thread_exception():
            m_sys_err(0)
        {}

        thread_exception(int sys_err_code):
            m_sys_err(sys_err_code)
        {}


    public:
        ~thread_exception() throw()
        {}


        int native_error() const
        {
            return m_sys_err;
        }


    private:
        int m_sys_err;
    };

    class condition_error:
        public std::exception
    {
    public:
        const char* what() const throw()
        {
            return "Condition error";
        }
    };


    class lock_error:
        public thread_exception
    {
    public:
        lock_error()
        {}

        lock_error(int sys_err_code):
            thread_exception(sys_err_code)
        {}

        ~lock_error() throw()
        {}


        virtual const char* what() const throw()
        {
            return "boost::lock_error";
        }
    };

    class thread_resource_error:
        public thread_exception
    {
    public:
        thread_resource_error()
        {}

        thread_resource_error(int sys_err_code):
            thread_exception(sys_err_code)
        {}

        ~thread_resource_error() throw()
        {}


        virtual const char* what() const throw()
        {
            return "boost::thread_resource_error";
        }

    };

    class unsupported_thread_option:
        public thread_exception
    {
    public:
        unsupported_thread_option()
        {}

        unsupported_thread_option(int sys_err_code):
            thread_exception(sys_err_code)
        {}

        ~unsupported_thread_option() throw()
        {}


        virtual const char* what() const throw()
        {
            return "boost::unsupported_thread_option";
        }

    };

    class invalid_thread_argument:
        public thread_exception
    {
    public:
        invalid_thread_argument()
        {}

        invalid_thread_argument(int sys_err_code):
            thread_exception(sys_err_code)
        {}

        ~invalid_thread_argument() throw()
        {}


        virtual const char* what() const throw()
        {
            return "boost::invalid_thread_argument";
        }

    };

    class thread_permission_error:
        public thread_exception
    {
    public:
        thread_permission_error()
        {}

        thread_permission_error(int sys_err_code):
            thread_exception(sys_err_code)
        {}

        ~thread_permission_error() throw()
        {}


        virtual const char* what() const throw()
        {
            return "boost::thread_permission_error";
        }

    };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 181 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/exceptions.hpp" 2
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/shared_ptr.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/shared_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/memory.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/bad_weak_ptr.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/bad_weak_ptr.hpp"
namespace boost
{
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/bad_weak_ptr.hpp"
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const throw()
    {
        return "tr1::bad_weak_ptr";
    }
};





}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_base.hpp" 1
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_base.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_base_gcc_mips.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_base_gcc_mips.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/sp_typeinfo.hpp" 1
# 105 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/sp_typeinfo.hpp"
namespace boost
{

namespace detail
{







typedef std::type_info sp_typeinfo;



}

}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_base_gcc_mips.hpp" 2

namespace boost
{

namespace detail
{

inline void atomic_increment( int * pw )
{


    int tmp;

    __asm__ __volatile__
    (
        "0:\n\t"
        "ll %0, %1\n\t"
        "addiu %0, 1\n\t"
        "sc %0, %1\n\t"
        "beqz %0, 0b":
        "=&r"( tmp ), "=m"( *pw ):
        "m"( *pw )
    );
}

inline int atomic_decrement( int * pw )
{


    int rv, tmp;

    __asm__ __volatile__
    (
        "0:\n\t"
        "ll %1, %2\n\t"
        "addiu %0, %1, -1\n\t"
        "sc %0, %2\n\t"
        "beqz %0, 0b\n\t"
        "addiu %0, %1, -1":
        "=&r"( rv ), "=&r"( tmp ), "=m"( *pw ):
        "m"( *pw ):
        "memory"
    );

    return rv;
}

inline int atomic_conditional_increment( int * pw )
{



    int rv, tmp;

    __asm__ __volatile__
    (
        "0:\n\t"
        "ll %0, %2\n\t"
        "beqz %0, 1f\n\t"
        "addiu %1, %0, 1\n\t"
        "sc %1, %2\n\t"
        "beqz %1, 0b\n\t"
        "addiu %0, %0, 1\n\t"
        "1:":
        "=&r"( rv ), "=&r"( tmp ), "=m"( *pw ):
        "m"( *pw ):
        "memory"
    );

    return rv;
}

class sp_counted_base
{
private:

    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );

    int use_count_;
    int weak_count_;

public:

    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() = 0;



    virtual void destroy()
    {
        delete this;
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;

    void add_ref_copy()
    {
        atomic_increment( &use_count_ );
    }

    bool add_ref_lock()
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }

    void release()
    {
        if( atomic_decrement( &use_count_ ) == 0 )
        {
            dispose();
            weak_release();
        }
    }

    void weak_add_ref()
    {
        atomic_increment( &weak_count_ );
    }

    void weak_release()
    {
        if( atomic_decrement( &weak_count_ ) == 0 )
        {
            destroy();
        }
    }

    long use_count() const
    {
        return static_cast<int const volatile &>( use_count_ );
    }
};

}

}
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 1
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 2

namespace boost
{
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
namespace detail
{

template<class X> class sp_counted_impl_p: public sp_counted_base
{
private:

    X * px_;

    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );

    typedef sp_counted_impl_p<X> this_type;

public:

    explicit sp_counted_impl_p( X * px ): px_( px )
    {



    }

    virtual void dispose()
    {



        boost::checked_delete( px_ );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & )
    {
        return 0;
    }
# 113 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
};
# 122 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
{
private:

    P ptr;
    D del;

    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );

    typedef sp_counted_impl_pd<P, D> this_type;

public:



    sp_counted_impl_pd( P p, D d ): ptr(p), del(d)
    {
    }

    virtual void dispose()
    {
        del( ptr );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }
# 179 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
};

template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
{
private:

    P p_;
    D d_;
    A a_;

    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );

    typedef sp_counted_impl_pda<P, D, A> this_type;

public:



    sp_counted_impl_pda( P p, D d, A a ): p_( p ), d_( d ), a_( a )
    {
    }

    virtual void dispose()
    {
        d_( p_ );
    }

    virtual void destroy()
    {
        typedef typename A::template rebind< this_type >::other A2;

        A2 a2( a_ );

        this->~this_type();
        a2.deallocate( this, 1 );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }
};





}

}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp" 2
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
namespace boost
{

namespace detail
{
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
struct sp_nothrow_tag {};

class weak_count;

class shared_count
{
private:

    sp_counted_base * pi_;





    friend class weak_count;

public:

    shared_count(): pi_(0)



    {
    }

    template<class Y> explicit shared_count( Y * p ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
# 106 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
    }




    template<class P, class D> shared_count( P p, D d ): pi_(0)




    {





        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 143 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
    }

    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 189 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
    }





    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )



    {
# 210 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
        r.release();
    }



    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();



    }

    shared_count(shared_count const & r): pi_(r.pi_)



    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }
# 243 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag );

    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const
    {
        return use_count() == 1;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }

    void * get_deleter( sp_typeinfo const & ti ) const
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }
};


class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    weak_count(): pi_(0)



    {
    }

    weak_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }
# 350 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/shared_count.hpp"
    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )



{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}

inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )



{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}

}

}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_convertible.hpp" 1
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/sp_convertible.hpp"
namespace boost
{

namespace detail
{

template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];

    static yes f( T* );
    static no f( ... );

    enum _vt { value = sizeof( (f)( static_cast<Y*>(0) ) ) == sizeof(yes) };
};

struct sp_empty
{
};

template< bool > struct sp_enable_if_convertible_impl;

template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};

template<> struct sp_enable_if_convertible_impl<false>
{
};

template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};

}

}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_pool.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_pool.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock.hpp" 1
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_sync.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_sync.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/yield_k.hpp" 1
# 91 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/yield_k.hpp"
namespace boost
{

namespace detail
{

inline void yield( unsigned k )
{
    if( k < 4 )
    {
    }






    else if( k < 32 || k & 1 )
    {
        sched_yield();
    }
    else
    {

        struct timespec rqtp = { 0, 0 };




        rqtp.tv_sec = 0;
        rqtp.tv_nsec = 1000;

        nanosleep( &rqtp, 0 );
    }
}

}

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_sync.hpp" 2





namespace boost
{

namespace detail
{

class spinlock
{
public:

    int v_;

public:

    bool try_lock()
    {
        int r = __sync_lock_test_and_set( &v_, 1 );
        return r == 0;
    }

    void lock()
    {
        for( unsigned k = 0; !try_lock(); ++k )
        {
            boost::detail::yield( k );
        }
    }

    void unlock()
    {
        __sync_lock_release( &v_ );
    }

public:

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( spinlock & sp ): sp_( sp )
        {
            sp.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

}
}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock.hpp" 2
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2

namespace boost
{

namespace detail
{

template< int I > class spinlock_pool
{
private:

    static spinlock pool_[ 41 ];

public:

    static spinlock & spinlock_for( void const * pv )
    {
        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;
        return pool_[ i ];
    }

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
{
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}
};

}
}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/memory_order.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/memory_order.hpp"
namespace boost
{
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/memory_order.hpp"
enum memory_order
{
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7,
    memory_order_consume = 8
};

}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
namespace boost
{

template<class T> class shared_ptr;
template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;
template<class T> class enable_shared_from_this2;

namespace detail
{

struct static_cast_tag {};
struct const_cast_tag {};
struct dynamic_cast_tag {};
struct polymorphic_cast_tag {};

template<class T> struct shared_ptr_traits
{
    typedef T & reference;
};

template<> struct shared_ptr_traits<void>
{
    typedef void reference;
};



template<> struct shared_ptr_traits<void const>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void volatile>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void const volatile>
{
    typedef void reference;
};





template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}

template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_this2< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}
# 136 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
inline void sp_enable_shared_from_this( ... )
{
}







template< class T, class R > struct sp_enable_if_auto_ptr
{
};

template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};



}
# 168 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
template<class T> class shared_ptr
{
private:


    typedef shared_ptr<T> this_type;

public:

    typedef T element_type;
    typedef T value_type;
    typedef T * pointer;
    typedef typename boost::detail::shared_ptr_traits<T>::reference reference;

    shared_ptr(): px(0), pn()
    {
    }

    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn( p )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }







    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }



    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }



    template<class Y>
    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn)
    {

        px = r.px;
    }

    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }


    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn )
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            pn = boost::detail::shared_count();
        }
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            boost::throw_exception(std::bad_cast());
        }
    }



    template<class Y>
    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
    {
        Y * tmp = r.get();
        pn = boost::detail::shared_count(r);
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }



    template<class Ap>
    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
    {
        typename Ap::element_type * tmp = r.get();
        pn = boost::detail::shared_count( r );
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }
# 303 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
    shared_ptr & operator=( shared_ptr const & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r)
    {
        this_type(r).swap(*this);
        return *this;
    }





    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Ap>
    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
    {
        this_type( r ).swap( *this );
        return *this;
    }
# 384 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
    void reset()
    {
        this_type().swap(*this);
    }

    template<class Y> void reset(Y * p)
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp", 391, __PRETTY_FUNCTION__));
        this_type(p).swap(*this);
    }

    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }

    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }

    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
    {
        this_type( r, p ).swap( *this );
    }

    reference operator* () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp", 412, __PRETTY_FUNCTION__));
        return *px;
    }

    T * operator-> () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp", 418, __PRETTY_FUNCTION__));
        return px;
    }

    T * get() const
    {
        return px;
    }


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp"
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 429 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp" 2

    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_ptr<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const
    {
        return pn.get_deleter( ti );
    }

    bool _internal_equiv( shared_ptr const & r ) const
    {
        return px == r.px && pn == r.pn;
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;




    T * px;
    boost::detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() != b.get();
}
# 500 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::const_cast_tag());
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}



template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
{
    ((dynamic_cast<T *>(r.get()) == r.get()) ? static_cast<void> (0) : __assert_fail ("dynamic_cast<T *>(r.get()) == r.get()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp", 544, __PRETTY_FUNCTION__));
    return shared_static_cast<T>(r);
}



template<class T> inline T * get_pointer(shared_ptr<T> const & p)
{
    return p.get();
}
# 577 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 607 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/shared_ptr.hpp"
template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
{
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
}







template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * )
{
    return false;
}

template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}

template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order )
{
    return atomic_load( p );
}

template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}

template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    atomic_store( p, r );
}

template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();
    p->swap( r );
    sp.unlock();

    return r;
}

template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    return atomic_exchange( p, r );
}

template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();

    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );

        sp.unlock();

        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );

        sp.unlock();

        tmp.swap( *v );
        return false;
    }
}

template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order , memory_order )
{
    return atomic_compare_exchange( p, v, w );
}



}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/shared_ptr.hpp" 2
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/enable_shared_from_this.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/enable_shared_from_this.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/enable_shared_from_this.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/enable_shared_from_this.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/weak_ptr.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/weak_ptr.hpp"
namespace boost
{

template<class T> class weak_ptr
{
private:


    typedef weak_ptr<T> this_type;

public:

    typedef T element_type;

    weak_ptr(): px(0), pn()
    {
    }
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/weak_ptr.hpp"
    template<class Y>


    weak_ptr( weak_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    : px(r.lock().get()), pn(r.pn)
    {
    }
# 110 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/weak_ptr.hpp"
    template<class Y>


    weak_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }



    template<class Y>
    weak_ptr & operator=(weak_ptr<Y> const & r)
    {
        px = r.lock().get();
        pn = r.pn;
        return *this;
    }
# 145 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/weak_ptr.hpp"
    template<class Y>
    weak_ptr & operator=(shared_ptr<Y> const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }



    shared_ptr<T> lock() const
    {
        return shared_ptr<element_type>( *this, boost::detail::sp_nothrow_tag() );
    }

    long use_count() const
    {
        return pn.use_count();
    }

    bool expired() const
    {
        return pn.use_count() == 0;
    }

    bool _empty() const
    {
        return pn.empty();
    }

    void reset()
    {
        this_type().swap(*this);
    }

    void swap(this_type & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    void _internal_assign(T * px2, boost::detail::shared_count const & pn2)
    {
        px = px2;
        pn = pn2;
    }

    template<class Y> bool _internal_less(weak_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }






private:

    template<class Y> friend class weak_ptr;
    template<class Y> friend class shared_ptr;



    T * px;
    boost::detail::weak_count pn;

};

template<class T, class U> inline bool operator<(weak_ptr<T> const & a, weak_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b)
{
    a.swap(b);
}

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/enable_shared_from_this.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/enable_shared_from_this.hpp" 2


namespace boost
{

template<class T> class enable_shared_from_this
{
protected:

    enable_shared_from_this()
    {
    }

    enable_shared_from_this(enable_shared_from_this const &)
    {
    }

    enable_shared_from_this & operator=(enable_shared_from_this const &)
    {
        return *this;
    }

    ~enable_shared_from_this()
    {
    }

public:

    shared_ptr<T> shared_from_this()
    {
        shared_ptr<T> p( weak_this_ );
        ((p.get() == this) ? static_cast<void> (0) : __assert_fail ("p.get() == this", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/enable_shared_from_this.hpp", 50, __PRETTY_FUNCTION__));
        return p;
    }

    shared_ptr<T const> shared_from_this() const
    {
        shared_ptr<T const> p( weak_this_ );
        ((p.get() == this) ? static_cast<void> (0) : __assert_fail ("p.get() == this", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/enable_shared_from_this.hpp", 57, __PRETTY_FUNCTION__));
        return p;
    }

public:


    template<class X, class Y> void _internal_accept_owner( shared_ptr<X> const * ppx, Y * py ) const
    {
        if( weak_this_.expired() )
        {
            weak_this_ = shared_ptr<T>( *ppx, py );
        }
    }

private:

    mutable weak_ptr<T> weak_this_;
};

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/enable_shared_from_this.hpp" 2
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/mutex.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/binary.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/binary.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/deduce_d.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/deduce_d.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/control/deduce_d.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/binary.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/cat.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/cat.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/fold_left.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/fold_left.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/fold_left.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/seq.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/seq.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/elem.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/seq.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/fold_left.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/size.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/fold_left.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/cat.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/binary.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/transform.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/binary.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/mod.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/mod.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/detail/div_base.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/comparison/less_equal.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/comparison/less_equal.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/logical/not.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/comparison/less_equal.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/arithmetic/mod.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/binary.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/next_prior.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/next_prior.hpp"
namespace boost {
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/next_prior.hpp"
template <class T>
inline T next(T x) { return ++x; }

template <class T, class Distance>
inline T next(T x, Distance n)
{
    std::advance(x, n);
    return x;
}

template <class T>
inline T prior(T x) { return --x; }

template <class T, class Distance>
inline T prior(T x, Distance n)
{
    std::advance(x, -n);
    return x;
}

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility.hpp" 2
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/move.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/move.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/move.hpp" 2

namespace boost
{
    namespace detail
    {
        template<typename T>
        struct thread_move_t
        {
            T& t;
            explicit thread_move_t(T& t_):
                t(t_)
            {}

            T& operator*() const
            {
                return t;
            }

            T* operator->() const
            {
                return &t;
            }
        private:
            void operator=(thread_move_t&);
        };
    }


    template<typename T>
    typename enable_if<boost::is_convertible<T&,detail::thread_move_t<T> >, detail::thread_move_t<T> >::type move(T& t)
    {
        return detail::thread_move_t<T>(t);
    }


    template<typename T>
    detail::thread_move_t<T> move(detail::thread_move_t<T> t)
    {
        return t;
    }

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/move.hpp" 2
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread_time.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread_time.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp" 1
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp" 2
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/locale_config.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp" 2
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp" 2
# 159 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/auto_link.hpp" 1
# 160 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/compiler_config.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 2 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp" 2
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/time.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 2 3 4
# 39 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 3 4
extern "C" {
# 57 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     throw () __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) throw ();
# 191 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/time.h" 3 4
}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp" 2






namespace boost {
namespace date_time {
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp"
  struct c_time {
    public:


      inline
      static std::tm* localtime(const std::time_t* t, std::tm* result)
      {

        result = localtime_r(t, result);
        if (!result)
          boost::throw_exception(std::runtime_error("could not convert calendar time to local time"));
        return result;
      }

      inline
      static std::tm* gmtime(const std::time_t* t, std::tm* result)
      {

        result = gmtime_r(t, result);
        if (!result)
          boost::throw_exception(std::runtime_error("could not convert calendar time to UTC time"));
        return result;
      }
# 104 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/c_time.hpp"
  };
}}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_clock.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_clock.hpp"
namespace boost {
namespace date_time {





  template<class time_type>
  class second_clock
  {
  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;

    static time_type local_time()
    {
      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;

      curr_ptr = c_time::localtime(&t, &curr);
      return create_time(curr_ptr);
    }



    static time_type universal_time()
    {

      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;

      curr_ptr = c_time::gmtime(&t, &curr);
      return create_time(curr_ptr);
    }

    template<class time_zone_type>
    static time_type local_time(boost::shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      utc_time_type utc_time = second_clock<utc_time_type>::universal_time();
      return time_type(utc_time, tz_ptr);
    }


  private:
    static time_type create_time(::std::tm* current)
    {
      date_type d(static_cast<unsigned short>(current->tm_year + 1900),
                  static_cast<unsigned short>(current->tm_mon + 1),
                  static_cast<unsigned short>(current->tm_mday));
      time_duration_type td(current->tm_hour,
                            current->tm_min,
                            current->tm_sec);
      return time_type(d,td);
    }

  };


} }
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/filetime_functions.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp" 2



namespace boost {
namespace date_time {
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp"
  template<class time_type>
  class microsec_clock
  {
  private:

    typedef std::tm* (*time_converter)(const std::time_t*, std::tm*);

  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::rep_type resolution_traits_type;



    template<class time_zone_type>
    static time_type local_time(shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      typedef second_clock<utc_time_type> second_clock;


      utc_time_type utc_time = second_clock::universal_time();
      time_duration_type utc_offset = second_clock::local_time() - utc_time;


      utc_time = microsec_clock<utc_time_type>::local_time() - utc_offset;
      return time_type(utc_time, tz_ptr);
    }


    static time_type local_time()
    {
      return create_time(&c_time::localtime);
    }


    static time_type universal_time()
    {
      return create_time(&c_time::gmtime);
    }

  private:
    static time_type create_time(time_converter converter)
    {

      timeval tv;
      gettimeofday(&tv, 0);
      std::time_t t = tv.tv_sec;
      boost::uint32_t sub_sec = tv.tv_usec;
# 99 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/microsec_time_clock.hpp"
      std::tm curr;
      std::tm* curr_ptr = converter(&t, &curr);
      date_type d(static_cast< typename date_type::year_type::value_type >(curr_ptr->tm_year + 1900),
                  static_cast< typename date_type::month_type::value_type >(curr_ptr->tm_mon + 1),
                  static_cast< typename date_type::day_type::value_type >(curr_ptr->tm_mday));





      int adjust = static_cast< int >(resolution_traits_type::res_adjust() / 1000000);

      time_duration_type td(static_cast< typename time_duration_type::hour_type >(curr_ptr->tm_hour),
                            static_cast< typename time_duration_type::min_type >(curr_ptr->tm_min),
                            static_cast< typename time_duration_type::sec_type >(curr_ptr->tm_sec),
                            sub_sec * adjust);

      return time_type(d,td);
    }
  };


} }
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread_time.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/ptime.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/ptime.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_system.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_system.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_duration.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_duration.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_duration.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_defs.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_defs.hpp"
namespace boost {
namespace date_time {


  enum time_resolutions {
    sec,
    tenth,
    hundreth,
    hundredth = hundreth,
    milli,
    ten_thousandth,
    micro,
    nano,
    NumResolutions
  };


  enum dst_flags {not_dst, is_dst, calculate};


} }
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_duration.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/special_defs.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/special_defs.hpp"
namespace boost {
namespace date_time {

    enum special_values {not_a_date_time,
                         neg_infin, pos_infin,
                         min_date_time, max_date_time,
                         not_special, NumSpecialValues};


} }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_duration.hpp" 2


namespace boost {
namespace date_time {
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_duration.hpp"
  template<class T, typename rep_type>
  class time_duration : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
    > >





  {
  public:
    typedef T duration_type;
    typedef rep_type traits_type;
    typedef typename rep_type::day_type day_type;
    typedef typename rep_type::hour_type hour_type;
    typedef typename rep_type::min_type min_type;
    typedef typename rep_type::sec_type sec_type;
    typedef typename rep_type::fractional_seconds_type fractional_seconds_type;
    typedef typename rep_type::tick_type tick_type;
    typedef typename rep_type::impl_type impl_type;

    time_duration() : ticks_(0) {}
    time_duration(hour_type hours_in,
                  min_type minutes_in,
                  sec_type seconds_in=0,
                  fractional_seconds_type frac_sec_in = 0) :
      ticks_(rep_type::to_tick_count(hours_in,minutes_in,seconds_in,frac_sec_in))
    {}


    time_duration(const time_duration<T, rep_type>& other)
      : ticks_(other.ticks_)
    {}

    time_duration(special_values sv) : ticks_(impl_type::from_special(sv))
    {}

    static duration_type unit()
    {
      return duration_type(0,0,0,1);
    }

    static tick_type ticks_per_second()
    {
      return rep_type::res_adjust();
    }

    static time_resolutions resolution()
    {
      return rep_type::resolution();
    }

    hour_type hours() const
    {
      return static_cast<hour_type>(ticks() / (3600*ticks_per_second()));
    }

    min_type minutes() const
    {
      return static_cast<min_type>((ticks() / (60*ticks_per_second())) % 60);
    }

    sec_type seconds() const
    {
      return static_cast<sec_type>((ticks()/ticks_per_second()) % 60);
    }

    sec_type total_seconds() const
    {
      return static_cast<sec_type>(ticks() / ticks_per_second());
    }

    tick_type total_milliseconds() const
    {
      if (ticks_per_second() < 1000) {
        return ticks() * (static_cast<tick_type>(1000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000)) ;
    }

    tick_type total_nanoseconds() const
    {
      if (ticks_per_second() < 1000000000) {
        return ticks() * (static_cast<tick_type>(1000000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000000)) ;
    }

    tick_type total_microseconds() const
    {
      if (ticks_per_second() < 1000000) {
        return ticks() * (static_cast<tick_type>(1000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000)) ;
    }

    fractional_seconds_type fractional_seconds() const
    {
      return (ticks() % ticks_per_second());
    }

    static unsigned short num_fractional_digits()
    {
      return rep_type::num_fractional_digits();
    }
    duration_type invert_sign() const
    {
      return duration_type(ticks_ * (-1));
    }
    bool is_negative() const
    {
      return ticks_ < 0;
    }
    bool operator<(const time_duration& rhs) const
    {
      return ticks_ < rhs.ticks_;
    }
    bool operator==(const time_duration& rhs) const
    {
      return ticks_ == rhs.ticks_;
    }

    duration_type operator-()const
    {
      return duration_type(ticks_ * (-1));
    }
    duration_type operator-(const duration_type& d) const
    {
      return duration_type(ticks_ - d.ticks_);
    }
    duration_type operator+(const duration_type& d) const
    {
      return duration_type(ticks_ + d.ticks_);
    }
    duration_type operator/(int divisor) const
    {
      return duration_type(ticks_ / divisor);
    }
    duration_type operator-=(const duration_type& d)
    {
      ticks_ = ticks_ - d.ticks_;
      return duration_type(ticks_);
    }
    duration_type operator+=(const duration_type& d)
    {
      ticks_ = ticks_ + d.ticks_;
      return duration_type(ticks_);
    }

    duration_type operator/=(int divisor)
    {
      ticks_ = ticks_ / divisor;
      return duration_type(ticks_);
    }

    duration_type operator*(int rhs) const
    {
      return duration_type(ticks_ * rhs);
    }
    duration_type operator*=(int divisor)
    {
      ticks_ = ticks_ * divisor;
      return duration_type(ticks_);
    }
    tick_type ticks() const
    {
      return traits_type::as_number(ticks_);
    }


    bool is_special()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_special();
      }
      else{
        return false;
      }
    }

    bool is_pos_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_pos_infinity();
      }
      else{
        return false;
      }
    }

    bool is_neg_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_neg_infinity();
      }
      else{
        return false;
      }
    }

    bool is_not_a_date_time()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_nan();
      }
      else{
        return false;
      }
    }


    impl_type get_rep()const
    {
      return ticks_;
    }

  protected:
    explicit time_duration(impl_type in) : ticks_(in) {};
    impl_type ticks_;
  };







  template<class base_duration, boost::int64_t frac_of_second>
  class subsecond_duration : public base_duration
  {
  public:
    typedef typename base_duration::traits_type traits_type;
    explicit subsecond_duration(boost::int64_t ss) :
      base_duration(0,0,0,ss*traits_type::res_adjust()/frac_of_second)
    {}
  };



} }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_resolution_traits.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_resolution_traits.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_resolution_traits.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/int_adapter.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/int_adapter.hpp"
namespace boost {
namespace date_time {
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/int_adapter.hpp"
template<typename int_type_>
class int_adapter {
public:
  typedef int_type_ int_type;
  int_adapter(int_type v) :
    value_(v)
  {}
  static bool has_infinity()
  {
    return true;
  }
  static const int_adapter pos_infinity()
  {
    return (::std::numeric_limits<int_type>::max)();
  }
  static const int_adapter neg_infinity()
  {
    return (::std::numeric_limits<int_type>::min)();
  }
  static const int_adapter not_a_number()
  {
    return (::std::numeric_limits<int_type>::max)()-1;
  }
  static int_adapter max ()
  {
    return (::std::numeric_limits<int_type>::max)()-2;
  }
  static int_adapter min ()
  {
    return (::std::numeric_limits<int_type>::min)()+1;
  }
  static int_adapter from_special(special_values sv)
  {
    switch (sv) {
    case not_a_date_time: return not_a_number();
    case neg_infin: return neg_infinity();
    case pos_infin: return pos_infinity();
    case max_date_time: return (max)();
    case min_date_time: return (min)();
    default: return not_a_number();
    }
  }
  static bool is_inf(int_type v)
  {
    return (v == neg_infinity().as_number() ||
            v == pos_infinity().as_number());
  }
  static bool is_neg_inf(int_type v)
  {
    return (v == neg_infinity().as_number());
  }
  static bool is_pos_inf(int_type v)
  {
    return (v == pos_infinity().as_number());
  }
  static bool is_not_a_number(int_type v)
  {
    return (v == not_a_number().as_number());
  }

  static special_values to_special(int_type v)
  {
    if (is_not_a_number(v)) return not_a_date_time;
    if (is_neg_inf(v)) return neg_infin;
    if (is_pos_inf(v)) return pos_infin;
    return not_special;
  }


  static int_type maxcount()
  {
    return (::std::numeric_limits<int_type>::max)()-3;
  }
  bool is_infinity() const
  {
    return (value_ == neg_infinity().as_number() ||
            value_ == pos_infinity().as_number());
  }
  bool is_pos_infinity()const
  {
    return(value_ == pos_infinity().as_number());
  }
  bool is_neg_infinity()const
  {
    return(value_ == neg_infinity().as_number());
  }
  bool is_nan() const
  {
    return (value_ == not_a_number().as_number());
  }
  bool is_special() const
  {
    return(is_infinity() || is_nan());
  }
  bool operator==(const int_adapter& rhs) const
  {
    return (compare(rhs) == 0);
  }
  bool operator==(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return false;
      }
    }
    return (compare(rhs) == 0);
  }
  bool operator!=(const int_adapter& rhs) const
  {
    return (compare(rhs) != 0);
  }
  bool operator!=(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) != 0);
  }
  bool operator<(const int_adapter& rhs) const
  {
    return (compare(rhs) == -1);
  }
  bool operator<(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) == -1);
  }
  bool operator>(const int_adapter& rhs) const
  {
    return (compare(rhs) == 1);
  }
  int_type as_number() const
  {
    return value_;
  }

  special_values as_special() const
  {
    return int_adapter::to_special(value_);
  }
# 205 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/int_adapter.hpp"
  template<class rhs_type>
  inline
  int_adapter operator+(const int_adapter<rhs_type>& rhs) const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_neg_inf(rhs.as_number())) ||
      (is_neg_inf(value_) && rhs.is_pos_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
    }
    return int_adapter<int_type>(value_ + rhs.as_number());
  }

  int_adapter operator+(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ + rhs);
  }



  template<class rhs_type>
  inline
  int_adapter operator-(const int_adapter<rhs_type>& rhs)const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_pos_inf(rhs.as_number())) ||
         (is_neg_inf(value_) && rhs.is_neg_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
    }
    return int_adapter<int_type>(value_ - rhs.as_number());
  }
  int_adapter operator-(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ - rhs);
  }


  int_adapter operator*(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs.value_);
  }


  int_adapter operator*(const int rhs) const
  {
    if(is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs);
  }


  int_adapter operator/(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ / rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ / rhs.value_);
  }


  int_adapter operator/(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ / rhs);
  }


  int_adapter operator%(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ % rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ % rhs.value_);
  }


  int_adapter operator%(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ % rhs);
  }
private:
  int_type value_;


  int compare(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(this->is_nan() || rhs.is_nan()) {
        if(this->is_nan() && rhs.is_nan()) {
          return 0;
        }
        else {
          return 2;
        }
      }
      if((is_neg_inf(value_) && !is_neg_inf(rhs.value_)) ||
         (is_pos_inf(rhs.value_) && !is_pos_inf(value_)) )
        {
          return -1;
        }
      if((is_pos_inf(value_) && !is_pos_inf(rhs.value_)) ||
         (is_neg_inf(rhs.value_) && !is_neg_inf(value_)) ) {
        return 1;
      }
    }
    if(value_ < rhs.value_) return -1;
    if(value_ > rhs.value_) return 1;

    return 0;
  }





  int_adapter mult_div_specials(const int_adapter& rhs)const
  {
    int min_value;

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan() || rhs.is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < min_value)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < min_value) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }

    return int_adapter<int_type>(not_a_number());
  }






  int_adapter mult_div_specials(const int& rhs) const
  {
    int min_value;

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < 0)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < 0) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }

    return int_adapter<int_type>(not_a_number());
  }

};






  template<class charT, class traits, typename int_type>
  inline
  std::basic_ostream<charT, traits>&
  operator<<(std::basic_ostream<charT, traits>& os, const int_adapter<int_type>& ia)
  {
    if(ia.is_special()) {

      switch(ia.as_special())
        {
      case not_a_date_time:
        os << "not-a-number";
        break;
      case pos_infin:
        os << "+infinity";
        break;
      case neg_infin:
        os << "-infinity";
        break;
      default:
        os << "";
      }
    }
    else {
      os << ia.as_number();
    }
    return os;
  }



} }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_resolution_traits.hpp" 2


namespace boost {
namespace date_time {


  template <typename T>


  inline T absolute_value(T x)
  {
    return x < 0 ? -x : x;
  }


  struct time_resolution_traits_bi32_impl {
    typedef boost::int32_t int_type;
    typedef boost::int32_t impl_type;
    static int_type as_number(impl_type i){ return i;}

    static bool is_adapted() { return false;}
  };

  struct time_resolution_traits_adapted32_impl {
    typedef boost::int32_t int_type;
    typedef boost::date_time::int_adapter<boost::int32_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}

    static bool is_adapted() { return true;}
  };

  struct time_resolution_traits_bi64_impl {
    typedef boost::int64_t int_type;
    typedef boost::int64_t impl_type;
    static int_type as_number(impl_type i){ return i;}

    static bool is_adapted() { return false;}
  };

  struct time_resolution_traits_adapted64_impl {
    typedef boost::int64_t int_type;
    typedef boost::date_time::int_adapter<boost::int64_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}

    static bool is_adapted() { return true;}
  };

  template<typename frac_sec_type,
           time_resolutions res,



           typename frac_sec_type::int_type resolution_adjust,

           unsigned short frac_digits,
           typename v_type = boost::int32_t >
  class time_resolution_traits {
  public:
    typedef typename frac_sec_type::int_type fractional_seconds_type;
    typedef typename frac_sec_type::int_type tick_type;
    typedef typename frac_sec_type::impl_type impl_type;
    typedef v_type day_type;
    typedef v_type hour_type;
    typedef v_type min_type;
    typedef v_type sec_type;


    static fractional_seconds_type as_number(impl_type i)
    {
      return frac_sec_type::as_number(i);
    }
    static bool is_adapted()
    {
      return frac_sec_type::is_adapted();
    }





    static const fractional_seconds_type ticks_per_second = resolution_adjust;


    static time_resolutions resolution()
    {
      return res;
    }
    static unsigned short num_fractional_digits()
    {
      return frac_digits;
    }
    static fractional_seconds_type res_adjust()
    {
      return resolution_adjust;
    }

    static tick_type to_tick_count(hour_type hours,
                                   min_type minutes,
                                   sec_type seconds,
                                   fractional_seconds_type fs)
    {
      if(hours < 0 || minutes < 0 || seconds < 0 || fs < 0)
      {
        hours = absolute_value(hours);
        minutes = absolute_value(minutes);
        seconds = absolute_value(seconds);
        fs = absolute_value(fs);
        return (((((fractional_seconds_type(hours)*3600)
                   + (fractional_seconds_type(minutes)*60)
                   + seconds)*res_adjust()) + fs) * -1);
      }

      return (((fractional_seconds_type(hours)*3600)
               + (fractional_seconds_type(minutes)*60)
               + seconds)*res_adjust()) + fs;
    }

  };

  typedef time_resolution_traits<time_resolution_traits_adapted32_impl, milli, 1000, 3 > milli_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, micro, 1000000, 6 > micro_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, nano, 1000000000, 9 > nano_res;


} }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/year_month_day.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/year_month_day.hpp"
namespace boost {
namespace date_time {


  template<typename YearType, typename MonthType, typename DayType>
  struct year_month_day_base {
    year_month_day_base(YearType year,
                        MonthType month,
                        DayType day);
    YearType year;
    MonthType month;
    DayType day;
    typedef YearType year_type;
    typedef MonthType month_type;
    typedef DayType day_type;
  };



  template<typename YearType, typename MonthType, typename DayType>
  inline
  year_month_day_base<YearType,MonthType,DayType>::year_month_day_base(YearType y,
                                                                       MonthType m,
                                                                       DayType d) :
    year(y),
    month(m),
    day(d)
  {}

} }
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date.hpp" 2


namespace boost {
namespace date_time {
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date.hpp"
  template<class T, class calendar, class duration_type_>
  class date : private
       boost::less_than_comparable<T
     , boost::equality_comparable<T
    > >
  {
  public:
    typedef T date_type;
    typedef calendar calendar_type;
    typedef typename calendar::date_traits_type traits_type;
    typedef duration_type_ duration_type;
    typedef typename calendar::year_type year_type;
    typedef typename calendar::month_type month_type;
    typedef typename calendar::day_type day_type;
    typedef typename calendar::ymd_type ymd_type;
    typedef typename calendar::date_rep_type date_rep_type;
    typedef typename calendar::date_int_type date_int_type;
    typedef typename calendar::day_of_week_type day_of_week_type;
    date(year_type y, month_type m, day_type d)
      : days_(calendar::day_number(ymd_type(y, m, d)))
    {}
    date(const ymd_type& ymd)
      : days_(calendar::day_number(ymd))
    {}

    year_type year() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.year;
    }
    month_type month() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.month;
    }
    day_type day() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.day;
    }
    day_of_week_type day_of_week() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return calendar::day_of_week(ymd);
    }
    ymd_type year_month_day() const
    {
      return calendar::from_day_number(days_);
    }
    bool operator<(const date_type& rhs) const
    {
      return days_ < rhs.days_;
    }
    bool operator==(const date_type& rhs) const
    {
      return days_ == rhs.days_;
    }

    bool is_special()const
    {
      return(is_not_a_date() || is_infinity());
    }

    bool is_not_a_date() const
    {
      return traits_type::is_not_a_number(days_);
    }

    bool is_infinity() const
    {
      return traits_type::is_inf(days_);
    }

    bool is_pos_infinity() const
    {
      return traits_type::is_pos_inf(days_);
    }

    bool is_neg_infinity() const
    {
      return traits_type::is_neg_inf(days_);
    }

    special_values as_special() const
    {
      return traits_type::to_special(days_);
    }
    duration_type operator-(const date_type& d) const
    {
      if (!this->is_special() && !d.is_special())
      {


        typedef typename duration_type::duration_rep_type duration_rep_type;
        return duration_type(static_cast< duration_rep_type >(days_) - static_cast< duration_rep_type >(d.days_));
      }
      else
      {

        date_rep_type val = date_rep_type(days_) - date_rep_type(d.days_);
        return duration_type(val.as_special());
      }
    }

    date_type operator-(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) - dd.get_rep());
      }
      return date_type(date_rep_type(days_) - dd.days());
    }
    date_type operator-=(const duration_type& dd)
    {
      *this = *this - dd;
      return date_type(days_);
    }
    date_rep_type day_count() const
    {
      return days_;
    }

    date_type operator+(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) + dd.get_rep());
      }
      return date_type(date_rep_type(days_) + dd.days());
    }
    date_type operator+=(const duration_type& dd)
    {
      *this = *this + dd;
      return date_type(days_);
    }


  protected:




    explicit date(date_int_type days) : days_(days) {};
    explicit date(date_rep_type days) : days_(days.as_number()) {};
    date_int_type days_;

  };




} }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
namespace boost {
namespace date_time {
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  class period : private
      boost::less_than_comparable<period<point_rep, duration_rep>
    , boost::equality_comparable< period<point_rep, duration_rep>
    > >
  {
  public:
    typedef point_rep point_type;
    typedef duration_rep duration_type;

    period(point_rep first_point, point_rep end_point);
    period(point_rep first_point, duration_rep len);
    point_rep begin() const;
    point_rep end() const;
    point_rep last() const;
    duration_rep length() const;
    bool is_null() const;
    bool operator==(const period& rhs) const;
    bool operator<(const period& rhs) const;
    void shift(const duration_rep& d);
    void expand(const duration_rep& d);
    bool contains(const point_rep& point) const;
    bool contains(const period& other) const;
    bool intersects(const period& other) const;
    bool is_adjacent(const period& other) const;
    bool is_before(const point_rep& point) const;
    bool is_after(const point_rep& point) const;
    period intersection(const period& other) const;
    period merge(const period& other) const;
    period span(const period& other) const;
  private:
    point_rep begin_;
    point_rep last_;
  };




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point,
                                         point_rep end_point) :
    begin_(first_point),
    last_(end_point - duration_rep::unit())
  {}




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point, duration_rep len) :
    begin_(first_point),
    last_(first_point + len-duration_rep::unit())
  { }



  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::begin() const
  {
    return begin_;
  }


  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::end() const
  {
    return last_ + duration_rep::unit();
  }


  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::last() const
  {
    return last_;
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::is_null() const
  {
    return end() <= begin_;
  }


  template<class point_rep, class duration_rep>
  inline
  duration_rep period<point_rep,duration_rep>::length() const
  {
    if(last_ < begin_){
      return last_+duration_rep::unit() - begin_;
    }
    else{
      return end() - begin_;
    }
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator==(const period& rhs) const
  {
    return ((begin_ == rhs.begin_) &&
             (last_ == rhs.last_));
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator<(const period& rhs) const
  {
    return (last_ < rhs.begin_);
  }



  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::shift(const duration_rep& d)
  {
    begin_ = begin_ + d;
    last_ = last_ + d;
  }
# 198 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::expand(const duration_rep& d)
  {
    begin_ = begin_ - d;
    last_ = last_ + d;
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const point_rep& point) const
  {
    return ((point >= begin_) &&
            (point <= last_));
  }



  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const period<point_rep,duration_rep>& other) const
  {
    return ((begin_ <= other.begin_) && (last_ >= other.last_));
  }
# 234 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_adjacent(const period<point_rep,duration_rep>& other) const
  {
    return (other.begin() == end() ||
            begin_ == other.end());
  }
# 253 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_after(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }

    return t < begin_;
  }
# 275 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_before(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }

    return last_ < t;
  }
# 300 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::intersects(const period<point_rep,duration_rep>& other) const
  {
    return ( contains(other.begin_) ||
             other.contains(begin_) ||
             ((other.begin_ < begin_) && (other.last_ >= begin_)));
  }


  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::intersection(const period<point_rep,duration_rep>& other) const
  {
    if (begin_ > other.begin_) {
      if (last_ <= other.last_) {
        return *this;
      }

      return period<point_rep,duration_rep>(begin_, other.end());
    }
    else {
      if (last_ <= other.last_) {
        return period<point_rep,duration_rep>(other.begin_, this->end());
      }

      return other;
    }

  }




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::merge(const period<point_rep,duration_rep>& other) const
  {
    if (this->intersects(other)) {
      if (begin_ < other.begin_) {
        return period<point_rep,duration_rep>(begin_, last_ > other.last_ ? this->end() : other.end());
      }

      return period<point_rep,duration_rep>(other.begin_, last_ > other.last_ ? this->end() : other.end());

    }
    return period<point_rep,duration_rep>(begin_,begin_);
  }
# 362 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/period.hpp"
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::span(const period<point_rep,duration_rep>& other) const
  {
    point_rep start((begin_ < other.begin_) ? begin() : other.begin());
    point_rep newend((last_ < other.last_) ? other.end() : this->end());
    return period<point_rep,duration_rep>(start, newend);
  }


} }
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_weekday.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_weekday.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/constrained_value.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/constrained_value.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_of.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_of.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_of.hpp" 2

namespace boost {

   namespace detail{
      template <class B, class D>
      struct is_base_of_imp
      {
          typedef typename remove_cv<B>::type ncvB;
          typedef typename remove_cv<D>::type ncvD;
          static const bool value = (::boost::type_traits::ice_or< (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value), (::boost::type_traits::ice_and< ::boost::is_same<ncvB,ncvD>::value, ::boost::is_class<ncvB>::value>::value)>::value)

                                                                                                                                 ;
      };
   }

template< typename Base, typename Derived > struct is_base_of : ::boost::integral_constant<bool,(::boost::detail::is_base_of_imp<Base, Derived>::value)> { };






template< typename Base, typename Derived > struct is_base_of< Base&,Derived > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_of< Base,Derived& > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_of< Base&,Derived& > : ::boost::integral_constant<bool,false> { };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_base_of.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/constrained_value.hpp" 2

namespace boost {


namespace CV {

  enum violation_enum {min_violation, max_violation};
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/constrained_value.hpp"
  template<class value_policies>
  class constrained_value {
  public:
    typedef typename value_policies::value_type value_type;

    constrained_value(value_type value) : value_((min)())
    {
      assign(value);
    }
    constrained_value& operator=(value_type v)
    {
      assign(v);
      return *this;
    }

    static value_type max () {return (value_policies::max)();}

    static value_type min () {return (value_policies::min)();}

    operator value_type() const {return value_;}
  protected:
    value_type value_;
  private:
    void assign(value_type value)
    {


      if (value+1 < (min)()+1) {
        value_policies::on_error(value_, value, min_violation);
        return;
      }
      if (value > (max)()) {
        value_policies::on_error(value_, value, max_violation);
        return;
      }
      value_ = value;
    }
};


  template<typename rep_type, rep_type min_value,
           rep_type max_value, class exception_type>
  class simple_exception_policy
  {
    struct exception_wrapper : public exception_type
    {




      operator std::out_of_range () const
      {

        return std::out_of_range("constrained value boundary has been violated");
      }
    };

    typedef typename mpl::if_<
      is_base_of< std::exception, exception_type >,
      exception_type,
      exception_wrapper
    >::type actual_exception_type;

  public:
    typedef rep_type value_type;
    static rep_type min () { return min_value; }
    static rep_type max () { return max_value; }
    static void on_error(rep_type, rep_type, violation_enum)
    {
      boost::throw_exception(actual_exception_type());
    }
  };



} }
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_weekday.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_defs.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_defs.hpp"
namespace boost {
namespace date_time {


  enum weekdays {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};


  enum months_of_year {Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec,NotAMonth,NumMonths};

} }
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_weekday.hpp" 2




namespace boost {
namespace gregorian {


  using date_time::Sunday;
  using date_time::Monday;
  using date_time::Tuesday;
  using date_time::Wednesday;
  using date_time::Thursday;
  using date_time::Friday;
  using date_time::Saturday;



  struct bad_weekday : public std::out_of_range
  {
    bad_weekday() : std::out_of_range(std::string("Weekday is out of range 0..6")) {}
  };
  typedef CV::simple_exception_policy<unsigned short, 0, 6, bad_weekday> greg_weekday_policies;
  typedef CV::constrained_value<greg_weekday_policies> greg_weekday_rep;



  class greg_weekday : public greg_weekday_rep {
  public:
    typedef boost::date_time::weekdays weekday_enum;
    greg_weekday(unsigned short day_of_week_num) :
      greg_weekday_rep(day_of_week_num)
    {}

    unsigned short as_number() const {return value_;}
    const char* as_short_string() const;
    const char* as_long_string() const;

    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;

    weekday_enum as_enum() const {return static_cast<weekday_enum>(value_);}


  };



} }
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_day_of_year.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_day_of_year.hpp"
namespace boost {
namespace gregorian {


  struct bad_day_of_year : public std::out_of_range
  {
    bad_day_of_year() :
      std::out_of_range(std::string("Day of year value is out of range 1..366"))
    {}
  };


  typedef CV::simple_exception_policy<unsigned short,1,366,bad_day_of_year> greg_day_of_year_policies;


  typedef CV::constrained_value<greg_day_of_year_policies> greg_day_of_year_rep;


} }
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian_calendar.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian_calendar.hpp"
namespace boost {
namespace date_time {
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian_calendar.hpp"
  template<typename ymd_type_, typename date_int_type_>
  class gregorian_calendar_base {
  public:

    typedef ymd_type_ ymd_type;

    typedef typename ymd_type::month_type month_type;

    typedef typename ymd_type::day_type day_type;

    typedef typename ymd_type::year_type year_type;

    typedef date_int_type_ date_int_type;


    static unsigned short day_of_week(const ymd_type& ymd);
    static int week_number(const ymd_type&ymd);

    static date_int_type day_number(const ymd_type& ymd);
    static date_int_type julian_day_number(const ymd_type& ymd);
    static date_int_type modjulian_day_number(const ymd_type& ymd);
    static ymd_type from_day_number(date_int_type);
    static ymd_type from_julian_day_number(date_int_type);
    static ymd_type from_modjulian_day_number(date_int_type);
    static bool is_leap_year(year_type);
    static unsigned short end_of_month_day(year_type y, month_type m);
    static ymd_type epoch();
    static unsigned short days_in_week();

  };



} }


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian_calendar.ipp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian_calendar.ipp"
namespace boost {
namespace date_time {



  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_of_week(const ymd_type& ymd) {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 2);
    unsigned short d = static_cast<unsigned short>((ymd.day + y + (y/4) - (y/100) + (y/400) + (31*m)/12) % 7);

    return d;
  }







  template<typename ymd_type_, typename date_int_type_>
  inline
  int
  gregorian_calendar_base<ymd_type_,date_int_type_>::week_number(const ymd_type& ymd) {
    unsigned long julianbegin = julian_day_number(ymd_type(ymd.year,1,1));
    unsigned long juliantoday = julian_day_number(ymd);
    unsigned long day = (julianbegin + 3) % 7;
    unsigned long week = (juliantoday + day - julianbegin + 4)/7;

    if ((week >= 1) && (week <= 52)) {
      return week;
    }

    if ((week == 53)) {
      if((day==6) ||(day == 5 && is_leap_year(ymd.year))) {
        return week;
      } else {
        return 1;
      }
    }

    else if (week == 0) {
      julianbegin = julian_day_number(ymd_type(static_cast<unsigned short>(ymd.year-1),1,1));
      juliantoday = julian_day_number(ymd);
      day = (julianbegin + 3) % 7;
      week = (juliantoday + day - julianbegin + 4)/7;
      return week;
    }

    return week;

  }




  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_number(const ymd_type& ymd)
  {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year + 4800 - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 3);
    unsigned long d = ymd.day + ((153*m + 2)/5) + 365*y + (y/4) - (y/100) + (y/400) - 32045;
    return d;
  }




  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::julian_day_number(const ymd_type& ymd)
  {
    return day_number(ymd);
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::modjulian_day_number(const ymd_type& ymd)
  {
    return julian_day_number(ymd)-2400001;
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a + 3)/146097;
    date_int_type c = a-((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - (1461*d)/4;
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<unsigned short>(100*b + d - 4800 + (m/10));


    return ymd_type(static_cast<unsigned short>(year),month,day);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_julian_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a+3)/146097;
    date_int_type c = a - ((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - ((1461*d)/4);
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<year_type>(100*b + d - 4800 + (m/10));


    return ymd_type(year,month,day);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_modjulian_day_number(date_int_type dayNumber) {
    date_int_type jd = dayNumber + 2400001;
    return from_julian_day_number(jd);
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  bool
  gregorian_calendar_base<ymd_type_,date_int_type_>::is_leap_year(year_type year)
  {

    return (!(year % 4)) && ((year % 100) || (!(year % 400)));
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::end_of_month_day(year_type year,
                                                                      month_type month)
  {
    switch (month) {
    case 2:
      if (is_leap_year(year)) {
        return 29;
      } else {
        return 28;
      };
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    default:
      return 31;
    };

  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::epoch()
  {
    return ymd_type(1400,1,1);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::days_in_week()
  {
    return 7;
  }


} }
# 64 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian_calendar.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_ymd.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_ymd.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_day.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_day.hpp"
namespace boost {
namespace gregorian {


  struct bad_day_of_month : public std::out_of_range
  {
    bad_day_of_month() :
      std::out_of_range(std::string("Day of month value is out of range 1..31"))
    {}

    bad_day_of_month(const std::string& s) :
      std::out_of_range(s)
    {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1, 31, bad_day_of_month> greg_day_policies;


  typedef CV::constrained_value<greg_day_policies> greg_day_rep;







  class greg_day : public greg_day_rep {
  public:
    greg_day(unsigned short day_of_month) : greg_day_rep(day_of_month) {}
    unsigned short as_number() const {return value_;}
    operator unsigned short() const {return value_;}
  private:

  };



} }
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_ymd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_year.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_year.hpp"
namespace boost {
namespace gregorian {


  struct bad_year : public std::out_of_range
  {
    bad_year() :
      std::out_of_range(std::string("Year is out of valid range: 1400..10000"))
    {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1400, 10000, bad_year> greg_year_policies;


  typedef CV::constrained_value<greg_year_policies> greg_year_rep;
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_year.hpp"
  class greg_year : public greg_year_rep {
  public:
    greg_year(unsigned short year) : greg_year_rep(year) {}
    operator unsigned short() const {return value_;}
  private:

  };



} }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_ymd.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_month.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_month.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/map" 1 3
# 58 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/map" 3
       
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/map" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 1 3
# 67 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;







    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }


      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }
# 413 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void
      swap(_Rb_tree& __t);


      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);
# 712 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);
# 732 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 867 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else

 return iterator(static_cast<_Link_type>
   (const_cast<_Base_ptr>(__position._M_node)));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }
# 1391 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }
# 1475 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 61 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/map" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 1 3
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 84 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 170 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 211 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 227 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 250 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 296 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 415 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 442 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 464 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 499 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 539 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 551 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 586 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 602 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 636 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 652 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 695 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 710 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 722 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 737 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 752 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 791 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 810 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 835 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 852 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/map" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 168 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 208 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 224 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 247 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 293 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 410 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 437 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 461 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 474 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 522 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 538 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 574 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 590 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 633 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 648 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 672 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 687 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 724 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 741 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 766 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 783 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/map" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_month.hpp" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_month.hpp" 2

namespace boost {
namespace gregorian {

  typedef date_time::months_of_year months_of_year;


  using date_time::Jan;
  using date_time::Feb;
  using date_time::Mar;
  using date_time::Apr;
  using date_time::May;
  using date_time::Jun;
  using date_time::Jul;
  using date_time::Aug;
  using date_time::Sep;
  using date_time::Oct;
  using date_time::Nov;
  using date_time::Dec;
  using date_time::NotAMonth;
  using date_time::NumMonths;


  struct bad_month : public std::out_of_range
  {
    bad_month() : std::out_of_range(std::string("Month number is out of range 1..12")) {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1, 12, bad_month> greg_month_policies;

  typedef CV::constrained_value<greg_month_policies> greg_month_rep;



  class greg_month : public greg_month_rep {
  public:
    typedef date_time::months_of_year month_enum;
    typedef std::map<std::string, unsigned short> month_map_type;
    typedef boost::shared_ptr<month_map_type> month_map_ptr_type;

    greg_month(month_enum theMonth) :
      greg_month_rep(static_cast<greg_month_rep::value_type>(theMonth)) {}

    greg_month(unsigned short theMonth) : greg_month_rep(theMonth) {}

    operator unsigned short() const {return value_;}

    unsigned short as_number() const {return value_;}
    month_enum as_enum() const {return static_cast<month_enum>(value_);}
    const char* as_short_string() const;
    const char* as_long_string() const;

    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;


    static month_map_ptr_type get_month_map_ptr();



    const char* as_short_string(char) const
    {
      return as_short_string();
    }
    const char* as_long_string(char) const
    {
      return as_long_string();
    }

    const wchar_t* as_short_string(wchar_t) const
    {
      return as_short_wstring();
    }
    const wchar_t* as_long_string(wchar_t) const
    {
      return as_long_wstring();
    }

  };

} }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_ymd.hpp" 2

namespace boost {
namespace gregorian {

  typedef date_time::year_month_day_base<greg_year,
                                         greg_month,
                                         greg_day> greg_year_month_day;



} }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_calendar.hpp" 2


namespace boost {
namespace gregorian {


  typedef date_time::int_adapter<uint32_t> fancy_date_rep;


  class gregorian_calendar :
    public date_time::gregorian_calendar_base<greg_year_month_day, fancy_date_rep::int_type> {
  public:

    typedef greg_weekday day_of_week_type;

    typedef greg_day_of_year_rep day_of_year_type;

    typedef fancy_date_rep date_rep_type;

    typedef fancy_date_rep date_traits_type;


  private:
  };

} }
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_duration.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_duration.hpp"
namespace boost {
namespace date_time {



  template<class duration_rep_traits>
  class date_duration : private
              boost::less_than_comparable1< date_duration< duration_rep_traits >
            , boost::equality_comparable1< date_duration< duration_rep_traits >
            , boost::addable1< date_duration< duration_rep_traits >
            , boost::subtractable1< date_duration< duration_rep_traits >
            , boost::dividable2< date_duration< duration_rep_traits >, int
            > > > > >
  {
  public:
    typedef typename duration_rep_traits::int_type duration_rep_type;
    typedef typename duration_rep_traits::impl_type duration_rep;


    explicit date_duration(duration_rep day_count) : days_(day_count) {};



    date_duration(special_values sv) :
            days_(duration_rep::from_special(sv))
    {}



    date_duration(const date_duration<duration_rep_traits>& other) :
            days_(other.days_)
    {}


    duration_rep get_rep()const
    {
        return days_;
    }
    bool is_special()const
    {
        return days_.is_special();
    }

    duration_rep_type days() const
    {
        return duration_rep_traits::as_number(days_);
    }

    static date_duration unit()
    {
        return date_duration<duration_rep_traits>(1);
    }

    bool operator==(const date_duration& rhs) const
    {
        return days_ == rhs.days_;
    }

    bool operator<(const date_duration& rhs) const
    {
        return days_ < rhs.days_;
    }







    date_duration& operator-=(const date_duration& rhs)
    {

        days_ = days_ - rhs.days_;
        return *this;
    }

    date_duration& operator+=(const date_duration& rhs)
    {
        days_ = days_ + rhs.days_;
        return *this;
    }


    date_duration operator-() const
    {
        return date_duration<duration_rep_traits>(get_rep() * (-1));
    }

    date_duration& operator/=(int divisor)
    {
        days_ = days_ / divisor;
        return *this;
    }


    bool is_negative() const
    {
        return days_ < 0;
    }

  private:
    duration_rep days_;
  };





  struct duration_traits_long
  {
    typedef long int_type;
    typedef long impl_type;
    static int_type as_number(impl_type i) { return i; };
  };




  struct duration_traits_adapted
  {
    typedef long int_type;
    typedef boost::date_time::int_adapter<long> impl_type;
    static int_type as_number(impl_type i) { return i.as_number(); };
  };


} }
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration.hpp" 2



namespace boost {
namespace gregorian {


  typedef boost::date_time::duration_traits_adapted date_duration_rep;




  class date_duration :
    public boost::date_time::date_duration< date_duration_rep >
  {
    typedef boost::date_time::date_duration< date_duration_rep > base_type;

  public:
    typedef base_type::duration_rep duration_rep;


    explicit date_duration(duration_rep day_count = 0) : base_type(day_count) {}


    date_duration(date_time::special_values sv) : base_type(sv) {}


    date_duration(const date_duration& other) : base_type(static_cast< base_type const& >(other))
    {}


    date_duration(const base_type& other) : base_type(other)
    {}





    bool operator== (const date_duration& rhs) const
    {
      return base_type::operator== (rhs);
    }
    bool operator!= (const date_duration& rhs) const
    {
      return !operator== (rhs);
    }
    bool operator< (const date_duration& rhs) const
    {
      return base_type::operator< (rhs);
    }
    bool operator> (const date_duration& rhs) const
    {
      return !(base_type::operator< (rhs) || base_type::operator== (rhs));
    }
    bool operator<= (const date_duration& rhs) const
    {
      return (base_type::operator< (rhs) || base_type::operator== (rhs));
    }
    bool operator>= (const date_duration& rhs) const
    {
      return !base_type::operator< (rhs);
    }


    date_duration& operator-= (const date_duration& rhs)
    {
      base_type::operator-= (rhs);
      return *this;
    }
    friend date_duration operator- (date_duration rhs, date_duration const& lhs)
    {
      rhs -= lhs;
      return rhs;
    }


    date_duration& operator+= (const date_duration& rhs)
    {
      base_type::operator+= (rhs);
      return *this;
    }
    friend date_duration operator+ (date_duration rhs, date_duration const& lhs)
    {
      rhs += lhs;
      return rhs;
    }


    date_duration operator- ()const
    {
      return date_duration(get_rep() * (-1));
    }


    date_duration& operator/= (int divisor)
    {
      base_type::operator/= (divisor);
      return *this;
    }
    friend date_duration operator/ (date_duration rhs, int lhs)
    {
      rhs /= lhs;
      return rhs;
    }


    static date_duration unit()
    {
      return date_duration(base_type::unit().get_rep());
    }
  };


  typedef date_duration days;

} }


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_duration_types.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_duration_types.hpp"
namespace boost {
namespace date_time {



  template <class duration_config>
  class weeks_duration : public date_duration<duration_config> {
  public:
    weeks_duration(typename duration_config::impl_type w)
      : date_duration<duration_config>(w * 7) {}
    weeks_duration(special_values sv)
      : date_duration<duration_config>(sv) {}
  };


  template<class t>
  class years_duration;






  template<class base_config>
  class months_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef months_duration<base_config> months_type;
      typedef years_duration<base_config> years_type;
    public:
      months_duration(int_rep num) : _m(num) {}
      months_duration(special_values sv) : _m(sv)
      {
        _m = int_rep::from_special(sv);
      }
      int_rep number_of_months() const { return _m; }

      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const months_type& rhs) const
      {
        return(_m == rhs._m);
      }
      bool operator!=(const months_type& rhs) const
      {
        return(_m != rhs._m);
      }
      months_type operator+(const months_type& rhs)const
      {
        return months_type(_m + rhs._m);
      }
      months_type& operator+=(const months_type& rhs)
      {
        _m = _m + rhs._m;
        return *this;
      }
      months_type operator-(const months_type& rhs)const
      {
        return months_type(_m - rhs._m);
      }
      months_type& operator-=(const months_type& rhs)
      {
        _m = _m - rhs._m;
        return *this;
      }
      months_type operator*(const int_type rhs)const
      {
        return months_type(_m * rhs);
      }
      months_type& operator*=(const int_type rhs)
      {
        _m = _m * rhs;
        return *this;
      }
      months_type operator/(const int_type rhs)const
      {
        return months_type(_m / rhs);
      }
      months_type& operator/=(const int_type rhs)
      {
        _m = _m / rhs;
        return *this;
      }
      months_type operator+(const years_type& y)const
      {
        return months_type(y.number_of_years() * 12 + _m);
      }
      months_type& operator+=(const years_type& y)
      {
        _m = y.number_of_years() * 12 + _m;
        return *this;
      }
      months_type operator-(const years_type& y) const
      {
        return months_type(_m - y.number_of_years() * 12);
      }
      months_type& operator-=(const years_type& y)
      {
        _m = _m - y.number_of_years() * 12;
        return *this;
      }


      friend date_type operator+(const date_type& d, const months_type& m)
      {
        return d + m.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const months_type& m)
      {
        return d += m.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const months_type& m)
      {

        return d + m.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const months_type& m)
      {

        return d += m.get_neg_offset(d);
      }

    private:
      int_rep _m;
  };







  template<class base_config>
  class years_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef years_duration<base_config> years_type;
      typedef months_duration<base_config> months_type;
    public:
      years_duration(int_rep num) : _y(num) {}
      years_duration(special_values sv) : _y(sv)
      {
        _y = int_rep::from_special(sv);
      }
      int_rep number_of_years() const { return _y; }

      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const years_type& rhs) const
      {
        return(_y == rhs._y);
      }
      bool operator!=(const years_type& rhs) const
      {
        return(_y != rhs._y);
      }
      years_type operator+(const years_type& rhs)const
      {
        return years_type(_y + rhs._y);
      }
      years_type& operator+=(const years_type& rhs)
      {
        _y = _y + rhs._y;
        return *this;
      }
      years_type operator-(const years_type& rhs)const
      {
        return years_type(_y - rhs._y);
      }
      years_type& operator-=(const years_type& rhs)
      {
        _y = _y - rhs._y;
        return *this;
      }
      years_type operator*(const int_type rhs)const
      {
        return years_type(_y * rhs);
      }
      years_type& operator*=(const int_type rhs)
      {
        _y = _y * rhs;
        return *this;
      }
      years_type operator/(const int_type rhs)const
      {
        return years_type(_y / rhs);
      }
      years_type& operator/=(const int_type rhs)
      {
        _y = _y / rhs;
        return *this;
      }
      months_type operator+(const months_type& m) const
      {
        return(months_type(_y * 12 + m.number_of_months()));
      }
      months_type operator-(const months_type& m) const
      {
        return(months_type(_y * 12 - m.number_of_months()));
      }


      friend date_type operator+(const date_type& d, const years_type& y)
      {
        return d + y.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const years_type& y)
      {
        return d += y.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const years_type& y)
      {

        return d + y.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const years_type& y)
      {

        return d += y.get_neg_offset(d);
      }

    private:
      int_rep _y;
  };

}}
# 132 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration_types.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration_types.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_date.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_date.hpp"
namespace boost {
namespace gregorian {


  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_date.hpp"
  class date : public date_time::date<date, gregorian_calendar, date_duration>
  {
   public:
    typedef gregorian_calendar::year_type year_type;
    typedef gregorian_calendar::month_type month_type;
    typedef gregorian_calendar::day_type day_type;
    typedef gregorian_calendar::day_of_year_type day_of_year_type;
    typedef gregorian_calendar::ymd_type ymd_type;
    typedef gregorian_calendar::date_rep_type date_rep_type;
    typedef gregorian_calendar::date_int_type date_int_type;
    typedef date_duration duration_type;


    date():
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(not_a_date_time))
    {}


    date(year_type y, month_type m, day_type d)
      : date_time::date<date, gregorian_calendar, date_duration>(y, m, d)
    {
      if (gregorian_calendar::end_of_month_day(y, m) < d) {
        boost::throw_exception(bad_day_of_month(std::string("Day of month is not valid for year")));
      }
    }

    explicit date(const ymd_type& ymd)
      : date_time::date<date, gregorian_calendar, date_duration>(ymd)
    {}

    explicit date(const date_int_type& rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}

    explicit date(date_rep_type rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}

    explicit date(special_values sv):
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(sv))
    {
      if (sv == min_date_time)
      {
        *this = date(1400, 1, 1);
      }
      if (sv == max_date_time)
      {
        *this = date(9999, 12, 31);
      }

    }

    date_int_type julian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::julian_day_number(ymd);
    }

    day_of_year_type day_of_year() const
    {
      date start_of_year(year(), 1, 1);
      unsigned short doy = static_cast<unsigned short>((*this-start_of_year).days() + 1);
      return day_of_year_type(doy);
    }

    date_int_type modjulian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::modjulian_day_number(ymd);
    }

    int week_number() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::week_number(ymd);
    }

    date_int_type day_number() const
    {
      return days_;
    }

    date end_of_month() const
    {
      ymd_type ymd = year_month_day();
      short eom_day = gregorian_calendar::end_of_month_day(ymd.year, ymd.month);
      return date(ymd.year, ymd.month, eom_day);
    }

   private:

  };



} }
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration_types.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/adjust_functors.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/adjust_functors.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/wrapping_int.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/wrapping_int.hpp"
namespace boost {
namespace date_time {
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/wrapping_int.hpp"
template<typename int_type_, int_type_ wrap_val>
class wrapping_int {
public:
  typedef int_type_ int_type;

  static int_type wrap_value() {return wrap_val;}

  wrapping_int(int_type v) : value_(v) {};

  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}





  template< typename IntT >
  IntT add(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    IntT overflow = static_cast<IntT>(v / (wrap_val));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }






  template< typename IntT >
  IntT subtract(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    IntT underflow = static_cast<IntT>(-(v / (wrap_val)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow) * -1;
  }
private:
  int_type value_;

  template< typename IntT >
  IntT calculate_wrap(IntT wrap)
  {
    if ((value_) >= wrap_val)
    {
      ++wrap;
      value_ -= (wrap_val);
    }
    else if(value_ < 0)
    {
      --wrap;
      value_ += (wrap_val);
    }
    return wrap;
  }

};






template<typename int_type_, int_type_ wrap_min, int_type_ wrap_max>
class wrapping_int2 {
public:
  typedef int_type_ int_type;
  static int_type wrap_value() {return wrap_max;}
  static int_type min_value() {return wrap_min;}


  wrapping_int2(int_type v) : value_(v) {
    if(value_ < wrap_min)
    {
      value_ = wrap_min;
    }
    if(value_ > wrap_max)
    {
      value_ = wrap_max;
    }
  }

  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}





  template< typename IntT >
  IntT add(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    IntT overflow = static_cast<IntT>(v / (wrap_max - wrap_min + 1));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }





  template< typename IntT >
  IntT subtract(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    IntT underflow = static_cast<IntT>(-(v / (wrap_max - wrap_min + 1)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow);
  }

private:
  int_type value_;

  template< typename IntT >
  IntT calculate_wrap(IntT wrap)
  {
    if ((value_) > wrap_max)
    {
      ++wrap;
      value_ -= (wrap_max - wrap_min + 1);
    }
    else if((value_) < wrap_min)
    {
      --wrap;
      value_ += (wrap_max - wrap_min + 1);
    }
    return wrap;
  }
};



} }
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/adjust_functors.hpp" 2

namespace boost {
namespace date_time {



  template<class date_type>
  class day_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    day_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {


      d.year();
      return duration_type(f_);
    }
    duration_type get_neg_offset(const date_type& d) const
    {

      d.year();
      return duration_type(-f_);
    }
  private:
    int f_;
  };
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/adjust_functors.hpp"
  template<class date_type>
  class month_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type cal_type;
    typedef typename cal_type::ymd_type ymd_type;
    typedef typename cal_type::day_type day_type;

    month_functor(int f) : f_(f), origDayOfMonth_(0) {}
    duration_type get_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);

      int_type year = wi.add(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);



      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));

      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }

    duration_type get_neg_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);

      int_type year = wi.subtract(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);

      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));

      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }
  private:
    int f_;
    mutable short origDayOfMonth_;
  };



  template<class date_type>
  class week_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type calendar_type;
    week_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {


      d.year();
      return duration_type(f_*calendar_type::days_in_week());
    }
    duration_type get_neg_offset(const date_type& d) const
    {

      d.year();
      return duration_type(-f_*calendar_type::days_in_week());
    }
  private:
    int f_;
  };


  template<class date_type>
  class year_functor
  {
  public:

    typedef typename date_type::duration_type duration_type;
    year_functor(int f) : _mf(f * 12) {}
    duration_type get_offset(const date_type& d) const
    {
      return _mf.get_offset(d);
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      return _mf.get_neg_offset(d);
    }
  private:
    month_functor<date_type> _mf;
  };


} }
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/greg_duration_types.hpp" 2



namespace boost {
namespace gregorian {


  struct greg_durations_config {
    typedef date date_type;
    typedef date_time::int_adapter<int> int_rep;
    typedef date_time::month_functor<date_type> month_adjustor_type;
  };

  typedef date_time::months_duration<greg_durations_config> months;
  typedef date_time::years_duration<greg_durations_config> years;

  class weeks_duration : public date_duration {
  public:
    weeks_duration(duration_rep w)
      : date_duration(w * 7) {}
    weeks_duration(date_time::special_values sv)
      : date_duration(sv) {}
  };

  typedef weeks_duration weeks;

}}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
       
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 57 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 91 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 119 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 143 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 195 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }
    };
# 255 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 291 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 309 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 331 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 365 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 401 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 419 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 441 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 475 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 509 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 525 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 547 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/sstream.tcc" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/sstream.tcc" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 574 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/sstream" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp" 2




namespace boost {
namespace date_time {







  template<class date_type>
  class year_based_generator
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::year_type year_type;
    year_based_generator() {};
    virtual ~year_based_generator() {};
    virtual date_type get_date(year_type y) const = 0;

    virtual std::string to_string() const =0;
  };
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
  template<class date_type>
 class partial_date : public year_based_generator<date_type>
 {
 public:
   typedef typename date_type::calendar_type calendar_type;
   typedef typename calendar_type::day_type day_type;
   typedef typename calendar_type::month_type month_type;
   typedef typename calendar_type::year_type year_type;
   typedef typename date_type::duration_type duration_type;
   typedef typename duration_type::duration_rep duration_rep;
   partial_date(day_type d, month_type m) :
     day_(d),
     month_(m)
   {}





   partial_date(duration_rep days) :
     day_(1),
     month_(1)
   {
     date_type d1(2000,1,1);
     if(days > 1) {
       if(days > 366)
       {
         days = 366;
       }
       days = days - 1;
       duration_type dd(days);
       d1 = d1 + dd;
     }
     day_ = d1.day();
     month_ = d1.month();
   }
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
   date_type get_date(year_type y) const
   {
     if((day_ == 29) && (month_ == 2) && !(calendar_type::is_leap_year(y))) {
       std::ostringstream ss;
       ss << "No Feb 29th in given year of " << y << ".";
       boost::throw_exception(std::invalid_argument(ss.str()));
     }
     return date_type(y, month_, day_);
   }
   date_type operator()(year_type y) const
   {
     return get_date(y);

   }
   bool operator==(const partial_date& rhs) const
   {
     return (month_ == rhs.month_) && (day_ == rhs.day_);
   }
   bool operator<(const partial_date& rhs) const
   {
     if (month_ < rhs.month_) return true;
     if (month_ > rhs.month_) return false;

     return (day_ < rhs.day_);
   }


   month_type month() const
   {
     return month_;
   }
   day_type day() const
   {
     return day_;
   }






   virtual std::string to_string() const
   {
     std::ostringstream ss;
     date_type d(2004, month_, day_);
     unsigned short c = d.day_of_year();
     c--;
     ss << c;
     return ss.str();
   }
 private:
   day_type day_;
   month_type month_;
 };



  const char* nth_as_str(int n);
# 177 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
  template<class date_type>
  class nth_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;
    enum week_num {first=1, second, third, fourth, fifth};
    nth_kday_of_month(week_num week_no,
                      day_of_week_type dow,
                      month_type m) :
      month_(m),
      wn_(week_no),
      dow_(dow)
    {}

    date_type get_date(year_type y) const
    {
      date_type d(y, month_, 1);
      duration_type one_day(1);
      duration_type one_week(7);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      int week = 1;
      while (week < wn_) {
        d = d + one_week;
        week++;
      }

      if(d.month() != month_) {
        d = d - one_week;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    week_num nth_week() const
    {
      return wn_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
    const char* nth_week_as_str() const
    {
      return nth_as_str(wn_);
    }


    virtual std::string to_string() const
    {
     std::ostringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << static_cast<int>(wn_) << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    week_num wn_;
    day_of_week_type dow_;
  };





  template<class date_type>
  class first_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;




    first_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}

    date_type get_date(year_type year) const
    {
      date_type d(year, month_,1);
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }


    virtual std::string to_string() const
    {
     std::ostringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << 1 << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
  };
# 313 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
  template<class date_type>
  class last_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;




    last_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}

    date_type get_date(year_type year) const
    {
      date_type d(year, month_, calendar_type::end_of_month_day(year,month_));
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }


    virtual std::string to_string() const
    {
      std::ostringstream ss;
      ss << 'M'
         << static_cast<int>(month_) << '.'
         << 5 << '.'
         << static_cast<int>(dow_);
      return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
   };
# 375 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
  template<class date_type>
  class first_kday_after
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_after(day_of_week_type dow) :
      dow_(dow)
    {}

    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day + one_day;
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }

    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };
# 413 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_generators.hpp"
  template<class date_type>
  class first_kday_before
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_before(day_of_week_type dow) :
      dow_(dow)
    {}

    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day - one_day;
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }

    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };





  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_until_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.is_negative()){
      wks = duration_type(7);
    }
    return dd + wks;
  }






  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_before_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.days() > 0){
      wks = duration_type(7);
    }


    return (-dd + wks);
  }






  template<class date_type, class weekday_type>
  inline
  date_type next_weekday(const date_type& d, const weekday_type& wd)
  {
    return d + days_until_weekday(d, wd);
  }






  template<class date_type, class weekday_type>
  inline
  date_type previous_weekday(const date_type& d, const weekday_type& wd)
  {
    return d - days_before_weekday(d, wd);
  }

} }
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_clock_device.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_clock_device.hpp"
namespace boost {
namespace date_time {







  template<class date_type>
  class day_clock
  {
  public:
    typedef typename date_type::ymd_type ymd_type;

    static date_type local_day()
    {
      return date_type(local_day_ymd());
    }

    static typename date_type::ymd_type local_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_local_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }

    static typename date_type::ymd_type universal_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_universal_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }

    static date_type universal_day()
    {
      return date_type(universal_day_ymd());
    }

  private:
    static ::std::tm* get_local_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::localtime(&t, &result);
    }
    static ::std::tm* get_universal_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::gmtime(&t, &result);
    }

  };

} }
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_iterator.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_iterator.hpp"
namespace boost {
namespace date_time {

  enum date_resolutions {day, week, months, year, decade, century, NumDateResolutions};
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_iterator.hpp"
  template<class date_type>
  class date_itr_base {



  public:
    typedef typename date_type::duration_type duration_type;
    typedef date_type value_type;
    typedef std::input_iterator_tag iterator_category;

    date_itr_base(date_type d) : current_(d) {}
    virtual ~date_itr_base() {};
    date_itr_base& operator++()
    {
      current_ = current_ + get_offset(current_);
      return *this;
    }
    date_itr_base& operator--()
    {
      current_ = current_ + get_neg_offset(current_);
      return *this;
    }
    virtual duration_type get_offset(const date_type& current) const=0;
    virtual duration_type get_neg_offset(const date_type& current) const=0;
    date_type operator*() {return current_;};
    date_type* operator->() {return &current_;};
    bool operator< (const date_type& d) {return current_ < d;}
    bool operator<= (const date_type& d) {return current_ <= d;}
    bool operator> (const date_type& d) {return current_ > d;}
    bool operator>= (const date_type& d) {return current_ >= d;}
    bool operator== (const date_type& d) {return current_ == d;}
    bool operator!= (const date_type& d) {return current_ != d;}
  private:
    date_type current_;
  };
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/date_iterator.hpp"
  template<class offset_functor, class date_type>
  class date_itr : public date_itr_base<date_type> {
  public:
    typedef typename date_type::duration_type duration_type;
    date_itr(date_type d, int factor=1) :
      date_itr_base<date_type>(d),
      of_(factor)
    {}
  private:
    virtual duration_type get_offset(const date_type& current) const
    {
      return of_.get_offset(current);
    }
    virtual duration_type get_neg_offset(const date_type& current) const
    {
      return of_.get_neg_offset(current);
    }
    offset_functor of_;
  };



} }
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/gregorian_types.hpp" 2


namespace boost {






namespace gregorian {



  typedef date_time::period<date, date_duration> date_period;






  typedef date_time::year_based_generator<date> year_based_generator;


  typedef date_time::partial_date<date> partial_date;

  typedef date_time::nth_kday_of_month<date> nth_kday_of_month;
  typedef nth_kday_of_month nth_day_of_the_week_in_month;

  typedef date_time::first_kday_of_month<date> first_kday_of_month;
  typedef first_kday_of_month first_day_of_the_week_in_month;

  typedef date_time::last_kday_of_month<date> last_kday_of_month;
  typedef last_kday_of_month last_day_of_the_week_in_month;

  typedef date_time::first_kday_after<date> first_kday_after;
  typedef first_kday_after first_day_of_the_week_after;

  typedef date_time::first_kday_before<date> first_kday_before;
  typedef first_kday_before first_day_of_the_week_before;




  typedef date_time::day_clock<date> day_clock;




  typedef date_time::date_itr_base<date> date_iterator;




  typedef date_time::date_itr<date_time::day_functor<date>,
                              date> day_iterator;



  typedef date_time::date_itr<date_time::week_functor<date>,
                              date> week_iterator;



  typedef date_time::date_itr<date_time::month_functor<date>,
                              date> month_iterator;



  typedef date_time::date_itr<date_time::year_functor<date>,
                              date> year_iterator;


  using date_time::days_until_weekday;
  using date_time::days_before_weekday;
  using date_time::next_weekday;
  using date_time::previous_weekday;

} }
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp" 2



namespace boost {
namespace posix_time {
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp"
  typedef date_time::time_resolution_traits<
    boost::date_time::time_resolution_traits_adapted64_impl, boost::date_time::micro,
                                            1000000, 6 > time_res_traits;
# 57 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp"
  class time_duration :
    public date_time::time_duration<time_duration, time_res_traits>
  {
  public:
    typedef time_res_traits rep_type;
    typedef time_res_traits::day_type day_type;
    typedef time_res_traits::hour_type hour_type;
    typedef time_res_traits::min_type min_type;
    typedef time_res_traits::sec_type sec_type;
    typedef time_res_traits::fractional_seconds_type fractional_seconds_type;
    typedef time_res_traits::tick_type tick_type;
    typedef time_res_traits::impl_type impl_type;
    time_duration(hour_type hour,
                  min_type min,
                  sec_type sec,
                  fractional_seconds_type fs=0) :
      date_time::time_duration<time_duration, time_res_traits>(hour,min,sec,fs)
    {}
    time_duration() :
      date_time::time_duration<time_duration, time_res_traits>(0,0,0)
    {}

    time_duration(boost::date_time::special_values sv) :
      date_time::time_duration<time_duration, time_res_traits>(sv)
    {}

    friend class date_time::time_duration<time_duration, time_res_traits>;
  private:
    explicit time_duration(impl_type tick_count) :
      date_time::time_duration<time_duration, time_res_traits>(tick_count)
    {}
  };
# 154 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_config.hpp"
  class millisec_posix_time_system_config
  {
   public:
    typedef boost::int64_t time_rep_type;

    typedef gregorian::date date_type;
    typedef gregorian::date_duration date_duration_type;
    typedef time_duration time_duration_type;
    typedef time_res_traits::tick_type int_type;
    typedef time_res_traits::impl_type impl_type;
    typedef time_res_traits resolution_traits;


    static const boost::int64_t tick_per_second = 1000000;

  };



} }
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_system.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_system_split.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_system_split.hpp"
namespace boost {
namespace date_time {





  template<typename config>

  class split_timedate_system
  {
   public:
    typedef typename config::time_rep_type time_rep_type;
    typedef typename config::date_type date_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::date_duration_type date_duration_type;
    typedef typename config::int_type int_type;
    typedef typename config::resolution_traits resolution_traits;





   private:
     static const int_type ticks_per_day = 86400LL * config::tick_per_second;
   public:



    typedef date_time::wrapping_int<int_type, ticks_per_day> wrap_int_type;



    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));

      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));

      }

    }

    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags = not_dst)
    {
      if(day.is_special() || tod.is_special()) {
        if(day.is_not_a_date() || tod.is_not_a_date_time()) {
          return time_rep_type(date_type(not_a_date_time),
                               time_duration_type(not_a_date_time));
        }
        else if(day.is_pos_infinity()) {
          if(tod.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(pos_infin));
          }
        }
        else if(day.is_neg_infinity()) {
          if(tod.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(neg_infin));
          }
        }
        else if(tod.is_pos_infinity()) {
          if(day.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(pos_infin), tod);
          }
        }
        else if(tod.is_neg_infinity()) {
          if(day.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(neg_infin), tod);
          }
        }
      }
      return time_rep_type(day, tod);
    }
    static date_type get_date(const time_rep_type& val)
    {
      return date_type(val.day);
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      return time_duration_type(val.time_of_day);
    }
    static std::string zone_name(const time_rep_type&)
    {
      return std::string();
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return ((lhs.day == rhs.day) && (lhs.time_of_day == rhs.time_of_day));
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      if (lhs.day < rhs.day) return true;
      if (lhs.day > rhs.day) return false;
      return (lhs.time_of_day < rhs.time_of_day);
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      return time_rep_type(base.day+dd, base.time_of_day);
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      return split_timedate_system::get_time_rep(base.day-dd, base.time_of_day);
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.day.is_special() || td.is_special())
      {
        return split_timedate_system::get_time_rep(base.day, -td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return add_time_duration(base,td1);
      }

      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast<typename date_duration_type::duration_rep_type>(day_offset.subtract(td.ticks())));

      return time_rep_type(base.day-day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.day.is_special() || td.is_special()) {
        return split_timedate_system::get_time_rep(base.day, td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return subtract_time_duration(base,td1);
      }

      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast< typename date_duration_type::duration_rep_type >(day_offset.add(td.ticks())));

      return time_rep_type(base.day+day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      date_duration_type dd = lhs.day - rhs.day;
      time_duration_type td(dd.days()*24,0,0);
      time_duration_type td2 = lhs.time_of_day - rhs.time_of_day;
      return td+td2;

    }

  };

} }
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_system.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_system_counted.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_system_counted.hpp"
namespace boost {
namespace date_time {


  template<class config>
  struct counted_time_rep
  {
    typedef typename config::int_type int_type;
    typedef typename config::date_type date_type;
    typedef typename config::impl_type impl_type;
    typedef typename date_type::duration_type date_duration_type;
    typedef typename date_type::calendar_type calendar_type;
    typedef typename date_type::ymd_type ymd_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::resolution_traits resolution_traits;

    counted_time_rep(const date_type& d, const time_duration_type& time_of_day)
      : time_count_(1)
    {
      if(d.is_infinity() || d.is_not_a_date() || time_of_day.is_special()) {
        time_count_ = time_of_day.get_rep() + d.day_count();

      }
      else {
        time_count_ = (d.day_number() * frac_sec_per_day()) + time_of_day.ticks();
      }
    }
    explicit counted_time_rep(int_type count) :
      time_count_(count)
    {}
    explicit counted_time_rep(impl_type count) :
      time_count_(count)
    {}
    date_type date() const
    {
      if(time_count_.is_special()) {
        return date_type(time_count_.as_special());
      }
      else {
        typename calendar_type::date_int_type dc = day_count();

        ymd_type ymd = calendar_type::from_day_number(dc);
        return date_type(ymd);
      }
    }

    unsigned long day_count() const
    {
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_system_counted.hpp"
      return static_cast<unsigned long>(resolution_traits::as_number(time_count_) / frac_sec_per_day());
    }
    int_type time_count() const
    {
      return resolution_traits::as_number(time_count_);
    }
    int_type tod() const
    {
      return resolution_traits::as_number(time_count_) % frac_sec_per_day();
    }
    static int_type frac_sec_per_day()
    {
      int_type seconds_per_day = 60*60*24;
      int_type fractional_sec_per_sec(resolution_traits::res_adjust());
      return seconds_per_day*fractional_sec_per_sec;
    }
    bool is_pos_infinity()const
    {
      return impl_type::is_pos_inf(time_count_.as_number());
    }
    bool is_neg_infinity()const
    {
      return impl_type::is_neg_inf(time_count_.as_number());
    }
    bool is_not_a_date_time()const
    {
      return impl_type::is_not_a_number(time_count_.as_number());
    }
    bool is_special()const
    {
      return time_count_.is_special();
    }
    impl_type get_rep()const
    {
      return time_count_;
    }
  private:
    impl_type time_count_;
  };


  template<class time_rep>
  class counted_time_system
  {
   public:
    typedef time_rep time_rep_type;
    typedef typename time_rep_type::impl_type impl_type;
    typedef typename time_rep_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::fractional_seconds_type fractional_seconds_type;
    typedef typename time_rep_type::date_type date_type;
    typedef typename time_rep_type::date_duration_type date_duration_type;


    template<class T> static void unused_var(const T&) {}

    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags dst=not_dst)
    {
      unused_var(dst);
      return time_rep_type(day, tod);
    }

    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));

      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));

      }

    }

    static date_type get_date(const time_rep_type& val)
    {
      return val.date();
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      if(val.is_special()) {
        return time_duration_type(val.get_rep().as_special());
      }
      else{
        return time_duration_type(0,0,0,val.tod());
      }
    }
    static std::string zone_name(const time_rep_type&)
    {
      return "";
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() == rhs.time_count());
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() < rhs.time_count());
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() + dd.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() - dd.get_rep()));
      }
      else{
        return time_rep_type(base.time_count() - (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() - td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() - td.ticks());
      }
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() + td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + td.ticks());
      }
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      if(lhs.is_special() || rhs.is_special()) {
        return(time_duration_type(
          impl_type::to_special((lhs.get_rep() - rhs.get_rep()).as_number())));
      }
      else {
        fractional_seconds_type fs = lhs.time_count() - rhs.time_count();
        return time_duration_type(0,0,0,fs);
      }
    }

  };


} }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_system.hpp" 2



namespace boost {
namespace posix_time {
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_system.hpp"
  typedef date_time::counted_time_rep<millisec_posix_time_system_config> int64_time_rep;
  typedef date_time::counted_time_system<int64_time_rep> posix_time_system;



} }
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/ptime.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time.hpp"
namespace boost {
namespace date_time {
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time.hpp"
  template <class T, class time_system>
  class base_time : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
      > >
  {
  public:
    typedef T time_type;
    typedef typename time_system::time_rep_type time_rep_type;
    typedef typename time_system::date_type date_type;
    typedef typename time_system::date_duration_type date_duration_type;
    typedef typename time_system::time_duration_type time_duration_type;


    base_time(const date_type& day,
              const time_duration_type& td,
              dst_flags dst=not_dst) :
      time_(time_system::get_time_rep(day, td, dst))
    {}
    base_time(special_values sv) :
      time_(time_system::get_time_rep(sv))
    {}
    base_time(const time_rep_type& rhs) :
      time_(rhs)
    {}
    date_type date() const
    {
      return time_system::get_date(time_);
    }
    time_duration_type time_of_day() const
    {
      return time_system::get_time_of_day(time_);
    }



    std::string zone_name(bool =false) const
    {
      return time_system::zone_name(time_);
    }



    std::string zone_abbrev(bool =false) const
    {
      return time_system::zone_name(time_);
    }

    std::string zone_as_posix_string() const
    {
      return std::string();
    }


    bool is_not_a_date_time() const
    {
      return time_.is_not_a_date_time();
    }

    bool is_infinity() const
    {
      return (is_pos_infinity() || is_neg_infinity());
    }

    bool is_pos_infinity() const
    {
      return time_.is_pos_infinity();
    }

    bool is_neg_infinity() const
    {
      return time_.is_neg_infinity();
    }

    bool is_special() const
    {
      return(is_not_a_date_time() || is_infinity());
    }

    bool operator==(const time_type& rhs) const
    {
      return time_system::is_equal(time_,rhs.time_);
    }

    bool operator<(const time_type& rhs) const
    {
      return time_system::is_less(time_,rhs.time_);
    }

    time_duration_type operator-(const time_type& rhs) const
    {
      return time_system::subtract_times(time_, rhs.time_);
    }

    time_type operator+(const date_duration_type& dd) const
    {
      return time_system::add_days(time_, dd);
    }
    time_type operator+=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() + dd, time_of_day()));
      return time_type(time_);
    }

    time_type operator-(const date_duration_type& dd) const
    {
      return time_system::subtract_days(time_, dd);
    }
    time_type operator-=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() - dd, time_of_day()));
      return time_type(time_);
    }

    time_type operator+(const time_duration_type& td) const
    {
      return time_type(time_system::add_time_duration(time_, td));
    }
    time_type operator+=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() + td));
      return time_type(time_);
    }

    time_type operator-(const time_duration_type& rhs) const
    {
      return time_system::subtract_time_duration(time_, rhs);
    }
    time_type operator-=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() - td));
      return time_type(time_);
    }

  protected:
    time_rep_type time_;
  };





} }
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/ptime.hpp" 2

namespace boost {

namespace posix_time {


  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;




  class ptime : public date_time::base_time<ptime, posix_time_system>
  {
  public:
    typedef posix_time_system time_system_type;
    typedef time_system_type::time_rep_type time_rep_type;
    typedef time_system_type::time_duration_type time_duration_type;
    typedef ptime time_type;

    ptime(gregorian::date d,time_duration_type td) : date_time::base_time<time_type,time_system_type>(d,td)
    {}

    explicit ptime(gregorian::date d) : date_time::base_time<time_type,time_system_type>(d,time_duration_type(0,0,0))
    {}

    ptime(const time_rep_type& rhs):
      date_time::base_time<time_type,time_system_type>(rhs)
    {}

    ptime(const special_values sv) : date_time::base_time<time_type,time_system_type>(sv)
    {}


    ptime() : date_time::base_time<time_type,time_system_type>(gregorian::date(not_a_date_time), time_duration_type(not_a_date_time))
    {}


  };



} }
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/date_duration_operators.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/date_duration_operators.hpp"
namespace boost {
namespace posix_time {
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/date_duration_operators.hpp"
  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::months& m)
  {
    return t + m.get_offset(t.date());
  }




  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::months& m)
  {

    return t += m.get_offset(t.date());
  }




  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::months& m)
  {

    return t + m.get_neg_offset(t.date());
  }




  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::months& m)
  {
    return t += m.get_neg_offset(t.date());
  }






  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::years& y)
  {
    return t + y.get_offset(t.date());
  }




  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::years& y)
  {
    return t += y.get_offset(t.date());
  }




  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::years& y)
  {

    return t + y.get_neg_offset(t.date());
  }




  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::years& y)
  {

    return t += y.get_neg_offset(t.date());
  }

}}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_duration.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_duration.hpp"
namespace boost {
namespace posix_time {




  class hours : public time_duration
  {
  public:
    explicit hours(long h) :
      time_duration(h,0,0)
    {}
  };




  class minutes : public time_duration
  {
  public:
    explicit minutes(long m) :
      time_duration(0,m,0)
    {}
  };




  class seconds : public time_duration
  {
  public:
    explicit seconds(long s) :
      time_duration(0,0,s)
    {}
  };





  typedef date_time::subsecond_duration<time_duration,1000> millisec;
  typedef date_time::subsecond_duration<time_duration,1000> milliseconds;




  typedef date_time::subsecond_duration<time_duration,1000000> microsec;
  typedef date_time::subsecond_duration<time_duration,1000000> microseconds;
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_duration.hpp"
} }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/time_period.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/time_period.hpp"
namespace boost {
namespace posix_time {




  typedef date_time::period<ptime, time_duration> time_period;


} }
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_iterator.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/time_iterator.hpp"
namespace boost {
namespace date_time {



  template<class time_type>
  class time_itr {
  public:
    typedef typename time_type::time_duration_type time_duration_type;
    time_itr(time_type t, time_duration_type d) : current_(t), offset_(d) {};
    time_itr& operator++()
    {
      current_ = current_ + offset_;
      return *this;
    }
    time_itr& operator--()
    {
      current_ = current_ - offset_;
      return *this;
    }
    time_type operator*() {return current_;};
    time_type* operator->() {return &current_;};
    bool operator< (const time_type& t) {return current_ < t;};
    bool operator<= (const time_type& t) {return current_ <= t;};
    bool operator!= (const time_type& t) {return current_ != t;};
    bool operator== (const time_type& t) {return current_ == t;};
    bool operator> (const time_type& t) {return current_ > t;};
    bool operator>= (const time_type& t) {return current_ >= t;};

  private:
    time_type current_;
    time_duration_type offset_;
  };



} }
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp"
namespace boost {
  namespace date_time {

    enum time_is_dst_result {is_not_in_dst, is_in_dst,
                             ambiguous, invalid_time_label};



    template<class date_type_,
             class time_duration_type_>
    class dst_calculator
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp"
      static time_is_dst_result
      process_local_dst_start_day(const time_duration_type& time_of_day,
                                  unsigned int dst_start_offset_minutes,
                                  long dst_length_minutes)
      {

        if (time_of_day < time_duration_type(0,dst_start_offset_minutes,0)) {
          return is_not_in_dst;
        }
        long offset = dst_start_offset_minutes + dst_length_minutes;
        if (time_of_day >= time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        return invalid_time_label;
      }
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp"
      static time_is_dst_result
      process_local_dst_end_day(const time_duration_type& time_of_day,
                                unsigned int dst_end_offset_minutes,
                                long dst_length_minutes)
      {

        int offset = dst_end_offset_minutes-dst_length_minutes;
        if (time_of_day < time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        if (time_of_day >= time_duration_type(0,dst_end_offset_minutes,0)) {
          return is_not_in_dst;
        }
        return ambiguous;
      }
# 100 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp"
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   const time_duration_type& dst_start_offset,
                   const date_type& dst_end_day,
                   const time_duration_type& dst_end_offset,
                   const time_duration_type& dst_length_minutes)
      {
        unsigned int start_minutes =
          dst_start_offset.hours() * 60 + dst_start_offset.minutes();
        unsigned int end_minutes =
          dst_end_offset.hours() * 60 + dst_end_offset.minutes();
        long length_minutes =
          dst_length_minutes.hours() * 60 + dst_length_minutes.minutes();

        return local_is_dst(current_day, time_of_day,
                            dst_start_day, start_minutes,
                            dst_end_day, end_minutes,
                            length_minutes);
      }
# 136 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp"
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   unsigned int dst_start_offset_minutes,
                   const date_type& dst_end_day,
                   unsigned int dst_end_offset_minutes,
                   long dst_length_minutes)
      {

        if (dst_start_day < dst_end_day) {
          if ((current_day > dst_start_day) && (current_day < dst_end_day)) {
            return is_in_dst;
          }
          if ((current_day < dst_start_day) || (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
        }
        else {
          if ((current_day < dst_start_day) && (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
          if ((current_day > dst_start_day) || (current_day < dst_end_day)) {
            return is_in_dst;
          }
        }

        if (current_day == dst_start_day) {
          return process_local_dst_start_day(time_of_day,
                                             dst_start_offset_minutes,
                                             dst_length_minutes);
        }

        if (current_day == dst_end_day) {
          return process_local_dst_end_day(time_of_day,
                                           dst_end_offset_minutes,
                                           dst_length_minutes);
        }

        return invalid_time_label;
      }

    };
# 208 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/dst_rules.hpp"
    template<class date_type,
             class time_duration_type,
             class dst_traits>
    class dst_calc_engine
    {
    public:
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;






      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {

        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,
                                     dst_traits::dst_start_offset_minutes(),
                                     dst_end,
                                     dst_traits::dst_end_offset_minutes(),
                                     dst_traits::dst_shift_length_minutes());

      }

      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }


      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_traits::dst_shift_length_minutes(),0);
      }

      static date_type local_dst_start_day(year_type year)
      {
        return dst_traits::local_dst_start_day(year);
      }

      static date_type local_dst_end_day(year_type year)
      {
        return dst_traits::local_dst_end_day(year);
      }


    };






    template<class date_type_,
             class time_duration_type_,
             unsigned int dst_start_offset_minutes=120,
             short dst_length_minutes=60>
    class us_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef date_time::last_kday_of_month<date_type> lkday;
      typedef date_time::first_kday_of_month<date_type> fkday;
      typedef date_time::nth_kday_of_month<date_type> nkday;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;






      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {

        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,dst_start_offset_minutes,
                                     dst_end, dst_start_offset_minutes,
                                     dst_length_minutes);

      }


      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }

      static date_type local_dst_start_day(year_type year)
      {
        if (year >= year_type(2007)) {

          nkday ssim(nkday::second, Sunday, gregorian::Mar);
          return ssim.get_date(year);
        } else {

          fkday fsia(Sunday, gregorian::Apr);
          return fsia.get_date(year);
        }
      }

      static date_type local_dst_end_day(year_type year)
      {
        if (year >= year_type(2007)) {

          fkday fsin(Sunday, gregorian::Nov);
          return fsin.get_date(year);
        } else {

          lkday lsio(Sunday, gregorian::Oct);
          return lsio.get_date(year);
        }
      }

      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_length_minutes,0);
      }

     private:


    };


    template<class date_type_, class time_duration_type_>
    class null_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;





      static time_is_dst_result local_is_dst(const date_type&,
                                             const time_duration_type&)
      {
        return is_not_in_dst;
      }


      static time_is_dst_result utc_is_dst(const date_type&,
                                           const time_duration_type&)
      {
        return is_not_in_dst;
      }

      static bool is_dst_boundary_day(date_type d)
      {
        return false;
      }

      static time_duration_type dst_offset()
      {
        return time_duration_type(0,0,0);
      }

    };


  } }
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/posix_time_types.hpp" 2

namespace boost {


namespace posix_time {




  typedef date_time::time_itr<ptime> time_iterator;



  typedef date_time::second_clock<ptime> second_clock;





  typedef date_time::microsec_clock<ptime> microsec_clock;



  typedef date_time::null_dst_rules<ptime::date_type, time_duration> no_dst;

  typedef date_time::us_dst_rules<ptime::date_type, time_duration> us_dst;


} }
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread_time.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread_time.hpp" 2

namespace boost
{
    typedef boost::posix_time::ptime system_time;

    inline system_time get_system_time()
    {
        return boost::date_time::microsec_clock<system_time>::universal_time();
    }

    namespace detail
    {
        inline system_time get_system_time_sentinel()
        {
            return system_time(boost::posix_time::pos_infin);
        }

        inline unsigned long get_milliseconds_until(system_time const& target_time)
        {
            if(target_time.is_pos_infinity())
            {
                return ~(unsigned long)0;
            }
            system_time const now=get_system_time();
            if(target_time<=now)
            {
                return 0;
            }
            return static_cast<unsigned long>((target_time-now).total_milliseconds()+1);
        }

    }

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread_time.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp" 2

namespace boost
{
    struct xtime;
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    namespace detail
    {
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        template<typename T, bool=boost::is_class<T>::value> struct has_member_called_lock { static const bool value=false; }; template<typename T> struct has_member_called_lock<T,true> { typedef char true_type; struct false_type { true_type dummy[2]; }; struct fallback { int lock; }; struct derived: T, fallback { derived(); }; template<int fallback::*> struct tester; template<typename U> static false_type has_member(tester<&U::lock>*); template<typename U> static true_type has_member(...); static const bool value=sizeof(has_member<derived>(0))==sizeof(true_type); };
        template<typename T, bool=boost::is_class<T>::value> struct has_member_called_unlock { static const bool value=false; }; template<typename T> struct has_member_called_unlock<T,true> { typedef char true_type; struct false_type { true_type dummy[2]; }; struct fallback { int unlock; }; struct derived: T, fallback { derived(); }; template<int fallback::*> struct tester; template<typename U> static false_type has_member(tester<&U::unlock>*); template<typename U> static true_type has_member(...); static const bool value=sizeof(has_member<derived>(0))==sizeof(true_type); };
        template<typename T, bool=boost::is_class<T>::value> struct has_member_called_try_lock { static const bool value=false; }; template<typename T> struct has_member_called_try_lock<T,true> { typedef char true_type; struct false_type { true_type dummy[2]; }; struct fallback { int try_lock; }; struct derived: T, fallback { derived(); }; template<int fallback::*> struct tester; template<typename U> static false_type has_member(tester<&U::try_lock>*); template<typename U> static true_type has_member(...); static const bool value=sizeof(has_member<derived>(0))==sizeof(true_type); };

        template<typename T,bool=has_member_called_lock<T>::value >
        struct has_member_lock
        {
            static const bool value=false;
        };

        template<typename T>
        struct has_member_lock<T,true>
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U,typename V>
            static true_type has_member(V (U::*)());
            template<typename U>
            static false_type has_member(U);

            static const bool value=sizeof(has_member_lock<T>::has_member(&T::lock))==sizeof(true_type)
                                                                                               ;
        };

        template<typename T,bool=has_member_called_unlock<T>::value >
        struct has_member_unlock
        {
            static const bool value=false;
        };

        template<typename T>
        struct has_member_unlock<T,true>
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U,typename V>
            static true_type has_member(V (U::*)());
            template<typename U>
            static false_type has_member(U);

            static const bool value=sizeof(has_member_unlock<T>::has_member(&T::unlock))==sizeof(true_type)
                                                                                                   ;
        };

        template<typename T,bool=has_member_called_try_lock<T>::value >
        struct has_member_try_lock
        {
            static const bool value=false;
        };

        template<typename T>
        struct has_member_try_lock<T,true>
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(bool (U::*)());
            template<typename U>
            static false_type has_member(U);

            static const bool value=sizeof(has_member_try_lock<T>::has_member(&T::try_lock))==sizeof(true_type)
                                                                                                       ;
        };

    }


    template<typename T>
    struct is_mutex_type
    {
        static const bool value = detail::has_member_lock<T>::value && detail::has_member_unlock<T>::value && detail::has_member_try_lock<T>::value

                                                                    ;

    };
# 160 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    struct defer_lock_t
    {};
    struct try_to_lock_t
    {};
    struct adopt_lock_t
    {};

    const defer_lock_t defer_lock={};
    const try_to_lock_t try_to_lock={};
    const adopt_lock_t adopt_lock={};

    template<typename Mutex>
    class shared_lock;

    template<typename Mutex>
    class upgrade_lock;

    template<typename Mutex>
    class unique_lock;

    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper;
    }
# 245 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    template<typename Mutex>
    class lock_guard
    {
    private:
        Mutex& m;

        explicit lock_guard(lock_guard&);
        lock_guard& operator=(lock_guard&);
    public:
        explicit lock_guard(Mutex& m_):
            m(m_)
        {
            m.lock();
        }
        lock_guard(Mutex& m_,adopt_lock_t):
            m(m_)
        {}
        ~lock_guard()
        {
            m.unlock();
        }
    };


    template<typename Mutex>
    class unique_lock
    {
    private:
        Mutex* m;
        bool is_locked;
        unique_lock(unique_lock&);
        explicit unique_lock(upgrade_lock<Mutex>&);
        unique_lock& operator=(unique_lock&);
        unique_lock& operator=(upgrade_lock<Mutex>& other);
    public:



        unique_lock():
            m(0),is_locked(false)
        {}

        explicit unique_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        unique_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        unique_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        unique_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        template<typename TimeDuration>
        unique_lock(Mutex& m_,TimeDuration const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
        unique_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
# 348 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        unique_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }
        unique_lock(detail::thread_move_t<upgrade_lock<Mutex> > other);

        operator detail::thread_move_t<unique_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<unique_lock<Mutex> > move()
        {
            return detail::thread_move_t<unique_lock<Mutex> >(*this);
        }
# 373 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        unique_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            unique_lock temp(other);
            swap(temp);
            return *this;
        }


        unique_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            unique_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            std::swap(m,other->m);
            std::swap(is_locked,other->is_locked);
        }

        void swap(unique_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }

        ~unique_lock()
        {
            if(owns_lock())
            {
                m->unlock();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->lock();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->try_lock();
            return is_locked;
        }
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const& relative_time)
        {
            is_locked=m->timed_lock(relative_time);
            return is_locked;
        }

        bool timed_lock(::boost::system_time const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        bool timed_lock(::boost::xtime const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->unlock();
            is_locked=false;
        }

        typedef void (unique_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&unique_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }

        Mutex* mutex() const
        {
            return m;
        }

        Mutex* release()
        {
            Mutex* const res=m;
            m=0;
            is_locked=false;
            return res;
        }

        friend class shared_lock<Mutex>;
        friend class upgrade_lock<Mutex>;
    };
# 501 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    template<typename Mutex>
    void swap(unique_lock<Mutex>& lhs,unique_lock<Mutex>& rhs)
    {
        lhs.swap(rhs);
    }
# 521 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    template<typename Mutex>
    class shared_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit shared_lock(shared_lock&);
        shared_lock& operator=(shared_lock&);
    public:
        shared_lock():
            m(0),is_locked(false)
        {}

        explicit shared_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        shared_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        shared_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        shared_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        shared_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }

        shared_lock(detail::thread_move_t<shared_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }

        shared_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }

        shared_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_upgrade_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }

        operator detail::thread_move_t<shared_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<shared_lock<Mutex> > move()
        {
            return detail::thread_move_t<shared_lock<Mutex> >(*this);
        }


        shared_lock& operator=(detail::thread_move_t<shared_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }

        shared_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }

        shared_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }
# 625 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        void swap(boost::detail::thread_move_t<shared_lock<Mutex> > other)
        {
            std::swap(m,other->m);
            std::swap(is_locked,other->is_locked);
        }

        void swap(shared_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }

        Mutex* mutex() const
        {
            return m;
        }

        ~shared_lock()
        {
            if(owns_lock())
            {
                m->unlock_shared();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->lock_shared();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->try_lock_shared();
            return is_locked;
        }
        bool timed_lock(boost::system_time const& target_time)
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        template<typename Duration>
        bool timed_lock(Duration const& target_time)
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->unlock_shared();
            is_locked=false;
        }

        typedef void (shared_lock<Mutex>::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&shared_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }

    };
# 719 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    template<typename Mutex>
    void swap(shared_lock<Mutex>& lhs,shared_lock<Mutex>& rhs)
    {
        lhs.swap(rhs);
    }


    template<typename Mutex>
    class upgrade_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit upgrade_lock(upgrade_lock&);
        upgrade_lock& operator=(upgrade_lock&);
    public:
        upgrade_lock():
            m(0),is_locked(false)
        {}

        explicit upgrade_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        upgrade_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        upgrade_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        upgrade_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
# 789 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        upgrade_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }

        upgrade_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_upgrade();
            }
            other->is_locked=false;
            other->m=0;
        }

        operator detail::thread_move_t<upgrade_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<upgrade_lock<Mutex> > move()
        {
            return detail::thread_move_t<upgrade_lock<Mutex> >(*this);
        }


        upgrade_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            upgrade_lock temp(other);
            swap(temp);
            return *this;
        }

        upgrade_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            upgrade_lock temp(other);
            swap(temp);
            return *this;
        }


        void swap(upgrade_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }

        ~upgrade_lock()
        {
            if(owns_lock())
            {
                m->unlock_upgrade();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->lock_upgrade();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->try_lock_upgrade();
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->unlock_upgrade();
            is_locked=false;
        }

        typedef void (upgrade_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&upgrade_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }
        friend class shared_lock<Mutex>;
        friend class unique_lock<Mutex>;
    };
# 904 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
    template<typename Mutex>
    unique_lock<Mutex>::unique_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
        m(other->m),is_locked(other->is_locked)
    {
        other->is_locked=false;
        if(is_locked)
        {
            m->unlock_upgrade_and_lock();
        }
    }

    template <class Mutex>
    class upgrade_to_unique_lock
    {
    private:
        upgrade_lock<Mutex>* source;
        unique_lock<Mutex> exclusive;

        explicit upgrade_to_unique_lock(upgrade_to_unique_lock&);
        upgrade_to_unique_lock& operator=(upgrade_to_unique_lock&);
    public:
        explicit upgrade_to_unique_lock(upgrade_lock<Mutex>& m_):
            source(&m_),exclusive(move(*source))
        {}
        ~upgrade_to_unique_lock()
        {
            if(source)
            {
                *source=move(exclusive);
            }
        }
# 950 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        upgrade_to_unique_lock(detail::thread_move_t<upgrade_to_unique_lock<Mutex> > other):
            source(other->source),exclusive(move(other->exclusive))
        {
            other->source=0;
        }

        upgrade_to_unique_lock& operator=(detail::thread_move_t<upgrade_to_unique_lock<Mutex> > other)
        {
            upgrade_to_unique_lock temp(other);
            swap(temp);
            return *this;
        }

        void swap(upgrade_to_unique_lock& other)
        {
            std::swap(source,other.source);
            exclusive.swap(other.exclusive);
        }
        typedef void (upgrade_to_unique_lock::*bool_type)(upgrade_to_unique_lock&);
        operator bool_type() const
        {
            return exclusive.owns_lock()?&upgrade_to_unique_lock::swap:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return exclusive.owns_lock();
        }
    };

    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper:
            private unique_lock<Mutex>
        {
            typedef unique_lock<Mutex> base;
        public:
            try_lock_wrapper()
            {}

            explicit try_lock_wrapper(Mutex& m):
                base(m,try_to_lock)
            {}

            try_lock_wrapper(Mutex& m_,adopt_lock_t):
                base(m_,adopt_lock)
            {}
            try_lock_wrapper(Mutex& m_,defer_lock_t):
                base(m_,defer_lock)
            {}
            try_lock_wrapper(Mutex& m_,try_to_lock_t):
                base(m_,try_to_lock)
            {}
# 1029 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
            try_lock_wrapper(detail::thread_move_t<try_lock_wrapper<Mutex> > other):
                base(detail::thread_move_t<base>(*other))
            {}

            operator detail::thread_move_t<try_lock_wrapper<Mutex> >()
            {
                return move();
            }

            detail::thread_move_t<try_lock_wrapper<Mutex> > move()
            {
                return detail::thread_move_t<try_lock_wrapper<Mutex> >(*this);
            }

            try_lock_wrapper& operator=(detail::thread_move_t<try_lock_wrapper<Mutex> > other)
            {
                try_lock_wrapper temp(other);
                swap(temp);
                return *this;
            }

            void swap(detail::thread_move_t<try_lock_wrapper<Mutex> > other)
            {
                base::swap(*other);
            }

            void swap(try_lock_wrapper& other)
            {
                base::swap(other);
            }
            void lock()
            {
                base::lock();
            }
            bool try_lock()
            {
                return base::try_lock();
            }
            void unlock()
            {
                base::unlock();
            }
            bool owns_lock() const
            {
                return base::owns_lock();
            }
            Mutex* mutex() const
            {
                return base::mutex();
            }
            Mutex* release()
            {
                return base::release();
            }
            bool operator!() const
            {
                return !this->owns_lock();
            }

            typedef typename base::bool_type bool_type;
            operator bool_type() const
            {
                return base::operator bool_type();
            }
        };
# 1102 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp"
        template<typename Mutex>
        void swap(try_lock_wrapper<Mutex>& lhs,try_lock_wrapper<Mutex>& rhs)
        {
            lhs.swap(rhs);
        }


        template<typename MutexType1,typename MutexType2>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(!m2.try_lock())
            {
                return 2;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }


        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }


        template<typename MutexType1,typename MutexType2>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(!m2.try_lock())
            {
                return 1;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }
    }

    namespace detail
    {
        template<bool x>
        struct is_mutex_type_wrapper
        {};

        template<typename MutexType1,typename MutexType2>
        void lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            unsigned const lock_count=2;
            unsigned lock_first=0;
            for(;;)
            {
                switch(lock_first)
                {
                case 0:
                    lock_first=detail::lock_helper(m1,m2);
                    if(!lock_first)
                        return;
                    break;
                case 1:
                    lock_first=detail::lock_helper(m2,m1);
                    if(!lock_first)
                        return;
                    lock_first=(lock_first+1)%lock_count;
                    break;
                }
            }
        }

        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }


    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        unsigned const lock_count=3;
        unsigned lock_first=0;
        for(;;)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            }
        }
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4)
    {
        unsigned const lock_count=4;
        unsigned lock_first=0;
        for(;;)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            }
        }
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4,typename MutexType5>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4,MutexType5& m5)
    {
        unsigned const lock_count=5;
        unsigned lock_first=0;
        for(;;)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4,m5);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m5,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m5,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m5,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            case 4:
                lock_first=detail::lock_helper(m5,m1,m2,m3,m4);
                if(!lock_first)
                    return;
                lock_first=(lock_first+4)%lock_count;
                break;
            }
        }
    }

    namespace detail
    {
        template<typename Mutex,bool x=is_mutex_type<Mutex>::value>
        struct try_lock_impl_return
        {
            typedef int type;
        };

        template<typename Iterator>
        struct try_lock_impl_return<Iterator,false>
        {
            typedef Iterator type;
        };

        template<typename MutexType1,typename MutexType2>
        int try_lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            return ((int)detail::try_lock_internal(m1,m2))-1;
        }

        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3))-1;
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4))-1;
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4,typename MutexType5>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4,MutexType5& m5)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4,m5))-1;
    }


    namespace detail
    {
        template<typename Iterator>
        struct range_lock_guard
        {
            Iterator begin;
            Iterator end;

            range_lock_guard(Iterator begin_,Iterator end_):
                begin(begin_),end(end_)
            {
                lock(begin,end);
            }

            void release()
            {
                begin=end;
            }

            ~range_lock_guard()
            {
                for(;begin!=end;++begin)
                {
                    begin->unlock();
                }
            }
        };

        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)

        {
            if(begin==end)
            {
                return end;
            }
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;
            unique_lock<lock_type> guard(*begin,try_to_lock);

            if(!guard.owns_lock())
            {
                return begin;
            }
            Iterator const failed=try_lock(++begin,end);
            if(failed==end)
            {
                guard.release();
            }

            return failed;
        }
    }


    namespace detail
    {
        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)
        {
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;

            if(begin==end)
            {
                return;
            }
            bool start_with_begin=true;
            Iterator second=begin;
            ++second;
            Iterator next=second;

            for(;;)
            {
                unique_lock<lock_type> begin_lock(*begin,defer_lock);
                if(start_with_begin)
                {
                    begin_lock.lock();
                    Iterator const failed_lock=try_lock(next,end);
                    if(failed_lock==end)
                    {
                        begin_lock.release();
                        return;
                    }
                    start_with_begin=false;
                    next=failed_lock;
                }
                else
                {
                    detail::range_lock_guard<Iterator> guard(next,end);
                    if(begin_lock.try_lock())
                    {
                        Iterator const failed_lock=try_lock(second,next);
                        if(failed_lock==next)
                        {
                            begin_lock.release();
                            guard.release();
                            return;
                        }
                        start_with_begin=false;
                        next=failed_lock;
                    }
                    else
                    {
                        start_with_begin=true;
                        next=second;
                    }
                }
            }
        }

    }

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 1584 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/locks.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/xtime.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/xtime.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/xtime.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/conversion.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/conversion.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 2 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/conversion.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/conversion.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/conversion.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 2 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/gregorian/conversion.hpp" 2







namespace boost {

namespace gregorian {


  inline
  std::tm to_tm(const date& d)
  {
    if (d.is_special())
    {
        std::string s = "tm unable to handle ";
        switch (d.as_special())
        {
        case date_time::not_a_date_time:
            s += "not-a-date-time value"; break;
        case date_time::neg_infin:
            s += "-infinity date value"; break;
        case date_time::pos_infin:
            s += "+infinity date value"; break;
        default:
            s += "a special date value"; break;
        }
        boost::throw_exception(std::out_of_range(s));
    }

    std::tm datetm;
    std::memset(&datetm, 0, sizeof(datetm));
    boost::gregorian::date::ymd_type ymd = d.year_month_day();
    datetm.tm_year = ymd.year - 1900;
    datetm.tm_mon = ymd.month - 1;
    datetm.tm_mday = ymd.day;
    datetm.tm_wday = d.day_of_week();
    datetm.tm_yday = d.day_of_year() - 1;
    datetm.tm_isdst = -1;
    return datetm;
  }


  inline
  date date_from_tm(const std::tm& datetm)
  {
    return date(static_cast<unsigned short>(datetm.tm_year+1900),
                static_cast<unsigned short>(datetm.tm_mon+1),
                static_cast<unsigned short>(datetm.tm_mday));
  }

} }
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/conversion.hpp" 2

namespace boost {

namespace posix_time {



  inline
  ptime from_time_t(std::time_t t)
  {
    ptime start(gregorian::date(1970,1,1));
    return start + seconds(static_cast<long>(t));
  }


  inline
  std::tm to_tm(const boost::posix_time::ptime& t) {
    std::tm timetm = boost::gregorian::to_tm(t.date());
    boost::posix_time::time_duration td = t.time_of_day();
    timetm.tm_hour = td.hours();
    timetm.tm_min = td.minutes();
    timetm.tm_sec = td.seconds();
    timetm.tm_isdst = -1;
    return timetm;
  }

  inline
  std::tm to_tm(const boost::posix_time::time_duration& td) {
    std::tm timetm;
    std::memset(&timetm, 0, sizeof(timetm));
    timetm.tm_hour = date_time::absolute_value(td.hours());
    timetm.tm_min = date_time::absolute_value(td.minutes());
    timetm.tm_sec = date_time::absolute_value(td.seconds());
    timetm.tm_isdst = -1;
    return timetm;
  }


  inline
  ptime ptime_from_tm(const std::tm& timetm) {
    boost::gregorian::date d = boost::gregorian::date_from_tm(timetm);
    return ptime(d, time_duration(timetm.tm_hour, timetm.tm_min, timetm.tm_sec));
  }
# 88 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/date_time/posix_time/conversion.hpp"
} }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/xtime.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/xtime.hpp" 2

namespace boost {

enum xtime_clock_types
{
    TIME_UTC=1







};

struct xtime
{



    typedef int_fast64_t xtime_sec_t;


    typedef int_fast32_t xtime_nsec_t;

    xtime_sec_t sec;
    xtime_nsec_t nsec;

    operator system_time() const
    {
        return boost::posix_time::from_time_t(0)+
            boost::posix_time::seconds(static_cast<long>(sec))+



        boost::posix_time::microseconds((nsec+500)/1000);

    }

};

inline xtime get_xtime(boost::system_time const& abs_time)
{
    xtime res;
    boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);

    res.sec=static_cast<xtime::xtime_sec_t>(time_since_epoch.total_seconds());
    res.nsec=static_cast<xtime::xtime_nsec_t>(time_since_epoch.fractional_seconds()*(1000000000/time_since_epoch.ticks_per_second()));
    return res;
}

inline int xtime_get(struct xtime* xtp, int clock_type)
{
    if (clock_type == TIME_UTC)
    {
        *xtp=get_xtime(get_system_time());
        return clock_type;
    }
    return 0;
}


inline int xtime_cmp(const xtime& xt1, const xtime& xt2)
{
    if (xt1.sec == xt2.sec)
        return (int)(xt1.nsec - xt2.nsec);
    else
        return (xt1.sec > xt2.sec) ? 1 : -1;
}

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 91 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/xtime.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/errno.h" 1 3 4
# 32 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/errno.h" 3 4
extern "C" {



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/errno.h" 1 3 4
# 26 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/errno.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/linux/errno.h" 1 3 4



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/asm/errno.h" 1 3 4
# 15 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/asm/errno.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/asm-generic/errno-base.h" 1 3 4
# 16 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/asm/errno.h" 2 3 4
# 5 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/linux/errno.h" 2 3 4
# 27 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/errno.h" 2 3 4
# 47 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 37 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/errno.h" 2 3 4
# 55 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/errno.h" 3 4
typedef int error_t;
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/timespec.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/timespec.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/timespec.hpp" 2

namespace boost
{
    namespace detail
    {
        inline struct timespec get_timespec(boost::system_time const& abs_time)
        {
            struct timespec timeout={0,0};
            boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);

            timeout.tv_sec=time_since_epoch.total_seconds();
            timeout.tv_nsec=(long)(time_since_epoch.fractional_seconds()*(1000000000l/time_since_epoch.ticks_per_second()));
            return timeout;
        }
    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/timespec.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 1
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2

namespace boost
{
    namespace pthread
    {
        class pthread_mutex_scoped_lock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_lock(pthread_mutex_t* m_):
                m(m_)
            {
                ((!pthread_mutex_lock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 25, __PRETTY_FUNCTION__));
            }
            ~pthread_mutex_scoped_lock()
            {
                ((!pthread_mutex_unlock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 29, __PRETTY_FUNCTION__));
            }

        };

        class pthread_mutex_scoped_unlock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_unlock(pthread_mutex_t* m_):
                m(m_)
            {
                ((!pthread_mutex_unlock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 41, __PRETTY_FUNCTION__));
            }
            ~pthread_mutex_scoped_unlock()
            {
                ((!pthread_mutex_lock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 45, __PRETTY_FUNCTION__));
            }

        };
    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2

namespace boost
{
    class mutex
    {
    private:
        mutex(mutex const&);
        mutex& operator=(mutex const&);
        pthread_mutex_t m;
    public:
        mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
        }
        ~mutex()
        {
            ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 47, __PRETTY_FUNCTION__));
        }

        void lock()
        {
            int const res=pthread_mutex_lock(&m);
            if(res)
            {
                boost::throw_exception(lock_error(res));
            }
        }

        void unlock()
        {
            ((!pthread_mutex_unlock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 61, __PRETTY_FUNCTION__));
        }

        bool try_lock()
        {
            int const res=pthread_mutex_trylock(&m);
            if(res && (res!=16))
            {
                boost::throw_exception(lock_error(res));
            }

            return !res;
        }

        typedef pthread_mutex_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &m;
        }

        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;
    };

    typedef mutex try_mutex;

    class timed_mutex
    {
    private:
        timed_mutex(timed_mutex const&);
        timed_mutex& operator=(timed_mutex const&);
    private:
        pthread_mutex_t m;




    public:
        timed_mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
# 115 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp"
        }
        ~timed_mutex()
        {
            ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 118, __PRETTY_FUNCTION__));



        }

        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time)
        {
            return timed_lock(get_system_time()+relative_time);
        }
        bool timed_lock(boost::xtime const & absolute_time)
        {
            return timed_lock(system_time(absolute_time));
        }


        void lock()
        {
            ((!pthread_mutex_lock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 137, __PRETTY_FUNCTION__));
        }

        void unlock()
        {
            ((!pthread_mutex_unlock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 142, __PRETTY_FUNCTION__));
        }

        bool try_lock()
        {
            int const res=pthread_mutex_trylock(&m);
            ((!res || res==16) ? static_cast<void> (0) : __assert_fail ("!res || res==16", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 148, __PRETTY_FUNCTION__));
            return !res;
        }
        bool timed_lock(system_time const & abs_time)
        {
            struct timespec const timeout=detail::get_timespec(abs_time);
            int const res=pthread_mutex_timedlock(&m,&timeout);
            ((!res || res==145) ? static_cast<void> (0) : __assert_fail ("!res || res==145", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp", 155, __PRETTY_FUNCTION__));
            return !res;
        }

        typedef pthread_mutex_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &m;
        }
# 212 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp"
        typedef unique_lock<timed_mutex> scoped_timed_lock;
        typedef detail::try_lock_wrapper<timed_mutex> scoped_try_lock;
        typedef scoped_timed_lock scoped_lock;
    };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 220 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/mutex.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/mutex.hpp" 2
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type.hpp"
namespace boost {



  template <class T>
  struct type {};

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/none.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/none.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/none_t.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/none_t.hpp"
namespace boost {

namespace detail { struct none_helper{}; }

typedef int detail::none_helper::*none_t ;

}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/none.hpp" 2





namespace boost {

none_t const none = ((none_t)0) ;

}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/compare_pointees.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/compare_pointees.hpp"
namespace boost {
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/compare_pointees.hpp"
template<class OptionalPointee>
inline
bool equal_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;
}

template<class OptionalPointee>
struct equal_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return equal_pointees(x,y) ; }
} ;
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/compare_pointees.hpp"
template<class OptionalPointee>
inline
bool less_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return !y ? false : ( !x ? true : (*x) < (*y) ) ;
}

template<class OptionalPointee>
struct less_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return less_pointees(x,y) ; }
} ;

}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional_fwd.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional_fwd.hpp"
namespace boost {

template<class T> class optional ;

}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp" 2
# 83 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
namespace boost_optional_detail
{
  template <class T, class Factory>
  void construct(Factory const& factory, void* address)
  {
    factory.template apply<T>(address);
  }
}


namespace boost {

class in_place_factory_base ;
class typed_in_place_factory_base ;

namespace optional_detail {





template <class T>
class aligned_storage
{

    union dummy_u
    {
        char data[ sizeof(T) ];
        typename type_with_alignment<
          ::boost::alignment_of<T>::value >::type aligner_;
    } dummy_ ;

  public:

    void const* address() const { return &dummy_.data[0]; }
    void * address() { return &dummy_.data[0]; }
} ;

template<class T>
struct types_when_isnt_ref
{
  typedef T const& reference_const_type ;
  typedef T & reference_type ;
  typedef T const* pointer_const_type ;
  typedef T * pointer_type ;
  typedef T const& argument_type ;
} ;
template<class T>
struct types_when_is_ref
{
  typedef typename remove_reference<T>::type raw_type ;

  typedef raw_type& reference_const_type ;
  typedef raw_type& reference_type ;
  typedef raw_type* pointer_const_type ;
  typedef raw_type* pointer_type ;
  typedef raw_type& argument_type ;
} ;

struct optional_tag {} ;

template<class T>
class optional_base : public optional_tag
{
  private :

    typedef

    typename

    ::boost::detail::make_reference_content<T>::type internal_type ;

    typedef aligned_storage<internal_type> storage_type ;

    typedef types_when_isnt_ref<T> types_when_not_ref ;
    typedef types_when_is_ref<T> types_when_ref ;

    typedef optional_base<T> this_type ;

  protected :

    typedef T value_type ;

    typedef mpl::true_ is_reference_tag ;
    typedef mpl::false_ is_not_reference_tag ;

    typedef typename is_reference<T>::type is_reference_predicate ;

  public:
    typedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;

  protected:
    typedef bool (this_type::*unspecified_bool_type)() const;

    typedef typename types::reference_type reference_type ;
    typedef typename types::reference_const_type reference_const_type ;
    typedef typename types::pointer_type pointer_type ;
    typedef typename types::pointer_const_type pointer_const_type ;
    typedef typename types::argument_type argument_type ;



    optional_base()
      :
      m_initialized(false) {}



    optional_base ( none_t )
      :
      m_initialized(false) {}



    optional_base ( argument_type val )
      :
      m_initialized(false)
    {
      construct(val);
    }



    optional_base ( bool cond, argument_type val )
      :
      m_initialized(false)
    {
      if ( cond )
        construct(val);
    }



    optional_base ( optional_base const& rhs )
      :
      m_initialized(false)
    {
      if ( rhs.is_initialized() )
        construct(rhs.get_impl());
    }





    template<class Expr>
    explicit optional_base ( Expr const& expr, Expr const* tag )
      :
      m_initialized(false)
    {
      construct(expr,tag);
    }




    ~optional_base() { destroy() ; }


    void assign ( optional_base const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(rhs.get_impl(), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(rhs.get_impl());
      }
    }


    template<class U>
    void assign ( optional<U> const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(static_cast<value_type>(rhs.get()));
      }
    }


    void assign ( argument_type val )
    {
      if (is_initialized())
           assign_value(val, is_reference_predicate() );
      else construct(val);
    }



    void assign ( none_t ) { destroy(); }


    template<class Expr>
    void assign_expr ( Expr const& expr, Expr const* tag )
      {
        if (is_initialized())
             assign_expr_to_initialized(expr,tag);
        else construct(expr,tag);
      }


  public :



    void reset() { destroy(); }


    void reset ( argument_type val ) { assign(val); }




    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }
    pointer_type get_ptr() { return m_initialized ? get_ptr_impl() : 0 ; }

    bool is_initialized() const { return m_initialized ; }

  protected :

    void construct ( argument_type val )
     {
       new (m_storage.address()) internal_type(val) ;
       m_initialized = true ;
     }



    template<class Expr>
    void construct ( Expr const& factory, in_place_factory_base const* )
     {
       typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((::boost::mpl::not_<is_reference_predicate>::value) == 0 ? false : true) >)> boost_static_assert_typedef_326 ;
       boost_optional_detail::construct<value_type>(factory, m_storage.address());
       m_initialized = true ;
     }


    template<class Expr>
    void construct ( Expr const& factory, typed_in_place_factory_base const* )
     {
       typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((::boost::mpl::not_<is_reference_predicate>::value) == 0 ? false : true) >)> boost_static_assert_typedef_335 ;
       factory.apply(m_storage.address()) ;
       m_initialized = true ;
     }

    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }


    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }






    template<class Expr>
    void construct ( Expr const& expr, void const* )
     {
       new (m_storage.address()) internal_type(expr) ;
       m_initialized = true ;
     }





    template<class Expr>
    void assign_expr_to_initialized ( Expr const& expr, void const* )
     {
       assign_value(expr, is_reference_predicate());
     }
# 404 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }
    void assign_value ( argument_type val, is_reference_tag ) { construct(val); }

    void destroy()
    {
      if ( m_initialized )
        destroy_impl(is_reference_predicate()) ;
    }

    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }

    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }
    reference_type get_impl() { return dereference(get_object(), is_reference_predicate() ) ; }

    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }
    pointer_type get_ptr_impl() { return cast_ptr(get_object(), is_reference_predicate() ) ; }

  private :


    internal_type const* get_object() const { return static_cast<internal_type const*>(m_storage.address()); }
    internal_type * get_object() { return static_cast<internal_type *> (m_storage.address()); }


    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }
    reference_type dereference( internal_type* p, is_not_reference_tag ) { return *p ; }
    reference_const_type dereference( internal_type const* p, is_reference_tag ) const { return p->get() ; }
    reference_type dereference( internal_type* p, is_reference_tag ) { return p->get() ; }




    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }


    void destroy_impl ( is_reference_tag ) { m_initialized = false ; }




    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }
    pointer_type cast_ptr( internal_type * p, is_not_reference_tag ) { return p ; }
    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag ) const { return &p->get() ; }
    pointer_type cast_ptr( internal_type * p, is_reference_tag ) { return &p->get() ; }

    bool m_initialized ;
    storage_type m_storage ;
} ;

}

template<class T>
class optional : public optional_detail::optional_base<T>
{
    typedef optional_detail::optional_base<T> base ;

    typedef typename base::unspecified_bool_type unspecified_bool_type ;

  public :

    typedef optional<T> this_type ;

    typedef typename base::value_type value_type ;
    typedef typename base::reference_type reference_type ;
    typedef typename base::reference_const_type reference_const_type ;
    typedef typename base::pointer_type pointer_type ;
    typedef typename base::pointer_const_type pointer_const_type ;
    typedef typename base::argument_type argument_type ;



    optional() : base() {}



    optional( none_t none_ ) : base(none_) {}



    optional ( argument_type val ) : base(val) {}



    optional ( bool cond, argument_type val ) : base(cond,val) {}







    template<class U>
    explicit optional ( optional<U> const& rhs )
      :
      base()
    {
      if ( rhs.is_initialized() )
        this->construct(rhs.get());
    }
# 515 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
    template<class Expr>
    explicit optional ( Expr const& expr ) : base(expr,&expr) {}




    optional ( optional const& rhs ) : base(rhs) {}


    ~optional() {}




    template<class Expr>
    optional& operator= ( Expr expr )
      {
        this->assign_expr(expr,&expr);
        return *this ;
      }







    template<class U>
    optional& operator= ( optional<U> const& rhs )
      {
        this->assign(rhs);
        return *this ;
      }





    optional& operator= ( optional const& rhs )
      {
        this->assign( rhs ) ;
        return *this ;
      }



    optional& operator= ( argument_type val )
      {
        this->assign( val ) ;
        return *this ;
      }




    optional& operator= ( none_t none_ )
      {
        this->assign( none_ ) ;
        return *this ;
      }




    reference_const_type get() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp", 579, __PRETTY_FUNCTION__)) ; return this->get_impl(); }
    reference_type get() { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp", 580, __PRETTY_FUNCTION__)) ; return this->get_impl(); }


    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }
    reference_type get_value_or ( reference_type v ) { return this->is_initialized() ? get() : v ; }




    pointer_const_type operator->() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp", 589, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }
    pointer_type operator->() { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp", 590, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }




    reference_const_type operator *() const { return this->get() ; }
    reference_type operator *() { return this->get() ; }



    operator unspecified_bool_type() const { return this->safe_bool() ; }



       bool operator!() const { return !this->is_initialized() ; }
} ;


template<class T>
inline
optional<T> make_optional ( T const& v )
{
  return optional<T>(v);
}


template<class T>
inline
optional<T> make_optional ( bool cond, T const& v )
{
  return optional<T>(cond,v);
}



template<class T>
inline
typename optional<T>::reference_const_type
get ( optional<T> const& opt )
{
  return opt.get() ;
}

template<class T>
inline
typename optional<T>::reference_type
get ( optional<T>& opt )
{
  return opt.get() ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get ( optional<T> const* opt )
{
  return opt->get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get ( optional<T>* opt )
{
  return opt->get_ptr() ;
}



template<class T>
inline
typename optional<T>::reference_const_type
get_optional_value_or ( optional<T> const& opt, typename optional<T>::reference_const_type v )
{
  return opt.get_value_or(v) ;
}

template<class T>
inline
typename optional<T>::reference_type
get_optional_value_or ( optional<T>& opt, typename optional<T>::reference_type v )
{
  return opt.get_value_or(v) ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get_pointer ( optional<T> const& opt )
{
  return opt.get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get_pointer ( optional<T>& opt )
{
  return opt.get_ptr() ;
}
# 703 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
template<class T>
inline
bool operator == ( optional<T> const& x, optional<T> const& y )
{ return equal_pointees(x,y); }

template<class T>
inline
bool operator < ( optional<T> const& x, optional<T> const& y )
{ return less_pointees(x,y); }

template<class T>
inline
bool operator != ( optional<T> const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, optional<T> const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( optional<T> const& x, T const& y )
{ return equal_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator < ( optional<T> const& x, T const& y )
{ return less_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator != ( optional<T> const& x, T const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, T const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, T const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, T const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( T const& x, optional<T> const& y )
{ return equal_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator < ( T const& x, optional<T> const& y )
{ return less_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator != ( T const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( T const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( T const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( T const& x, optional<T> const& y )
{ return !( x < y ) ; }






template<class T>
inline
bool operator == ( optional<T> const& x, none_t )
{ return equal_pointees(x, optional<T>() ); }

template<class T>
inline
bool operator < ( optional<T> const& x, none_t )
{ return less_pointees(x,optional<T>() ); }

template<class T>
inline
bool operator != ( optional<T> const& x, none_t y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, none_t y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, none_t y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, none_t y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( none_t x, optional<T> const& y )
{ return equal_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator < ( none_t x, optional<T> const& y )
{ return less_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator != ( none_t x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( none_t x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( none_t x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( none_t x, optional<T> const& y )
{ return !( x < y ) ; }





namespace optional_detail {
# 888 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional/optional.hpp"
template<class T>
inline
void optional_swap ( optional<T>& x, optional<T>& y )
{
  if ( !x && !!y )
  {
    x.reset(*y);
    y.reset();
  }
  else if ( !!x && !y )
  {
    y.reset(*x);
    x.reset();
  }
  else if ( !!x && !!y )
  {



    using std::swap ;

    swap(*x,*y);
  }
}

}

template<class T> inline void swap ( optional<T>& x, optional<T>& y )
{
  optional_detail::optional_swap(x,y);
}


}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/optional.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable_fwd.hpp" 1







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable_fwd.hpp" 2







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable_fwd.hpp" 2

namespace boost
{
    class condition_variable
    {
    private:
        pthread_cond_t cond;

        condition_variable(condition_variable&);
        condition_variable& operator=(condition_variable&);

    public:
        condition_variable()
        {
            int const res=pthread_cond_init(&cond,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
        }
        ~condition_variable()
        {
            ((!pthread_cond_destroy(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_destroy(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable_fwd.hpp", 39, __PRETTY_FUNCTION__));
        }

        void wait(unique_lock<mutex>& m);

        template<typename predicate_type>
        void wait(unique_lock<mutex>& m,predicate_type pred)
        {
            while(!pred()) wait(m);
        }

        inline bool timed_wait(unique_lock<mutex>& m,
                               boost::system_time const& wait_until);
        bool timed_wait(unique_lock<mutex>& m,xtime const& wait_until)
        {
            return timed_wait(m,system_time(wait_until));
        }

        template<typename duration_type>
        bool timed_wait(unique_lock<mutex>& m,duration_type const& wait_duration)
        {
            return timed_wait(m,get_system_time()+wait_duration);
        }

        template<typename predicate_type>
        bool timed_wait(unique_lock<mutex>& m,boost::system_time const& wait_until,predicate_type pred)
        {
            while (!pred())
            {
                if(!timed_wait(m, wait_until))
                    return pred();
            }
            return true;
        }

        template<typename predicate_type>
        bool timed_wait(unique_lock<mutex>& m,xtime const& wait_until,predicate_type pred)
        {
            return timed_wait(m,system_time(wait_until),pred);
        }

        template<typename duration_type,typename predicate_type>
        bool timed_wait(unique_lock<mutex>& m,duration_type const& wait_duration,predicate_type pred)
        {
            return timed_wait(m,get_system_time()+wait_duration,pred);
        }

        typedef pthread_cond_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &cond;
        }

        void notify_one();
        void notify_all();
    };
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable_fwd.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2

namespace boost
{
    class thread;

    namespace detail
    {
        struct tss_cleanup_function;
        struct thread_exit_callback_node;
        struct tss_data_node
        {
            boost::shared_ptr<boost::detail::tss_cleanup_function> func;
            void* value;

            tss_data_node(boost::shared_ptr<boost::detail::tss_cleanup_function> func_,
                          void* value_):
                func(func_),value(value_)
            {}
        };

        struct thread_data_base;
        typedef boost::shared_ptr<thread_data_base> thread_data_ptr;

        struct thread_data_base:
            enable_shared_from_this<thread_data_base>
        {
            thread_data_ptr self;
            pthread_t thread_handle;
            boost::mutex data_mutex;
            boost::condition_variable done_condition;
            boost::mutex sleep_mutex;
            boost::condition_variable sleep_condition;
            bool done;
            bool join_started;
            bool joined;
            boost::detail::thread_exit_callback_node* thread_exit_callbacks;
            std::map<void const*,boost::detail::tss_data_node> tss_data;
            bool interrupt_enabled;
            bool interrupt_requested;
            pthread_cond_t* current_cond;

            thread_data_base():
                done(false),join_started(false),joined(false),
                thread_exit_callbacks(0),
                interrupt_enabled(true),
                interrupt_requested(false),
                current_cond(0)
            {}
            virtual ~thread_data_base();

            typedef pthread_t native_handle_type;

            virtual void run()=0;
        };

        thread_data_base* get_current_thread_data();

        class interruption_checker
        {
            thread_data_base* const thread_info;

            void check_for_interruption()
            {
                if(thread_info->interrupt_requested)
                {
                    thread_info->interrupt_requested=false;
                    throw thread_interrupted();
                }
            }

            void operator=(interruption_checker&);
        public:
            explicit interruption_checker(pthread_cond_t* cond):
                thread_info(detail::get_current_thread_data())
            {
                if(thread_info && thread_info->interrupt_enabled)
                {
                    lock_guard<mutex> guard(thread_info->data_mutex);
                    check_for_interruption();
                    thread_info->current_cond=cond;
                }
            }
            ~interruption_checker()
            {
                if(thread_info && thread_info->interrupt_enabled)
                {
                    lock_guard<mutex> guard(thread_info->data_mutex);
                    thread_info->current_cond=__null;
                    check_for_interruption();
                }
            }
        };
    }

    namespace this_thread
    {
        void yield();

        void sleep(system_time const& abs_time);

        template<typename TimeDuration>
        inline void sleep(TimeDuration const& rel_time)
        {
            this_thread::sleep(get_system_time()+rel_time);
        }
    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 128 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_heap_alloc.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_heap_alloc.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_heap_alloc.hpp" 1







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_heap_alloc.hpp" 2

namespace boost
{
    namespace detail
    {
        template<typename T>
        inline T* heap_new()
        {
            return new T();
        }
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_heap_alloc.hpp"
        template<typename T,typename A1>
        inline T* heap_new_impl(A1 a1)
        {
            return new T(a1);
        }
        template<typename T,typename A1,typename A2>
        inline T* heap_new_impl(A1 a1,A2 a2)
        {
            return new T(a1,a2);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3)
        {
            return new T(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4)
        {
            return new T(a1,a2,a3,a4);
        }

        template<typename T,typename A1>
        inline T* heap_new(A1 const& a1)
        {
            return heap_new_impl<T,A1 const&>(a1);
        }
        template<typename T,typename A1>
        inline T* heap_new(A1& a1)
        {
            return heap_new_impl<T,A1&>(a1);
        }

        template<typename T,typename A1,typename A2>
        inline T* heap_new(A1 const& a1,A2 const& a2)
        {
            return heap_new_impl<T,A1 const&,A2 const&>(a1,a2);
        }
        template<typename T,typename A1,typename A2>
        inline T* heap_new(A1& a1,A2 const& a2)
        {
            return heap_new_impl<T,A1&,A2 const&>(a1,a2);
        }
        template<typename T,typename A1,typename A2>
        inline T* heap_new(A1 const& a1,A2& a2)
        {
            return heap_new_impl<T,A1 const&,A2&>(a1,a2);
        }
        template<typename T,typename A1,typename A2>
        inline T* heap_new(A1& a1,A2& a2)
        {
            return heap_new_impl<T,A1&,A2&>(a1,a2);
        }

        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1 const& a1,A2 const& a2,A3 const& a3)
        {
            return heap_new_impl<T,A1 const&,A2 const&,A3 const&>(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1& a1,A2 const& a2,A3 const& a3)
        {
            return heap_new_impl<T,A1&,A2 const&,A3 const&>(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1 const& a1,A2& a2,A3 const& a3)
        {
            return heap_new_impl<T,A1 const&,A2&,A3 const&>(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1& a1,A2& a2,A3 const& a3)
        {
            return heap_new_impl<T,A1&,A2&,A3 const&>(a1,a2,a3);
        }

        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1 const& a1,A2 const& a2,A3& a3)
        {
            return heap_new_impl<T,A1 const&,A2 const&,A3&>(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1& a1,A2 const& a2,A3& a3)
        {
            return heap_new_impl<T,A1&,A2 const&,A3&>(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1 const& a1,A2& a2,A3& a3)
        {
            return heap_new_impl<T,A1 const&,A2&,A3&>(a1,a2,a3);
        }
        template<typename T,typename A1,typename A2,typename A3>
        inline T* heap_new(A1& a1,A2& a2,A3& a3)
        {
            return heap_new_impl<T,A1&,A2&,A3&>(a1,a2,a3);
        }

        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2 const& a2,A3 const& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1 const&,A2 const&,A3 const&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2 const& a2,A3 const& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1&,A2 const&,A3 const&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2& a2,A3 const& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1 const&,A2&,A3 const&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2& a2,A3 const& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1&,A2&,A3 const&,A4 const&>(a1,a2,a3,a4);
        }

        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2 const& a2,A3& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1 const&,A2 const&,A3&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2 const& a2,A3& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1&,A2 const&,A3&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2& a2,A3& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1 const&,A2&,A3&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2& a2,A3& a3,A4 const& a4)
        {
            return heap_new_impl<T,A1&,A2&,A3&,A4 const&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2 const& a2,A3 const& a3,A4& a4)
        {
            return heap_new_impl<T,A1 const&,A2 const&,A3 const&,A4&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2 const& a2,A3 const& a3,A4& a4)
        {
            return heap_new_impl<T,A1&,A2 const&,A3 const&,A4&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2& a2,A3 const& a3,A4& a4)
        {
            return heap_new_impl<T,A1 const&,A2&,A3 const&,A4&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2& a2,A3 const& a3,A4& a4)
        {
            return heap_new_impl<T,A1&,A2&,A3 const&,A4&>(a1,a2,a3,a4);
        }

        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2 const& a2,A3& a3,A4& a4)
        {
            return heap_new_impl<T,A1 const&,A2 const&,A3&,A4&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2 const& a2,A3& a3,A4& a4)
        {
            return heap_new_impl<T,A1&,A2 const&,A3&,A4&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1 const& a1,A2& a2,A3& a3,A4& a4)
        {
            return heap_new_impl<T,A1 const&,A2&,A3&,A4&>(a1,a2,a3,a4);
        }
        template<typename T,typename A1,typename A2,typename A3,typename A4>
        inline T* heap_new(A1& a1,A2& a2,A3& a3,A4& a4)
        {
            return heap_new_impl<T,A1&,A2&,A3&,A4&>(a1,a2,a3,a4);
        }


        template<typename T>
        inline void heap_delete(T* data)
        {
            delete data;
        }

        template<typename T>
        struct do_heap_delete
        {
            void operator()(T* data) const
            {
                detail::heap_delete(data);
            }
        };
    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 241 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_heap_alloc.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_heap_alloc.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/list" 1 3
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/list" 3
       
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/list" 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y) throw ();

    void
    _M_transfer(_List_node_base * const __first,
  _List_node_base * const __last) throw ();

    void
    _M_reverse() throw ();

    void
    _M_hook(_List_node_base * const __position) throw ();

    void
    _M_unhook() throw ();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {

      _Tp _M_data;






    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 293 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }
# 359 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 416 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;







      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }
# 493 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(__a) { }
# 518 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 531 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 570 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 595 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 641 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 657 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 680 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 799 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
# 823 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 878 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 905 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 919 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 945 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 978 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1027 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 1047 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 1071 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 1092 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 1109 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1145 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x)

      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 1175 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x, iterator __i)

      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 1211 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void




      splice(iterator __position, list& __x, iterator __first,
      iterator __last)

      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 1246 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1260 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1274 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      unique();
# 1289 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1310 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1336 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);







      void
      reverse()
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }
# 1407 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }



      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->_M_hook(__position._M_node);
      }
# 1448 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
      void
      _M_erase(iterator __position)
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);



 _M_get_Tp_allocator().destroy(&__n->_M_data);

        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1481 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1510 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 64 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/list" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/list.tcc" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);



   _M_get_Tp_allocator().destroy(&__tmp->_M_data);

   _M_put_node(__tmp);
 }
    }
# 95 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (&*__first != &__value)
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::



    merge(list& __x)

    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::



      merge(list& __x, _StrictWeakOrdering __comp)

      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }

}
# 67 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/list" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mem_fn.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mem_fn.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/get_pointer.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/get_pointer.hpp"
namespace boost {



template<class T> T * get_pointer(T * p)
{
    return p;
}



template<class T> T * get_pointer(std::auto_ptr<T> const& p)
{
    return p.get();
}


}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp" 2


namespace boost
{
# 207 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp"
namespace _mfi
{






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn_template.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn_template.hpp"
template<class R, class T > class mf0
{
public:

    typedef R result_type;
    typedef T * argument_type;

private:

    typedef R ( T::*F) ();
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit mf0(F f): f_(f) {}

    R operator()(T * p) const
    {
        return (p->*f_)();
    }

    template<class U> R operator()(U & u) const
    {
        U const * p = 0;
        return call(u, p);
    }



    template<class U> R operator()(U const & u) const
    {
        U const * p = 0;
        return call(u, p);
    }



    R operator()(T & t) const
    {
        return (t.*f_)();
    }

    bool operator==(mf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T > class cmf0
{
public:

    typedef R result_type;
    typedef T const * argument_type;

private:

    typedef R ( T::*F) () const;
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit cmf0(F f): f_(f) {}

    template<class U> R operator()(U const & u) const
    {
        U const * p = 0;
        return call(u, p);
    }

    R operator()(T const & t) const
    {
        return (t.*f_)();
    }

    bool operator==(cmf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class mf1
{
public:

    typedef R result_type;
    typedef T * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1);
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit mf1(F f): f_(f) {}

    R operator()(T * p, A1 a1) const
    {
        return (p->*f_)(a1);
    }

    template<class U> R operator()(U & u, A1 a1) const
    {
        U const * p = 0;
        return call(u, p, a1);
    }



    template<class U> R operator()(U const & u, A1 a1) const
    {
        U const * p = 0;
        return call(u, p, a1);
    }



    R operator()(T & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(mf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class cmf1
{
public:

    typedef R result_type;
    typedef T const * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1) const;
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit cmf1(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1) const
    {
        U const * p = 0;
        return call(u, p, a1);
    }

    R operator()(T const & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(cmf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class mf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2);
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit mf2(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2) const
    {
        return (p->*f_)(a1, a2);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2) const
    {
        U const * p = 0;
        return call(u, p, a1, a2);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        U const * p = 0;
        return call(u, p, a1, a2);
    }



    R operator()(T & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(mf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class cmf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2) const;
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit cmf2(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        U const * p = 0;
        return call(u, p, a1, a2);
    }

    R operator()(T const & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(cmf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class mf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3);
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit mf3(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3) const
    {
        return (p->*f_)(a1, a2, a3);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(mf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class cmf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3) const;
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit cmf3(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(cmf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class mf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4);
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit mf4(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (p->*f_)(a1, a2, a3, a4);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(mf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class cmf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit cmf4(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(cmf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class mf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit mf5(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(mf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class cmf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit cmf5(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(cmf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class mf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit mf6(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(mf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class cmf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit cmf6(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(cmf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class mf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit mf7(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(mf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class cmf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit cmf7(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(cmf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class mf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit mf8(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(mf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class cmf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit cmf8(F f): f_(f) {}

    R operator()(T const * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7, a8);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(cmf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};
# 216 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp" 2
# 258 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp"
}
# 268 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn_cc.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn_cc.hpp"
template<class R, class T> _mfi::mf0<R, T> mem_fn(R ( T::*f) ())
{
    return _mfi::mf0<R, T>(f);
}

template<class R, class T> _mfi::cmf0<R, T> mem_fn(R ( T::*f) () const)
{
    return _mfi::cmf0<R, T>(f);
}

template<class R, class T, class A1> _mfi::mf1<R, T, A1> mem_fn(R ( T::*f) (A1))
{
    return _mfi::mf1<R, T, A1>(f);
}

template<class R, class T, class A1> _mfi::cmf1<R, T, A1> mem_fn(R ( T::*f) (A1) const)
{
    return _mfi::cmf1<R, T, A1>(f);
}

template<class R, class T, class A1, class A2> _mfi::mf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2))
{
    return _mfi::mf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2> _mfi::cmf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2) const)
{
    return _mfi::cmf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::mf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3))
{
    return _mfi::mf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::cmf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3) const)
{
    return _mfi::cmf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::mf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4))
{
    return _mfi::mf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::cmf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4) const)
{
    return _mfi::cmf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::mf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5))
{
    return _mfi::mf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::cmf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5) const)
{
    return _mfi::cmf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6))
{
    return _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6) const)
{
    return _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7))
{
    return _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7) const)
{
    return _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8))
{
    return _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8) const)
{
    return _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}
# 269 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp" 2
# 311 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/mem_fn.hpp"
namespace _mfi
{

template<class R, class T> class dm
{
public:

    typedef R const & result_type;
    typedef T const * argument_type;

private:

    typedef R (T::*F);
    F f_;

    template<class U> R const & call(U & u, T const *) const
    {
        return (u.*f_);
    }

    template<class U> R const & call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_);
    }

public:

    explicit dm(F f): f_(f) {}

    R & operator()(T * p) const
    {
        return (p->*f_);
    }

    R const & operator()(T const * p) const
    {
        return (p->*f_);
    }

    template<class U> R const & operator()(U const & u) const
    {
        return call(u, &u);
    }



    R & operator()(T & t) const
    {
        return (t.*f_);
    }

    R const & operator()(T const & t) const
    {
        return (t.*f_);
    }



    bool operator==(dm const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(dm const & rhs) const
    {
        return f_ != rhs.f_;
    }
};

}

template<class R, class T> _mfi::dm<R, T> mem_fn(R T::*f)
{
    return _mfi::dm<R, T>(f);
}

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mem_fn.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/is_placeholder.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/is_placeholder.hpp"
namespace boost
{

template< class T > struct is_placeholder
{
    enum _vt { value = 0 };
};

}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/arg.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/arg.hpp"
namespace boost
{

template< int I > struct arg
{
    arg()
    {
    }

    template< class T > arg( T const & )
    {

        typedef char T_must_be_placeholder[ I == is_placeholder<T>::value? 1: -1 ];
    }
};

template< int I > bool operator==( arg<I> const &, arg<I> const & )
{
    return true;
}



template< int I > struct is_placeholder< arg<I> >
{
    enum _vt { value = I };
};

template< int I > struct is_placeholder< arg<I> (*) () >
{
    enum _vt { value = I };
};



}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/visit_each.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/visit_each.hpp"
namespace boost {
  template<typename Visitor, typename T>
  inline void visit_each(Visitor& visitor, const T& t, long)
  {
    visitor(t);
  }

  template<typename Visitor, typename T>
  inline void visit_each(Visitor& visitor, const T& t)
  {
    visit_each(visitor, t, 0);
  }
}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/storage.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/storage.hpp"
namespace boost
{

namespace _bi
{



template<class A1> struct storage1
{
    explicit storage1( A1 a1 ): a1_( a1 ) {}

    template<class V> void accept(V & v) const
    {
        visit_each(v, a1_, 0);
    }

    A1 a1_;
};



template<int I> struct storage1< boost::arg<I> >
{
    explicit storage1( boost::arg<I> ) {}

    template<class V> void accept(V &) const { }

    static boost::arg<I> a1_() { return boost::arg<I>(); }
};

template<int I> struct storage1< boost::arg<I> (*) () >
{
    explicit storage1( boost::arg<I> (*) () ) {}

    template<class V> void accept(V &) const { }

    static boost::arg<I> a1_() { return boost::arg<I>(); }
};





template<class A1, class A2> struct storage2: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, A2 a2 ): storage1<A1>( a1 ), a2_( a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a2_, 0);
    }

    A2 a2_;
};



template<class A1, int I> struct storage2< A1, boost::arg<I> >: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, boost::arg<I> ): storage1<A1>( a1 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a2_() { return boost::arg<I>(); }
};

template<class A1, int I> struct storage2< A1, boost::arg<I> (*) () >: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, boost::arg<I> (*) () ): storage1<A1>( a1 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a2_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3> struct storage3: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, A3 a3 ): storage2<A1, A2>( a1, a2 ), a3_( a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a3_, 0);
    }

    A3 a3_;
};



template<class A1, class A2, int I> struct storage3< A1, A2, boost::arg<I> >: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, boost::arg<I> ): storage2<A1, A2>( a1, a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a3_() { return boost::arg<I>(); }
};

template<class A1, class A2, int I> struct storage3< A1, A2, boost::arg<I> (*) () >: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, boost::arg<I> (*) () ): storage2<A1, A2>( a1, a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a3_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4> struct storage4: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, A4 a4 ): storage3<A1, A2, A3>( a1, a2, a3 ), a4_( a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a4_, 0);
    }

    A4 a4_;
};



template<class A1, class A2, class A3, int I> struct storage4< A1, A2, A3, boost::arg<I> >: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, boost::arg<I> ): storage3<A1, A2, A3>( a1, a2, a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a4_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, int I> struct storage4< A1, A2, A3, boost::arg<I> (*) () >: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, boost::arg<I> (*) () ): storage3<A1, A2, A3>( a1, a2, a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a4_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5> struct storage5: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ), a5_( a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a5_, 0);
    }

    A5 a5_;
};



template<class A1, class A2, class A3, class A4, int I> struct storage5< A1, A2, A3, A4, boost::arg<I> >: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I> ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a5_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, int I> struct storage5< A1, A2, A3, A4, boost::arg<I> (*) () >: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I> (*) () ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a5_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6> struct storage6: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ), a6_( a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a6_, 0);
    }

    A6 a6_;
};



template<class A1, class A2, class A3, class A4, class A5, int I> struct storage6< A1, A2, A3, A4, A5, boost::arg<I> >: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I> ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a6_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, int I> struct storage6< A1, A2, A3, A4, A5, boost::arg<I> (*) () >: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I> (*) () ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a6_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct storage7: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ), a7_( a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a7_, 0);
    }

    A7 a7_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, int I> struct storage7< A1, A2, A3, A4, A5, A6, boost::arg<I> >: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I> ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a7_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, int I> struct storage7< A1, A2, A3, A4, A5, A6, boost::arg<I> (*) () >: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I> (*) () ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a7_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> struct storage8: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8 ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ), a8_( a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a8_, 0);
    }

    A8 a8_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I> struct storage8< A1, A2, A3, A4, A5, A6, A7, boost::arg<I> >: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I> ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a8_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I> struct storage8< A1, A2, A3, A4, A5, A6, A7, boost::arg<I> (*) () >: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I> (*) () ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a8_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> struct storage9: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9 ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ), a9_( a9 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a9_, 0);
    }

    A9 a9_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I> struct storage9< A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> >: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I> ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a9_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I> struct storage9< A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> (*) () >: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I> (*) () ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a9_() { return boost::arg<I>(); }
};



}

}
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2






namespace boost
{

template<class T> class weak_ptr;

namespace _bi
{



template<class R, class F> struct result_traits
{
    typedef R type;
};



struct unspecified {};

template<class F> struct result_traits<unspecified, F>
{
    typedef typename F::result_type type;
};

template<class F> struct result_traits< unspecified, reference_wrapper<F> >
{
    typedef typename F::result_type type;
};





template<class T> bool ref_compare( T const & a, T const & b, long )
{
    return a == b;
}

template<int I> bool ref_compare( arg<I> const &, arg<I> const &, int )
{
    return true;
}

template<int I> bool ref_compare( arg<I> (*) (), arg<I> (*) (), int )
{
    return true;
}

template<class T> bool ref_compare( reference_wrapper<T> const & a, reference_wrapper<T> const & b, int )
{
    return a.get_pointer() == b.get_pointer();
}



template<class R, class F, class L> class bind_t;

template<class R, class F, class L> bool ref_compare( bind_t<R, F, L> const & a, bind_t<R, F, L> const & b, int )
{
    return a.compare( b );
}



template<class T> class value
{
public:

    value(T const & t): t_(t) {}

    T & get() { return t_; }
    T const & get() const { return t_; }

    bool operator==(value const & rhs) const
    {
        return t_ == rhs.t_;
    }

private:

    T t_;
};



template<class T> bool ref_compare( value< weak_ptr<T> > const & a, value< weak_ptr<T> > const & b, int )
{
    return !(a.get() < b.get()) && !(b.get() < a.get());
}



template<class T> class type {};



template<class F> struct unwrapper
{
    static inline F & unwrap( F & f, long )
    {
        return f;
    }

    template<class F2> static inline F2 & unwrap( reference_wrapper<F2> rf, int )
    {
        return rf.get();
    }

    template<class R, class T> static inline _mfi::dm<R, T> unwrap( R T::* pm, int )
    {
        return _mfi::dm<R, T>( pm );
    }
};



class list0
{
public:

    list0() {}

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A &, long)
    {
        return unwrapper<F>::unwrap(f, 0)();
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A &, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)();
    }

    template<class F, class A> void operator()(type<void>, F & f, A &, int)
    {
        unwrapper<F>::unwrap(f, 0)();
    }

    template<class F, class A> void operator()(type<void>, F const & f, A &, int) const
    {
        unwrapper<F const>::unwrap(f, 0)();
    }

    template<class V> void accept(V &) const
    {
    }

    bool operator==(list0 const &) const
    {
        return true;
    }
};
# 217 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template< class A1 > class list1: private storage1< A1 >
{
private:

    typedef storage1< A1 > base_type;

public:

    explicit list1( A1 a1 ): base_type( a1 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list1 const & rhs) const
    {
        return ref_compare(base_type::a1_, rhs.a1_, 0);
    }
};

struct logical_and;
struct logical_or;

template< class A1, class A2 > class list2: private storage2< A1, A2 >
{
private:

    typedef storage2< A1, A2 > base_type;

public:

    list2( A1 a1, A2 a2 ): base_type( a1, a2 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class A> bool operator()( type<bool>, logical_and & , A & a, int )
    {
        return a[ base_type::a1_ ] && a[ base_type::a2_ ];
    }

    template<class A> bool operator()( type<bool>, logical_and const & , A & a, int ) const
    {
        return a[ base_type::a1_ ] && a[ base_type::a2_ ];
    }

    template<class A> bool operator()( type<bool>, logical_or & , A & a, int )
    {
        return a[ base_type::a1_ ] || a[ base_type::a2_ ];
    }

    template<class A> bool operator()( type<bool>, logical_or const & , A & a, int ) const
    {
        return a[ base_type::a1_ ] || a[ base_type::a2_ ];
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list2 const & rhs) const
    {
        return ref_compare(base_type::a1_, rhs.a1_, 0) && ref_compare(base_type::a2_, rhs.a2_, 0);
    }
};

template< class A1, class A2, class A3 > class list3: private storage3< A1, A2, A3 >
{
private:

    typedef storage3< A1, A2, A3 > base_type;

public:

    list3( A1 a1, A2 a2, A3 a3 ): base_type( a1, a2, a3 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list3 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 );
    }
};

template< class A1, class A2, class A3, class A4 > class list4: private storage4< A1, A2, A3, A4 >
{
private:

    typedef storage4< A1, A2, A3, A4 > base_type;

public:

    list4( A1 a1, A2 a2, A3 a3, A4 a4 ): base_type( a1, a2, a3, a4 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list4 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 );
    }
};

template< class A1, class A2, class A3, class A4, class A5 > class list5: private storage5< A1, A2, A3, A4, A5 >
{
private:

    typedef storage5< A1, A2, A3, A4, A5 > base_type;

public:

    list5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): base_type( a1, a2, a3, a4, a5 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list5 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6> class list6: private storage6< A1, A2, A3, A4, A5, A6 >
{
private:

    typedef storage6< A1, A2, A3, A4, A5, A6 > base_type;

public:

    list6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): base_type( a1, a2, a3, a4, a5, a6 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list6 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> class list7: private storage7< A1, A2, A3, A4, A5, A6, A7 >
{
private:

    typedef storage7< A1, A2, A3, A4, A5, A6, A7 > base_type;

public:

    list7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): base_type( a1, a2, a3, a4, a5, a6, a7 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list7 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class list8: private storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
private:

    typedef storage8< A1, A2, A3, A4, A5, A6, A7, A8 > base_type;

public:

    list8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8 ): base_type( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8>) const { return base_type::a8_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8> (*) ()) const { return base_type::a8_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list8 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 ) &&
            ref_compare( base_type::a8_, rhs.a8_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> class list9: private storage9< A1, A2, A3, A4, A5, A6, A7, A8, A9 >
{
private:

    typedef storage9< A1, A2, A3, A4, A5, A6, A7, A8, A9 > base_type;

public:

    list9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9 ): base_type( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8>) const { return base_type::a8_; }
    A9 operator[] (boost::arg<9>) const { return base_type::a9_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8> (*) ()) const { return base_type::a8_; }
    A9 operator[] (boost::arg<9> (*) ()) const { return base_type::a9_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list9 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 ) &&
            ref_compare( base_type::a8_, rhs.a8_, 0 ) &&
            ref_compare( base_type::a9_, rhs.a9_, 0 );
    }
};
# 864 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template<class R, class F, class L> class bind_t
{
public:

    typedef bind_t this_type;

    bind_t(F f, L const & l): f_(f), l_(l) {}


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_template.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_template.hpp"
    typedef typename result_traits<R, F>::type result_type;

    result_type operator()()
    {
        list0 a;
        return l_(type<result_type>(), f_, a, 0);
    }

    result_type operator()() const
    {
        list0 a;
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1> result_type operator()(A1 & a1)
    {
        list1<A1 &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1> result_type operator()(A1 & a1) const
    {
        list1<A1 &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1> result_type operator()(A1 const & a1)
    {
        list1<A1 const &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1> result_type operator()(A1 const & a1) const
    {
        list1<A1 const &> a(a1);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2> result_type operator()(A1 & a1, A2 & a2)
    {
        list2<A1 &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 & a2) const
    {
        list2<A1 &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2> result_type operator()(A1 const & a1, A2 & a2)
    {
        list2<A1 const &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 & a2) const
    {
        list2<A1 const &, A2 &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }


    template<class A1, class A2> result_type operator()(A1 & a1, A2 const & a2)
    {
        list2<A1 &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 const & a2) const
    {
        list2<A1 &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }


    template<class A1, class A2> result_type operator()(A1 const & a1, A2 const & a2)
    {
        list2<A1 const &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 const & a2) const
    {
        list2<A1 const &, A2 const &> a(a1, a2);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3> result_type operator()(A1 & a1, A2 & a2, A3 & a3)
    {
        list3<A1 &, A2 &, A3 &> a(a1, a2, a3);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3> result_type operator()(A1 & a1, A2 & a2, A3 & a3) const
    {
        list3<A1 &, A2 &, A3 &> a(a1, a2, a3);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3)
    {
        list3<A1 const &, A2 const &, A3 const &> a(a1, a2, a3);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3) const
    {
        list3<A1 const &, A2 const &, A3 const &> a(a1, a2, a3);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3, class A4> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4)
    {
        list4<A1 &, A2 &, A3 &, A4 &> a(a1, a2, a3, a4);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4) const
    {
        list4<A1 &, A2 &, A3 &, A4 &> a(a1, a2, a3, a4);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3, class A4> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4)
    {
        list4<A1 const &, A2 const &, A3 const &, A4 const &> a(a1, a2, a3, a4);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4) const
    {
        list4<A1 const &, A2 const &, A3 const &, A4 const &> a(a1, a2, a3, a4);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5)
    {
        list5<A1 &, A2 &, A3 &, A4 &, A5 &> a(a1, a2, a3, a4, a5);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5) const
    {
        list5<A1 &, A2 &, A3 &, A4 &, A5 &> a(a1, a2, a3, a4, a5);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5)
    {
        list5<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &> a(a1, a2, a3, a4, a5);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5) const
    {
        list5<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &> a(a1, a2, a3, a4, a5);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6)
    {
        list6<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &> a(a1, a2, a3, a4, a5, a6);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6) const
    {
        list6<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &> a(a1, a2, a3, a4, a5, a6);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6)
    {
        list6<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &> a(a1, a2, a3, a4, a5, a6);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6) const
    {
        list6<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &> a(a1, a2, a3, a4, a5, a6);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7)
    {
        list7<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &> a(a1, a2, a3, a4, a5, a6, a7);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7) const
    {
        list7<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &> a(a1, a2, a3, a4, a5, a6, a7);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7)
    {
        list7<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &, A7 const &> a(a1, a2, a3, a4, a5, a6, a7);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7) const
    {
        list7<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &, A7 const &> a(a1, a2, a3, a4, a5, a6, a7);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8)
    {
        list8<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &> a(a1, a2, a3, a4, a5, a6, a7, a8);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8) const
    {
        list8<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &> a(a1, a2, a3, a4, a5, a6, a7, a8);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8)
    {
        list8<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &, A7 const &, A8 const &> a(a1, a2, a3, a4, a5, a6, a7, a8);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8) const
    {
        list8<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &, A7 const &, A8 const &> a(a1, a2, a3, a4, a5, a6, a7, a8);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9)
    {
        list9<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &, A9 &> a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9) const
    {
        list9<A1 &, A2 &, A3 &, A4 &, A5 &, A6 &, A7 &, A8 &, A9 &> a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
        return l_(type<result_type>(), f_, a, 0);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8, A9 const & a9)
    {
        list9<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &, A7 const &, A8 const &, A9 const &> a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8, A9 const & a9) const
    {
        list9<A1 const &, A2 const &, A3 const &, A4 const &, A5 const &, A6 const &, A7 const &, A8 const &, A9 const &> a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
        return l_(type<result_type>(), f_, a, 0);
    }



    template<class A> result_type eval(A & a)
    {
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A> result_type eval(A & a) const
    {
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class V> void accept(V & v) const
    {


        using boost::visit_each;


        visit_each(v, f_, 0);
        l_.accept(v);
    }

    bool compare(this_type const & rhs) const
    {
        return ref_compare(f_, rhs.f_, 0) && l_ == rhs.l_;
    }

private:

    F f_;
    L l_;
# 874 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2


};
# 940 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template<class R, class F, class L> bool function_equal( bind_t<R, F, L> const & a, bind_t<R, F, L> const & b )
{
    return a.compare(b);
}
# 994 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template< class T, int I > struct add_value_2
{
    typedef boost::arg<I> type;
};

template< class T > struct add_value_2< T, 0 >
{
    typedef _bi::value< T > type;
};

template<class T> struct add_value
{
    typedef typename add_value_2< T, boost::is_placeholder< T >::value >::type type;
};



template<class T> struct add_value< value<T> >
{
    typedef _bi::value<T> type;
};

template<class T> struct add_value< reference_wrapper<T> >
{
    typedef reference_wrapper<T> type;
};

template<int I> struct add_value< arg<I> >
{
    typedef boost::arg<I> type;
};

template<int I> struct add_value< arg<I> (*) () >
{
    typedef boost::arg<I> (*type) ();
};

template<class R, class F, class L> struct add_value< bind_t<R, F, L> >
{
    typedef bind_t<R, F, L> type;
};
# 1077 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template<class A1> struct list_av_1
{
    typedef typename add_value<A1>::type B1;
    typedef list1<B1> type;
};

template<class A1, class A2> struct list_av_2
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef list2<B1, B2> type;
};

template<class A1, class A2, class A3> struct list_av_3
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef list3<B1, B2, B3> type;
};

template<class A1, class A2, class A3, class A4> struct list_av_4
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef list4<B1, B2, B3, B4> type;
};

template<class A1, class A2, class A3, class A4, class A5> struct list_av_5
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef list5<B1, B2, B3, B4, B5> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6> struct list_av_6
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef list6<B1, B2, B3, B4, B5, B6> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct list_av_7
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef list7<B1, B2, B3, B4, B5, B6, B7> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> struct list_av_8
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef typename add_value<A8>::type B8;
    typedef list8<B1, B2, B3, B4, B5, B6, B7, B8> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> struct list_av_9
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef typename add_value<A8>::type B8;
    typedef typename add_value<A9>::type B9;
    typedef list9<B1, B2, B3, B4, B5, B6, B7, B8, B9> type;
};



struct logical_not
{
    template<class V> bool operator()(V const & v) const { return !v; }
};

template<class R, class F, class L>
    bind_t< bool, logical_not, list1< bind_t<R, F, L> > >
    operator! (bind_t<R, F, L> const & f)
{
    typedef list1< bind_t<R, F, L> > list_type;
    return bind_t<bool, logical_not, list_type> ( logical_not(), list_type(f) );
}
# 1200 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
struct equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v == w; } }; template<class R, class F, class L, class A2> bind_t< bool, equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator == (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, equal, list_type> ( equal(), list_type(f, a2) ); }
struct not_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v != w; } }; template<class R, class F, class L, class A2> bind_t< bool, not_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator != (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, not_equal, list_type> ( not_equal(), list_type(f, a2) ); }

struct less { template<class V, class W> bool operator()(V const & v, W const & w) const { return v < w; } }; template<class R, class F, class L, class A2> bind_t< bool, less, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator < (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, less, list_type> ( less(), list_type(f, a2) ); }
struct less_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v <= w; } }; template<class R, class F, class L, class A2> bind_t< bool, less_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator <= (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, less_equal, list_type> ( less_equal(), list_type(f, a2) ); }

struct greater { template<class V, class W> bool operator()(V const & v, W const & w) const { return v > w; } }; template<class R, class F, class L, class A2> bind_t< bool, greater, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator > (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, greater, list_type> ( greater(), list_type(f, a2) ); }
struct greater_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v >= w; } }; template<class R, class F, class L, class A2> bind_t< bool, greater_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator >= (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, greater_equal, list_type> ( greater_equal(), list_type(f, a2) ); }

struct logical_and { template<class V, class W> bool operator()(V const & v, W const & w) const { return v && w; } }; template<class R, class F, class L, class A2> bind_t< bool, logical_and, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator && (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, logical_and, list_type> ( logical_and(), list_type(f, a2) ); }
struct logical_or { template<class V, class W> bool operator()(V const & v, W const & w) const { return v || w; } }; template<class R, class F, class L, class A2> bind_t< bool, logical_or, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator || (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, logical_or, list_type> ( logical_or(), list_type(f, a2) ); }
# 1240 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template<class V, class T> void visit_each( V & v, value<T> const & t, int )
{
    using boost::visit_each;
    visit_each( v, t.get(), 0 );
}

template<class V, class R, class F, class L> void visit_each( V & v, bind_t<R, F, L> const & t, int )
{
    t.accept( v );
}



}
# 1274 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template< class T > struct is_bind_expression
{
    enum _vt { value = 0 };
};



template< class R, class F, class L > struct is_bind_expression< _bi::bind_t< R, F, L > >
{
    enum _vt { value = 1 };
};
# 1296 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
template<class R, class F>
    _bi::bind_t<R, F, _bi::list0>
    bind(F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class F, class A1>
    _bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>
    bind(F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class F, class A1, class A2>
    _bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>
    bind(F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R, class F, class A1, class A2, class A3>
    _bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R, class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}



template<class R, class F>
    _bi::bind_t<R, F, _bi::list0>
    bind(boost::type<R>, F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class F, class A1>
    _bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>
    bind(boost::type<R>, F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class F, class A1, class A2>
    _bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R, class F, class A1, class A2, class A3>
    _bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R, class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}





template<class F>
    _bi::bind_t<_bi::unspecified, F, _bi::list0>
    bind(F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type());
}

template<class F, class A1>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_1<A1>::type>
    bind(F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type(a1));
}

template<class F, class A1, class A2>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_2<A1, A2>::type>
    bind(F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type(a1, a2));
}

template<class F, class A1, class A2, class A3>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3));
}

template<class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1549 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_cc.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_cc.hpp"
template<class R>
    _bi::bind_t<R, R ( *) (), _bi::list0>
    bind( R ( *f) ())
{
    typedef R ( *F) ();
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class B1, class A1>
    _bi::bind_t<R, R ( *) (B1), typename _bi::list_av_1<A1>::type>
    bind( R ( *f) (B1), A1 a1)
{
    typedef R ( *F) (B1);
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class B1, class B2, class A1, class A2>
    _bi::bind_t<R, R ( *) (B1, B2), typename _bi::list_av_2<A1, A2>::type>
    bind( R ( *f) (B1, B2), A1 a1, A2 a2)
{
    typedef R ( *F) (B1, B2);
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R,
    class B1, class B2, class B3,
    class A1, class A2, class A3>
    _bi::bind_t<R, R ( *) (B1, B2, B3), typename _bi::list_av_3<A1, A2, A3>::type>
    bind( R ( *f) (B1, B2, B3), A1 a1, A2 a2, A3 a3)
{
    typedef R ( *F) (B1, B2, B3);
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4), typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind( R ( *f) (B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef R ( *F) (B1, B2, B3, B4);
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5), typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef R ( *F) (B1, B2, B3, B4, B5);
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6), typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6);
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7), typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7);
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7, B8), typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7, B8);
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class B9,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7, B8, B9), typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7, B8, B9), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7, B8, B9);
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1550 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2
# 1595 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_mf_cc.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_mf_cc.hpp"
template<class R, class T,
    class A1>
    _bi::bind_t<R, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(R ( T::*f) (), A1 a1)
{
    typedef _mfi::mf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
}

template<class R, class T,
    class A1>
    _bi::bind_t<R, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(R ( T::*f) () const, A1 a1)
{
    typedef _mfi::cmf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
}



template<class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<R, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(R ( T::*f) (B1), A1 a1, A2 a2)
{
    typedef _mfi::mf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
}

template<class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<R, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(R ( T::*f) (B1) const, A1 a1, A2 a2)
{
    typedef _mfi::cmf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
}



template<class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<R, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(R ( T::*f) (B1, B2), A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::mf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<R, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(R ( T::*f) (B1, B2) const, A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::cmf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
}



template<class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(R ( T::*f) (B1, B2, B3), A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::mf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(R ( T::*f) (B1, B2, B3) const, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::cmf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}



template<class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(R ( T::*f) (B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::mf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(R ( T::*f) (B1, B2, B3, B4) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::cmf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1596 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_mf2_cc.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind_mf2_cc.hpp"
template<class Rt2, class R, class T,
    class A1>
    _bi::bind_t<Rt2, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(boost::type<Rt2>, R ( T::*f) (), A1 a1)
{
    typedef _mfi::mf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
}

template<class Rt2, class R, class T,
    class A1>
    _bi::bind_t<Rt2, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(boost::type<Rt2>, R ( T::*f) () const, A1 a1)
{
    typedef _mfi::cmf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
}



template<class Rt2, class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<Rt2, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1), A1 a1, A2 a2)
{
    typedef _mfi::mf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
}

template<class Rt2, class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<Rt2, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1) const, A1 a1, A2 a2)
{
    typedef _mfi::cmf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
}



template<class Rt2, class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<Rt2, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2), A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::mf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class Rt2, class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<Rt2, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2) const, A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::cmf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<Rt2, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3), A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::mf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<Rt2, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3) const, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::cmf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<Rt2, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::mf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<Rt2, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::cmf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<Rt2, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<Rt2, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<Rt2, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<Rt2, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<Rt2, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<Rt2, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<Rt2, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<Rt2, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 1597 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2
# 1656 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp"
namespace _bi
{

template< class Pm, int I > struct add_cref;

template< class M, class T > struct add_cref< M T::*, 0 >
{
    typedef M type;
};

template< class M, class T > struct add_cref< M T::*, 1 >
{




    typedef M const & type;



};

template< class R, class T > struct add_cref< R (T::*) (), 1 >
{
    typedef void type;
};



template< class R, class T > struct add_cref< R (T::*) () const, 1 >
{
    typedef void type;
};



template<class R> struct isref
{
    enum value_type { value = 0 };
};

template<class R> struct isref< R& >
{
    enum value_type { value = 1 };
};

template<class R> struct isref< R* >
{
    enum value_type { value = 1 };
};

template<class Pm, class A1> struct dm_result
{
    typedef typename add_cref< Pm, 1 >::type type;
};

template<class Pm, class R, class F, class L> struct dm_result< Pm, bind_t<R, F, L> >
{
    typedef typename bind_t<R, F, L>::result_type result_type;
    typedef typename add_cref< Pm, isref< result_type >::value >::type type;
};

}

template< class A1, class M, class T >

_bi::bind_t<
    typename _bi::dm_result< M T::*, A1 >::type,
    _mfi::dm<M, T>,
    typename _bi::list_av_1<A1>::type
>

bind( M T::*f, A1 a1 )
{
    typedef typename _bi::dm_result< M T::*, A1 >::type result_type;
    typedef _mfi::dm<M, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t< result_type, F, list_type >( F( f ), list_type( a1 ) );
}



}



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/placeholders.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/placeholders.hpp"
namespace
{
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/placeholders.hpp"
boost::arg<1> _1;
boost::arg<2> _2;
boost::arg<3> _3;
boost::arg<4> _4;
boost::arg<5> _5;
boost::arg<6> _6;
boost::arg<7> _7;
boost::arg<8> _8;
boost::arg<9> _9;



}
# 1743 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind/bind.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/bind.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2






namespace boost
{
    namespace detail
    {
        template<typename F>
        class thread_data:
            public detail::thread_data_base
        {
        public:
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
            thread_data(F f_):
                f(f_)
            {}
            thread_data(detail::thread_move_t<F> f_):
                f(f_)
            {}

            void run()
            {
                f();
            }
        private:
            F f;

            void operator=(thread_data&);
            thread_data(thread_data&);
        };

        template<typename F>
        class thread_data<boost::reference_wrapper<F> >:
            public detail::thread_data_base
        {
        private:
            F& f;

            void operator=(thread_data&);
            thread_data(thread_data&);
        public:
            thread_data(boost::reference_wrapper<F> f_):
                f(f_)
            {}

            void run()
            {
                f();
            }
        };

        template<typename F>
        class thread_data<const boost::reference_wrapper<F> >:
            public detail::thread_data_base
        {
        private:
            F& f;
            void operator=(thread_data&);
            thread_data(thread_data&);
        public:
            thread_data(const boost::reference_wrapper<F> f_):
                f(f_)
            {}

            void run()
            {
                f();
            }
        };
    }

    class thread
    {
    private:
        thread(thread&);
        thread& operator=(thread&);

        void release_handle();

        detail::thread_data_ptr thread_info;

        void start_thread();

        explicit thread(detail::thread_data_ptr data);

        detail::thread_data_ptr get_thread_info () const;
# 137 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
        template<typename F>
        static inline detail::thread_data_ptr make_thread_info(F f)
        {
            return detail::thread_data_ptr(detail::heap_new<detail::thread_data<F> >(f));
        }
        template<typename F>
        static inline detail::thread_data_ptr make_thread_info(boost::detail::thread_move_t<F> f)
        {
            return detail::thread_data_ptr(detail::heap_new<detail::thread_data<F> >(f));
        }


        struct dummy;
    public:



        thread();
        ~thread();
# 200 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
        template <class F>
        explicit thread(F f,typename disable_if<boost::is_convertible<F&,detail::thread_move_t<F> >, dummy* >::type=0):
            thread_info(make_thread_info(f))
        {
            start_thread();
        }


        template <class F>
        explicit thread(detail::thread_move_t<F> f):
            thread_info(make_thread_info(f))
        {
            start_thread();
        }

        thread(detail::thread_move_t<thread> x)
        {
            thread_info=x->thread_info;
            x->thread_info.reset();
        }
# 228 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
        thread& operator=(detail::thread_move_t<thread> x)
        {
            thread new_thread(x);
            swap(new_thread);
            return *this;
        }

        operator detail::thread_move_t<thread>()
        {
            return move();
        }

        detail::thread_move_t<thread> move()
        {
            detail::thread_move_t<thread> x(*this);
            return x;
        }



        template <class F,class A1>
        thread(F f,A1 a1):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1)))
        {
            start_thread();
        }
        template <class F,class A1,class A2>
        thread(F f,A1 a1,A2 a2):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3>
        thread(F f,A1 a1,A2 a2,A3 a3):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3,class A4>
        thread(F f,A1 a1,A2 a2,A3 a3,A4 a4):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3,class A4,class A5>
        thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3,class A4,class A5,class A6>
        thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7>
        thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7,class A8>
        thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7,a8)))
        {
            start_thread();
        }

        template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7,class A8,class A9>
        thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8,A9 a9):
            thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7,a8,a9)))
        {
            start_thread();
        }

        void swap(thread& x)
        {
            thread_info.swap(x.thread_info);
        }

        class id;
        id get_id() const;


        bool joinable() const;
        void join();
        bool timed_join(const system_time& wait_until);

        template<typename TimeDuration>
        inline bool timed_join(TimeDuration const& rel_time)
        {
            return timed_join(get_system_time()+rel_time);
        }
        void detach();

        static unsigned hardware_concurrency();

        typedef detail::thread_data_base::native_handle_type native_handle_type;
        native_handle_type native_handle();


        bool operator==(const thread& other) const;
        bool operator!=(const thread& other) const;

        static inline void yield()
        {
            this_thread::yield();
        }

        static inline void sleep(const system_time& xt)
        {
            this_thread::sleep(xt);
        }


        void interrupt();
        bool interruption_requested() const;
    };

    inline void swap(thread& lhs,thread& rhs)
    {
        return lhs.swap(rhs);
    }
# 369 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
    inline detail::thread_move_t<thread> move(detail::thread_move_t<thread> t)
    {
        return t;
    }


    namespace this_thread
    {
        thread::id get_id();

        void interruption_point();
        bool interruption_enabled();
        bool interruption_requested();

        inline void sleep(xtime const& abs_time)
        {
            sleep(system_time(abs_time));
        }
    }

    class thread::id
    {
    private:
        detail::thread_data_ptr thread_data;

        id(detail::thread_data_ptr thread_data_):
            thread_data(thread_data_)
        {}
        friend class thread;
        friend id this_thread::get_id();
    public:
        id():
            thread_data()
        {}

        bool operator==(const id& y) const
        {
            return thread_data==y.thread_data;
        }

        bool operator!=(const id& y) const
        {
            return thread_data!=y.thread_data;
        }

        bool operator<(const id& y) const
        {
            return thread_data<y.thread_data;
        }

        bool operator>(const id& y) const
        {
            return y.thread_data<thread_data;
        }

        bool operator<=(const id& y) const
        {
            return !(y.thread_data<thread_data);
        }

        bool operator>=(const id& y) const
        {
            return !(thread_data<y.thread_data);
        }



        template<class charT, class traits>
        friend std::basic_ostream<charT, traits>&
        operator<<(std::basic_ostream<charT, traits>& os, const id& x)
        {
            if(x.thread_data)
            {
                return os<<x.thread_data;
            }
            else
            {
                return os<<"{Not-any-thread}";
            }
        }
# 466 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
    };
# 477 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp"
    inline bool thread::operator==(const thread& other) const
    {
        return get_id()==other.get_id();
    }

    inline bool thread::operator!=(const thread& other) const
    {
        return get_id()!=other.get_id();
    }

    namespace detail
    {
        struct thread_exit_function_base
        {
            virtual ~thread_exit_function_base()
            {}
            virtual void operator()()=0;
        };

        template<typename F>
        struct thread_exit_function:
            thread_exit_function_base
        {
            F f;

            thread_exit_function(F f_):
                f(f_)
            {}

            void operator()()
            {
                f();
            }
        };

        void add_thread_exit_function(thread_exit_function_base*);
    }

    namespace this_thread
    {
        template<typename F>
        void at_thread_exit(F f)
        {
            detail::thread_exit_function_base* const thread_exit_func=detail::heap_new<detail::thread_exit_function<F> >(f);
            detail::add_thread_exit_function(thread_exit_func);
        }
    }
}





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 531 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_interruption.hpp" 1







namespace boost
{
    namespace this_thread
    {
        class disable_interruption
        {
            disable_interruption(const disable_interruption&);
            disable_interruption& operator=(const disable_interruption&);

            bool interruption_was_enabled;
            friend class restore_interruption;
        public:
            disable_interruption();
            ~disable_interruption();
        };

        class restore_interruption
        {
            restore_interruption(const restore_interruption&);
            restore_interruption& operator=(const restore_interruption&);
        public:
            explicit restore_interruption(disable_interruption& d);
            ~restore_interruption();
        };
    }
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_group.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_group.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/shared_mutex.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/shared_mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/shared_mutex.hpp" 1
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/shared_mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/shared_mutex.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/condition_variable.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/condition_variable.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp" 1
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/thread_data.hpp" 1
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp" 2

namespace boost
{
    inline void condition_variable::wait(unique_lock<mutex>& m)
    {
        detail::interruption_checker check_for_interruption(&cond);
        ((!pthread_cond_wait(&cond,m.mutex()->native_handle())) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_wait(&cond,m.mutex()->native_handle())", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 20, __PRETTY_FUNCTION__));
    }

    inline bool condition_variable::timed_wait(unique_lock<mutex>& m,boost::system_time const& wait_until)
    {
        detail::interruption_checker check_for_interruption(&cond);
        struct timespec const timeout=detail::get_timespec(wait_until);
        int const cond_res=pthread_cond_timedwait(&cond,m.mutex()->native_handle(),&timeout);
        if(cond_res==145)
        {
            return false;
        }
        ((!cond_res) ? static_cast<void> (0) : __assert_fail ("!cond_res", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 32, __PRETTY_FUNCTION__));
        return true;
    }

    inline void condition_variable::notify_one()
    {
        ((!pthread_cond_signal(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_signal(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 38, __PRETTY_FUNCTION__));
    }

    inline void condition_variable::notify_all()
    {
        ((!pthread_cond_broadcast(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_broadcast(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 43, __PRETTY_FUNCTION__));
    }

    class condition_variable_any
    {
        pthread_mutex_t internal_mutex;
        pthread_cond_t cond;

        condition_variable_any(condition_variable_any&);
        condition_variable_any& operator=(condition_variable_any&);

    public:
        condition_variable_any()
        {
            int const res=pthread_mutex_init(&internal_mutex,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
            int const res2=pthread_cond_init(&cond,__null);
            if(res2)
            {
                ((!pthread_mutex_destroy(&internal_mutex)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&internal_mutex)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 65, __PRETTY_FUNCTION__));
                boost::throw_exception(thread_resource_error());
            }
        }
        ~condition_variable_any()
        {
            ((!pthread_mutex_destroy(&internal_mutex)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&internal_mutex)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 71, __PRETTY_FUNCTION__));
            ((!pthread_cond_destroy(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_destroy(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 72, __PRETTY_FUNCTION__));
        }

        template<typename lock_type>
        void wait(lock_type& m)
        {
            int res=0;
            {
                detail::interruption_checker check_for_interruption(&cond);
                {
                    boost::pthread::pthread_mutex_scoped_lock internal_lock(&internal_mutex);
                    m.unlock();
                    res=pthread_cond_wait(&cond,&internal_mutex);
                }
                m.lock();
            }
            if(res)
            {
                boost::throw_exception(condition_error());
            }
        }

        template<typename lock_type,typename predicate_type>
        void wait(lock_type& m,predicate_type pred)
        {
            while(!pred()) wait(m);
        }

        template<typename lock_type>
        bool timed_wait(lock_type& m,boost::system_time const& wait_until)
        {
            struct timespec const timeout=detail::get_timespec(wait_until);
            int res=0;
            {
                detail::interruption_checker check_for_interruption(&cond);
                {
                    boost::pthread::pthread_mutex_scoped_lock internal_lock(&internal_mutex);
                    m.unlock();
                    res=pthread_cond_timedwait(&cond,&internal_mutex,&timeout);
                }
                m.lock();
            }
            if(res==145)
            {
                return false;
            }
            if(res)
            {
                boost::throw_exception(condition_error());
            }
            return true;
        }
        template<typename lock_type>
        bool timed_wait(lock_type& m,xtime const& wait_until)
        {
            return timed_wait(m,system_time(wait_until));
        }

        template<typename lock_type,typename duration_type>
        bool timed_wait(lock_type& m,duration_type const& wait_duration)
        {
            return timed_wait(m,get_system_time()+wait_duration);
        }

        template<typename lock_type,typename predicate_type>
        bool timed_wait(lock_type& m,boost::system_time const& wait_until,predicate_type pred)
        {
            while (!pred())
            {
                if(!timed_wait(m, wait_until))
                    return pred();
            }
            return true;
        }

        template<typename lock_type,typename predicate_type>
        bool timed_wait(lock_type& m,xtime const& wait_until,predicate_type pred)
        {
            return timed_wait(m,system_time(wait_until),pred);
        }

        template<typename lock_type,typename duration_type,typename predicate_type>
        bool timed_wait(lock_type& m,duration_type const& wait_duration,predicate_type pred)
        {
            return timed_wait(m,get_system_time()+wait_duration,pred);
        }

        void notify_one()
        {
            boost::pthread::pthread_mutex_scoped_lock internal_lock(&internal_mutex);
            ((!pthread_cond_signal(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_signal(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 162, __PRETTY_FUNCTION__));
        }

        void notify_all()
        {
            boost::pthread::pthread_mutex_scoped_lock internal_lock(&internal_mutex);
            ((!pthread_cond_broadcast(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_broadcast(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp", 168, __PRETTY_FUNCTION__));
        }
    };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 175 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/condition_variable.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/condition_variable.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/shared_mutex.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/shared_mutex.hpp" 2

namespace boost
{
    class shared_mutex
    {
    private:
        struct state_data
        {
            unsigned shared_count;
            bool exclusive;
            bool upgrade;
            bool exclusive_waiting_blocked;
        };



        state_data state;
        boost::mutex state_change;
        boost::condition_variable shared_cond;
        boost::condition_variable exclusive_cond;
        boost::condition_variable upgrade_cond;

        void release_waiters()
        {
            exclusive_cond.notify_one();
            shared_cond.notify_all();
        }


    public:
        shared_mutex()
        {
            state_data state_={0,0,0,0};
            state=state_;
        }

        ~shared_mutex()
        {
        }

        void lock_shared()
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);

            while(state.exclusive || state.exclusive_waiting_blocked)
            {
                shared_cond.wait(lk);
            }
            ++state.shared_count;
        }

        bool try_lock_shared()
        {
            boost::mutex::scoped_lock lk(state_change);

            if(state.exclusive || state.exclusive_waiting_blocked)
            {
                return false;
            }
            else
            {
                ++state.shared_count;
                return true;
            }
        }

        bool timed_lock_shared(system_time const& timeout)
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);

            while(state.exclusive || state.exclusive_waiting_blocked)
            {
                if(!shared_cond.timed_wait(lk,timeout))
                {
                    return false;
                }
            }
            ++state.shared_count;
            return true;
        }

        template<typename TimeDuration>
        bool timed_lock_shared(TimeDuration const & relative_time)
        {
            return timed_lock_shared(get_system_time()+relative_time);
        }

        void unlock_shared()
        {
            boost::mutex::scoped_lock lk(state_change);
            bool const last_reader=!--state.shared_count;

            if(last_reader)
            {
                if(state.upgrade)
                {
                    state.upgrade=false;
                    state.exclusive=true;
                    upgrade_cond.notify_one();
                }
                else
                {
                    state.exclusive_waiting_blocked=false;
                }
                release_waiters();
            }
        }

        void lock()
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);

            while(state.shared_count || state.exclusive)
            {
                state.exclusive_waiting_blocked=true;
                exclusive_cond.wait(lk);
            }
            state.exclusive=true;
        }

        bool timed_lock(system_time const& timeout)
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);

            while(state.shared_count || state.exclusive)
            {
                state.exclusive_waiting_blocked=true;
                if(!exclusive_cond.timed_wait(lk,timeout))
                {
                    if(state.shared_count || state.exclusive)
                    {
                        state.exclusive_waiting_blocked=false;
                        exclusive_cond.notify_one();
                        return false;
                    }
                    break;
                }
            }
            state.exclusive=true;
            return true;
        }

        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time)
        {
            return timed_lock(get_system_time()+relative_time);
        }

        bool try_lock()
        {
            boost::mutex::scoped_lock lk(state_change);

            if(state.shared_count || state.exclusive)
            {
                return false;
            }
            else
            {
                state.exclusive=true;
                return true;
            }

        }

        void unlock()
        {
            boost::mutex::scoped_lock lk(state_change);
            state.exclusive=false;
            state.exclusive_waiting_blocked=false;
            release_waiters();
        }

        void lock_upgrade()
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);
            while(state.exclusive || state.exclusive_waiting_blocked || state.upgrade)
            {
                shared_cond.wait(lk);
            }
            ++state.shared_count;
            state.upgrade=true;
        }

        bool timed_lock_upgrade(system_time const& timeout)
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);
            while(state.exclusive || state.exclusive_waiting_blocked || state.upgrade)
            {
                if(!shared_cond.timed_wait(lk,timeout))
                {
                    if(state.exclusive || state.exclusive_waiting_blocked || state.upgrade)
                    {
                        return false;
                    }
                    break;
                }
            }
            ++state.shared_count;
            state.upgrade=true;
            return true;
        }

        template<typename TimeDuration>
        bool timed_lock_upgrade(TimeDuration const & relative_time)
        {
            return timed_lock_upgrade(get_system_time()+relative_time);
        }

        bool try_lock_upgrade()
        {
            boost::mutex::scoped_lock lk(state_change);
            if(state.exclusive || state.exclusive_waiting_blocked || state.upgrade)
            {
                return false;
            }
            else
            {
                ++state.shared_count;
                state.upgrade=true;
                return true;
            }
        }

        void unlock_upgrade()
        {
            boost::mutex::scoped_lock lk(state_change);
            state.upgrade=false;
            bool const last_reader=!--state.shared_count;

            if(last_reader)
            {
                state.exclusive_waiting_blocked=false;
                release_waiters();
            }
        }

        void unlock_upgrade_and_lock()
        {
            boost::this_thread::disable_interruption do_not_disturb;
            boost::mutex::scoped_lock lk(state_change);
            --state.shared_count;
            while(state.shared_count)
            {
                upgrade_cond.wait(lk);
            }
            state.upgrade=false;
            state.exclusive=true;
        }

        void unlock_and_lock_upgrade()
        {
            boost::mutex::scoped_lock lk(state_change);
            state.exclusive=false;
            state.upgrade=true;
            ++state.shared_count;
            state.exclusive_waiting_blocked=false;
            release_waiters();
        }

        void unlock_and_lock_shared()
        {
            boost::mutex::scoped_lock lk(state_change);
            state.exclusive=false;
            ++state.shared_count;
            state.exclusive_waiting_blocked=false;
            release_waiters();
        }

        void unlock_upgrade_and_lock_shared()
        {
            boost::mutex::scoped_lock lk(state_change);
            state.upgrade=false;
            state.exclusive_waiting_blocked=false;
            release_waiters();
        }
    };
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 302 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/shared_mutex.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/shared_mutex.hpp" 2
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_group.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_group.hpp" 2






namespace boost
{
    class thread_group
    {
    private:
        thread_group(thread_group const&);
        thread_group& operator=(thread_group const&);
    public:
        thread_group() {}
        ~thread_group()
        {
            for(std::list<thread*>::iterator it=threads.begin(),end=threads.end();
                it!=end;
                ++it)
            {
                delete *it;
            }
        }

        template<typename F>
        thread* create_thread(F threadfunc)
        {
            boost::lock_guard<shared_mutex> guard(m);
            std::auto_ptr<thread> new_thread(new thread(threadfunc));
            threads.push_back(new_thread.get());
            return new_thread.release();
        }

        void add_thread(thread* thrd)
        {
            if(thrd)
            {
                boost::lock_guard<shared_mutex> guard(m);
                threads.push_back(thrd);
            }
        }

        void remove_thread(thread* thrd)
        {
            boost::lock_guard<shared_mutex> guard(m);
            std::list<thread*>::iterator const it=std::find(threads.begin(),threads.end(),thrd);
            if(it!=threads.end())
            {
                threads.erase(it);
            }
        }

        void join_all()
        {
            boost::shared_lock<shared_mutex> guard(m);

            for(std::list<thread*>::iterator it=threads.begin(),end=threads.end();
                it!=end;
                ++it)
            {
                (*it)->join();
            }
        }

        void interrupt_all()
        {
            boost::shared_lock<shared_mutex> guard(m);

            for(std::list<thread*>::iterator it=threads.begin(),end=threads.end();
                it!=end;
                ++it)
            {
                (*it)->interrupt();
            }
        }

        size_t size() const
        {
            boost::shared_lock<shared_mutex> guard(m);
            return threads.size();
        }

    private:
        std::list<thread*> threads;
        mutable shared_mutex m;
    };
}





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 107 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/detail/thread_group.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/thread.hpp" 2
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/once.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/once.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp" 2

namespace boost
{

    struct once_flag
    {
        boost::uintmax_t epoch;
    };

    namespace detail
    {
        boost::uintmax_t& get_once_per_thread_epoch();
        extern boost::uintmax_t once_global_epoch;
        extern pthread_mutex_t once_epoch_mutex;
        extern pthread_cond_t once_epoch_cv;
    }







    template<typename Function>
    void call_once(once_flag& flag,Function f)
    {
        static boost::uintmax_t const uninitialized_flag=0;
        static boost::uintmax_t const being_initialized=uninitialized_flag+1;
        boost::uintmax_t const epoch=flag.epoch;
        boost::uintmax_t& this_thread_epoch=detail::get_once_per_thread_epoch();

        if(epoch<this_thread_epoch)
        {
            pthread::pthread_mutex_scoped_lock lk(&detail::once_epoch_mutex);

            while(flag.epoch<=being_initialized)
            {
                if(flag.epoch==uninitialized_flag)
                {
                    flag.epoch=being_initialized;

                    try
                    {

                        pthread::pthread_mutex_scoped_unlock relocker(&detail::once_epoch_mutex);
                        f();

                    }
                    catch(...)
                    {
                        flag.epoch=uninitialized_flag;
                        ((!pthread_cond_broadcast(&detail::once_epoch_cv)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_broadcast(&detail::once_epoch_cv)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp", 73, __PRETTY_FUNCTION__));
                        throw;
                    }

                    flag.epoch=--detail::once_global_epoch;
                    ((!pthread_cond_broadcast(&detail::once_epoch_cv)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_broadcast(&detail::once_epoch_cv)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp", 78, __PRETTY_FUNCTION__));
                }
                else
                {
                    while(flag.epoch==being_initialized)
                    {
                        ((!pthread_cond_wait(&detail::once_epoch_cv,&detail::once_epoch_mutex)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_wait(&detail::once_epoch_cv,&detail::once_epoch_mutex)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp", 84, __PRETTY_FUNCTION__));
                    }
                }
            }
            this_thread_epoch=detail::once_global_epoch;
        }
    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 94 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/once.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/once.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/once.hpp" 2

namespace boost
{
    inline void call_once(void (*func)(),once_flag& flag)
    {
        call_once(flag,func);
    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/once.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/recursive_mutex.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/recursive_mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp" 2




# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/errno.h" 1 3 4
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp" 2

namespace boost
{
    class recursive_mutex
    {
    private:
        recursive_mutex(recursive_mutex const&);
        recursive_mutex& operator=(recursive_mutex const&);
        pthread_mutex_t m;

        pthread_cond_t cond;
        bool is_locked;
        pthread_t owner;
        unsigned count;

    public:
        recursive_mutex()
        {
# 75 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp"
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
            int const res2=pthread_cond_init(&cond,__null);
            if(res2)
            {
                ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 83, __PRETTY_FUNCTION__));
                boost::throw_exception(thread_resource_error());
            }
            is_locked=false;
            count=0;

        }
        ~recursive_mutex()
        {
            ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 92, __PRETTY_FUNCTION__));

            ((!pthread_cond_destroy(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_destroy(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 94, __PRETTY_FUNCTION__));

        }
# 122 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp"
        void lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked && pthread_equal(owner,pthread_self()))
            {
                ++count;
                return;
            }

            while(is_locked)
            {
                ((!pthread_cond_wait(&cond,&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_wait(&cond,&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 133, __PRETTY_FUNCTION__));
            }
            is_locked=true;
            ++count;
            owner=pthread_self();
        }

        void unlock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(!--count)
            {
                is_locked=false;
            }
            ((!pthread_cond_signal(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_signal(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 147, __PRETTY_FUNCTION__));
        }

        bool try_lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked && !pthread_equal(owner,pthread_self()))
            {
                return false;
            }
            is_locked=true;
            ++count;
            owner=pthread_self();
            return true;
        }



        typedef unique_lock<recursive_mutex> scoped_lock;
        typedef detail::try_lock_wrapper<recursive_mutex> scoped_try_lock;
    };

    typedef recursive_mutex recursive_try_mutex;

    class recursive_timed_mutex
    {
    private:
        recursive_timed_mutex(recursive_timed_mutex const&);
        recursive_timed_mutex& operator=(recursive_timed_mutex const&);
    private:
        pthread_mutex_t m;

        pthread_cond_t cond;
        bool is_locked;
        pthread_t owner;
        unsigned count;

    public:
        recursive_timed_mutex()
        {
# 209 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp"
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
            int const res2=pthread_cond_init(&cond,__null);
            if(res2)
            {
                ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 217, __PRETTY_FUNCTION__));
                boost::throw_exception(thread_resource_error());
            }
            is_locked=false;
            count=0;

        }
        ~recursive_timed_mutex()
        {
            ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 226, __PRETTY_FUNCTION__));

            ((!pthread_cond_destroy(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_destroy(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 228, __PRETTY_FUNCTION__));

        }

        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time)
        {
            return timed_lock(get_system_time()+relative_time);
        }
# 270 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp"
        void lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked && pthread_equal(owner,pthread_self()))
            {
                ++count;
                return;
            }

            while(is_locked)
            {
                ((!pthread_cond_wait(&cond,&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_wait(&cond,&m)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 281, __PRETTY_FUNCTION__));
            }
            is_locked=true;
            ++count;
            owner=pthread_self();
        }

        void unlock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(!--count)
            {
                is_locked=false;
            }
            ((!pthread_cond_signal(&cond)) ? static_cast<void> (0) : __assert_fail ("!pthread_cond_signal(&cond)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 295, __PRETTY_FUNCTION__));
        }

        bool try_lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked && !pthread_equal(owner,pthread_self()))
            {
                return false;
            }
            is_locked=true;
            ++count;
            owner=pthread_self();
            return true;
        }

        bool timed_lock(system_time const & abs_time)
        {
            struct timespec const timeout=detail::get_timespec(abs_time);
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked && pthread_equal(owner,pthread_self()))
            {
                ++count;
                return true;
            }
            while(is_locked)
            {
                int const cond_res=pthread_cond_timedwait(&cond,&m,&timeout);
                if(cond_res==145)
                {
                    return false;
                }
                ((!cond_res) ? static_cast<void> (0) : __assert_fail ("!cond_res", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp", 327, __PRETTY_FUNCTION__));
            }
            is_locked=true;
            ++count;
            owner=pthread_self();
            return true;
        }


        typedef unique_lock<recursive_timed_mutex> scoped_timed_lock;
        typedef detail::try_lock_wrapper<recursive_timed_mutex> scoped_try_lock;
        typedef scoped_timed_lock scoped_lock;
    };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 344 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/pthread/recursive_mutex.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/recursive_mutex.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/tss.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/tss.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/tss.hpp" 2

namespace boost
{
    namespace detail
    {
        struct tss_cleanup_function
        {
            virtual ~tss_cleanup_function()
            {}

            virtual void operator()(void* data)=0;
        };

        void set_tss_data(void const* key,boost::shared_ptr<tss_cleanup_function> func,void* tss_data,bool cleanup_existing);
        void* get_tss_data(void const* key);
    }

    template <typename T>
    class thread_specific_ptr
    {
    private:
        thread_specific_ptr(thread_specific_ptr&);
        thread_specific_ptr& operator=(thread_specific_ptr&);

        struct delete_data:
            detail::tss_cleanup_function
        {
            void operator()(void* data)
            {
                delete static_cast<T*>(data);
            }
        };

        struct run_custom_cleanup_function:
            detail::tss_cleanup_function
        {
            void (*cleanup_function)(T*);

            explicit run_custom_cleanup_function(void (*cleanup_function_)(T*)):
                cleanup_function(cleanup_function_)
            {}

            void operator()(void* data)
            {
                cleanup_function(static_cast<T*>(data));
            }
        };


        boost::shared_ptr<detail::tss_cleanup_function> cleanup;

    public:
        typedef T element_type;

        thread_specific_ptr():
            cleanup(detail::heap_new<delete_data>(),detail::do_heap_delete<delete_data>())
        {}
        explicit thread_specific_ptr(void (*func_)(T*))
        {
            if(func_)
            {
                cleanup.reset(detail::heap_new<run_custom_cleanup_function>(func_),detail::do_heap_delete<run_custom_cleanup_function>());
            }
        }
        ~thread_specific_ptr()
        {
            detail::set_tss_data(this,boost::shared_ptr<detail::tss_cleanup_function>(),0,true);
        }

        T* get() const
        {
            return static_cast<T*>(detail::get_tss_data(this));
        }
        T* operator->() const
        {
            return get();
        }
        T& operator*() const
        {
            return *get();
        }
        T* release()
        {
            T* const temp=get();
            detail::set_tss_data(this,boost::shared_ptr<detail::tss_cleanup_function>(),0,false);
            return temp;
        }
        void reset(T* new_value=0)
        {
            T* const current_value=get();
            if(current_value!=new_value)
            {
                detail::set_tss_data(this,cleanup,new_value,true);
            }
        }
    };
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 112 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/tss.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/barrier.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/barrier.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_prefix.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/barrier.hpp" 2

namespace boost
{

    class barrier
    {
    public:
        barrier(unsigned int count)
            : m_threshold(count), m_count(count), m_generation(0)
        {
            if (count == 0)
                boost::throw_exception(std::invalid_argument("count cannot be zero."));
        }

        bool wait()
        {
            boost::mutex::scoped_lock lock(m_mutex);
            unsigned int gen = m_generation;

            if (--m_count == 0)
            {
                m_generation++;
                m_count = m_threshold;
                m_cond.notify_all();
                return true;
            }

            while (gen == m_generation)
                m_cond.wait(lock);
            return false;
        }

    private:
        mutex m_mutex;
        condition_variable m_cond;
        unsigned int m_threshold;
        unsigned int m_count;
        unsigned int m_generation;
    };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/abi_suffix.hpp" 1
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/barrier.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception_ptr.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp" 1
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp"
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp" 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp" 3






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp" 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string.hpp" 3






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/is_output_streamable.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/is_output_streamable.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/is_output_streamable.hpp" 3







namespace
boost
    {
    namespace
    to_string_detail
        {
        struct
        partial_ordering_helper1
            {
            template <class CharT,class Traits>
            partial_ordering_helper1( std::basic_ostream<CharT,Traits> & );
            };

        struct
        partial_ordering_helper2
            {
            template <class T>
            partial_ordering_helper2( T const & );
            };

        char operator<<( partial_ordering_helper1, partial_ordering_helper2 );

        template <class T,class CharT,class Traits>
        struct
        is_output_streamable_impl
            {
            static std::basic_ostream<CharT,Traits> & f();
            static T const & g();
            enum e { value=1!=(sizeof(f()<<g())) };
            };
        }

    template <class T, class CharT=char, class Traits=std::char_traits<CharT> >
    struct
    is_output_streamable
        {
        enum e { value=to_string_detail::is_output_streamable_impl<T,CharT,Traits>::value };
        };
    }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string.hpp" 2 3


namespace
boost
    {
    namespace
    to_string_detail
        {
        template <class T>
        typename disable_if<is_output_streamable<T>,char>::type to_string( T const & );

        template <class,bool IsOutputStreamable>
        struct has_to_string_impl;

        template <class T>
        struct
        has_to_string_impl<T,true>
            {
            enum e { value=1 };
            };

        template <class T>
        struct
        has_to_string_impl<T,false>
            {
            static T const & f();
            enum e { value=1!=sizeof(to_string(f())) };
            };
        }

    template <class T>
    inline
    typename enable_if<is_output_streamable<T>,std::string>::type
    to_string( T const & x )
        {
        std::ostringstream out;
        out << x;
        return out.str();
        }

    template <class T>
    struct
    has_to_string
        {
        enum e { value=to_string_detail::has_to_string_impl<T,is_output_streamable<T>::value>::value };
        };

    template <class T,class U>
    inline
    std::string
    to_string( std::pair<T,U> const & x )
        {
        return std::string("(") + to_string(x.first) + ',' + to_string(x.second) + ')';
        }

    inline
    std::string
    to_string( std::exception const & x )
        {
        return x.what();
        }
    }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/object_hex_dump.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/object_hex_dump.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/object_hex_dump.hpp" 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/type_info.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/type_info.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/type_info.hpp" 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/type_info.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/units/detail/utility.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/units/detail/utility.hpp" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/units/detail/utility.hpp" 2 3
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/units/detail/utility.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/config.hpp" 1 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 2 3

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range.hpp" 1 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 1 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_traits.hpp" 1 3







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/iterator.hpp" 1 3
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/iterator.hpp" 3
namespace boost { namespace detail {


template <class Iterator>
struct iterator_traits
    : std::iterator_traits<Iterator>
{};
using std::distance;

}}
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_traits.hpp" 2 3


namespace boost {
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_traits.hpp" 3
template <class Iterator>
struct iterator_value
{
    typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename boost::detail::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
};
# 90 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_traits.hpp" 3
}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 1 3
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/interoperable.hpp" 1 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/interoperable.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1 3
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/interoperable.hpp" 2 3

namespace boost
{
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/interoperable.hpp" 3
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1 3
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/interoperable.hpp" 2 3
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 1 3






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 1 3
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1 3
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 2 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/placeholders.hpp" 1 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 2 3






namespace boost {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};
# 108 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 3
  template <class Traversal>
  struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal,random_access_traversal_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Traversal,bidirectional_traversal_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Traversal,forward_traversal_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Traversal,single_pass_traversal_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Traversal,incrementable_traversal_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {
  };
# 142 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 3
}





template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename boost::detail::iterator_traits<Iterator>::iterator_category
    >
{};
# 184 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 3
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1 3
# 187 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_categories.hpp" 2 3
# 8 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 1 3
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_pointer.hpp" 1 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_pointer.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_pointer.hpp" 2 3

namespace boost {



template< typename T > struct remove_pointer { typedef T type; };
template< typename T > struct remove_pointer<T*> { typedef T type; };
template< typename T > struct remove_pointer<T* const> { typedef T type; };
template< typename T > struct remove_pointer<T* volatile> { typedef T type; };
template< typename T > struct remove_pointer<T* const volatile> { typedef T type; };







}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/remove_pointer.hpp" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 2 3
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 3
namespace boost { namespace detail {

namespace indirect_traits {


template <class T>
struct is_reference_to_const : mpl::false_
{
};

template <class T>
struct is_reference_to_const<T const&> : mpl::true_
{
};
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_function : mpl::false_
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : mpl::false_
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : mpl::false_
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
   
};

template <class T>
struct is_reference_to_function_pointer_aux
    : mpl::and_<
          is_reference<T>
        , is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : mpl::if_<
          is_reference_to_function<T>
        , mpl::false_
        , is_reference_to_function_pointer_aux<T>
     >::type
{
};

template <class T>
struct is_reference_to_non_const
    : mpl::and_<
          is_reference<T>
        , mpl::not_<
             is_reference_to_const<T>
          >
      >
{
};

template <class T>
struct is_reference_to_volatile : mpl::false_
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : mpl::true_
{
};
# 149 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_pointer : mpl::false_
{
};

template <class T>
struct is_reference_to_pointer<T*&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_class
    : mpl::and_<
          is_reference<T>
        , is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{
   
};

template <class T>
struct is_pointer_to_class
    : mpl::and_<
          is_pointer<T>
        , is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >
      >
{
   
};
# 481 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/indirect_traits.hpp" 3
}

using namespace indirect_traits;

}}
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3







namespace boost { struct use_default; }

namespace boost { namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
# 86 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 3
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{




    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) }



             ;

    enum { mpl_assertion_in_line_151 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_152 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_153 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };

    enum { mpl_assertion_in_line_155 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };


};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{

    enum { mpl_assertion_in_line_166 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };


    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1 3
# 199 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/enable_if.hpp" 1 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/enable_if.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/enable_if.hpp" 2 3







namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/enable_if.hpp" 3
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {



    };

  }

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1 3
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/enable_if.hpp" 2 3
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/implicit_cast.hpp" 1 3
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/implicit_cast.hpp" 3
namespace boost {






template <typename T>
inline T implicit_cast (typename mpl::identity<T>::type x) {
    return x;
}





}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/mpl/apply.hpp" 1 3
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1 3
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3

namespace boost
{


  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable
# 80 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
      : ::boost::iterators::enable_if<
           mpl::or_<
               is_convertible<Facade1, Facade2>
             , is_convertible<Facade2, Facade1>
           >
         , Return
        >
    {};






    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;

        typedef typename mpl::eval_if<
            boost::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
# 130 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
# 244 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
# 269 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<Reference,Value const&>



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class T>
    struct operator_arrow_proxy
    {
        operator_arrow_proxy(T const* px) : m_value(*px) {}
        T* operator->() const { return &m_value; }


        operator T*() const { return &m_value; }
        mutable T m_value;
    };




    template <class ValueType, class Reference, class Pointer>
    struct operator_arrow_result
    {



        typedef typename mpl::if_<
            is_reference<Reference>
          , Pointer
          , operator_arrow_proxy<ValueType>
        >::type type;

        static type make(Reference x)
        {
            return implicit_cast<type>(&x);
        }
    };
# 342 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :
# 420 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };
  }
# 471 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
  class iterator_core_access
  {






      template <class I, class V, class TC, class R, class D> friend class iterator_facade;




      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);

      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);


      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }

   private:

      iterator_core_access();
  };





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade






  {
   private:



      Derived& derived()
      {
          return *static_cast<Derived*>(this);
      }

      Derived const& derived() const
      {
          return *static_cast<Derived const*>(this);
      }

      typedef boost::detail::iterator_facade_types<
         Value, CategoryOrTraversal, Reference, Difference
      > associated_types;

   protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;

   public:

      typedef typename associated_types::value_type value_type;
      typedef Reference reference;
      typedef Difference difference_type;
      typedef typename associated_types::pointer pointer;
      typedef typename associated_types::iterator_category iterator_category;

      reference operator*() const
      {
          return iterator_core_access::dereference(this->derived());
      }

      typename boost::detail::operator_arrow_result<
          value_type
        , reference
        , pointer
      >::type
      operator->() const
      {
          return boost::detail::operator_arrow_result<
              value_type
            , reference
            , pointer
          >::make(*this->derived());
      }

      typename boost::detail::operator_brackets_result<Derived,Value,reference>::type
      operator[](difference_type n) const
      {
          typedef boost::detail::use_operator_brackets_proxy<Value,Reference> use_proxy;

          return boost::detail::make_operator_brackets_result<Derived>(
              this->derived() + n
            , use_proxy()
          );
      }

      Derived& operator++()
      {
          iterator_core_access::increment(this->derived());
          return this->derived();
      }
# 679 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
      Derived& operator--()
      {
          iterator_core_access::decrement(this->derived());
          return this->derived();
      }

      Derived operator--(int)
      {
          Derived tmp(this->derived());
          --*this;
          return tmp;
      }

      Derived& operator+=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), n);
          return this->derived();
      }

      Derived& operator-=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), -n);
          return this->derived();
      }

      Derived operator-(difference_type x) const
      {
          Derived result(this->derived());
          return result -= x;
      }
# 721 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
  };


  template <class I, class V, class TC, class R, class D>
  inline typename boost::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
# 836 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_836; return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_837; return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }

  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_839; return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_840; return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_841; return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_842; return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }



  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)>




 boost_static_assert_typedef_851
# 846 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
  ; return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 862 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 3
template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }






}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1 3
# 877 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_facade.hpp" 2 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 1 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/begin.hpp" 1 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/begin.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/config.hpp" 1 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/begin.hpp" 2 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator.hpp" 1 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/mutable_iterator.hpp" 1 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/mutable_iterator.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/extract_optional_type.hpp" 1 3
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/extract_optional_type.hpp" 3
namespace boost {
    namespace range_detail {
        template< typename T > struct exists { typedef void type; };
    }
}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/mutable_iterator.hpp" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/mutable_iterator.hpp" 2 3


namespace boost
{




    namespace range_detail {
        template< typename C, typename Enable=void > struct extract_iterator {}; template< typename C > struct extract_iterator< C , typename boost::range_detail::exists< typename C::iterator >::type > { typedef typename C::iterator type; };
    }

    template< typename C >
    struct range_mutable_iterator : range_detail::extract_iterator<C>
    {};





    template< typename Iterator >
    struct range_mutable_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };





    template< typename T, std::size_t sz >
    struct range_mutable_iterator< T[sz] >
    {
        typedef T* type;
    };

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/const_iterator.hpp" 1 3
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/const_iterator.hpp" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/const_iterator.hpp" 2 3


namespace boost
{




    namespace range_detail {
        template< typename C, typename Enable=void > struct extract_const_iterator {}; template< typename C > struct extract_const_iterator< C , typename boost::range_detail::exists< typename C::const_iterator >::type > { typedef typename C::const_iterator type; };
    }

    template< typename C >
    struct range_const_iterator : range_detail::extract_const_iterator<C>
    {};





    template< typename Iterator >
    struct range_const_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };





    template< typename T, std::size_t sz >
    struct range_const_iterator< T[sz] >
    {
        typedef const T* type;
    };

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator.hpp" 2 3




namespace boost
{
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator.hpp" 3
    template< typename C >
    struct range_iterator
    {







        typedef typename
            mpl::eval_if_c< is_const<C>::value,
                            range_const_iterator< typename remove_const<C>::type >,
                            range_mutable_iterator<C> >::type type;


    };

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/begin.hpp" 2 3

namespace boost
{




namespace range_detail
{






    template< typename C >
    inline typename range_iterator<C>::type
    range_begin( C& c )
    {





        return c.begin();
    }





    template< typename Iterator >
    inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }

    template< typename Iterator >
    inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
# 75 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/begin.hpp" 3
    template< typename T, std::size_t sz >
    inline const T* range_begin( const T (&a)[sz] )
    {
        return a;
    }

    template< typename T, std::size_t sz >
    inline T* range_begin( T (&a)[sz] )
    {
        return a;
    }





}



template< class T >
inline typename range_iterator<T>::type begin( T& r )
{



    using namespace range_detail;

    return range_begin( r );
}

template< class T >
inline typename range_iterator<const T>::type begin( const T& r )
{



    using namespace range_detail;

    return range_begin( r );
}

}



namespace boost
{
    template< class T >
    inline typename range_iterator<const T>::type
    const_begin( const T& r )
    {
        return boost::begin( r );
    }
}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/end.hpp" 1 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/end.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/implementation_help.hpp" 1 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/implementation_help.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/common.hpp" 1 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/common.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/sfinae.hpp" 1 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/sfinae.hpp" 3
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;





        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );

        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );

        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );

        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );

        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );

        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );

        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );





        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );





        struct char_or_wchar_t_array_tag {};

    }

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/common.hpp" 2 3




# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/common.hpp" 2 3





namespace boost
{
    namespace range_detail
    {
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/common.hpp" 3
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;

        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;

            static const bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            static const bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_string_ = (boost::type_traits::ice_or<is_const_char_ptr_, is_const_wchar_t_ptr_>::value );
            static const bool is_array_ = boost::is_array<C>::value;

        };

        template< typename C >
        class range
        {
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef typename boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/implementation_help.hpp" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/implementation_help.hpp" 2 3



# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/implementation_help.hpp" 2 3


namespace boost
{
    namespace range_detail
    {
        template <typename T>
        inline void boost_range_silence_warning( const T& ) { }





        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }


        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            return s + wcslen( s );
        }
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/implementation_help.hpp" 3
        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }

        template< class T, std::size_t sz >
        inline T* array_end( T (&boost_range_array)[sz] )
        {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        inline const T* array_end( const T (&boost_range_array)[sz] )
        {
            return boost_range_array + sz;
        }





        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

    }

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/end.hpp" 2 3



namespace boost
{




namespace range_detail
{





        template< typename C >
        inline typename range_iterator<C>::type
        range_end( C& c )
        {





            return c.end();
        }





        template< typename Iterator >
        inline Iterator range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }

        template< typename Iterator >
        inline Iterator range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }





        template< typename T, std::size_t sz >
        inline const T* range_end( const T (&a)[sz] )
        {
            return range_detail::array_end<T,sz>( a );
        }

        template< typename T, std::size_t sz >
        inline T* range_end( T (&a)[sz] )
        {
            return range_detail::array_end<T,sz>( a );
        }




}


template< class T >
inline typename range_iterator<T>::type end( T& r )
{



    using namespace range_detail;

    return range_end( r );
}

template< class T >
inline typename range_iterator<const T>::type end( const T& r )
{



    using namespace range_detail;

    return range_end( r );
}

}






namespace boost
{
    template< class T >
    inline typename range_iterator<const T>::type
    const_end( const T& r )
    {
        return boost::end( r );
    }
}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp" 1 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/difference_type.hpp" 1 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/difference_type.hpp" 3
namespace boost
{
    template< class T >
    struct range_difference : iterator_difference< typename range_iterator<T>::type >
    { };
}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp" 2 3

namespace boost
{

    template< class T >
    inline typename range_difference<T>::type size( const T& r )
    {
        (((boost::end( r ) - boost::begin( r )) >= 0 && "reachability invariant broken!") ? static_cast<void> (0) : __assert_fail ("(boost::end( r ) - boost::begin( r )) >= 0 && \"reachability invariant broken!\"",
 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp"
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp" 3
        ,
 30
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size.hpp" 3
        , __PRETTY_FUNCTION__))
                                                        ;
        return boost::end( r ) - boost::begin( r );
    }

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/distance.hpp" 1 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/distance.hpp" 3
namespace boost
{

    template< class T >
    inline typename range_difference<T>::type
    distance( const T& r )
    {
        return std::distance( boost::begin( r ), boost::end( r ) );
    }

}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/empty.hpp" 1 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/empty.hpp" 3
namespace boost
{

    template< class T >
    inline bool empty( const T& r )
    {
        return boost::begin( r ) == boost::end( r );
    }

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rbegin.hpp" 1 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rbegin.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/reverse_iterator.hpp" 1 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/reverse_iterator.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/reverse_iterator.hpp" 1 3
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/reverse_iterator.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 1 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1 3
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 2 3



namespace boost
{



  struct use_default;





  template<class To>
  struct is_convertible<use_default,To>
    : mpl::false_ {};


  namespace detail
  {
# 66 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 3
    struct enable_type;
  }
# 148 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 3
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , boost::detail::enable_type
      >
  {};






  namespace detail
  {


    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };



    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived


          , typename boost::detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type






          , typename boost::detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type

          , typename boost::detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type

          , typename boost::detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };


    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((is_convertible<Tr1, Tr2>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_230;
    }
  }
# 259 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 3
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public boost::detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;

   protected:
      typedef typename boost::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}

      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }

      typedef Base base_type;

      Base const& base() const
        { return m_iterator; }

   protected:

      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;




      Base const& base_reference() const
        { return m_iterator; }

      Base& base_reference()
        { return m_iterator; }

   private:






      typename super_t::reference dereference() const
        { return *m_iterator; }

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {




          return m_iterator == x.base();
      }

      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;




      void advance(typename super_t::difference_type n)
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }

      void increment() { ++m_iterator; }

      void decrement()
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();




          return y.base() - m_iterator;
      }



   private:
      Base m_iterator;
  };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1 3
# 370 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/reverse_iterator.hpp" 2 3

namespace boost
{




  template <class Iterator>
  class reverse_iterator
      : public iterator_adaptor< reverse_iterator<Iterator>, Iterator >
  {
      typedef iterator_adaptor< reverse_iterator<Iterator>, Iterator > super_t;

      friend class iterator_core_access;

   public:
      reverse_iterator() {}

      explicit reverse_iterator(Iterator x)
          : super_t(x) {}

      template<class OtherIterator>
      reverse_iterator(
          reverse_iterator<OtherIterator> const& r
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0
          )
          : super_t(r.base())
      {}

   private:
      typename super_t::reference dereference() const { return *boost::prior(this->base()); }

      void increment() { --this->base_reference(); }
      void decrement() { ++this->base_reference(); }

      void advance(typename super_t::difference_type n)
      {
          this->base_reference() += -n;
      }

      template <class OtherIterator>
      typename super_t::difference_type
      distance_to(reverse_iterator<OtherIterator> const& y) const
      {
          return this->base_reference() - y.base();
      }
  };

  template <class BidirectionalIterator>
  reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
  {
      return reverse_iterator<BidirectionalIterator>(x);
  }

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/reverse_iterator.hpp" 2 3


namespace boost
{




    template< typename C >
    struct range_reverse_iterator
    {
        typedef reverse_iterator<
            typename range_iterator<C>::type > type;
    };


}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rbegin.hpp" 2 3

namespace boost
{
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rbegin.hpp" 3
template< class C >
inline typename range_reverse_iterator<C>::type
rbegin( C& c )
{
    typedef typename range_reverse_iterator<C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rbegin( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rbegin( const T& r )
{
    return boost::rbegin( r );
}

}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rend.hpp" 1 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rend.hpp" 3
namespace boost
{
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/rend.hpp" 3
template< class C >
inline typename range_reverse_iterator<C>::type
rend( C& c )
{
    typedef typename range_reverse_iterator<C>::type
               iter_type;
    return iter_type( boost::begin( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rend( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::begin( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rend( const T& r )
{
    return boost::rend( r );
}

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/functions.hpp" 2 3
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/algorithm/equal.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/algorithm/equal.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 1 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 1 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/assert.hpp" 1 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/assert.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/general.hpp" 1 3







# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/backward_compatibility.hpp" 1 3






namespace boost
{
  namespace concepts {}




}
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/general.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/has_constraints.hpp" 1 3
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/has_constraints.hpp" 3
namespace boost { namespace concepts {

namespace detail
{



  typedef char yes;
  typedef char (&no)[2];

  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/has_constraints.hpp" 3
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);

}



template <class Model>
struct not_satisfied
{
    static const bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes)

                                                                                      ;
    typedef mpl::bool_<value> type;
};

}}
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/general.hpp" 2 3





namespace boost { namespace concepts {

template <class ModelFn>
struct requirement_;

namespace detail
{
  template <void(*)()> struct instantiate {};
}

template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};

struct failed {};

template <class Model>
struct requirement<failed ************ Model::************>
{
    static void failed() { ((Model*)0)->~Model(); }
};



template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};

template <class Model>
struct requirement_<void(*)(Model)>
  : mpl::if_<
        concepts::not_satisfied<Model>
      , constraint<Model>
      , requirement<failed ************ Model::************>
    >::type
{};
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/general.hpp" 3
}}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/assert.hpp" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 2 3


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/conversion_traits.hpp" 1 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 2 3
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/usage.hpp" 1 3
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/usage.hpp" 3
namespace boost { namespace concepts {







template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/usage.hpp" 3
}}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/concept_def.hpp" 1 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/for_each_i.hpp" 1 3
# 7 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/concept_def.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/enum.hpp" 1 3
# 8 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/concept_def.hpp" 2 3
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 2 3

namespace boost
{





  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Model)>::failed> boost_concept_check43;
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 3
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check65; ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };

  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};

  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};





  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check90; ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};

  template <> struct SignedInteger< ::boost::long_long_type> {};




  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check107; ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };

  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};

  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};







  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check129; ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };

  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check137; ~Assignable() {

      a = a;

      const_constraints(a);
    }
   private:
    void const_constraints(const TT& b) {

      a = b;



    }
   private:
    TT a;
  };


  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check158; ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };







  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check182; ~SGIAssignable() {
      TT b(a);

      a = a;

      const_constraints(a);
      ignore_unused_variable_warning(b);
    }
   private:
    void const_constraints(const TT& b) {
      TT c(b);

      a = b;

      ignore_unused_variable_warning(c);
    }
    TT a;
  };




  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check206; ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
# 223 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 3
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }

  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check231; ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };

  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check241; ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };


  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check251; ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
# 281 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 3
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check281; ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check282; ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check283; ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check284; ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check285; ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check286; ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };

  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check288; ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check289; ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check290; ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check291; ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check292; ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };




  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check299; ~Generator() { test(is_void<Return>()); }

   private:
      void test(boost::mpl::false_)
      {

          const Return& r = f();
          ignore_unused_variable_warning(r);
      }

      void test(boost::mpl::true_)
      {
          f();
      }

      Func f;
  };

  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check319; ~UnaryFunction() { test(is_void<Return>()); }

   private:
      void test(boost::mpl::false_)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }

      void test(boost::mpl::true_)
      {
          f(arg);
      }







      UnaryFunction();


      Func f;
      Arg arg;
  };

  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check349; ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::mpl::false_)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }

      void test(boost::mpl::true_)
      {
          f(first,second);
      }

      Func f;
      First first;
      Second second;
  };

  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check370; ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:
    Func f;
    Arg arg;
  };

  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check380; ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:
    Func f;
    First a;
    Second b;
  };


  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check393; ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {

      require_boolean_expr(fun(a, b));
    }
    Func f;
    First a;
    Second b;
  };

  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check411; ~AdaptableGenerator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check413;
      }
  };

  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check425;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check426;
      }
  };

  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check444;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check445;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check446;
      }
  };

  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };

  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };




  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename boost::detail::iterator_traits<TT>::value_type value_type;
      typedef typename boost::detail::iterator_traits<TT>::difference_type difference_type;
      typedef typename boost::detail::iterator_traits<TT>::reference reference;
      typedef typename boost::detail::iterator_traits<TT>::pointer pointer;
      typedef typename boost::detail::iterator_traits<TT>::iterator_category iterator_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check475; ~InputIterator()
      {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check477;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check478;

        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };

  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check492; ~OutputIterator() {

      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };

  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check506; ~ForwardIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed>


 boost_concept_check511;

          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }

   private:
      TT i;
  };

  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check524; ~Mutable_ForwardIterator() {
        *i++ = *i;
      }
   private:
      TT i;
  };

  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check534; ~BidirectionalIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed>


 boost_concept_check539;

          --i;
          i--;
      }
   private:
      TT i;
  };

  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check552; ~Mutable_BidirectionalIterator()
      {
          *i-- = *i;
      }
   private:
      TT i;
  };

  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check564; ~RandomAccessIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed>


 boost_concept_check569;

          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }

   private:
    TT a, b;
    TT i, j;
      typename boost::detail::iterator_traits<TT>::difference_type n;
  };

  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check589; ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename boost::detail::iterator_traits<TT>::difference_type n;
  };




  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check611; ~Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check613;
          const_constraints(c);
      }

   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };

  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check638; ~Mutable_Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed>
 boost_concept_check641;

          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check643;

          i = c.begin();
          i = c.end();
          c.swap(c2);
      }

   private:
      iterator i;
      C c, c2;
  };

  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check658; ~ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed>


 boost_concept_check663;
      }
  };

  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check671; ~Mutable_ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed>


 boost_concept_check676;
      }
  };

  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check687; ~ReversibleContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed>

 boost_concept_check691;

          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check693;

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator i = cc.rbegin();
          i = cc.rend();
      }
      C c;
  };

  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check712; ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check715;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check716;

          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };

  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check731; ~RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed>


 boost_concept_check736;

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }

      C c;
      size_type n;
  };

  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check758; ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check760;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check761;

          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }

   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };


  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>



    , DefaultConstructible<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check780; ~Sequence()
      {
          S
              c(n),
              c2(n, t),
              c3(first, last);

          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);

          c.erase(p);
          c.erase(p, q);

          typename Sequence::reference r = c.front();

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }

      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };

  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check817; ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };

  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check830; ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      };
      S c;
      typename S::value_type t;
  };

  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check857; ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check865;

          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check868;
      }


      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }

      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };

  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check893; ~UniqueAssociativeContainer()
      {
          C c(first, last);

          pos_flag = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check911; ~MultipleAssociativeContainer()
      {
          C c(first, last);

          pos = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check930; ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          enum { mpl_assertion_in_line_934 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<key_type,value_type>))0, 1 ) ) ) };
      }
  };

  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check941; ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          enum { mpl_assertion_in_line_947 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<value_type,required_value_type>))0, 1 ) ) ) };
      }
  };

  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check955; ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);

          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);

          c.insert(p, t);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }

      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();

          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }

   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;

      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };



}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/concept_undef.hpp" 1 3
# 1005 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept_check.hpp" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_concepts.hpp" 1 3
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_concepts.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/concept_def.hpp" 1 3
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_concepts.hpp" 2 3

namespace boost_concepts
{







  template < typename Iterator > struct ReadableIterator; template < typename Iterator > struct ReadableIteratorConcept : ReadableIterator< Iterator > { }; template < typename Iterator > struct ReadableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>

  {
      typedef typename boost::detail::iterator_traits<Iterator>::value_type value_type;
      typedef typename boost::detail::iterator_traits<Iterator>::reference reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReadableIterator>)>::failed> boost_concept_check50; ~ReadableIterator()
      {

          value_type v = *i;
          boost::ignore_unused_variable_warning(v);
      }
  private:
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = typename boost::detail::iterator_traits<Iterator>::value_type
  >
  struct WritableIterator
    : boost::CopyConstructible<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WritableIterator>)>::failed> boost_concept_check67; ~WritableIterator()
      {
          *i = v;
      }
  private:
      ValueType v;
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = typename boost::detail::iterator_traits<Iterator>::value_type
  >
  struct WritableIteratorConcept : WritableIterator<Iterator,ValueType> {};

  template < typename Iterator > struct SwappableIterator; template < typename Iterator > struct SwappableIteratorConcept : SwappableIterator< Iterator > { }; template < typename Iterator > struct SwappableIterator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SwappableIterator>)>::failed> boost_concept_check84; ~SwappableIterator()
      {
          std::iter_swap(i1, i2);
      }
  private:
      Iterator i1;
      Iterator i2;
  };

  template < typename Iterator > struct LvalueIterator; template < typename Iterator > struct LvalueIteratorConcept : LvalueIterator< Iterator > { }; template < typename Iterator > struct LvalueIterator
  {
      typedef typename boost::detail::iterator_traits<Iterator>::value_type value_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LvalueIterator>)>::failed> boost_concept_check97; ~LvalueIterator()
      {
        value_type& r = const_cast<value_type&>(*i);
        boost::ignore_unused_variable_warning(r);
      }
  private:
      Iterator i;
  };





  template < typename Iterator > struct IncrementableIterator; template < typename Iterator > struct IncrementableIteratorConcept : IncrementableIterator< Iterator > { }; template < typename Iterator > struct IncrementableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>
  {
      typedef typename boost::iterator_traversal<Iterator>::type traversal_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< traversal_category , boost::incrementable_traversal_tag >)>::failed>



 boost_concept_check120;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIterator>)>::failed> boost_concept_check122; ~IncrementableIterator()
      {
          ++i;
          (void)i++;
      }
  private:
      Iterator i;
  };

  template < typename Iterator > struct SinglePassIterator; template < typename Iterator > struct SinglePassIteratorConcept : SinglePassIterator< Iterator > { }; template < typename Iterator > struct SinglePassIterator
    : IncrementableIterator<Iterator>
    , boost::EqualityComparable<Iterator>

  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename SinglePassIterator::traversal_category , boost::single_pass_traversal_tag > )>::failed>



 boost_concept_check140;
  };

  template < typename Iterator > struct ForwardTraversal; template < typename Iterator > struct ForwardTraversalConcept : ForwardTraversal< Iterator > { }; template < typename Iterator > struct ForwardTraversal
    : SinglePassIterator<Iterator>
    , boost::DefaultConstructible<Iterator>
  {
      typedef typename boost::detail::iterator_traits<Iterator>::difference_type difference_type;

      enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_integral<difference_type>))0, 1 ) ) ) };
      enum { mpl_assert_rel_value150 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_150 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value150>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename ForwardTraversal::traversal_category , boost::forward_traversal_tag > )>::failed>



 boost_concept_check156;
  };

  template < typename Iterator > struct BidirectionalTraversal; template < typename Iterator > struct BidirectionalTraversalConcept : BidirectionalTraversal< Iterator > { }; template < typename Iterator > struct BidirectionalTraversal
    : ForwardTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename BidirectionalTraversal::traversal_category , boost::bidirectional_traversal_tag > )>::failed>



 boost_concept_check166;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalTraversal>)>::failed> boost_concept_check168; ~BidirectionalTraversal()
      {
          --i;
          (void)i--;
      }
   private:
      Iterator i;
  };

  template < typename Iterator > struct RandomAccessTraversal; template < typename Iterator > struct RandomAccessTraversalConcept : RandomAccessTraversal< Iterator > { }; template < typename Iterator > struct RandomAccessTraversal
    : BidirectionalTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename RandomAccessTraversal::traversal_category , boost::random_access_traversal_tag > )>::failed>



 boost_concept_check184;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessTraversal>)>::failed> boost_concept_check186; ~RandomAccessTraversal()
      {
          i += n;
          i = i + n;
          i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
      }

   private:
      typename BidirectionalTraversal<Iterator>::difference_type n;
      Iterator i, j;
  };




  namespace detail
  {
    template <typename Iterator1, typename Iterator2>
    void interop_single_pass_constraints(Iterator1 const& i1, Iterator2 const& i2)
    {
        bool b;
        b = i1 == i2;
        b = i1 != i2;

        b = i2 == i1;
        b = i2 != i1;
        boost::ignore_unused_variable_warning(b);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const& i1, Iterator2 const& i2,
        boost::random_access_traversal_tag, boost::random_access_traversal_tag)
    {
        bool b;
        typename boost::detail::iterator_traits<Iterator2>::difference_type n;
        b = i1 < i2;
        b = i1 <= i2;
        b = i1 > i2;
        b = i1 >= i2;
        n = i1 - i2;

        b = i2 < i1;
        b = i2 <= i1;
        b = i2 > i1;
        b = i2 >= i1;
        n = i2 - i1;
        boost::ignore_unused_variable_warning(b);
        boost::ignore_unused_variable_warning(n);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const&, Iterator2 const&,
        boost::single_pass_traversal_tag, boost::single_pass_traversal_tag)
    { }

  }

  template < typename Iterator , typename ConstIterator > struct InteroperableIterator; template < typename Iterator , typename ConstIterator > struct InteroperableIteratorConcept : InteroperableIterator< Iterator, ConstIterator > { }; template < typename Iterator , typename ConstIterator > struct InteroperableIterator
  {
   private:
      typedef typename boost::detail::pure_traversal_tag<
          typename boost::iterator_traversal<
              Iterator
          >::type
      >::type traversal_category;

      typedef typename boost::detail::pure_traversal_tag<
          typename boost::iterator_traversal<
              ConstIterator
          >::type
      >::type const_traversal_category;

  public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<Iterator>)>::failed> boost_concept_check264;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<ConstIterator>)>::failed> boost_concept_check265;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InteroperableIterator>)>::failed> boost_concept_check267; ~InteroperableIterator()
      {
          detail::interop_single_pass_constraints(i, ci);
          detail::interop_rand_access_constraints(i, ci, traversal_category(), const_traversal_category());

          ci = i;
      }

   private:
      Iterator i;
      ConstIterator ci;
  };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/concept/detail/concept_undef.hpp" 1 3
# 283 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/iterator_concepts.hpp" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 2 3



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/value_type.hpp" 1 3
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/value_type.hpp" 3
namespace boost
{
    template< class T >
    struct range_value : iterator_value< typename range_iterator<T>::type >
    { };
}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/misc_concept.hpp" 1 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/misc_concept.hpp" 3
namespace boost
{
    namespace range_detail
    {
        template<typename T1, typename T2>
        class SameTypeConcept
        {
        public:
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SameTypeConcept>)>::failed> boost_concept_check21; ~SameTypeConcept()
            {
                same_type(a,b);
            }
        private:
            template<typename T> void same_type(T,T) {}
            T1 a;
            T2 b;
        };
    }
}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 2 3
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 3
namespace boost {

    namespace range_detail {
# 111 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/concepts.hpp" 3
        template<class Iterator>
        struct IncrementableIteratorConcept : CopyConstructible<Iterator>
        {

            typedef typename iterator_traversal<Iterator>::type traversal_category;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< traversal_category, incrementable_traversal_tag >)>::failed>



 boost_concept_check121;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIteratorConcept>)>::failed> boost_concept_check123; ~IncrementableIteratorConcept()
            {
                ++i;
                (void)i++;
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct SinglePassIteratorConcept
            : IncrementableIteratorConcept<Iterator>
            , EqualityComparable<Iterator>
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename SinglePassIteratorConcept::traversal_category, single_pass_traversal_tag >)>::failed>



 boost_concept_check143;

        };

        template<class Iterator>
        struct ForwardIteratorConcept
            : SinglePassIteratorConcept<Iterator>
            , DefaultConstructible<Iterator>
        {

            typedef typename boost::detail::iterator_traits<Iterator>::difference_type difference_type;

            enum { mpl_assertion_in_line_155 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_integral<difference_type>))0, 1 ) ) ) };
            enum { mpl_assert_rel_value156 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_156 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value156>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename ForwardIteratorConcept::traversal_category, forward_traversal_tag >)>::failed>



 boost_concept_check162;

         };

         template<class Iterator>
         struct BidirectionalIteratorConcept
             : ForwardIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename BidirectionalIteratorConcept::traversal_category, bidirectional_traversal_tag >)>::failed>



 boost_concept_check175;

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIteratorConcept>)>::failed> boost_concept_check177; ~BidirectionalIteratorConcept()
             {
                 --i;
                 (void)i--;
             }
         private:
             Iterator i;

         };

         template<class Iterator>
         struct RandomAccessIteratorConcept
             : BidirectionalIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename RandomAccessIteratorConcept::traversal_category, random_access_traversal_tag >)>::failed>



 boost_concept_check196;

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIteratorConcept>)>::failed> boost_concept_check198; ~RandomAccessIteratorConcept()
             {
                 i += n;
                 i = i + n;
                 i = n + i;
                 i -= n;
                 i = i - n;
                 n = i - j;
             }
         private:
             typename RandomAccessIteratorConcept::difference_type n;
             Iterator i;
             Iterator j;

         };

    }


    template<class T>
    struct SinglePassRangeConcept
    {

         typedef typename range_iterator<T const>::type const_iterator;
         typedef typename range_iterator<T>::type iterator;

         typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::SinglePassIteratorConcept<iterator>)>::failed> boost_concept_check224;
         typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::SinglePassIteratorConcept<const_iterator>)>::failed> boost_concept_check225;

         typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassRangeConcept>)>::failed> boost_concept_check227; ~SinglePassRangeConcept()
         {



            iterator i1 = boost::begin(*m_range);
            iterator i2 = boost::end(*m_range);

            ignore_unused_variable_warning(i1);
            ignore_unused_variable_warning(i2);

            const_constraints(*m_range);
        }

    private:
        void const_constraints(const T& const_range)
        {
            const_iterator ci1 = boost::begin(const_range);
            const_iterator ci2 = boost::end(const_range);

            ignore_unused_variable_warning(ci1);
            ignore_unused_variable_warning(ci2);
        }





       T* m_range;

    };


    template<class T>
    struct ForwardRangeConcept : SinglePassRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::iterator>)>::failed> boost_concept_check264;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::const_iterator>)>::failed> boost_concept_check265;

    };

    template<class Range>
    struct WriteableRangeConcept
    {

        typedef typename range_iterator<Range>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WriteableRangeConcept>)>::failed> boost_concept_check275; ~WriteableRangeConcept()
        {
            *i = v;
        }
    private:
        iterator i;
        typename range_value<Range>::type v;

    };


    template<class T>
    struct WriteableForwardRangeConcept
        : ForwardRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct BidirectionalRangeConcept : ForwardRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIteratorConcept<typename BidirectionalRangeConcept::iterator>)>::failed> boost_concept_check298;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIteratorConcept<typename BidirectionalRangeConcept::const_iterator>)>::failed> boost_concept_check299;

    };


    template<class T>
    struct WriteableBidirectionalRangeConcept
        : BidirectionalRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct RandomAccessRangeConcept : BidirectionalRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(RandomAccessIteratorConcept<typename RandomAccessRangeConcept::iterator>)>::failed> boost_concept_check316;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(RandomAccessIteratorConcept<typename RandomAccessRangeConcept::const_iterator>)>::failed> boost_concept_check317;

    };


    template<class T>
    struct WriteableRandomAccessRangeConcept
        : RandomAccessRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };

}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/algorithm/equal.hpp" 2 3


namespace boost
{
    namespace range_detail
    {


        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2 >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            do
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


            } while(*first1++ == *first2++);



            return false;
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2,
                  class BinaryPredicate >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            do
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


            } while(pred(*first1++, *first2++));



            return false;
        }



        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2 >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2);
        }

        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                BinaryPredicate pred )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2, pred);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2 >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2 )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, tag1, tag2);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2,
                           BinaryPredicate pred )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, pred, tag1, tag2);
        }

    }

    namespace range
    {
# 159 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/algorithm/equal.hpp" 3
        template< class SinglePassRange1, class SinglePassRange2 >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2 )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check162;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check163;

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2) );
        }


        template< class SinglePassRange1, class SinglePassRange2, class BinaryPredicate >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2,
                           BinaryPredicate pred )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check175;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check176;

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2),
                pred);
        }

    }
    using range::equal;
}
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 2 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 2 3
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
namespace boost
{
    namespace iterator_range_detail
    {




        template<class IteratorT>
        struct iterator_range_impl {
            template< class ForwardRange >
            static IteratorT adl_begin( ForwardRange& r )
            {
                return IteratorT( boost::begin( r ) );
            }

            template< class ForwardRange >
            static IteratorT adl_end( ForwardRange& r )
            {
                return IteratorT( boost::end( r ) );
            }
        };

        template< class Left, class Right >
        inline bool less_than( const Left& l, const Right& r )
        {
            return std::lexicographical_compare( boost::begin(l),
                                                 boost::end(l),
                                                 boost::begin(r),
                                                 boost::end(r) );
        }



        template< class Left, class Right >
        inline bool equal(const Left& l, const Right& r)
        {
            return boost::equal(l, r);
        }

        struct range_tag { };
        struct const_range_tag { };

    }
# 106 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
        template<class IteratorT>
        class iterator_range
        {
        protected:

            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;
        public:


            typedef iterator_range<IteratorT> type;



            typedef typename
                iterator_value<IteratorT>::type value_type;


            typedef typename
                iterator_difference<IteratorT>::type difference_type;


            typedef std::size_t size_type;


            typedef iterator_range<IteratorT> this_type;






            typedef typename
                iterator_reference<IteratorT>::type reference;






            typedef IteratorT const_iterator;

            typedef IteratorT iterator;

        private:
            typedef typename
                boost::mpl::if_< boost::is_abstract<value_type>,
                                 reference, value_type >::type abstract_value_type;

        public:
            iterator_range() : m_Begin( iterator() ), m_End( iterator() )
            { }


            template< class Iterator >
            iterator_range( Iterator Begin, Iterator End ) :
                m_Begin(Begin), m_End(End)
            {}


            template< class Range >
            iterator_range( const Range& r ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}


            template< class Range >
            iterator_range( Range& r ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}


            template< class Range >
            iterator_range( const Range& r, iterator_range_detail::const_range_tag ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}


            template< class Range >
            iterator_range( Range& r, iterator_range_detail::range_tag ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}


            this_type& operator=( const this_type& r )
            {
                m_Begin = r.begin();
                m_End = r.end();
                return *this;
            }


            template< class Iterator >
            iterator_range& operator=( const iterator_range<Iterator>& r )
            {
                m_Begin = r.begin();
                m_End = r.end();
                return *this;
            }

            template< class ForwardRange >
            iterator_range& operator=( ForwardRange& r )
            {
                m_Begin = impl::adl_begin( r );
                m_End = impl::adl_end( r );
                return *this;
            }

            template< class ForwardRange >
            iterator_range& operator=( const ForwardRange& r )
            {
                m_Begin = impl::adl_begin( r );
                m_End = impl::adl_end( r );
                return *this;
            }

            IteratorT begin() const
            {
                return m_Begin;
            }

            IteratorT end() const
            {
                return m_End;
            }

            difference_type size() const
            {
                return m_End - m_Begin;
            }

            bool empty() const
            {
                return m_Begin == m_End;
            }







            typedef iterator (iterator_range::*unspecified_bool_type) () const;
            operator unspecified_bool_type() const
            {
                return empty() ? 0: &iterator_range::end;
            }


            bool equal( const iterator_range& r ) const
            {
                return m_Begin == r.m_Begin && m_End == r.m_End;
            }
# 279 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
        public:
           reference front() const
           {
               ((!empty()) ? static_cast<void> (0) : __assert_fail ("!empty()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp", 282, __PRETTY_FUNCTION__));
               return *m_Begin;
           }

           reference back() const
           {
               ((!empty()) ? static_cast<void> (0) : __assert_fail ("!empty()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp", 288, __PRETTY_FUNCTION__));
               IteratorT last( m_End );
               return *--last;
           }

           reference operator[]( difference_type at ) const
           {
               ((at >= 0 && at < size()) ? static_cast<void> (0) : __assert_fail ("at >= 0 && at < size()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp", 295, __PRETTY_FUNCTION__));
               return m_Begin[at];
           }






           abstract_value_type operator()( difference_type at ) const
           {
               ((at >= 0 && at < size()) ? static_cast<void> (0) : __assert_fail ("at >= 0 && at < size()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp", 306, __PRETTY_FUNCTION__));
               return m_Begin[at];
           }

           iterator_range& advance_begin( difference_type n )
           {
               std::advance( m_Begin, n );
               return *this;
           }

           iterator_range& advance_end( difference_type n )
           {
               std::advance( m_End, n );
               return *this;
           }

        private:

            IteratorT m_Begin;
            IteratorT m_End;

        protected:




            typedef iterator_range iterator_range_;
        };







        template< class IteratorT, class ForwardRange >
        inline bool operator==( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator!=( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator<( const ForwardRange& l,
                               const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }



        template< class Iterator1T, class Iterator2T >
        inline bool operator==( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator==( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool operator!=( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator!=( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return !boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool operator<( const iterator_range<Iterator1T>& l,
                               const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator<( const iterator_range<IteratorT>& l,
                               const ForwardRange& r )
        {
            return iterator_range_detail::less_than( l, r );
        }
# 420 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
        template< typename IteratorT >
        inline iterator_range< IteratorT >
        make_iterator_range( IteratorT Begin, IteratorT End )
        {
            return iterator_range<IteratorT>( Begin, End );
        }
# 443 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
        template< class ForwardRange >
        inline iterator_range< typename range_iterator<ForwardRange>::type >
        make_iterator_range( ForwardRange& r )
        {
           return iterator_range< typename range_iterator<ForwardRange>::type >
                ( r, iterator_range_detail::range_tag() );
        }

        template< class ForwardRange >
        inline iterator_range< typename range_iterator<const ForwardRange>::type >
        make_iterator_range( const ForwardRange& r )
        {
           return iterator_range< typename range_iterator<const ForwardRange>::type >
                ( r, iterator_range_detail::const_range_tag() );
        }



        namespace iterator_range_detail
        {
            template< class Range >
            inline iterator_range< typename range_iterator<Range>::type >
            make_range_impl( Range& r,
                             typename range_difference<Range>::type advance_begin,
                             typename range_difference<Range>::type advance_end )
            {







                typename range_iterator<Range>::type
                    new_begin = boost::begin( r ),
                    new_end = boost::end( r );
                std::advance( new_begin, advance_begin );
                std::advance( new_end, advance_end );
                return make_iterator_range( new_begin, new_end );
            }
        }
# 499 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
        template< class Range >
        inline iterator_range< typename range_iterator<Range>::type >
        make_iterator_range( Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {

            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }

        template< class Range >
        inline iterator_range< typename range_iterator<const Range>::type >
        make_iterator_range( const Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {

            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
# 529 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_core.hpp" 3
        template< typename SeqT, typename Range >
        inline SeqT copy_range( const Range& r )
        {
            return SeqT( boost::begin( r ), boost::end( r ) );
        }

}
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_io.hpp" 1 3
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_io.hpp" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_io.hpp" 2 3

namespace boost
{
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_io.hpp" 3
        template< typename IteratorT, typename Elem, typename Traits >
        inline std::basic_ostream<Elem,Traits>& operator<<(
                    std::basic_ostream<Elem, Traits>& Os,
                    const iterator_range<IteratorT>& r )
        {
            std::copy( r.begin(), r.end(),
                       std::ostream_iterator< typename
                                              iterator_value<IteratorT>::type,
                                              Elem, Traits>(Os) );
            return Os;
        }
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range_io.hpp" 3
}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/iterator_range.hpp" 2 3
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 2 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/deque" 1 3
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/deque" 3
       
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/deque" 3





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 1 3
# 65 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 102 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
# 435 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
# 475 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 565 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 712 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:





      deque()
      : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 784 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 797 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 849 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 874 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 924 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 940 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 966 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
# 1080 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 1100 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }
# 1121 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1137 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1152 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 1177 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1195 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1252 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1283 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1314 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1335 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1372 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1412 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1426 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1449 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1468 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1480 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1542 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1564 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);
# 1574 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }




      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);
# 1645 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1657 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);







      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }



      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1793 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1825 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1843 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }



}
# 66 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/deque" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/deque.tcc" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
# 118 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }
# 163 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)

      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {




     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);

     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(const value_type& __t)

      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;




     this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);

   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>
# 514 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/deque.tcc" 3
    typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, const value_type& __x)
      {
 value_type __x_copy = __x;

 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front((front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::copy(__front2, __pos1, __front1);
   }
 else
   {
     push_back((back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::copy_backward(__pos, __back2, __back1);
   }
 *__pos = (__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }
# 987 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/deque.tcc" 3
}
# 69 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/deque" 2 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 2 3





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/as_literal.hpp" 1 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/as_literal.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/str_types.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/str_types.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size_type.hpp" 1 3
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size_type.hpp" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/size_type.hpp" 2 3


namespace boost
{
    namespace detail
    {





        template< typename C >
        struct range_size
        {
            typedef typename C::size_type type;
        };





        template< typename Iterator >
        struct range_size< std::pair<Iterator,Iterator> >
        {
            typedef std::size_t type;
        };





        template< typename T, std::size_t sz >
        struct range_size< T[sz] >
        {
            typedef std::size_t type;
        };
    }

    template< class T >
    struct range_size :
        detail::range_size<T>
    { };

    template< class T >
    struct range_size<const T >
        : detail::range_size<T>
    { };

}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/detail/str_types.hpp" 2 3


namespace boost
{
    template< class T >
    struct range_mutable_iterator<T*>
    {
        typedef T* type;
    };

    template< class T >
    struct range_const_iterator<T*>
    {
        typedef const T* type;
    };

    template< class T >
    struct range_size<T*>
    {
       typedef std::size_t type;
    };
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/as_literal.hpp" 2 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 2 3
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/as_literal.hpp" 2 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 2 3


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwchar" 2 3
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/as_literal.hpp" 2 3


namespace boost
{
    namespace range_detail
    {
        inline std::size_t length( const char* s )
        {
            return strlen( s );
        }


        inline std::size_t length( const wchar_t* s )
        {
            return wcslen( s );
        }
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/range/as_literal.hpp" 3
        inline bool is_char_ptr( char* )
        {
            return true;
        }

        inline bool is_char_ptr( const char* )
        {
            return true;
        }


        inline bool is_char_ptr( wchar_t* )
        {
            return true;
        }

        inline bool is_char_ptr( const wchar_t* )
        {
            return true;
        }


        template< class T >
        inline long is_char_ptr( T )
        {
            return 0L;
        }

        template< class T >
        inline iterator_range<T*>
        make_range( T* const r, bool )
        {
            return iterator_range<T*>( r, r + length(r) );
        }

        template< class T >
        inline iterator_range<typename range_iterator<T>::type>
        make_range( T& r, long )
        {
            return boost::make_iterator_range( r );
        }

    }

    template< class Range >
    inline iterator_range<typename range_iterator<Range>::type>
    as_literal( Range& r )
    {
        return range_detail::make_range( r, range_detail::is_char_ptr(r) );
    }

    template< class Range >
    inline iterator_range<typename range_iterator<const Range>::type>
    as_literal( const Range& r )
    {
        return range_detail::make_range( r, range_detail::is_char_ptr(r) );
    }

    template< class Char, std::size_t sz >
    inline iterator_range<Char*> as_literal( Char (&arr)[sz] )
    {
        return range_detail::make_range( arr, range_detail::is_char_ptr(arr) );
    }

    template< class Char, std::size_t sz >
    inline iterator_range<const Char*> as_literal( const Char (&arr)[sz] )
    {
        return range_detail::make_range( arr, range_detail::is_char_ptr(arr) );
    }
}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 2 3

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/concept.hpp" 1 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/concept.hpp" 3
namespace boost {
    namespace algorithm {
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/concept.hpp" 3
        template<typename FinderT, typename IteratorT>
        struct FinderConcept
        {
        private:
            typedef iterator_range<IteratorT> range;
        public:
            void constraints()
            {

                r=(*pF)(i,i);
            }
        private:
            range r;
            IteratorT i;
            FinderT* pF;
        };
# 61 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/concept.hpp" 3
        template<typename FormatterT, typename FinderT, typename IteratorT>
        struct FormatterConcept
        {
        public:
            void constraints()
            {

                ::boost::begin((*pFo)( (*pF)(i,i) ));
                ::boost::end((*pFo)( (*pF)(i,i) ));
            }
        private:
            IteratorT i;
            FinderT* pF;
            FormatterT *pFo;
        };

    }
}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format.hpp" 1 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format_store.hpp" 1 3
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format_store.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {







            template<
                typename ForwardIteratorT,
                typename FormatterT,
                typename FormatResultT >
            class find_format_store :
                public iterator_range<ForwardIteratorT>
            {
            public:

                typedef iterator_range<ForwardIteratorT> base_type;
                typedef FormatterT formatter_type;
                typedef FormatResultT format_result_type;

            public:

                find_format_store(
                        const base_type& FindResult,
                        const format_result_type& FormatResult,
                        const formatter_type& Formatter ) :
                    base_type(FindResult),
                    m_FormatResult(FormatResult),
                    m_Formatter(Formatter) {}


                template< typename FindResultT >
                find_format_store& operator=( FindResultT FindResult )
                {
                    iterator_range<ForwardIteratorT>::operator=(FindResult);
                    if( !this->empty() ) {
                    m_FormatResult=m_Formatter(FindResult);
                    }

                    return *this;
                }


                const format_result_type& format_result()
                {
                    return m_FormatResult;
                }

            private:
                format_result_type m_FormatResult;
                const formatter_type& m_Formatter;
            };

            template<typename InputT, typename FindResultT>
            bool check_find_result(InputT& Input, FindResultT& FindResult)
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;
                iterator_range<input_iterator_type> ResultRange(FindResult);
                return !ResultRange.empty();
            }




        }
    }
}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/replace_storage.hpp" 1 3
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/replace_storage.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/sequence_traits.hpp" 1 3
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/sequence_traits.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/yes_no_type.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/yes_no_type.hpp" 3
namespace boost {
    namespace algorithm {





        template<int I> struct size_descriptor
        {
            typedef char (& type)[I];
        };

        typedef size_descriptor<1>::type yes_type;
        typedef size_descriptor<2>::type no_type;

    }
}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/sequence_traits.hpp" 2 3
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/sequence_traits.hpp" 3
namespace boost {
    namespace algorithm {
# 85 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/sequence_traits.hpp" 3
        template< typename T >
        class has_native_replace
        {
# 96 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/sequence_traits.hpp" 3
        public:



            static const bool value=false;




            typedef mpl::bool_<has_native_replace<T>::value> type;
        };







        template< typename T >
        class has_stable_iterators
        {







        public:



            static const bool value=false;



            typedef mpl::bool_<has_stable_iterators<T>::value> type;
        };







        template< typename T >
        class has_const_time_insert
        {







        public:



            static const bool value=false;



            typedef mpl::bool_<has_const_time_insert<T>::value> type;
        };







        template< typename T >
        class has_const_time_erase
        {







        public:



            static const bool value=false;



            typedef mpl::bool_<has_const_time_erase<T>::value> type;
        };

    }
}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/replace_storage.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/sequence.hpp" 1 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/sequence.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {



            template< typename InputT, typename ForwardIteratorT >
            inline void insert(
                InputT& Input,
                typename InputT::iterator At,
                ForwardIteratorT Begin,
                ForwardIteratorT End )
            {
                Input.insert( At, Begin, End );
            }

            template< typename InputT, typename InsertT >
            inline void insert(
                InputT& Input,
                typename InputT::iterator At,
                const InsertT& Insert )
            {
                ::boost::algorithm::detail::insert( Input, At, ::boost::begin(Insert), ::boost::end(Insert) );
            }







            template< typename InputT >
            inline typename InputT::iterator erase(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To )
            {
                return Input.erase( From, To );
            }





            template< bool HasConstTimeOperations >
            struct replace_const_time_helper
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {

                    ForwardIteratorT InsertIt=Begin;
                    typename InputT::iterator InputIt=From;
                    for(; InsertIt!=End && InputIt!=To; InsertIt++, InputIt++ )
                    {
                        *InputIt=*InsertIt;
                    }

                    if ( InsertIt!=End )
                    {

                        Input.insert( InputIt, InsertIt, End );
                    }
                    else
                    {
                        if ( InputIt!=To )
                        {

                            Input.erase( InputIt, To );
                        }
                    }
                }
            };

            template<>
            struct replace_const_time_helper< true >
            {

                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    typename InputT::iterator At=Input.erase( From, To );
                    if ( Begin!=End )
                    {
                        if(!Input.empty())
                        {
                            Input.insert( At, Begin, End );
                        }
                        else
                        {
                            Input.insert( Input.begin(), Begin, End );
                        }
                    }
                }
            };


            template< bool HasNative >
            struct replace_native_helper
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    replace_const_time_helper<
                        boost::mpl::and_<
                            has_const_time_insert<InputT>,
                            has_const_time_erase<InputT> >::value >()(
                        Input, From, To, Begin, End );
                }
            };


            template<>
            struct replace_native_helper< true >
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    Input.replace( From, To, Begin, End );
                }
            };



            template< typename InputT, typename ForwardIteratorT >
            inline void replace(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End )
            {
                replace_native_helper< has_native_replace<InputT>::value >()(
                    Input, From, To, Begin, End );
            }

            template< typename InputT, typename InsertT >
            inline void replace(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                const InsertT& Insert )
            {
                if(From!=To)
                {
                    ::boost::algorithm::detail::replace( Input, From, To, ::boost::begin(Insert), ::boost::end(Insert) );
                }
                else
                {
                    ::boost::algorithm::detail::insert( Input, From, ::boost::begin(Insert), ::boost::end(Insert) );
                }
            }

        }
    }
}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/replace_storage.hpp" 2 3

namespace boost {
    namespace algorithm {
        namespace detail {



            template< typename StorageT, typename OutputIteratorT >
            inline OutputIteratorT move_from_storage(
                StorageT& Storage,
                OutputIteratorT DestBegin,
                OutputIteratorT DestEnd )
            {
                OutputIteratorT OutputIt=DestBegin;

                while( !Storage.empty() && OutputIt!=DestEnd )
                {
                    *OutputIt=Storage.front();
                    Storage.pop_front();
                    ++OutputIt;
                }

                return OutputIt;
            }

            template< typename StorageT, typename WhatT >
            inline void copy_to_storage(
                StorageT& Storage,
                const WhatT& What )
            {
                Storage.insert( Storage.end(), ::boost::begin(What), ::boost::end(What) );
            }




            template< bool HasStableIterators >
            struct process_segment_helper
            {

                template<
                    typename StorageT,
                    typename InputT,
                    typename ForwardIteratorT >
                ForwardIteratorT operator()(
                    StorageT& Storage,
                    InputT& ,
                    ForwardIteratorT InsertIt,
                    ForwardIteratorT SegmentBegin,
                    ForwardIteratorT SegmentEnd )
                {

                    ForwardIteratorT It=::boost::algorithm::detail::move_from_storage( Storage, InsertIt, SegmentBegin );






                    if( Storage.empty() )
                    {
                        if( It==SegmentBegin )
                        {

                            return SegmentEnd;
                        }
                        else
                        {

                            return std::copy( SegmentBegin, SegmentEnd, It );
                        }
                    }
                    else
                    {

                        while( It!=SegmentEnd )
                        {

                            Storage.push_back( *It );

                            *It=Storage.front();
                            Storage.pop_front();


                            ++It;
                        }

                        return It;
                    }
                }
            };

            template<>
            struct process_segment_helper< true >
            {

                template<
                    typename StorageT,
                    typename InputT,
                    typename ForwardIteratorT >
                ForwardIteratorT operator()(
                    StorageT& Storage,
                    InputT& Input,
                    ForwardIteratorT InsertIt,
                    ForwardIteratorT SegmentBegin,
                    ForwardIteratorT SegmentEnd )

                {

                    ::boost::algorithm::detail::replace( Input, InsertIt, SegmentBegin, Storage );

                    Storage.clear();

                    return SegmentEnd;
                }
            };


            template<
                typename StorageT,
                typename InputT,
                typename ForwardIteratorT >
            inline ForwardIteratorT process_segment(
                StorageT& Storage,
                InputT& Input,
                ForwardIteratorT InsertIt,
                ForwardIteratorT SegmentBegin,
                ForwardIteratorT SegmentEnd )
            {
                return
                    process_segment_helper<
                        has_stable_iterators<InputT>::value>()(
                                Storage, Input, InsertIt, SegmentBegin, SegmentEnd );
            }


        }
    }
}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format.hpp" 2 3

namespace boost {
    namespace algorithm {
        namespace detail {



           template<
                typename OutputIteratorT,
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline OutputIteratorT find_format_copy_impl2(
                OutputIteratorT Output,
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult )
            {
                typedef find_format_store<
                    typename
                        range_const_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );

                if ( !M )
                {

                    Output = std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
                    return Output;
                }


                Output = std::copy( ::boost::begin(Input), ::boost::begin(M), Output );


                Output = std::copy( ::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output );

                Output = std::copy( M.end(), ::boost::end(Input), Output );

                return Output;
            }

            template<
                typename OutputIteratorT,
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline OutputIteratorT find_format_copy_impl(
                OutputIteratorT Output,
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult )
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                return ::boost::algorithm::detail::find_format_copy_impl2(
                    Output,
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
                } else {
                    return std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
            }
            }




           template<
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline InputT find_format_copy_impl2(
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef find_format_store<
                    typename
                        range_const_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );

                if ( !M )
                {

                    return InputT( Input );
                }

                InputT Output;

                insert( Output, ::boost::end(Output), ::boost::begin(Input), M.begin() );

                insert( Output, ::boost::end(Output), M.format_result() );

                insert( Output, ::boost::end(Output), M.end(), ::boost::end(Input) );

                return Output;
            }

            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline InputT find_format_copy_impl(
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                return ::boost::algorithm::detail::find_format_copy_impl2(
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
                } else {
                    return Input;
            }
            }



            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline void find_format_impl2(
                InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef find_format_store<
                    typename
                        range_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );

                if ( !M )
                {

                    return;
                }


                ::boost::algorithm::detail::replace( Input, M.begin(), M.end(), M.format_result() );
            }

            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline void find_format_impl(
                InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                ::boost::algorithm::detail::find_format_impl2(
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }
            }

        }
    }
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format_all.hpp" 1 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/find_format_all.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {



           template<
                typename OutputIteratorT,
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline OutputIteratorT find_format_all_copy_impl2(
                OutputIteratorT Output,
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult )
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;

                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );


                input_iterator_type LastMatch=::boost::begin(Input);


                while( M )
                {

                    Output = std::copy( LastMatch, M.begin(), Output );

                    Output = std::copy( ::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output );


                    LastMatch=M.end();
                    M=Finder( LastMatch, ::boost::end(Input) );
                }


                Output = std::copy( LastMatch, ::boost::end(Input), Output );

                return Output;
            }

            template<
                typename OutputIteratorT,
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline OutputIteratorT find_format_all_copy_impl(
                OutputIteratorT Output,
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult )
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                return ::boost::algorithm::detail::find_format_all_copy_impl2(
                    Output,
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
                } else {
                    return std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
            }
            }



           template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline InputT find_format_all_copy_impl2(
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;

                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );


                input_iterator_type LastMatch=::boost::begin(Input);


                InputT Output;


                while( M )
                {

                    insert( Output, ::boost::end(Output), LastMatch, M.begin() );

                    insert( Output, ::boost::end(Output), M.format_result() );


                    LastMatch=M.end();
                    M=Finder( LastMatch, ::boost::end(Input) );
                }


                ::boost::algorithm::detail::insert( Output, ::boost::end(Output), LastMatch, ::boost::end(Input) );

                return Output;
            }

            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline InputT find_format_all_copy_impl(
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                return ::boost::algorithm::detail::find_format_all_copy_impl2(
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
                } else {
                    return Input;
            }
            }



            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline void find_format_all_impl2(
                InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                FindResultT FindResult,
                FormatResultT FormatResult)
            {
                typedef typename
                    range_iterator<InputT>::type input_iterator_type;
                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );


                std::deque<
                    typename range_value<InputT>::type> Storage;


                input_iterator_type InsertIt=::boost::begin(Input);
                input_iterator_type SearchIt=::boost::begin(Input);

                while( M )
                {

                    InsertIt=process_segment(
                        Storage,
                        Input,
                        InsertIt,
                        SearchIt,
                        M.begin() );


                    SearchIt=M.end();


                    ::boost::algorithm::detail::copy_to_storage( Storage, M.format_result() );


                    M=Finder( SearchIt, ::boost::end(Input) );
                }


                InsertIt=::boost::algorithm::detail::process_segment(
                    Storage,
                    Input,
                    InsertIt,
                    SearchIt,
                    ::boost::end(Input) );

                if ( Storage.empty() )
                {

                    ::boost::algorithm::detail::erase( Input, InsertIt, ::boost::end(Input) );
                }
                else
                {

                    ::boost::algorithm::detail::insert( Input, ::boost::end(Input), Storage.begin(), Storage.end() );
                }
            }

            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline void find_format_all_impl(
                InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                FindResultT FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                ::boost::algorithm::detail::find_format_all_impl2(
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }
            }

        }
    }
}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 2 3







namespace boost {
    namespace algorithm {
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename OutputIteratorT,
            typename RangeT,
            typename FinderT,
            typename FormatterT>
        inline OutputIteratorT find_format_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<RangeT>::type> )>::failed>



 boost_concept_check69;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<RangeT>::type> )>::failed>



 boost_concept_check74;

            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));

            return detail::find_format_copy_impl(
                Output,
                lit_input,
                Formatter,
                Finder( ::boost::begin(lit_input), ::boost::end(lit_input) ) );
        }





        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT>
        inline SequenceT find_format_copy(
            const SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check103;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check108;

            return detail::find_format_copy_impl(
                Input,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
# 125 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT>
        inline void find_format(
            SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter)
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check139;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check144;

            detail::find_format_impl(
                Input,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
# 172 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename OutputIteratorT,
            typename RangeT,
            typename FinderT,
            typename FormatterT>
        inline OutputIteratorT find_format_all_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            FinderT Finder,
            FormatterT Formatter)
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<RangeT>::type> )>::failed>



 boost_concept_check188;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<RangeT>::type> )>::failed>



 boost_concept_check193;

            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));

            return detail::find_format_all_copy_impl(
                Output,
                lit_input,
                Finder,
                Formatter,
                Finder(::boost::begin(lit_input), ::boost::end(lit_input)));
        }





        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT >
        inline SequenceT find_format_all_copy(
            const SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check223;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check228;

            return detail::find_format_all_copy_impl(
                Input,
                Finder,
                Formatter,
                Finder( ::boost::begin(Input), ::boost::end(Input) ) );
        }
# 247 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT >
        inline void find_format_all(
            SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check261;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed>



 boost_concept_check266;

            detail::find_format_all_impl(
                Input,
                Finder,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));

        }

    }


    using algorithm::find_format_copy;
    using algorithm::find_format;
    using algorithm::find_format_all_copy;
    using algorithm::find_format_all;

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 1 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/constants.hpp" 1 3
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/constants.hpp" 3
namespace boost {
    namespace algorithm {





    enum token_compress_mode_type
    {
        token_compress_on,
        token_compress_off
    };

    }


    using algorithm::token_compress_on;
    using algorithm::token_compress_off;

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 1 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename SearchIteratorT,typename PredicateT>
            struct first_finderF
            {
                typedef SearchIteratorT search_iterator_type;


                template< typename SearchT >
                first_finderF( const SearchT& Search, PredicateT Comp ) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
                first_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        PredicateT Comp ) :
                    m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    typedef ForwardIteratorT input_iterator_type;


                    for(input_iterator_type OuterIt=Begin;
                        OuterIt!=End;
                        ++OuterIt)
                    {

                        if( boost::empty(m_Search) )
                            return result_type( End, End );

                        input_iterator_type InnerIt=OuterIt;
                        search_iterator_type SubstrIt=m_Search.begin();
                        for(;
                            InnerIt!=End && SubstrIt!=m_Search.end();
                            ++InnerIt,++SubstrIt)
                        {
                            if( !( m_Comp(*InnerIt,*SubstrIt) ) )
                                break;
                        }


                        if ( SubstrIt==m_Search.end() )
                            return result_type( OuterIt, InnerIt );
                    }

                    return result_type( End, End );
                }

            private:
                iterator_range<search_iterator_type> m_Search;
                PredicateT m_Comp;
            };
# 100 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename SearchIteratorT, typename PredicateT>
            struct last_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                typedef first_finderF<
                    search_iterator_type,
                    PredicateT> first_finder_type;


                template< typename SearchT >
                last_finderF( const SearchT& Search, PredicateT Comp ) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
                last_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        PredicateT Comp ) :
                    m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;

                    if( boost::empty(m_Search) )
                        return result_type( End, End );

                    typedef typename boost::detail::
                        iterator_traits<ForwardIteratorT>::iterator_category category;

                    return findit( Begin, End, category() );
                }

            private:

                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                findit(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    std::forward_iterator_tag ) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;

                    first_finder_type first_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );

                    result_type M=first_finder( Begin, End );
                    result_type Last=M;

                    while( M )
                    {
                        Last=M;
                        M=first_finder( ::boost::end(M), End );
                    }

                    return Last;
                }


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                findit(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    std::bidirectional_iterator_tag ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    typedef ForwardIteratorT input_iterator_type;


                    for(input_iterator_type OuterIt=End;
                        OuterIt!=Begin; )
                    {
                        input_iterator_type OuterIt2=--OuterIt;

                        input_iterator_type InnerIt=OuterIt2;
                        search_iterator_type SubstrIt=m_Search.begin();
                        for(;
                            InnerIt!=End && SubstrIt!=m_Search.end();
                            ++InnerIt,++SubstrIt)
                        {
                            if( !( m_Comp(*InnerIt,*SubstrIt) ) )
                                break;
                        }


                        if( SubstrIt==m_Search.end() )
                            return result_type( OuterIt2, InnerIt );
                    }

                    return result_type( End, End );
                }

            private:
                iterator_range<search_iterator_type> m_Search;
                PredicateT m_Comp;
            };
# 210 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename SearchIteratorT, typename PredicateT>
            struct nth_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                typedef first_finderF<
                    search_iterator_type,
                    PredicateT> first_finder_type;
                typedef last_finderF<
                    search_iterator_type,
                    PredicateT> last_finder_type;


                template< typename SearchT >
                nth_finderF(
                        const SearchT& Search,
                        int Nth,
                        PredicateT Comp) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)),
                    m_Nth(Nth),
                    m_Comp(Comp) {}
                nth_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        int Nth,
                        PredicateT Comp) :
                    m_Search(SearchBegin, SearchEnd),
                    m_Nth(Nth),
                    m_Comp(Comp) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_Nth>=0)
                    {
                        return find_forward(Begin, End, m_Nth);
                    }
                    else
                    {
                        return find_backward(Begin, End, -m_Nth);
                    }

                }

            private:

                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                find_forward(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    unsigned int N) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;


                    if( boost::empty(m_Search) )
                        return result_type( End, End );


                    first_finder_type first_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );

                    result_type M( Begin, Begin );

                    for( unsigned int n=0; n<=N; ++n )
                    {

                        M=first_finder( ::boost::end(M), End );

                        if ( !M )
                        {

                            return M;
                        }
                    }

                    return M;
                }

                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                find_backward(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    unsigned int N) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;


                    if( boost::empty(m_Search) )
                        return result_type( End, End );


                    last_finder_type last_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );

                    result_type M( End, End );

                    for( unsigned int n=1; n<=N; ++n )
                    {

                        M=last_finder( Begin, ::boost::begin(M) );

                        if ( !M )
                        {

                            return M;
                        }
                    }

                    return M;
                }


            private:
                iterator_range<search_iterator_type> m_Search;
                int m_Nth;
                PredicateT m_Comp;
            };



            template<typename ForwardIteratorT>
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::forward_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                input_iterator_type It=Begin;
                for(
                    unsigned int Index=0;
                    Index<N && It!=End; ++Index,++It ) {};

                return result_type( Begin, It );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::random_access_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                if ( (End<=Begin) || ( static_cast<unsigned int>(End-Begin) < N ) )
                    return result_type( Begin, End );

                return result_type(Begin,Begin+N);
            }


            template<typename ForwardIteratorT>
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;

                return ::boost::algorithm::detail::find_head_impl( Begin, End, N, category() );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::forward_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                unsigned int Index=0;
                input_iterator_type It=Begin;
                input_iterator_type It2=Begin;


                for( Index=0; Index<N && It2!=End; ++Index,++It2 ) {};


                for(; It2!=End; ++It,++It2 ) {};

                return result_type( It, It2 );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::bidirectional_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                input_iterator_type It=End;
                for(
                    unsigned int Index=0;
                    Index<N && It!=Begin; ++Index,--It ) {};

                return result_type( It, End );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::random_access_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                if ( (End<=Begin) || ( static_cast<unsigned int>(End-Begin) < N ) )
                    return result_type( Begin, End );

                return result_type( End-N, End );
            }


            template< typename ForwardIteratorT >
            iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;

                return ::boost::algorithm::detail::find_tail_impl( Begin, End, N, category() );
            }
# 473 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            struct head_finderF
            {

                head_finderF( int N ) : m_N(N) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_N>=0)
                    {
                        return ::boost::algorithm::detail::find_head_impl( Begin, End, m_N );
                    }
                    else
                    {
                        iterator_range<ForwardIteratorT> Res=
                            ::boost::algorithm::detail::find_tail_impl( Begin, End, -m_N );

                        return ::boost::make_iterator_range(Begin, Res.begin());
                    }
                }

            private:
                int m_N;
            };
# 511 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            struct tail_finderF
            {

                tail_finderF( int N ) : m_N(N) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_N>=0)
                    {
                        return ::boost::algorithm::detail::find_tail_impl( Begin, End, m_N );
                    }
                    else
                    {
                        iterator_range<ForwardIteratorT> Res=
                            ::boost::algorithm::detail::find_head_impl( Begin, End, -m_N );

                        return ::boost::make_iterator_range(Res.end(), End);
                    }
                }

            private:
                int m_N;
            };
# 552 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            template< typename PredicateT >
            struct token_finderF
            {

                token_finderF(
                    PredicateT Pred,
                    token_compress_mode_type eCompress=token_compress_off ) :
                        m_Pred(Pred), m_eCompress(eCompress) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;

                    ForwardIteratorT It=std::find_if( Begin, End, m_Pred );

                    if( It==End )
                    {
                        return result_type( End, End );
                    }
                    else
                    {
                        ForwardIteratorT It2=It;

                        if( m_eCompress==token_compress_on )
                        {

                            while( It2!=End && m_Pred(*It2) ) ++It2;
                        }
                        else
                        {

                            ++It2;
                        }

                        return result_type( It, It2 );
                    }
                }

            private:
                PredicateT m_Pred;
                token_compress_mode_type m_eCompress;
            };
# 607 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename ForwardIterator1T>
            struct range_finderF
            {
                typedef ForwardIterator1T input_iterator_type;
                typedef iterator_range<input_iterator_type> result_type;


                range_finderF(
                    input_iterator_type Begin,
                    input_iterator_type End ) : m_Range(Begin, End) {}

                range_finderF(const iterator_range<input_iterator_type>& Range) :
                    m_Range(Range) {}


                template< typename ForwardIterator2T >
                iterator_range<ForwardIterator2T>
                operator()(
                    ForwardIterator2T,
                    ForwardIterator2T ) const
                {





                    return m_Range;

                }

            private:
                iterator_range<input_iterator_type> m_Range;
            };


        }
    }
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 1 3
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/locale" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/locale" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/locale" 3




# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
       
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/ctime" 2 3
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 50 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 208 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();


}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/time_members.h" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null), _M_c_locale_timepunct(__null),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(__null),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null), _M_c_locale_timepunct(__null),
      _M_name_timepunct(__null)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }

}
# 346 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 362 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 384 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 401 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 425 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 450 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 478 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 507 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 533 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 553 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 571 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 590 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 609 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 628 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 647 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 709 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 730 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 749 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 769 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 796 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 835 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }
# 928 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 957 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 969 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 984 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 998 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1011 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1041 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1054 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1071 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1088 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1140 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1162 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1174 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1187 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1200 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1213 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1226 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1240 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1254 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1268 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;


# 1363 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1385 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1415 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1446 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1469 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1481 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1492 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1514 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1535 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1555 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1578 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1612 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1636 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1647 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;







  struct messages_base
  {
    typedef int catalog;
  };
# 1688 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1716 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1730 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1743 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1761 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1779 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1790 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1810 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1829 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 1886 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };

}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/messages_members.h" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/messages_members.h" 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libintl.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libintl.h" 3 4
extern "C" {




extern char *gettext (__const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));



extern char *dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (__const char *__domainname,
   __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (__const char *__domainname,
     __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (__const char *__msgid1, __const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (__const char *__domainname, __const char *__msgid1,
   __const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (__const char *__domainname, __const char *__msgid1,
    __const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (__const char *__domainname) throw ();



extern char *bindtextdomain (__const char *__domainname,
        __const char *__dirname) throw ();



extern char *bind_textdomain_codeset (__const char *__domainname,
          __const char *__codeset) throw ();
# 122 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libintl.h" 3 4
}
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
       _M_name_messages(_S_get_c_name())
     { }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale __cloc, const char* __s,
    size_t __refs)
     : facet(__refs), _M_c_locale_messages(__null), _M_name_messages(__null)
     {
       if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
  {
    const size_t __len = __builtin_strlen(__s) + 1;
    char* __tmp = new char[__len];
    __builtin_memcpy(__tmp, __s, __len);
    _M_name_messages = __tmp;
  }
       else
  _M_name_messages = _S_get_c_name();


       _M_c_locale_messages = _S_clone_c_locale(__cloc);
     }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
       if (this->_M_name_messages != locale::facet::_S_get_c_name())
  {
    delete [] this->_M_name_messages;
    if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
      {
        const size_t __len = __builtin_strlen(__s) + 1;
        char* __tmp = new char[__len];
        __builtin_memcpy(__tmp, __s, __len);
        this->_M_name_messages = __tmp;
      }
    else
      this->_M_name_messages = locale::facet::_S_get_c_name();
  }

       if (__builtin_strcmp(__s, "C") != 0
    && __builtin_strcmp(__s, "POSIX") != 0)
  {
    this->_S_destroy_c_locale(this->_M_c_locale_messages);
    this->_S_create_c_locale(this->_M_c_locale_messages, __s);
  }
     }

}
# 1925 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 1 3
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
       
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 66 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 114 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 153 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 194 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 235 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 274 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



}
# 1928 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.tcc" 1 3
# 33 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.tcc" 3
       
# 34 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   _M_grouping_size = __mp.grouping().size();
   __grouping = new char[_M_grouping_size];
   __mp.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_curr_symbol_size = __mp.curr_symbol().size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
   _M_curr_symbol = __curr_symbol;

   _M_positive_sign_size = __mp.positive_sign().size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
   _M_positive_sign = __positive_sign;

   _M_negative_sign_size = __mp.negative_sign().size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
   _M_negative_sign = __negative_sign;

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }



  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 360 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 565 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 597 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }






  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg, ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, ++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }






  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);



}
# 1931 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/locale_facets_nonio.h" 2 3
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/locale" 2 3
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 2 3
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 3
namespace boost {
    namespace algorithm {
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 3
        struct is_equal
        {




            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1==Arg2;
            }
        };






        struct is_iequal
        {




            is_iequal( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}





            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {



                    return std::toupper<T1>(Arg1,m_Loc)==std::toupper<T2>(Arg2,m_Loc);

            }

        private:
            std::locale m_Loc;
        };
# 86 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 3
        struct is_less
        {




            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1<Arg2;
            }
        };







        struct is_iless
        {




            is_iless( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}





            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {



                    return std::toupper<T1>(Arg1,m_Loc)<std::toupper<T2>(Arg2,m_Loc);

            }

        private:
            std::locale m_Loc;
        };
# 139 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/compare.hpp" 3
        struct is_not_greater
        {




            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1<=Arg2;
            }
        };







        struct is_not_igreater
        {




            is_not_igreater( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}





            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {



                    return std::toupper<T1>(Arg1,m_Loc)<=std::toupper<T2>(Arg2,m_Loc);

            }

        private:
            std::locale m_Loc;
        };


    }


    using algorithm::is_equal;
    using algorithm::is_iequal;
    using algorithm::is_less;
    using algorithm::is_iless;
    using algorithm::is_not_greater;
    using algorithm::is_not_igreater;

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 2 3
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
namespace boost {
    namespace algorithm {
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        template<typename RangeT>
        inline detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        first_finder( const RangeT& Search )
        {
            return
                detail::first_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                        is_equal>( ::boost::as_literal(Search), is_equal() ) ;
        }





        template<typename RangeT,typename PredicateT>
        inline detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        first_finder(
            const RangeT& Search, PredicateT Comp )
        {
            return
                detail::first_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( ::boost::as_literal(Search), Comp );
        }
# 90 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        template<typename RangeT>
        inline detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        last_finder( const RangeT& Search )
        {
            return
                detail::last_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( ::boost::as_literal(Search), is_equal() );
        }




        template<typename RangeT, typename PredicateT>
        inline detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        last_finder( const RangeT& Search, PredicateT Comp )
        {
            return
                detail::last_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( ::boost::as_literal(Search), Comp ) ;
        }
# 130 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        template<typename RangeT>
        inline detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        nth_finder(
            const RangeT& Search,
            int Nth)
        {
            return
                detail::nth_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( ::boost::as_literal(Search), Nth, is_equal() ) ;
        }




        template<typename RangeT, typename PredicateT>
        inline detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        nth_finder(
            const RangeT& Search,
            int Nth,
            PredicateT Comp )
        {
            return
                detail::nth_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( ::boost::as_literal(Search), Nth, Comp );
        }
# 175 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        inline detail::head_finderF
        head_finder( int N )
        {
            return detail::head_finderF(N);
        }
# 192 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        inline detail::tail_finderF
        tail_finder( int N )
        {
            return detail::tail_finderF(N);
        }
# 216 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        template< typename PredicateT >
        inline detail::token_finderF<PredicateT>
        token_finder(
            PredicateT Pred,
            token_compress_mode_type eCompress=token_compress_off )
        {
            return detail::token_finderF<PredicateT>( Pred, eCompress );
        }
# 236 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/finder.hpp" 3
        template< typename ForwardIteratorT >
        inline detail::range_finderF<ForwardIteratorT>
        range_finder(
            ForwardIteratorT Begin,
            ForwardIteratorT End )
        {
            return detail::range_finderF<ForwardIteratorT>( Begin, End );
        }





        template< typename ForwardIteratorT >
        inline detail::range_finderF<ForwardIteratorT>
        range_finder( iterator_range<ForwardIteratorT> Range )
        {
            return detail::range_finderF<ForwardIteratorT>( Range );
        }

    }


    using algorithm::first_finder;
    using algorithm::last_finder;
    using algorithm::nth_finder;
    using algorithm::head_finder;
    using algorithm::tail_finder;
    using algorithm::token_finder;
    using algorithm::range_finder;

}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 1 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/formatter.hpp" 1 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/formatter.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/util.hpp" 1 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/util.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/util.hpp" 3
            template< typename CharT >
            struct empty_container
            {
                typedef empty_container<CharT> type;
                typedef CharT value_type;
                typedef std::size_t size_type;
                typedef std::ptrdiff_t difference_type;
                typedef const value_type& reference;
                typedef const value_type& const_reference;
                typedef const value_type* iterator;
                typedef const value_type* const_iterator;



                const_iterator begin() const
                {
                    return reinterpret_cast<const_iterator>(0);
                }

                const_iterator end() const
                {
                    return reinterpret_cast<const_iterator>(0);
                }

                bool empty() const
                {
                    return false;
                }

                size_type size() const
                {
                    return 0;
                }
            };




            template<typename InputIteratorT, typename OutputIteratorT>
            inline OutputIteratorT bounded_copy(
                InputIteratorT First,
                InputIteratorT Last,
                OutputIteratorT DestFirst,
                OutputIteratorT DestLast )
            {
                InputIteratorT InputIt=First;
                OutputIteratorT OutputIt=DestFirst;
                for(; InputIt!=Last && OutputIt!=DestLast; InputIt++, OutputIt++ )
                {
                    *OutputIt=*InputIt;
                }

                return OutputIt;
            }




            template<
                typename SeqT,
                typename IteratorT=typename SeqT::const_iterator >
            struct copy_iterator_rangeF :
                public std::unary_function< iterator_range<IteratorT>, SeqT >
            {
                SeqT operator()( const iterator_range<IteratorT>& Range ) const
                {
                    return copy_range<SeqT>(Range);
                }
            };

        }
    }
}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/formatter.hpp" 2 3



namespace boost {
    namespace algorithm {
        namespace detail {




            template<typename RangeT>
            struct const_formatF
            {
            private:
                typedef typename
                    range_const_iterator<RangeT>::type format_iterator;
                typedef iterator_range<format_iterator> result_type;

            public:

                const_formatF(const RangeT& Format) :
                    m_Format(::boost::begin(Format), ::boost::end(Format)) {}
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/formatter.hpp" 3
                template<typename Range2T>
                const result_type& operator()(const Range2T&) const
                {
                    return m_Format;
                }

            private:
                result_type m_Format;
            };




            template<typename RangeT>
            struct identity_formatF
            {

                template< typename Range2T >
                const RangeT& operator()(const Range2T& Replace) const
                {
                    return RangeT(::boost::begin(Replace), ::boost::end(Replace));
                }
            };




            template< typename CharT >
            struct empty_formatF
            {
                template< typename ReplaceT >
                empty_container<CharT> operator()(const ReplaceT&) const
                {
                    return empty_container<CharT>();
                }
            };

        }
    }
}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 2 3
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 3
namespace boost {
    namespace algorithm {
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 3
        template<typename RangeT>
        inline detail::const_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type> >
        const_formatter(const RangeT& Format)
        {
            return detail::const_formatF<
                iterator_range<
                    typename range_const_iterator<RangeT>::type> >(::boost::as_literal(Format));
        }
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 3
        template<typename RangeT>
        inline detail::identity_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type> >
        identity_formatter()
        {
            return detail::identity_formatF<
                iterator_range<
                    typename range_const_iterator<RangeT>::type> >();
        }
# 83 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/formatter.hpp" 3
        template<typename RangeT>
        inline detail::empty_formatF<
            typename range_value<RangeT>::type>
        empty_formatter(const RangeT&)
        {
            return detail::empty_formatF<
                typename range_value<RangeT>::type>();
        }


    }


    using algorithm::const_formatter;
    using algorithm::identity_formatter;
    using algorithm::empty_formatter;

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 2 3







namespace boost {
    namespace algorithm {
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_range_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const iterator_range<
                typename
                    range_const_iterator<Range1T>::type>& SearchRange,
            const Range2T& Format)
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::range_finder(SearchRange),
                ::boost::algorithm::const_formatter(Format));
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_range_copy(
            const SequenceT& Input,
            const iterator_range<
                typename
                    range_const_iterator<SequenceT>::type>& SearchRange,
            const RangeT& Format)
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::range_finder(SearchRange),
                ::boost::algorithm::const_formatter(Format));
        }
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void replace_range(
            SequenceT& Input,
            const iterator_range<
                typename
                    range_iterator<SequenceT>::type>& SearchRange,
            const RangeT& Format)
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::range_finder(SearchRange),
                ::boost::algorithm::const_formatter(Format));
        }
# 130 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format)
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_first_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
# 173 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_first(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
# 205 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range2T, typename Range1T>
        inline SequenceT ireplace_first_copy(
            const SequenceT& Input,
            const Range2T& Search,
            const Range1T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 252 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_first(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 283 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::last_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_last_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::last_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_last(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::last_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
# 358 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_last_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 406 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_last(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 439 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const Range3T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::nth_finder(Search, Nth),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_nth_copy(
            const SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth),
                ::boost::algorithm::const_formatter(Format) );
        }
# 486 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_nth(
            SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth),
                ::boost::algorithm::const_formatter(Format) );
        }
# 521 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc) ),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_nth_copy(
            const SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 572 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_nth(
            SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 604 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format )
        {
            return ::boost::algorithm::find_format_all_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_all_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_all_copy(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
# 648 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_all(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format_all(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
# 680 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_all_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_all_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_all_copy(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 727 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_all(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format_all(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
# 762 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_head_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            int N,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::head_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_head_copy(
            const SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::head_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
# 808 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void replace_head(
            SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::head_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
# 842 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_tail_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            int N,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::tail_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_tail_copy(
            const SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::tail_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
# 888 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void replace_tail(
            SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::tail_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }

    }


    using algorithm::replace_range_copy;
    using algorithm::replace_range;
    using algorithm::replace_first_copy;
    using algorithm::replace_first;
    using algorithm::ireplace_first_copy;
    using algorithm::ireplace_first;
    using algorithm::replace_last_copy;
    using algorithm::replace_last;
    using algorithm::ireplace_last_copy;
    using algorithm::ireplace_last;
    using algorithm::replace_nth_copy;
    using algorithm::replace_nth;
    using algorithm::ireplace_nth_copy;
    using algorithm::ireplace_nth;
    using algorithm::replace_all_copy;
    using algorithm::replace_all;
    using algorithm::ireplace_all_copy;
    using algorithm::ireplace_all;
    using algorithm::replace_head_copy;
    using algorithm::replace_head;
    using algorithm::replace_tail_copy;
    using algorithm::replace_tail;

}
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/units/detail/utility.hpp" 2 3

namespace boost {

namespace units {

namespace detail {

inline
std::string
demangle(const char* name)
{

    char* realname;
    std::size_t len;
    int stat;

    realname = abi::__cxa_demangle(name,__null,&len,&stat);

    if (realname != __null)
    {
        std::string out(realname);

        std::free(realname);

        boost::replace_all(out,"boost::units::","");

        return out;
    }

    return std::string("demangle :: error - unable to demangle specified symbol");
}

}

template<class L>
std::string simplify_typename(const L& )
{
    const std::string demangled = detail::demangle(typeid(L).name());

    return demangled;
}

}

}
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/type_info.hpp" 2 3



namespace
boost
    {
    template <class T>
    inline
    std::string
    tag_type_name()
        {



        return units::detail::demangle(typeid(T*).name());

        }

    template <class T>
    inline
    std::string
    type_name()
        {



        return units::detail::demangle(typeid(T).name());

        }

    namespace
    exception_detail
        {
        struct
        type_info_
            {
            detail::sp_typeinfo const & type_;

            explicit
            type_info_( detail::sp_typeinfo const & type ):
                type_(type)
                {
                }

            friend
            bool
            operator<( type_info_ const & a, type_info_ const & b )
                {
                return 0!=(a.type_.before(b.type_));
                }
            };
        }
    }
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/object_hex_dump.hpp" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
# 48 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
namespace std __attribute__ ((__visibility__ ("default"))) {




  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 92 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 123 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 160 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 191 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 221 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }
# 318 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);



}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/object_hex_dump.hpp" 2 3



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdlib" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/object_hex_dump.hpp" 2 3

namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        inline
        std::string
        object_hex_dump( T const & x, std::size_t max_size=16 )
            {
            std::ostringstream s;
            s << "type: " << type_name<T>() << ", size: " << sizeof(T) << ", dump: ";
            std::size_t n=sizeof(T)>max_size?max_size:sizeof(T);
            s.fill('0');
            s.width(2);
            unsigned char const * b=reinterpret_cast<unsigned char const *>(&x);
            s << std::setw(2) << std::hex << (unsigned int)*b;
            for( unsigned char const * e=b+n; ++b!=e; )
                s << " " << std::setw(2) << std::hex << (unsigned int)*b;
            return s.str();
            }
        }
    }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1 3
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp" 2 3

namespace
boost
    {
    namespace
    exception_detail
        {
        template <bool ToStringAvailable>
        struct
        to_string_dispatcher
            {
            template <class T,class Stub>
            static
            std::string
            convert( T const & x, Stub )
                {
                return to_string(x);
                }
            };

        template <>
        struct
        to_string_dispatcher<false>
            {
            template <class T,class Stub>
            static
            std::string
            convert( T const & x, Stub s )
                {
                return s(x);
                }

            template <class T>
            static
            std::string
            convert( T const & x, std::string s )
                {
                return s;
                }

            template <class T>
            static
            std::string
            convert( T const & x, char const * s )
                {
                ((s!=0) ? static_cast<void> (0) : __assert_fail ("s!=0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/to_string_stub.hpp", 63, __PRETTY_FUNCTION__));
                return s;
                }
            };

        namespace
        to_string_dispatch
            {
            template <class T,class Stub>
            inline
            std::string
            dispatch( T const & x, Stub s )
                {
                return to_string_dispatcher<has_to_string<T>::value>::convert(x,s);
                }
            }

        template <class T>
        inline
        std::string
        string_stub_dump( T const & x )
            {
            return "[ " + exception_detail::object_hex_dump(x) + " ]";
            }
        }

    template <class T>
    inline
    std::string
    to_string_stub( T const & x )
        {
        return exception_detail::to_string_dispatch::dispatch(x,&exception_detail::string_stub_dump<T>);
        }

    template <class T,class Stub>
    inline
    std::string
    to_string_stub( T const & x, Stub s )
        {
        return exception_detail::to_string_dispatch::dispatch(x,s);
        }
    }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/error_info_impl.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/error_info_impl.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/error_info_impl.hpp" 3







namespace
boost
    {
    namespace
    exception_detail
        {
        class
        error_info_base
            {
            public:

            virtual std::string tag_typeid_name() const = 0;
            virtual std::string value_as_string() const = 0;

            protected:

            ~error_info_base() throw()
                {
                }
            };
        }

    template <class Tag,class T>
    class
    error_info:
        public exception_detail::error_info_base
        {
        public:

        typedef T value_type;

        error_info( value_type const & value );
        ~error_info() throw();

        value_type const &
        value() const
            {
            return value_;
            }

        value_type &
        value()
            {
            return value_;
            }

        private:

        std::string tag_typeid_name() const;
        std::string value_as_string() const;

        value_type value_;
        };
    }
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp" 2 3




namespace
boost
    {
    template <class Tag,class T>
    inline
    typename enable_if<has_to_string<T>,std::string>::type
    to_string( error_info<Tag,T> const & x )
        {
        return to_string(x.value());
        }

    template <class Tag,class T>
    inline
    error_info<Tag,T>::
    error_info( value_type const & value ):
        value_(value)
        {
        }

    template <class Tag,class T>
    inline
    error_info<Tag,T>::
    ~error_info() throw()
        {
        }

    template <class Tag,class T>
    inline
    std::string
    error_info<Tag,T>::
    tag_typeid_name() const
        {
        return tag_type_name<Tag>();
        }

    template <class Tag,class T>
    inline
    std::string
    error_info<Tag,T>::
    value_as_string() const
        {
        return to_string_stub(*this);
        }

    namespace
    exception_detail
        {
        class
        error_info_container_impl:
            public error_info_container
            {
            public:

            error_info_container_impl():
                count_(0)
                {
                }

            ~error_info_container_impl() throw()
                {
                }

            void
            set( shared_ptr<error_info_base> const & x, type_info_ const & typeid_ )
                {
                ((x) ? static_cast<void> (0) : __assert_fail ("x", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp", 87, __PRETTY_FUNCTION__));
                info_[typeid_] = x;
                diagnostic_info_str_.clear();
                }

            shared_ptr<error_info_base>
            get( type_info_ const & ti ) const
                {
                error_info_map::const_iterator i=info_.find(ti);
                if( info_.end()!=i )
                    {
                    shared_ptr<error_info_base> const & p = i->second;

                    ((::boost::exception_detail::type_info_(typeid(*p)).type_==ti.type_) ? static_cast<void> (0) : __assert_fail ("::boost::exception_detail::type_info_(typeid(*p)).type_==ti.type_", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp", 100, __PRETTY_FUNCTION__));

                    return p;
                    }
                return shared_ptr<error_info_base>();
                }

            char const *
            diagnostic_information( char const * header ) const
                {
                if( header )
                    {
                    ((*header!=0) ? static_cast<void> (0) : __assert_fail ("*header!=0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/info.hpp", 112, __PRETTY_FUNCTION__));
                    std::ostringstream tmp;
                    tmp << header;
                    for( error_info_map::const_iterator i=info_.begin(),end=info_.end(); i!=end; ++i )
                        {
                        error_info_base const & x = *i->second;
                        tmp << '[' << x.tag_typeid_name() << "] = " << x.value_as_string() << '\n';
                        }
                    tmp.str().swap(diagnostic_info_str_);
                    }
                return diagnostic_info_str_.c_str();
                }

            private:

            friend class boost::exception;

            typedef std::map< type_info_, shared_ptr<error_info_base> > error_info_map;
            error_info_map info_;
            mutable std::string diagnostic_info_str_;
            mutable int count_;

            error_info_container_impl( error_info_container_impl const & );
            error_info_container_impl & operator=( error_info_container const & );

            void
            add_ref() const
                {
                ++count_;
                }

            bool
            release() const
                {
                if( --count_ )
                    return false;
                else
                    {
                    delete this;
                    return true;
                    }
                }

            refcount_ptr<error_info_container>
            clone() const
                {
                refcount_ptr<error_info_container> p;
                error_info_container_impl * c=new error_info_container_impl;
                p.adopt(c);
                c->info_ = info_;
                return p;
                }
            };

        template <class E,class Tag,class T>
        inline
        E const &
        set_info( E const & x, error_info<Tag,T> const & v )
            {
            typedef error_info<Tag,T> error_info_tag_t;
            shared_ptr<error_info_tag_t> p( new error_info_tag_t(v) );
            exception_detail::error_info_container * c=x.data_.get();
            if( !c )
                x.data_.adopt(c=new exception_detail::error_info_container_impl);
            c->set(p,::boost::exception_detail::type_info_(typeid(error_info_tag_t)));
            return x;
            }

        template <class T>
        struct
        derives_boost_exception
            {
            enum e { value = (sizeof(dispatch_boost_exception((T*)0))==sizeof(large_size)) };
            };
        }

    template <class E,class Tag,class T>
    inline
    typename enable_if<exception_detail::derives_boost_exception<E>,E const &>::type
    operator<<( E const & x, error_info<Tag,T> const & v )
        {
        return exception_detail::set_info(x,v);
        }
    }
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp" 2 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/diagnostic_information.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/diagnostic_information.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/diagnostic_information.hpp" 3






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/get_error_info.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/get_error_info.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/get_error_info.hpp" 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/get_error_info.hpp" 3
namespace
boost
    {
    namespace
    exception_detail
        {
        template <class ErrorInfo>
        struct
        get_info
            {
            static
            typename ErrorInfo::value_type *
            get( exception const & x )
                {
                if( exception_detail::error_info_container * c=x.data_.get() )
                    if( shared_ptr<exception_detail::error_info_base> eib = c->get(::boost::exception_detail::type_info_(typeid(ErrorInfo))) )
                        {

                        ((0!=dynamic_cast<ErrorInfo *>(eib.get())) ? static_cast<void> (0) : __assert_fail ("0!=dynamic_cast<ErrorInfo *>(eib.get())", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/get_error_info.hpp", 38, __PRETTY_FUNCTION__));

                        ErrorInfo * w = static_cast<ErrorInfo *>(eib.get());
                        return &w->value();
                        }
                return 0;
                }
            };

        template <>
        struct
        get_info<throw_function>
            {
            static
            char const * *
            get( exception const & x )
                {
                return x.throw_function_ ? &x.throw_function_ : 0;
                }
            };

        template <>
        struct
        get_info<throw_file>
            {
            static
            char const * *
            get( exception const & x )
                {
                return x.throw_file_ ? &x.throw_file_ : 0;
                }
            };

        template <>
        struct
        get_info<throw_line>
            {
            static
            int *
            get( exception const & x )
                {
                return x.throw_line_!=-1 ? &x.throw_line_ : 0;
                }
            };

        template <class T,class R>
        struct
        get_error_info_return_type
            {
            typedef R * type;
            };

        template <class T,class R>
        struct
        get_error_info_return_type<T const,R>
            {
            typedef R const * type;
            };
        }
# 114 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/get_error_info.hpp" 3
    template <class ErrorInfo,class E>
    inline
    typename exception_detail::get_error_info_return_type<E,typename ErrorInfo::value_type>::type
    get_error_info( E & some_exception )
        {
        if( exception const * x = dynamic_cast<exception const *>(&some_exception) )
            return exception_detail::get_info<ErrorInfo>::get(*x);
        else
            return 0;
        }

    }
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/diagnostic_information.hpp" 2 3
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/diagnostic_information.hpp" 3
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/current_exception_cast.hpp" 1 3
# 9 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/current_exception_cast.hpp" 3
       
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/current_exception_cast.hpp" 3





namespace
boost
    {
    template <class E>
    inline
    E *
    current_exception_cast()
        {
        try
            {
            throw;
            }
        catch(
        E & e )
            {
            return &e;
            }
        catch(
        ...)
            {
            return 0;
            }
        }
    }
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/diagnostic_information.hpp" 2 3
namespace
boost
    {
    namespace
    exception_detail
        {
        std::string diagnostic_information_impl( boost::exception const *, std::exception const *, bool );
        }

    inline
    std::string
    current_exception_diagnostic_information()
        {
        boost::exception const * be=current_exception_cast<boost::exception const>();
        std::exception const * se=current_exception_cast<std::exception const>();
        if( be || se )
            return exception_detail::diagnostic_information_impl(be,se,true);
        else
            return "No diagnostic information available.";
        }
    }


namespace
boost
    {
    namespace
    exception_detail
        {
        inline
        exception const *
        get_boost_exception( exception const * e )
            {
            return e;
            }

        inline
        exception const *
        get_boost_exception( ... )
            {
            return 0;
            }

        inline
        std::exception const *
        get_std_exception( std::exception const * e )
            {
            return e;
            }

        inline
        std::exception const *
        get_std_exception( ... )
            {
            return 0;
            }

        inline
        char const *
        get_diagnostic_information( exception const & x, char const * header )
            {
            if( error_info_container * c=x.data_.get() )

                try
                    {

                    return c->diagnostic_information(header);

                    }
                catch(...)
                    {
                    }

            return 0;
            }

        inline
        std::string
        diagnostic_information_impl( boost::exception const * be, std::exception const * se, bool with_what )
            {
            if( !be && !se )
                return "Unknown exception.";

            if( !be )
                be=dynamic_cast<boost::exception const *>(se);
            if( !se )
                se=dynamic_cast<std::exception const *>(be);

            char const * wh=0;
            if( with_what && se )
                {
                wh=se->what();
                if( be && exception_detail::get_diagnostic_information(*be,0)==wh )
                    return wh;
                }
            std::ostringstream tmp;
            if( be )
                {
                if( char const * const * f=get_error_info<throw_file>(*be) )
                    {
                    tmp << *f;
                    if( int const * l=get_error_info<throw_line>(*be) )
                        tmp << '(' << *l << "): ";
                    }
                tmp << "Throw in function ";
                if( char const * const * fn=get_error_info<throw_function>(*be) )
                    tmp << *fn;
                else
                    tmp << "(unknown)";
                tmp << '\n';
                }

            tmp << std::string("Dynamic exception type: ") <<
                units::detail::demangle((be?::boost::exception_detail::type_info_(typeid(*be)): ::boost::exception_detail::type_info_(typeid(*se))).type_.name()) << '\n';

            if( with_what && se )
                tmp << "std::exception::what: " << wh << '\n';
            if( be )
                if( char const * s=exception_detail::get_diagnostic_information(*be,tmp.str().c_str()) )
                    if( *s )
                        return s;
            return tmp.str();
            }
        }

    template <class T>
    std::string
    diagnostic_information( T const & e )
        {
        return exception_detail::diagnostic_information_impl(exception_detail::get_boost_exception(&e),exception_detail::get_std_exception(&e),true);
        }

    inline
    char const *
    diagnostic_information_what( exception const & e ) throw()
        {
        char const * w=0;

        try
            {

            (void) exception_detail::diagnostic_information_impl(&e,0,false);
            return exception_detail::get_diagnostic_information(e,0);

            }
        catch(
        ... )
            {
            }

        return w;
        }
    }
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp" 2 3






namespace
boost
    {
    typedef shared_ptr<exception_detail::clone_base const> exception_ptr;

    exception_ptr current_exception();

    template <class T>
    inline
    exception_ptr
    copy_exception( T const & e )
        {
        try
            {
            throw enable_current_exception(e);
            }
        catch(
        ... )
            {
            return current_exception();
            }
        }


    typedef error_info<struct tag_original_exception_type,std::type_info const *> original_exception_type;

    inline
    std::string
    to_string( original_exception_type const & x )
        {
        return x.value()->name();
        }


    namespace
    exception_detail
        {
        struct
        bad_alloc_:
            boost::exception,
            std::bad_alloc
                {
                };

        template <int Dummy>
        exception_ptr
        get_bad_alloc()
            {
            bad_alloc_ ba;
            exception_detail::clone_impl<bad_alloc_> c(ba);
            c <<
                throw_function(__PRETTY_FUNCTION__) <<
                throw_file("/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp") <<
                throw_line(81);
            static exception_ptr ep(new exception_detail::clone_impl<bad_alloc_>(c));
            return ep;
            }

        template <int Dummy>
        struct
        exception_ptr_bad_alloc
            {
            static exception_ptr const e;
            };

        template <int Dummy>
        exception_ptr const
        exception_ptr_bad_alloc<Dummy>::
        e = get_bad_alloc<Dummy>();
        }

    class
    unknown_exception:
        public boost::exception,
        public std::exception
        {
        public:

        unknown_exception()
            {
            }

        explicit
        unknown_exception( std::exception const & e )
            {
            add_original_type(e);
            }

        explicit
        unknown_exception( boost::exception const & e ):
            boost::exception(e)
            {
            add_original_type(e);
            }

        ~unknown_exception() throw()
            {
            }

        private:

        template <class E>
        void
        add_original_type( E const & e )
            {

            (*this) << original_exception_type(&typeid(e));

            }
        };

    namespace
    exception_detail
        {
        template <class T>
        class
        current_exception_std_exception_wrapper:
            public T,
            public boost::exception
            {
            public:

            explicit
            current_exception_std_exception_wrapper( T const & e1 ):
                T(e1)
                {
                add_original_type(e1);
                }

            current_exception_std_exception_wrapper( T const & e1, boost::exception const & e2 ):
                T(e1),
                boost::exception(e2)
                {
                add_original_type(e1);
                }

            ~current_exception_std_exception_wrapper() throw()
                {
                }

            private:

            template <class E>
            void
            add_original_type( E const & e )
                {

                (*this) << original_exception_type(&typeid(e));

                }
            };
# 200 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp" 3
        template <class T>
        boost::exception const *
        get_boost_exception( T const * x )
            {
            return dynamic_cast<boost::exception const *>(x);
            }


        template <class T>
        inline
        exception_ptr
        current_exception_std_exception( T const & e1 )
            {
            if( boost::exception const * e2 = get_boost_exception(&e1) )
                return boost::copy_exception(current_exception_std_exception_wrapper<T>(e1,*e2));
            else
                return boost::copy_exception(current_exception_std_exception_wrapper<T>(e1));
            }

        inline
        exception_ptr
        current_exception_unknown_exception()
            {
            return boost::copy_exception(unknown_exception());
            }

        inline
        exception_ptr
        current_exception_unknown_boost_exception( boost::exception const & e )
            {
            return boost::copy_exception(unknown_exception(e));
            }

        inline
        exception_ptr
        current_exception_unknown_std_exception( std::exception const & e )
            {
            if( boost::exception const * be = get_boost_exception(&e) )
                return current_exception_unknown_boost_exception(*be);
            else
                return boost::copy_exception(unknown_exception(e));
            }

        inline
        exception_ptr
        current_exception_impl()
            {
            try
                {
                throw;
                }
            catch(
            exception_detail::clone_base & e )
                {
                return exception_ptr(e.clone());
                }
            catch(
            std::domain_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::invalid_argument & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::length_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::out_of_range & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::logic_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::range_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::overflow_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::underflow_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::ios_base::failure & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::runtime_error & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::bad_alloc & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }

            catch(
            std::bad_cast & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::bad_typeid & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }

            catch(
            std::bad_exception & e )
                {
                return exception_detail::current_exception_std_exception(e);
                }
            catch(
            std::exception & e )
                {
                return exception_detail::current_exception_unknown_std_exception(e);
                }
            catch(
            boost::exception & e )
                {
                return exception_detail::current_exception_unknown_boost_exception(e);
                }
            catch(
            ... )
                {
                return exception_detail::current_exception_unknown_exception();
                }
            }
        }

    inline
    exception_ptr
    current_exception()
        {
        exception_ptr ret;
        ((!ret) ? static_cast<void> (0) : __assert_fail ("!ret", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp", 351, __PRETTY_FUNCTION__));
        try
            {
            ret=exception_detail::current_exception_impl();
            }
        catch(
        std::bad_alloc & )
            {
            ret=exception_detail::exception_ptr_bad_alloc<42>::e;
            }
        catch(
        ... )
            {
            try
                {
                ret=exception_detail::current_exception_std_exception(std::bad_exception());
                }
            catch(
            std::bad_alloc & )
                {
                ret=exception_detail::exception_ptr_bad_alloc<42>::e;
                }
            catch(
            ... )
                {
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp", 376, __PRETTY_FUNCTION__));
                }
            }
        ((ret) ? static_cast<void> (0) : __assert_fail ("ret", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp", 379, __PRETTY_FUNCTION__));
        return ret;
        }

    inline
    void
    rethrow_exception( exception_ptr const & p )
        {
        ((p) ? static_cast<void> (0) : __assert_fail ("p", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception/detail/exception_ptr.hpp", 387, __PRETTY_FUNCTION__));
        p->rethrow();
        }

    inline
    std::string
    diagnostic_information( exception_ptr const & p )
        {
        if( p )
            try
                {
                rethrow_exception(p);
                }
            catch(
            ... )
                {
                return current_exception_diagnostic_information();
                }
        return "<empty>";
        }

    inline
    std::string
    to_string( exception_ptr const & p )
        {
        std::string s='\n'+diagnostic_information(p);
        std::string padding("  ");
        std::string r;
        bool f=false;
        for( std::string::const_iterator i=s.begin(),e=s.end(); i!=e; ++i )
            {
            if( f )
                r+=padding;
            char c=*i;
            r+=c;
            f=(c=='\n');
            }
        return r;
        }
    }
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/exception_ptr.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/scoped_ptr.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/scoped_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp" 2







namespace boost
{
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp"
template<class T> class scoped_ptr
{
private:

    T * px;

    scoped_ptr(scoped_ptr const &);
    scoped_ptr & operator=(scoped_ptr const &);

    typedef scoped_ptr<T> this_type;

    void operator==( scoped_ptr const& ) const;
    void operator!=( scoped_ptr const& ) const;

public:

    typedef T element_type;

    explicit scoped_ptr( T * p = 0 ): px( p )
    {



    }



    explicit scoped_ptr( std::auto_ptr<T> p ): px( p.release() )
    {



    }



    ~scoped_ptr()
    {



        boost::checked_delete( px );
    }

    void reset(T * p = 0)
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp", 85, __PRETTY_FUNCTION__));
        this_type(p).swap(*this);
    }

    T & operator*() const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp", 91, __PRETTY_FUNCTION__));
        return *px;
    }

    T * operator->() const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp", 97, __PRETTY_FUNCTION__));
        return px;
    }

    T * get() const
    {
        return px;
    }


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp"
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 108 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_ptr.hpp" 2

    void swap(scoped_ptr & b)
    {
        T * tmp = b.px;
        b.px = px;
        px = tmp;
    }
};

template<class T> inline void swap(scoped_ptr<T> & a, scoped_ptr<T> & b)
{
    a.swap(b);
}



template<class T> inline T * get_pointer(scoped_ptr<T> const & p)
{
    return p.get();
}

}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/scoped_ptr.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/prologue.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/prologue.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/prologue.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/config/no_tr1/functional.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/prologue.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp" 2
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp"
       
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp" 3


namespace boost
{





  template< typename LeastInt >
  struct int_fast_t
  {
     typedef LeastInt fast;
     typedef fast type;
  };

  namespace detail{


  template< int Category > struct int_least_helper {};





  template<> struct int_least_helper<1> { typedef boost::long_long_type least; };



  template<> struct int_least_helper<2> { typedef long least; };
  template<> struct int_least_helper<3> { typedef int least; };
  template<> struct int_least_helper<4> { typedef short least; };
  template<> struct int_least_helper<5> { typedef signed char least; };

  template<> struct int_least_helper<6> { typedef boost::ulong_long_type least; };



  template<> struct int_least_helper<7> { typedef unsigned long least; };
  template<> struct int_least_helper<8> { typedef unsigned int least; };
  template<> struct int_least_helper<9> { typedef unsigned short least; };
  template<> struct int_least_helper<10> { typedef unsigned char least; };

  template <int Bits>
  struct exact_signed_base_helper{};
  template <int Bits>
  struct exact_unsigned_base_helper{};

  template <> struct exact_signed_base_helper<sizeof(signed char)* 8> { typedef signed char exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned char)* 8> { typedef unsigned char exact; };

  template <> struct exact_signed_base_helper<sizeof(short)* 8> { typedef short exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned short)* 8> { typedef unsigned short exact; };


  template <> struct exact_signed_base_helper<sizeof(int)* 8> { typedef int exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned int)* 8> { typedef unsigned int exact; };
# 101 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp" 3
  template <> struct exact_signed_base_helper<sizeof(boost::long_long_type)* 8> { typedef boost::long_long_type exact; };
  template <> struct exact_unsigned_base_helper<sizeof(boost::ulong_long_type)* 8> { typedef boost::ulong_long_type exact; };



  }




  template< int Bits >
  struct int_t : public detail::exact_signed_base_helper<Bits>
  {
      typedef typename detail::int_least_helper
        <

          (Bits-1 <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits-1 <= ::std::numeric_limits<long>::digits) +
          (Bits-1 <= ::std::numeric_limits<int>::digits) +
          (Bits-1 <= ::std::numeric_limits<short>::digits) +
          (Bits-1 <= ::std::numeric_limits<signed char>::digits)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< int Bits >
  struct uint_t : public detail::exact_unsigned_base_helper<Bits>
  {
# 143 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp" 3
      typedef typename detail::int_least_helper
        <
          5 +

          (Bits-1 <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits <= ::std::numeric_limits<unsigned long>::digits) +
          (Bits <= ::std::numeric_limits<unsigned int>::digits) +
          (Bits <= ::std::numeric_limits<unsigned short>::digits) +
          (Bits <= ::std::numeric_limits<unsigned char>::digits)
        >::least least;

      typedef typename int_fast_t<least>::type fast;

  };





  template< boost::long_long_type MaxValue >



  struct int_max_value_t
  {
      typedef typename detail::int_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::long_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<long>::const_max) +
          (MaxValue <= ::boost::integer_traits<int>::const_max) +
          (MaxValue <= ::boost::integer_traits<short>::const_max) +
          (MaxValue <= ::boost::integer_traits<signed char>::const_max)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< boost::long_long_type MinValue >



  struct int_min_value_t
  {
      typedef typename detail::int_least_helper
        <

          (MinValue >= ::boost::integer_traits<boost::long_long_type>::const_min) +



          (MinValue >= ::boost::integer_traits<long>::const_min) +
          (MinValue >= ::boost::integer_traits<int>::const_min) +
          (MinValue >= ::boost::integer_traits<short>::const_min) +
          (MinValue >= ::boost::integer_traits<signed char>::const_min)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };



  template< boost::ulong_long_type MaxValue >



  struct uint_value_t
  {
# 237 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/integer.hpp" 3
      typedef typename detail::int_least_helper
        <
          5 +

          (MaxValue <= ::boost::integer_traits<boost::ulong_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<unsigned long>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned int>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned short>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned char>::const_max)
        >::least least;

      typedef typename int_fast_t<least>::type fast;
  };


}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/composite_traits.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/composite_traits.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_union.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_union.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_union.hpp" 2

namespace boost {

namespace detail {
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_union.hpp"
template <typename T> struct is_union_impl
{
   static const bool value = __is_union(T);
};

}

template< typename T > struct is_union : ::boost::integral_constant<bool,::boost::detail::is_union_impl<T>::value> { };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_union.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/composite_traits.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 2
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function_equal.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function_equal.hpp"
namespace boost {

template<typename F, typename G>
  bool function_equal_impl(const F& f, const G& g, long)
  { return f == g; }




template<typename F, typename G>
  bool function_equal(const F& f, const G& g)
  { return function_equal_impl(f, g, 0); }

}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_fwd.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_fwd.hpp"
namespace boost {
  class bad_function_call;



  template<typename Signature> class function;

  template<typename Signature>
  inline void swap(function<Signature>& f1, function<Signature>& f2)
  {
    f1.swap(f2);
  }



  template<typename R> class function0;
  template<typename R, typename T1> class function1;
  template<typename R, typename T1, typename T2> class function2;
  template<typename R, typename T1, typename T2, typename T3> class function3;
  template<typename R, typename T1, typename T2, typename T3, typename T4>
    class function4;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5>
    class function5;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6>
    class function6;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7>
    class function7;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7, typename T8>
    class function8;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7, typename T8, typename T9>
    class function9;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7, typename T8, typename T9,
           typename T10>
    class function10;
}
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 2
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstring" 2 3
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp" 2
# 89 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
namespace boost {
  namespace detail {
    namespace function {
      class X;







      union function_buffer
      {

        mutable void* obj_ptr;


        struct type_t {

          const detail::sp_typeinfo* type;


          bool const_qualified;

          bool volatile_qualified;
        } type;


        mutable void (*func_ptr)();


        struct bound_memfunc_ptr_t {
          void (X::*memfunc_ptr)(int);
          void* obj_ptr;
        } bound_memfunc_ptr;



        struct obj_ref_t {
          mutable void* obj_ptr;
          bool is_const_qualified;
          bool is_volatile_qualified;
        } obj_ref;


        mutable char data;
      };







      struct unusable
      {
        unusable() {}
        template<typename T> unusable(const T&) {}
      };





      template<typename T> struct function_return_type { typedef T type; };

      template<>
      struct function_return_type<void>
      {
        typedef unusable type;
      };


      enum functor_manager_operation_type {
        clone_functor_tag,
        move_functor_tag,
        destroy_functor_tag,
        check_functor_type_tag,
        get_functor_type_tag
      };


      struct function_ptr_tag {};
      struct function_obj_tag {};
      struct member_ptr_tag {};
      struct function_obj_ref_tag {};

      template<typename F>
      class get_function_tag
      {
        typedef typename mpl::if_c<(is_pointer<F>::value),
                                   function_ptr_tag,
                                   function_obj_tag>::type ptr_or_obj_tag;

        typedef typename mpl::if_c<(is_member_pointer<F>::value),
                                   member_ptr_tag,
                                   ptr_or_obj_tag>::type ptr_or_obj_or_mem_tag;

        typedef typename mpl::if_c<(is_reference_wrapper<F>::value),
                                   function_obj_ref_tag,
                                   ptr_or_obj_or_mem_tag>::type or_ref_tag;

      public:
        typedef or_ref_tag type;
      };



      template<typename F>
      struct reference_manager
      {
        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          switch (op) {
          case clone_functor_tag:
            out_buffer.obj_ref.obj_ptr = in_buffer.obj_ref.obj_ptr;
            return;

          case move_functor_tag:
            out_buffer.obj_ref.obj_ptr = in_buffer.obj_ref.obj_ptr;
            in_buffer.obj_ref.obj_ptr = 0;
            return;

          case destroy_functor_tag:
            out_buffer.obj_ref.obj_ptr = 0;
            return;

          case check_functor_type_tag:
            {
              const detail::sp_typeinfo& check_type
                = *out_buffer.type.type;



              if ((std::strcmp((check_type).name(),(typeid(F)).name()) == 0)
                  && (!in_buffer.obj_ref.is_const_qualified
                      || out_buffer.type.const_qualified)
                  && (!in_buffer.obj_ref.is_volatile_qualified
                      || out_buffer.type.volatile_qualified))
                out_buffer.obj_ptr = in_buffer.obj_ref.obj_ptr;
              else
                out_buffer.obj_ptr = 0;
            }
            return;

          case get_functor_type_tag:
            out_buffer.type.type = &typeid(F);
            out_buffer.type.const_qualified = in_buffer.obj_ref.is_const_qualified;
            out_buffer.type.volatile_qualified = in_buffer.obj_ref.is_volatile_qualified;
            return;
          }
        }
      };





      template<typename F>
      struct function_allows_small_object_optimization
      {
        static const bool value = ((sizeof(F) <= sizeof(function_buffer) && (alignment_of<function_buffer>::value % alignment_of<F>::value == 0)))



                                                       ;
      };

      template <typename F,typename A>
      struct functor_wrapper: public F, public A
      {
        functor_wrapper( F f, A a ):
          F(f),
          A(a)
        {
        }

        functor_wrapper(const functor_wrapper& f) :
          F(static_cast<const F&>(f)),
          A(static_cast<const A&>(f))
        {
        }
      };





      template<typename Functor>
      struct functor_manager_common
      {
        typedef Functor functor_type;


        static inline void
        manage_ptr(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op)
        {
          if (op == clone_functor_tag)
            out_buffer.func_ptr = in_buffer.func_ptr;
          else if (op == move_functor_tag) {
            out_buffer.func_ptr = in_buffer.func_ptr;
            in_buffer.func_ptr = 0;
          } else if (op == destroy_functor_tag)
            out_buffer.func_ptr = 0;
          else if (op == check_functor_type_tag) {
            const detail::sp_typeinfo& check_type
              = *out_buffer.type.type;
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = &in_buffer.func_ptr;
            else
              out_buffer.obj_ptr = 0;
          } else {
            out_buffer.type.type = &typeid(Functor);
            out_buffer.type.const_qualified = false;
            out_buffer.type.volatile_qualified = false;
          }
        }


        static inline void
        manage_small(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op)
        {
          if (op == clone_functor_tag || op == move_functor_tag) {
            const functor_type* in_functor =
              reinterpret_cast<const functor_type*>(&in_buffer.data);
            new ((void*)&out_buffer.data) functor_type(*in_functor);

            if (op == move_functor_tag) {
              reinterpret_cast<functor_type*>(&in_buffer.data)->~Functor();
            }
          } else if (op == destroy_functor_tag) {

            reinterpret_cast<functor_type*>(&out_buffer.data)->~Functor();
          } else if (op == check_functor_type_tag) {
            const detail::sp_typeinfo& check_type
              = *out_buffer.type.type;
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = &in_buffer.data;
            else
              out_buffer.obj_ptr = 0;
          } else {
            out_buffer.type.type = &typeid(Functor);
            out_buffer.type.const_qualified = false;
            out_buffer.type.volatile_qualified = false;
          }
        }
      };

      template<typename Functor>
      struct functor_manager
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::true_)
        {
          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::false_)
        {
          if (op == clone_functor_tag) {



            const functor_type* f =
              (const functor_type*)(in_buffer.obj_ptr);
            functor_type* new_f = new functor_type(*f);
            out_buffer.obj_ptr = new_f;
          } else if (op == move_functor_tag) {
            out_buffer.obj_ptr = in_buffer.obj_ptr;
            in_buffer.obj_ptr = 0;
          } else if (op == destroy_functor_tag) {

            functor_type* f =
              static_cast<functor_type*>(out_buffer.obj_ptr);
            delete f;
            out_buffer.obj_ptr = 0;
          } else if (op == check_functor_type_tag) {
            const detail::sp_typeinfo& check_type
              = *out_buffer.type.type;
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = in_buffer.obj_ptr;
            else
              out_buffer.obj_ptr = 0;
          } else {
            out_buffer.type.type = &typeid(Functor);
            out_buffer.type.const_qualified = false;
            out_buffer.type.volatile_qualified = false;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, member_ptr_tag)
        {
          manager(in_buffer, out_buffer, op, mpl::true_());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.type.type = &typeid(functor_type);
            out_buffer.type.const_qualified = false;
            out_buffer.type.volatile_qualified = false;
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };

      template<typename Functor, typename Allocator>
      struct functor_manager_a
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::true_)
        {
          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::false_)
        {
          typedef functor_wrapper<Functor,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;

          if (op == clone_functor_tag) {



            const functor_wrapper_type* f =
              (const functor_wrapper_type*)(in_buffer.obj_ptr);
            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*f));
            wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
            wrapper_allocator.construct(copy, *f);


            functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
            out_buffer.obj_ptr = new_f;
          } else if (op == move_functor_tag) {
            out_buffer.obj_ptr = in_buffer.obj_ptr;
            in_buffer.obj_ptr = 0;
          } else if (op == destroy_functor_tag) {

            functor_wrapper_type* victim =
              static_cast<functor_wrapper_type*>(in_buffer.obj_ptr);
            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*victim));
            wrapper_allocator.destroy(victim);
            wrapper_allocator.deallocate(victim,1);
            out_buffer.obj_ptr = 0;
          } else if (op == check_functor_type_tag) {
            const detail::sp_typeinfo& check_type
              = *out_buffer.type.type;
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = in_buffer.obj_ptr;
            else
              out_buffer.obj_ptr = 0;
          } else {
            out_buffer.type.type = &typeid(Functor);
            out_buffer.type.const_qualified = false;
            out_buffer.type.volatile_qualified = false;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.type.type = &typeid(functor_type);
            out_buffer.type.const_qualified = false;
            out_buffer.type.volatile_qualified = false;
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };


      struct useless_clear_type {};
# 609 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
      struct vtable_base
      {
        void (*manager)(const function_buffer& in_buffer,
                        function_buffer& out_buffer,
                        functor_manager_operation_type op);
      };
    }
  }







class function_base
{
public:
  function_base() : vtable(0) { }


  bool empty() const { return !vtable; }



  const detail::sp_typeinfo& target_type() const
  {
    if (!vtable) return typeid(void);

    detail::function::function_buffer type;
    get_vtable()->manager(functor, type, detail::function::get_functor_type_tag);
    return *type.type.type;
  }

  template<typename Functor>
    Functor* target()
    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.type.type = &typeid(Functor);
      type_result.type.const_qualified = is_const<Functor>::value;
      type_result.type.volatile_qualified = is_volatile<Functor>::value;
      get_vtable()->manager(functor, type_result,
                      detail::function::check_functor_type_tag);
      return static_cast<Functor*>(type_result.obj_ptr);
    }

  template<typename Functor>



    const Functor* target() const

    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.type.type = &typeid(Functor);
      type_result.type.const_qualified = true;
      type_result.type.volatile_qualified = is_volatile<Functor>::value;
      get_vtable()->manager(functor, type_result,
                      detail::function::check_functor_type_tag);


      return (const Functor*)(type_result.obj_ptr);
    }

  template<typename F>
    bool contains(const F& f) const
    {



      if (const F* fp = this->template target<F>())

      {
        return function_equal(*fp, f);
      } else {
        return false;
      }
    }
# 715 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
public:
  detail::function::vtable_base* get_vtable() const {
    return reinterpret_cast<detail::function::vtable_base*>(
             reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
  }

  bool has_trivial_copy_and_destroy() const {
    return reinterpret_cast<std::size_t>(vtable) & 0x01;
  }

  detail::function::vtable_base* vtable;
  mutable detail::function::function_buffer functor;
};





class bad_function_call : public std::runtime_error
{
public:
  bad_function_call() : std::runtime_error("call to empty boost::function") {}
};


inline bool operator==(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return f.empty();
}

inline bool operator!=(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return !f.empty();
}

inline bool operator==(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return f.empty();
}

inline bool operator!=(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return !f.empty();
}
# 800 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_base.hpp"
template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(*fp, g);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(g, *fp);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(*fp, g);
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(g, *fp);
    else return true;
  }


template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp == g.get_pointer();
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() == fp;
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp != g.get_pointer();
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() != fp;
    else return true;
  }



namespace detail {
  namespace function {
    inline bool has_empty_target(const function_base* f)
    {
      return f->empty();
    }







    inline bool has_empty_target(...)
    {
      return false;
    }

  }
}
}
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/prologue.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function.hpp" 2
# 64 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/detail/shared.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/slot/detail/shared.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 13 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R
       
        >
      struct function_invoker0
      {
        static R invoke(function_buffer& function_ptr
                        )
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f();
        }
      };

      template<
        typename FunctionPtr,
        typename R
       
        >
      struct void_function_invoker0
      {
        static void
        invoke(function_buffer& function_ptr
               )

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_obj_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_obj_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_ref_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_ref_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)();
        }
      };
# 230 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<
        typename FunctionPtr,
        typename R
       
      >
      struct get_function_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker0<
                            FunctionPtr,
                            R
                           
                          >,
                          function_invoker0<
                            FunctionPtr,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_obj_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_ref_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker0 { };


      template<>
      struct get_invoker0<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R >
        struct apply
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R ,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };
# 400 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<>
      struct get_invoker0<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R >
        struct apply
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R ,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker0<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R >
        struct apply
        {
          typedef typename get_function_ref_invoker0<
                             typename RefWrapper::type,
                             R
                            
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R ,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker0<
                             typename RefWrapper::type,
                             R
                            
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R >
      struct basic_vtable0
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                           
                                            );

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }
# 562 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R
   
  >
  class function0 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable0<
              R >
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 0;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 0;
   

    typedef function0 self_type;

    function0() : function_base() { }



    template<typename Functor>
    function0(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function0(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function0(clear_type*) : function_base() { }







    function0(const function0& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function0() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()() const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function0&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function0& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function0& operator=(const function0& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function0& other)
    {
      if (&other == this)
        return;

      function0 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function0& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker0<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R
                        >
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker0<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R
                         ,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function0& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R >
  inline void swap(function0<
                     R
                    
                   >& f1,
                   function0<
                     R
                    
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R >
  typename function0<
      R >::result_type
  inline
  function0<R >
  ::operator()() const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor );
  }



template<typename R >
  void operator==(const function0<
                          R
                          >&,
                  const function0<
                          R
                          >&);
template<typename R >
  void operator!=(const function0<
                          R
                          >&,
                  const function0<
                          R
                          >& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R
         >
class function<R (void)>
  : public function0<R >
{
  typedef function0<R > base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0
        >
      struct function_invoker1
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0
        >
      struct void_function_invoker1
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct function_obj_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct void_function_obj_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct function_ref_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct void_function_ref_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0
      >
      struct function_mem_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0
      >
      struct function_void_mem_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0
      >
      struct get_function_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker1<
                            FunctionPtr,
                            R ,
                            T0
                          >,
                          function_invoker1<
                            FunctionPtr,
                            R ,
                            T0
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
       >
      struct get_function_obj_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >,
                          function_obj_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
       >
      struct get_function_ref_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >,
                          function_ref_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0
       >
      struct get_member_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker1<
                            MemberPtr,
                            R ,
                            T0
                          >,
                          function_mem_invoker1<
                            MemberPtr,
                            R ,
                            T0
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker1 { };


      template<>
      struct get_invoker1<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0>
        struct apply
        {
          typedef typename get_function_invoker1<
                             FunctionPtr,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker1<
                             FunctionPtr,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker1<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0>
        struct apply
        {
          typedef typename get_member_invoker1<
                             MemberPtr,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker1<
                             MemberPtr,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker1<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0>
        struct apply
        {
          typedef typename get_function_obj_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker1<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0>
        struct apply
        {
          typedef typename get_function_ref_invoker1<
                             typename RefWrapper::type,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker1<
                             typename RefWrapper::type,
                             R ,
                             T0
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0>
      struct basic_vtable1
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0
  >
  class function1 : public function_base



    , public std::unary_function<T0,R>







  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable1<
              R , T0>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 1;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };


    typedef T0 argument_type;





    static const int arity = 1;
    typedef T0 arg1_type;

    typedef function1 self_type;

    function1() : function_base() { }



    template<typename Functor>
    function1(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function1(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function1(clear_type*) : function_base() { }







    function1(const function1& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function1() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function1&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function1& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function1& operator=(const function1& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function1& other)
    {
      if (&other == this)
        return;

      function1 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function1& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker1<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker1<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function1& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0>
  inline void swap(function1<
                     R ,
                     T0
                   >& f1,
                   function1<
                     R ,
                     T0
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0>
  typename function1<
      R , T0>::result_type
  inline
  function1<R , T0>
  ::operator()( T0 a0) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0);
  }



template<typename R , typename T0>
  void operator==(const function1<
                          R ,
                          T0>&,
                  const function1<
                          R ,
                          T0>&);
template<typename R , typename T0>
  void operator!=(const function1<
                          R ,
                          T0>&,
                  const function1<
                          R ,
                          T0>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0>
class function<R ( T0)>
  : public function1<R , T0>
{
  typedef function1<R , T0> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct function_invoker2
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct void_function_invoker2
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_obj_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_obj_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_ref_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_ref_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct function_mem_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct function_void_mem_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct get_function_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >,
                          function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_obj_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_ref_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1
       >
      struct get_member_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker2<
                            MemberPtr,
                            R ,
                            T0 , T1
                          >,
                          function_mem_invoker2<
                            MemberPtr,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker2 { };


      template<>
      struct get_invoker2<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker2<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_member_invoker2<
                             MemberPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker2<
                             MemberPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker2<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker2<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_function_ref_invoker2<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker2<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1>
      struct basic_vtable2
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1
  >
  class function2 : public function_base







    , public std::binary_function<T0,T1,R>



  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable2<
              R , T0 , T1>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 2;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };




    typedef T0 first_argument_type;
    typedef T1 second_argument_type;


    static const int arity = 2;
    typedef T0 arg1_type; typedef T1 arg2_type;

    typedef function2 self_type;

    function2() : function_base() { }



    template<typename Functor>
    function2(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function2(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function2(clear_type*) : function_base() { }







    function2(const function2& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function2() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function2&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function2& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function2& operator=(const function2& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function2& other)
    {
      if (&other == this)
        return;

      function2 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function2& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker2<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker2<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function2& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1>
  inline void swap(function2<
                     R ,
                     T0 , T1
                   >& f1,
                   function2<
                     R ,
                     T0 , T1
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1>
  typename function2<
      R , T0 , T1>::result_type
  inline
  function2<R , T0 , T1>
  ::operator()( T0 a0 , T1 a1) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1);
  }



template<typename R , typename T0 , typename T1>
  void operator==(const function2<
                          R ,
                          T0 , T1>&,
                  const function2<
                          R ,
                          T0 , T1>&);
template<typename R , typename T0 , typename T1>
  void operator!=(const function2<
                          R ,
                          T0 , T1>&,
                  const function2<
                          R ,
                          T0 , T1>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1>
class function<R ( T0 , T1)>
  : public function2<R , T0 , T1>
{
  typedef function2<R , T0 , T1> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
        >
      struct function_invoker3
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
        >
      struct void_function_invoker3
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_obj_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct void_function_obj_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_ref_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct void_function_ref_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_mem_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_void_mem_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct get_function_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker3<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_invoker3<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_function_obj_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_obj_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_function_ref_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_ref_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_member_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker3<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_mem_invoker3<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker3 { };


      template<>
      struct get_invoker3<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2>
        struct apply
        {
          typedef typename get_function_invoker3<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker3<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker3<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2>
        struct apply
        {
          typedef typename get_member_invoker3<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker3<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker3<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2>
        struct apply
        {
          typedef typename get_function_obj_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker3<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2>
        struct apply
        {
          typedef typename get_function_ref_invoker3<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker3<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2>
      struct basic_vtable3
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2
  >
  class function3 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable3<
              R , T0 , T1 , T2>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 3;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 3;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type;

    typedef function3 self_type;

    function3() : function_base() { }



    template<typename Functor>
    function3(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function3(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function3(clear_type*) : function_base() { }







    function3(const function3& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function3() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function3&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function3& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function3& operator=(const function3& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function3& other)
    {
      if (&other == this)
        return;

      function3 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function3& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker3<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker3<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function3& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2>
  inline void swap(function3<
                     R ,
                     T0 , T1 , T2
                   >& f1,
                   function3<
                     R ,
                     T0 , T1 , T2
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2>
  typename function3<
      R , T0 , T1 , T2>::result_type
  inline
  function3<R , T0 , T1 , T2>
  ::operator()( T0 a0 , T1 a1 , T2 a2) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2);
  }



template<typename R , typename T0 , typename T1 , typename T2>
  void operator==(const function3<
                          R ,
                          T0 , T1 , T2>&,
                  const function3<
                          R ,
                          T0 , T1 , T2>&);
template<typename R , typename T0 , typename T1 , typename T2>
  void operator!=(const function3<
                          R ,
                          T0 , T1 , T2>&,
                  const function3<
                          R ,
                          T0 , T1 , T2>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2>
class function<R ( T0 , T1 , T2)>
  : public function3<R , T0 , T1 , T2>
{
  typedef function3<R , T0 , T1 , T2> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
        >
      struct function_invoker4
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
        >
      struct void_function_invoker4
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_obj_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct void_function_obj_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_ref_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct void_function_ref_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_mem_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_void_mem_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct get_function_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker4<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_invoker4<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_function_obj_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_obj_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_function_ref_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_ref_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_member_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker4<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_mem_invoker4<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker4 { };


      template<>
      struct get_invoker4<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3>
        struct apply
        {
          typedef typename get_function_invoker4<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker4<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker4<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3>
        struct apply
        {
          typedef typename get_member_invoker4<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker4<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker4<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3>
        struct apply
        {
          typedef typename get_function_obj_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker4<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3>
        struct apply
        {
          typedef typename get_function_ref_invoker4<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker4<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
      struct basic_vtable4
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3
  >
  class function4 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable4<
              R , T0 , T1 , T2 , T3>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 4;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 4;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type;

    typedef function4 self_type;

    function4() : function_base() { }



    template<typename Functor>
    function4(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function4(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function4(clear_type*) : function_base() { }







    function4(const function4& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function4() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function4&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function4& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function4& operator=(const function4& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function4& other)
    {
      if (&other == this)
        return;

      function4 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function4& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker4<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker4<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function4& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  inline void swap(function4<
                     R ,
                     T0 , T1 , T2 , T3
                   >& f1,
                   function4<
                     R ,
                     T0 , T1 , T2 , T3
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  typename function4<
      R , T0 , T1 , T2 , T3>::result_type
  inline
  function4<R , T0 , T1 , T2 , T3>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  void operator==(const function4<
                          R ,
                          T0 , T1 , T2 , T3>&,
                  const function4<
                          R ,
                          T0 , T1 , T2 , T3>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  void operator!=(const function4<
                          R ,
                          T0 , T1 , T2 , T3>&,
                  const function4<
                          R ,
                          T0 , T1 , T2 , T3>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3>
class function<R ( T0 , T1 , T2 , T3)>
  : public function4<R , T0 , T1 , T2 , T3>
{
  typedef function4<R , T0 , T1 , T2 , T3> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 68 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
        >
      struct function_invoker5
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
        >
      struct void_function_invoker5
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_obj_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct void_function_obj_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_ref_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct void_function_ref_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_mem_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_void_mem_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct get_function_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker5<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_invoker5<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_function_obj_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_obj_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_function_ref_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_ref_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_member_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker5<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_mem_invoker5<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker5 { };


      template<>
      struct get_invoker5<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
        struct apply
        {
          typedef typename get_function_invoker5<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker5<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker5<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
        struct apply
        {
          typedef typename get_member_invoker5<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker5<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker5<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
        struct apply
        {
          typedef typename get_function_obj_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker5<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
        struct apply
        {
          typedef typename get_function_ref_invoker5<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker5<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
      struct basic_vtable5
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4
  >
  class function5 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable5<
              R , T0 , T1 , T2 , T3 , T4>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 5;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 5;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type;

    typedef function5 self_type;

    function5() : function_base() { }



    template<typename Functor>
    function5(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function5(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function5(clear_type*) : function_base() { }







    function5(const function5& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function5() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function5&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function5& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function5& operator=(const function5& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function5& other)
    {
      if (&other == this)
        return;

      function5 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function5& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker5<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3 , T4>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker5<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3 , T4,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function5& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  inline void swap(function5<
                     R ,
                     T0 , T1 , T2 , T3 , T4
                   >& f1,
                   function5<
                     R ,
                     T0 , T1 , T2 , T3 , T4
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  typename function5<
      R , T0 , T1 , T2 , T3 , T4>::result_type
  inline
  function5<R , T0 , T1 , T2 , T3 , T4>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  void operator==(const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>&,
                  const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  void operator!=(const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>&,
                  const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
class function<R ( T0 , T1 , T2 , T3 , T4)>
  : public function5<R , T0 , T1 , T2 , T3 , T4>
{
  typedef function5<R , T0 , T1 , T2 , T3 , T4> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
        >
      struct function_invoker6
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
        >
      struct void_function_invoker6
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_obj_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct void_function_obj_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_ref_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct void_function_ref_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_mem_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_void_mem_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct get_function_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker6<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_invoker6<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_function_obj_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_obj_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_function_ref_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_ref_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_member_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker6<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_mem_invoker6<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker6 { };


      template<>
      struct get_invoker6<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
        struct apply
        {
          typedef typename get_function_invoker6<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker6<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker6<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
        struct apply
        {
          typedef typename get_member_invoker6<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker6<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker6<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
        struct apply
        {
          typedef typename get_function_obj_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker6<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
        struct apply
        {
          typedef typename get_function_ref_invoker6<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker6<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
      struct basic_vtable6
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
  >
  class function6 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable6<
              R , T0 , T1 , T2 , T3 , T4 , T5>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 6;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 6;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type;

    typedef function6 self_type;

    function6() : function_base() { }



    template<typename Functor>
    function6(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function6(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function6(clear_type*) : function_base() { }







    function6(const function6& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function6() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function6&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function6& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function6& operator=(const function6& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function6& other)
    {
      if (&other == this)
        return;

      function6 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function6& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker6<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3 , T4 , T5>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker6<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3 , T4 , T5,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function6& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  inline void swap(function6<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5
                   >& f1,
                   function6<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  typename function6<
      R , T0 , T1 , T2 , T3 , T4 , T5>::result_type
  inline
  function6<R , T0 , T1 , T2 , T3 , T4 , T5>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  void operator==(const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>&,
                  const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  void operator!=(const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>&,
                  const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5)>
  : public function6<R , T0 , T1 , T2 , T3 , T4 , T5>
{
  typedef function6<R , T0 , T1 , T2 , T3 , T4 , T5> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
        >
      struct function_invoker7
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
        >
      struct void_function_invoker7
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_obj_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct void_function_obj_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_ref_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct void_function_ref_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_mem_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_void_mem_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct get_function_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker7<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_invoker7<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_function_obj_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_obj_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_function_ref_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_ref_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_member_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker7<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_mem_invoker7<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker7 { };


      template<>
      struct get_invoker7<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
        struct apply
        {
          typedef typename get_function_invoker7<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker7<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker7<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
        struct apply
        {
          typedef typename get_member_invoker7<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker7<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker7<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
        struct apply
        {
          typedef typename get_function_obj_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker7<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
        struct apply
        {
          typedef typename get_function_ref_invoker7<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker7<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
      struct basic_vtable7
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
  >
  class function7 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable7<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 7;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 7;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type;

    typedef function7 self_type;

    function7() : function_base() { }



    template<typename Functor>
    function7(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function7(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function7(clear_type*) : function_base() { }







    function7(const function7& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function7() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function7&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function7& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function7& operator=(const function7& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function7& other)
    {
      if (&other == this)
        return;

      function7 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function7& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker7<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3 , T4 , T5 , T6>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker7<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3 , T4 , T5 , T6,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function7& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  inline void swap(function7<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6
                   >& f1,
                   function7<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  typename function7<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6>::result_type
  inline
  function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  void operator==(const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>&,
                  const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  void operator!=(const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>&,
                  const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6)>
  : public function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6>
{
  typedef function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 83 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
        >
      struct function_invoker8
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
        >
      struct void_function_invoker8
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_obj_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct void_function_obj_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_ref_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct void_function_ref_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_mem_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_void_mem_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct get_function_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker8<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_invoker8<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_function_obj_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_obj_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_function_ref_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_ref_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_member_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker8<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_mem_invoker8<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker8 { };


      template<>
      struct get_invoker8<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
        struct apply
        {
          typedef typename get_function_invoker8<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker8<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker8<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
        struct apply
        {
          typedef typename get_member_invoker8<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker8<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker8<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
        struct apply
        {
          typedef typename get_function_obj_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker8<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
        struct apply
        {
          typedef typename get_function_ref_invoker8<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker8<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
      struct basic_vtable8
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
  >
  class function8 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable8<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 8;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 8;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type;

    typedef function8 self_type;

    function8() : function_base() { }



    template<typename Functor>
    function8(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function8(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function8(clear_type*) : function_base() { }







    function8(const function8& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function8() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function8&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function8& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function8& operator=(const function8& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function8& other)
    {
      if (&other == this)
        return;

      function8 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function8& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker8<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker8<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function8& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  inline void swap(function8<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                   >& f1,
                   function8<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  typename function8<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>::result_type
  inline
  function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  void operator==(const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>&,
                  const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  void operator!=(const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>&,
                  const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)>
  : public function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
{
  typedef function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 88 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
        >
      struct function_invoker9
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
        >
      struct void_function_invoker9
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_obj_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct void_function_obj_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_ref_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct void_function_ref_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_mem_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_void_mem_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct get_function_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker9<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_invoker9<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_function_obj_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_obj_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_function_ref_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_ref_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_member_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker9<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_mem_invoker9<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker9 { };


      template<>
      struct get_invoker9<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
        struct apply
        {
          typedef typename get_function_invoker9<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker9<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker9<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
        struct apply
        {
          typedef typename get_member_invoker9<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker9<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker9<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
        struct apply
        {
          typedef typename get_function_obj_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker9<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
        struct apply
        {
          typedef typename get_function_ref_invoker9<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker9<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
      struct basic_vtable9
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
  >
  class function9 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable9<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 9;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 9;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type; typedef T8 arg9_type;

    typedef function9 self_type;

    function9() : function_base() { }



    template<typename Functor>
    function9(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function9(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function9(clear_type*) : function_base() { }







    function9(const function9& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function9() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function9&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function9& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function9& operator=(const function9& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function9& other)
    {
      if (&other == this)
        return;

      function9 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function9& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker9<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker9<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function9& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  inline void swap(function9<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                   >& f1,
                   function9<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  typename function9<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>::result_type
  inline
  function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  void operator==(const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>&,
                  const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  void operator!=(const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>&,
                  const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)>
  : public function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
{
  typedef function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 93 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 1
# 63 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp" 1
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
        >
      struct function_invoker10
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
        >
      struct void_function_invoker10
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_obj_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct void_function_obj_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_ref_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct void_function_ref_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_mem_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          return boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_void_mem_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
          boost::mem_fn(*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct get_function_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker10<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_invoker10<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_function_obj_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_obj_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_function_ref_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_ref_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_member_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            function_void_mem_invoker10<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_mem_invoker10<
                            MemberPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename Tag>
      struct get_invoker10 { };


      template<>
      struct get_invoker10<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
        struct apply
        {
          typedef typename get_function_invoker10<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_invoker10<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker10<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
        struct apply
        {
          typedef typename get_member_invoker10<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_member_invoker10<
                             MemberPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker10<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
        struct apply
        {
          typedef typename get_function_obj_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_obj_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker10<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
        struct apply
        {
          typedef typename get_function_ref_invoker10<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper,
                 typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9,
                 typename Allocator>
        struct apply_a
        {
          typedef typename get_function_ref_invoker10<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 475 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
      struct basic_vtable10
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9);

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          functor.obj_ref.obj_ptr = (void *)f.get_pointer();
          functor.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
  >
  class function10 : public function_base
# 664 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable10<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~(std::size_t)0x01);
    }

    struct clear_type {};

  public:
    static const int args = 10;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 702 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    static const int arity = 10;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type; typedef T8 arg9_type; typedef T9 arg10_type;

    typedef function10 self_type;

    function10() : function_base() { }



    template<typename Functor>
    function10(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function10(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function10(clear_type*) : function_base() { }







    function10(const function10& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function10() { clear(); }
# 766 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function10&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function10& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 824 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
    function10& operator=(const function10& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }

    void swap(function10& other)
    {
      if (&other == this)
        return;

      function10 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function10& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())
          this->functor = f.functor;
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker10<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using detail::function::vtable_base;

      typedef typename detail::function::get_function_tag<Functor>::type tag;
      typedef detail::function::get_invoker10<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, R ,
                         T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9,
                         Allocator>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);
        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= (std::size_t)0x01;
        vtable = reinterpret_cast<detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function10& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())
            this->functor = f.functor;
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  inline void swap(function10<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                   >& f1,
                   function10<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  typename function10<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>::result_type
  inline
  function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return get_vtable()->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  void operator==(const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>&,
                  const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  void operator!=(const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>&,
                  const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>& );
# 1041 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/function_template.hpp"
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)>
  : public function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
{
  typedef function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 64 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/maybe_include.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function/detail/function_iterate.hpp" 2
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/function.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/scoped_array.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/scoped_array.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp" 2





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp" 2

namespace boost
{
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp"
template<class T> class scoped_array
{
private:

    T * px;

    scoped_array(scoped_array const &);
    scoped_array & operator=(scoped_array const &);

    typedef scoped_array<T> this_type;

    void operator==( scoped_array const& ) const;
    void operator!=( scoped_array const& ) const;

public:

    typedef T element_type;

    explicit scoped_array( T * p = 0 ) : px( p )
    {



    }

    ~scoped_array()
    {



        boost::checked_array_delete( px );
    }

    void reset(T * p = 0)
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp", 73, __PRETTY_FUNCTION__));
        this_type(p).swap(*this);
    }

    T & operator[](std::ptrdiff_t i) const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp", 79, __PRETTY_FUNCTION__));
        ((i >= 0) ? static_cast<void> (0) : __assert_fail ("i >= 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp", 80, __PRETTY_FUNCTION__));
        return px[i];
    }

    T * get() const
    {
        return px;
    }


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp"
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 91 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/scoped_array.hpp" 2

    void swap(scoped_array & b)
    {
        T * tmp = b.px;
        b.px = px;
        px = tmp;
    }
};

template<class T> inline void swap(scoped_array<T> & a, scoped_array<T> & b)
{
    a.swap(b);
}

}
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/scoped_array.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/vector" 1 3
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/vector" 3
       
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/vector" 3





# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 1 3
# 65 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 131 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 169 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 226 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 241 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 296 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 324 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 374 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 390 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 417 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 532 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 552 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }
# 572 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 602 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 617 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 632 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 657 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 675 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 721 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 740 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 771 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 807 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 857 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 875 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 900 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 921 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 933 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 988 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1052 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1092 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1170 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1187 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 66 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/vector" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 1 3
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 429 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std __attribute__ ((__visibility__ ("default"))) {
# 473 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 542 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 591 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }







    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 659 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 67 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/vector" 2 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/vector.tcc" 1 3
# 60 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 104 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 126 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 293 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1))
             );
   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;

   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,



                               __x);

       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

}
# 70 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/vector" 2 3
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp" 2

namespace boost
{
    class future_uninitialized:
        public std::logic_error
    {
    public:
        future_uninitialized():
            std::logic_error("Future Uninitialized")
        {}
    };
    class broken_promise:
        public std::logic_error
    {
    public:
        broken_promise():
            std::logic_error("Broken promise")
        {}
    };
    class future_already_retrieved:
        public std::logic_error
    {
    public:
        future_already_retrieved():
            std::logic_error("Future already retrieved")
        {}
    };
    class promise_already_satisfied:
        public std::logic_error
    {
    public:
        promise_already_satisfied():
            std::logic_error("Promise already satisfied")
        {}
    };

    class task_already_started:
        public std::logic_error
    {
    public:
        task_already_started():
            std::logic_error("Task already started")
        {}
    };

    class task_moved:
        public std::logic_error
    {
    public:
        task_moved():
            std::logic_error("Task moved")
        {}
    };

    namespace future_state
    {
        enum state { uninitialized, waiting, ready, moved };
    }

    namespace detail
    {
        struct future_object_base
        {
            boost::exception_ptr exception;
            bool done;
            boost::mutex mutex;
            boost::condition_variable waiters;
            typedef std::list<boost::condition_variable_any*> waiter_list;
            waiter_list external_waiters;
            boost::function<void()> callback;

            future_object_base():
                done(false)
            {}
            virtual ~future_object_base()
            {}

            waiter_list::iterator register_external_waiter(boost::condition_variable_any& cv)
            {
                boost::unique_lock<boost::mutex> lock(mutex);
                do_callback(lock);
                return external_waiters.insert(external_waiters.end(),&cv);
            }

            void remove_external_waiter(waiter_list::iterator it)
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                external_waiters.erase(it);
            }

            void mark_finished_internal()
            {
                done=true;
                waiters.notify_all();
                for(waiter_list::const_iterator it=external_waiters.begin(),
                        end=external_waiters.end();it!=end;++it)
                {
                    (*it)->notify_all();
                }
            }

            struct relocker
            {
                boost::unique_lock<boost::mutex>& lock;

                relocker(boost::unique_lock<boost::mutex>& lock_):
                    lock(lock_)
                {
                    lock.unlock();
                }
                ~relocker()
                {
                    lock.lock();
                }
            private:
                relocker& operator=(relocker const&);
            };

            void do_callback(boost::unique_lock<boost::mutex>& lock)
            {
                if(callback && !done)
                {
                    boost::function<void()> local_callback=callback;
                    relocker relock(lock);
                    local_callback();
                }
            }


            void wait(bool rethrow=true)
            {
                boost::unique_lock<boost::mutex> lock(mutex);
                do_callback(lock);
                while(!done)
                {
                    waiters.wait(lock);
                }
                if(rethrow && exception)
                {
                    boost::rethrow_exception(exception);
                }
            }

            bool timed_wait_until(boost::system_time const& target_time)
            {
                boost::unique_lock<boost::mutex> lock(mutex);
                do_callback(lock);
                while(!done)
                {
                    bool const success=waiters.timed_wait(lock,target_time);
                    if(!success && !done)
                    {
                        return false;
                    }
                }
                return true;
            }

            void mark_exceptional_finish_internal(boost::exception_ptr const& e)
            {
                exception=e;
                mark_finished_internal();
            }
            void mark_exceptional_finish()
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                mark_exceptional_finish_internal(boost::current_exception());
            }

            bool has_value()
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                return done && !exception;
            }
            bool has_exception()
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                return done && exception;
            }

            template<typename F,typename U>
            void set_wait_callback(F f,U* u)
            {
                callback=boost::bind(f,boost::ref(*u));
            }

        private:
            future_object_base(future_object_base const&);
            future_object_base& operator=(future_object_base const&);
        };

        template<typename T>
        struct future_traits
        {
            typedef boost::scoped_ptr<T> storage_type;






            typedef T& source_reference_type;
            typedef typename boost::mpl::if_<boost::is_convertible<T&,boost::detail::thread_move_t<T> >,boost::detail::thread_move_t<T>,T const&>::type rvalue_source_type;
            typedef typename boost::mpl::if_<boost::is_convertible<T&,boost::detail::thread_move_t<T> >,boost::detail::thread_move_t<T>,T>::type move_dest_type;


            static void init(storage_type& storage,source_reference_type t)
            {
                storage.reset(new T(t));
            }

            static void init(storage_type& storage,rvalue_source_type t)
            {
                storage.reset(new T(static_cast<rvalue_source_type>(t)));
            }

            static void cleanup(storage_type& storage)
            {
                storage.reset();
            }
        };

        template<typename T>
        struct future_traits<T&>
        {
            typedef T* storage_type;
            typedef T& source_reference_type;
            struct rvalue_source_type
            {};
            typedef T& move_dest_type;

            static void init(storage_type& storage,T& t)
            {
                storage=&t;
            }

            static void cleanup(storage_type& storage)
            {
                storage=0;
            }
        };

        template<>
        struct future_traits<void>
        {
            typedef bool storage_type;
            typedef void move_dest_type;

            static void init(storage_type& storage)
            {
                storage=true;
            }

            static void cleanup(storage_type& storage)
            {
                storage=false;
            }

        };

        template<typename T>
        struct future_object:
            detail::future_object_base
        {
            typedef typename future_traits<T>::storage_type storage_type;
            typedef typename future_traits<T>::source_reference_type source_reference_type;
            typedef typename future_traits<T>::rvalue_source_type rvalue_source_type;
            typedef typename future_traits<T>::move_dest_type move_dest_type;

            storage_type result;

            future_object():
                result(0)
            {}

            void mark_finished_with_result_internal(source_reference_type result_)
            {
                future_traits<T>::init(result,result_);
                mark_finished_internal();
            }
            void mark_finished_with_result_internal(rvalue_source_type result_)
            {
                future_traits<T>::init(result,static_cast<rvalue_source_type>(result_));
                mark_finished_internal();
            }

            void mark_finished_with_result(source_reference_type result_)
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                mark_finished_with_result_internal(result_);
            }
            void mark_finished_with_result(rvalue_source_type result_)
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                mark_finished_with_result_internal(result_);
            }

            move_dest_type get()
            {
                wait();
                return static_cast<move_dest_type>(*result);
            }

            future_state::state get_state()
            {
                boost::lock_guard<boost::mutex> guard(mutex);
                if(!done)
                {
                    return future_state::waiting;
                }
                else
                {
                    return future_state::ready;
                }
            }

        private:
            future_object(future_object const&);
            future_object& operator=(future_object const&);
        };

        template<>
        struct future_object<void>:
            detail::future_object_base
        {
            future_object()
            {}

            void mark_finished_with_result_internal()
            {
                mark_finished_internal();
            }

            void mark_finished_with_result()
            {
                boost::lock_guard<boost::mutex> lock(mutex);
                mark_finished_with_result_internal();
            }

            void get()
            {
                wait();
            }

            future_state::state get_state()
            {
                boost::lock_guard<boost::mutex> guard(mutex);
                if(!done)
                {
                    return future_state::waiting;
                }
                else
                {
                    return future_state::ready;
                }
            }

        private:
            future_object(future_object const&);
            future_object& operator=(future_object const&);
        };

        class future_waiter
        {
            struct registered_waiter;
            typedef std::vector<registered_waiter>::size_type count_type;

            struct registered_waiter
            {
                boost::shared_ptr<detail::future_object_base> future;
                detail::future_object_base::waiter_list::iterator wait_iterator;
                count_type index;

                registered_waiter(boost::shared_ptr<detail::future_object_base> const& future_,
                                  detail::future_object_base::waiter_list::iterator wait_iterator_,
                                  count_type index_):
                    future(future_),wait_iterator(wait_iterator_),index(index_)
                {}

            };

            struct all_futures_lock
            {
                count_type count;
                boost::scoped_array<boost::unique_lock<boost::mutex> > locks;

                all_futures_lock(std::vector<registered_waiter>& futures):
                    count(futures.size()),locks(new boost::unique_lock<boost::mutex>[count])
                {
                    for(count_type i=0;i<count;++i)
                    {
                        locks[i]=boost::unique_lock<boost::mutex>(futures[i].future->mutex);
                    }
                }

                void lock()
                {
                    boost::lock(locks.get(),locks.get()+count);
                }

                void unlock()
                {
                    for(count_type i=0;i<count;++i)
                    {
                        locks[i].unlock();
                    }
                }
            };

            boost::condition_variable_any cv;
            std::vector<registered_waiter> futures;
            count_type future_count;

        public:
            future_waiter():
                future_count(0)
            {}

            template<typename F>
            void add(F& f)
            {
                if(f.future)
                {
                    futures.push_back(registered_waiter(f.future,f.future->register_external_waiter(cv),future_count));
                }
                ++future_count;
            }

            count_type wait()
            {
                all_futures_lock lk(futures);
                for(;;)
                {
                    for(count_type i=0;i<futures.size();++i)
                    {
                        if(futures[i].future->done)
                        {
                            return futures[i].index;
                        }
                    }
                    cv.wait(lk);
                }
            }

            ~future_waiter()
            {
                for(count_type i=0;i<futures.size();++i)
                {
                    futures[i].future->remove_external_waiter(futures[i].wait_iterator);
                }
            }

        };

    }

    template <typename R>
    class unique_future;

    template <typename R>
    class shared_future;

    template<typename T>
    struct is_future_type
    {
        static const bool value=false;
    };

    template<typename T>
    struct is_future_type<unique_future<T> >
    {
        static const bool value=true;
    };

    template<typename T>
    struct is_future_type<shared_future<T> >
    {
        static const bool value=true;
    };

    template<typename Iterator>
    typename boost::disable_if<is_future_type<Iterator>,void>::type wait_for_all(Iterator begin,Iterator end)
    {
        for(Iterator current=begin;current!=end;++current)
        {
            current->wait();
        }
    }

    template<typename F1,typename F2>
    typename boost::enable_if<is_future_type<F1>,void>::type wait_for_all(F1& f1,F2& f2)
    {
        f1.wait();
        f2.wait();
    }

    template<typename F1,typename F2,typename F3>
    void wait_for_all(F1& f1,F2& f2,F3& f3)
    {
        f1.wait();
        f2.wait();
        f3.wait();
    }

    template<typename F1,typename F2,typename F3,typename F4>
    void wait_for_all(F1& f1,F2& f2,F3& f3,F4& f4)
    {
        f1.wait();
        f2.wait();
        f3.wait();
        f4.wait();
    }

    template<typename F1,typename F2,typename F3,typename F4,typename F5>
    void wait_for_all(F1& f1,F2& f2,F3& f3,F4& f4,F5& f5)
    {
        f1.wait();
        f2.wait();
        f3.wait();
        f4.wait();
        f5.wait();
    }

    template<typename Iterator>
    typename boost::disable_if<is_future_type<Iterator>,Iterator>::type wait_for_any(Iterator begin,Iterator end)
    {
        if(begin==end)
            return end;

        detail::future_waiter waiter;
        for(Iterator current=begin;current!=end;++current)
        {
            waiter.add(*current);
        }
        return boost::next(begin,waiter.wait());
    }

    template<typename F1,typename F2>
    typename boost::enable_if<is_future_type<F1>,unsigned>::type wait_for_any(F1& f1,F2& f2)
    {
        detail::future_waiter waiter;
        waiter.add(f1);
        waiter.add(f2);
        return waiter.wait();
    }

    template<typename F1,typename F2,typename F3>
    unsigned wait_for_any(F1& f1,F2& f2,F3& f3)
    {
        detail::future_waiter waiter;
        waiter.add(f1);
        waiter.add(f2);
        waiter.add(f3);
        return waiter.wait();
    }

    template<typename F1,typename F2,typename F3,typename F4>
    unsigned wait_for_any(F1& f1,F2& f2,F3& f3,F4& f4)
    {
        detail::future_waiter waiter;
        waiter.add(f1);
        waiter.add(f2);
        waiter.add(f3);
        waiter.add(f4);
        return waiter.wait();
    }

    template<typename F1,typename F2,typename F3,typename F4,typename F5>
    unsigned wait_for_any(F1& f1,F2& f2,F3& f3,F4& f4,F5& f5)
    {
        detail::future_waiter waiter;
        waiter.add(f1);
        waiter.add(f2);
        waiter.add(f3);
        waiter.add(f4);
        waiter.add(f5);
        return waiter.wait();
    }

    template <typename R>
    class promise;

    template <typename R>
    class packaged_task;

    template <typename R>
    class unique_future
    {
        unique_future(unique_future & rhs);
        unique_future& operator=(unique_future& rhs);

        typedef boost::shared_ptr<detail::future_object<R> > future_ptr;

        future_ptr future;

        friend class shared_future<R>;
        friend class promise<R>;
        friend class packaged_task<R>;
        friend class detail::future_waiter;

        typedef typename detail::future_traits<R>::move_dest_type move_dest_type;

        unique_future(future_ptr future_):
            future(future_)
        {}

    public:
        typedef future_state::state state;

        unique_future()
        {}

        ~unique_future()
        {}
# 658 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp"
        unique_future(boost::detail::thread_move_t<unique_future> other):
            future(other->future)
        {
            other->future.reset();
        }

        unique_future& operator=(boost::detail::thread_move_t<unique_future> other)
        {
            future=other->future;
            other->future.reset();
            return *this;
        }

        operator boost::detail::thread_move_t<unique_future>()
        {
            return boost::detail::thread_move_t<unique_future>(*this);
        }


        void swap(unique_future& other)
        {
            future.swap(other.future);
        }


        move_dest_type get()
        {
            if(!future)
            {
                boost::throw_exception(future_uninitialized());
            }

            return future->get();
        }


        state get_state() const
        {
            if(!future)
            {
                return future_state::uninitialized;
            }
            return future->get_state();
        }


        bool is_ready() const
        {
            return get_state()==future_state::ready;
        }

        bool has_exception() const
        {
            return future && future->has_exception();
        }

        bool has_value() const
        {
            return future && future->has_value();
        }

        void wait() const
        {
            if(!future)
            {
                boost::throw_exception(future_uninitialized());
            }
            future->wait(false);
        }

        template<typename Duration>
        bool timed_wait(Duration const& rel_time) const
        {
            return timed_wait_until(boost::get_system_time()+rel_time);
        }

        bool timed_wait_until(boost::system_time const& abs_time) const
        {
            if(!future)
            {
                boost::throw_exception(future_uninitialized());
            }
            return future->timed_wait_until(abs_time);
        }

    };

    template <typename R>
    class shared_future
    {
        typedef boost::shared_ptr<detail::future_object<R> > future_ptr;

        future_ptr future;




        friend class detail::future_waiter;
        friend class promise<R>;
        friend class packaged_task<R>;

        shared_future(future_ptr future_):
            future(future_)
        {}

    public:
        shared_future(shared_future const& other):
            future(other.future)
        {}

        typedef future_state::state state;

        shared_future()
        {}

        ~shared_future()
        {}

        shared_future& operator=(shared_future const& other)
        {
            future=other.future;
            return *this;
        }
# 803 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp"
        shared_future(boost::detail::thread_move_t<shared_future> other):
            future(other->future)
        {
            other->future.reset();
        }

        shared_future(boost::detail::thread_move_t<unique_future<R> > other):
            future(other->future)
        {
            other->future.reset();
        }
        shared_future& operator=(boost::detail::thread_move_t<shared_future> other)
        {
            future.swap(other->future);
            other->future.reset();
            return *this;
        }
        shared_future& operator=(boost::detail::thread_move_t<unique_future<R> > other)
        {
            future.swap(other->future);
            other->future.reset();
            return *this;
        }

        operator boost::detail::thread_move_t<shared_future>()
        {
            return boost::detail::thread_move_t<shared_future>(*this);
        }



        void swap(shared_future& other)
        {
            future.swap(other.future);
        }


        R get()
        {
            if(!future)
            {
                boost::throw_exception(future_uninitialized());
            }

            return future->get();
        }


        state get_state() const
        {
            if(!future)
            {
                return future_state::uninitialized;
            }
            return future->get_state();
        }


        bool is_ready() const
        {
            return get_state()==future_state::ready;
        }

        bool has_exception() const
        {
            return future && future->has_exception();
        }

        bool has_value() const
        {
            return future && future->has_value();
        }

        void wait() const
        {
            if(!future)
            {
                boost::throw_exception(future_uninitialized());
            }
            future->wait(false);
        }

        template<typename Duration>
        bool timed_wait(Duration const& rel_time) const
        {
            return timed_wait_until(boost::get_system_time()+rel_time);
        }

        bool timed_wait_until(boost::system_time const& abs_time) const
        {
            if(!future)
            {
                boost::throw_exception(future_uninitialized());
            }
            return future->timed_wait_until(abs_time);
        }

    };

    template <typename R>
    class promise
    {
        typedef boost::shared_ptr<detail::future_object<R> > future_ptr;

        future_ptr future;
        bool future_obtained;

        promise(promise & rhs);
        promise & operator=(promise & rhs);

        void lazy_init()
        {
            if(!future)
            {
                future_obtained=false;
                future.reset(new detail::future_object<R>);
            }
        }

    public:


        promise():
            future(),future_obtained(false)
        {}

        ~promise()
        {
            if(future)
            {
                boost::lock_guard<boost::mutex> lock(future->mutex);

                if(!future->done)
                {
                    future->mark_exceptional_finish_internal(boost::copy_exception(broken_promise()));
                }
            }
        }
# 957 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp"
        promise(boost::detail::thread_move_t<promise> rhs):
            future(rhs->future),future_obtained(rhs->future_obtained)
        {
            rhs->future.reset();
        }
        promise & operator=(boost::detail::thread_move_t<promise> rhs)
        {
            future=rhs->future;
            future_obtained=rhs->future_obtained;
            rhs->future.reset();
            return *this;
        }

        operator boost::detail::thread_move_t<promise>()
        {
            return boost::detail::thread_move_t<promise>(*this);
        }


        void swap(promise& other)
        {
            future.swap(other.future);
            std::swap(future_obtained,other.future_obtained);
        }


        unique_future<R> get_future()
        {
            lazy_init();
            if(future_obtained)
            {
                boost::throw_exception(future_already_retrieved());
            }
            future_obtained=true;
            return unique_future<R>(future);
        }

        void set_value(typename detail::future_traits<R>::source_reference_type r)
        {
            lazy_init();
            boost::lock_guard<boost::mutex> lock(future->mutex);
            if(future->done)
            {
                boost::throw_exception(promise_already_satisfied());
            }
            future->mark_finished_with_result_internal(r);
        }


        void set_value(typename detail::future_traits<R>::rvalue_source_type r)
        {
            lazy_init();
            boost::lock_guard<boost::mutex> lock(future->mutex);
            if(future->done)
            {
                boost::throw_exception(promise_already_satisfied());
            }
            future->mark_finished_with_result_internal(static_cast<typename detail::future_traits<R>::rvalue_source_type>(r));
        }

        void set_exception(boost::exception_ptr p)
        {
            lazy_init();
            boost::lock_guard<boost::mutex> lock(future->mutex);
            if(future->done)
            {
                boost::throw_exception(promise_already_satisfied());
            }
            future->mark_exceptional_finish_internal(p);
        }

        template<typename F>
        void set_wait_callback(F f)
        {
            lazy_init();
            future->set_wait_callback(f,this);
        }

    };

    template <>
    class promise<void>
    {
        typedef boost::shared_ptr<detail::future_object<void> > future_ptr;

        future_ptr future;
        bool future_obtained;

        promise(promise & rhs);
        promise & operator=(promise & rhs);

        void lazy_init()
        {
            if(!future)
            {
                future_obtained=false;
                future.reset(new detail::future_object<void>);
            }
        }
    public:


        promise():
            future(),future_obtained(false)
        {}

        ~promise()
        {
            if(future)
            {
                boost::lock_guard<boost::mutex> lock(future->mutex);

                if(!future->done)
                {
                    future->mark_exceptional_finish_internal(boost::copy_exception(broken_promise()));
                }
            }
        }
# 1091 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp"
        promise(boost::detail::thread_move_t<promise> rhs):
            future(rhs->future),future_obtained(rhs->future_obtained)
        {
            rhs->future.reset();
        }
        promise & operator=(boost::detail::thread_move_t<promise> rhs)
        {
            future=rhs->future;
            future_obtained=rhs->future_obtained;
            rhs->future.reset();
            return *this;
        }

        operator boost::detail::thread_move_t<promise>()
        {
            return boost::detail::thread_move_t<promise>(*this);
        }


        void swap(promise& other)
        {
            future.swap(other.future);
            std::swap(future_obtained,other.future_obtained);
        }


        unique_future<void> get_future()
        {
            lazy_init();

            if(future_obtained)
            {
                boost::throw_exception(future_already_retrieved());
            }
            future_obtained=true;
            return unique_future<void>(future);
        }

        void set_value()
        {
            lazy_init();
            boost::lock_guard<boost::mutex> lock(future->mutex);
            if(future->done)
            {
                boost::throw_exception(promise_already_satisfied());
            }
            future->mark_finished_with_result_internal();
        }

        void set_exception(boost::exception_ptr p)
        {
            lazy_init();
            boost::lock_guard<boost::mutex> lock(future->mutex);
            if(future->done)
            {
                boost::throw_exception(promise_already_satisfied());
            }
            future->mark_exceptional_finish_internal(p);
        }

        template<typename F>
        void set_wait_callback(F f)
        {
            lazy_init();
            future->set_wait_callback(f,this);
        }

    };

    namespace detail
    {
        template<typename R>
        struct task_base:
            detail::future_object<R>
        {
            bool started;

            task_base():
                started(false)
            {}

            void run()
            {
                {
                    boost::lock_guard<boost::mutex> lk(this->mutex);
                    if(started)
                    {
                        boost::throw_exception(task_already_started());
                    }
                    started=true;
                }
                do_run();
            }

            void owner_destroyed()
            {
                boost::lock_guard<boost::mutex> lk(this->mutex);
                if(!started)
                {
                    started=true;
                    this->mark_exceptional_finish_internal(boost::copy_exception(boost::broken_promise()));
                }
            }


            virtual void do_run()=0;
        };


        template<typename R,typename F>
        struct task_object:
            task_base<R>
        {
            F f;
            task_object(F const& f_):
                f(f_)
            {}
            task_object(boost::detail::thread_move_t<F> f_):
                f(f_)
            {}

            void do_run()
            {
                try
                {
                    this->mark_finished_with_result(f());
                }
                catch(...)
                {
                    this->mark_exceptional_finish();
                }
            }
        };

        template<typename F>
        struct task_object<void,F>:
            task_base<void>
        {
            F f;
            task_object(F const& f_):
                f(f_)
            {}
            task_object(boost::detail::thread_move_t<F> f_):
                f(f_)
            {}

            void do_run()
            {
                try
                {
                    f();
                    this->mark_finished_with_result();
                }
                catch(...)
                {
                    this->mark_exceptional_finish();
                }
            }
        };

    }


    template<typename R>
    class packaged_task
    {
        boost::shared_ptr<detail::task_base<R> > task;
        bool future_obtained;

        packaged_task(packaged_task&);
        packaged_task& operator=(packaged_task&);

    public:
        packaged_task():
            future_obtained(false)
        {}


        template <class F>
        explicit packaged_task(F const& f):
            task(new detail::task_object<R,F>(f)),future_obtained(false)
        {}
        explicit packaged_task(R(*f)()):
            task(new detail::task_object<R,R(*)()>(f)),future_obtained(false)
        {}

        template <class F>
        explicit packaged_task(boost::detail::thread_move_t<F> f):
            task(new detail::task_object<R,F>(f)),future_obtained(false)
        {}







        ~packaged_task()
        {
            if(task)
            {
                task->owner_destroyed();
            }
        }
# 1311 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread/future.hpp"
        packaged_task(boost::detail::thread_move_t<packaged_task> other):
            future_obtained(other->future_obtained)
        {
            task.swap(other->task);
            other->future_obtained=false;
        }
        packaged_task& operator=(boost::detail::thread_move_t<packaged_task> other)
        {
            packaged_task temp(other);
            swap(temp);
            return *this;
        }
        operator boost::detail::thread_move_t<packaged_task>()
        {
            return boost::detail::thread_move_t<packaged_task>(*this);
        }


        void swap(packaged_task& other)
        {
            task.swap(other.task);
            std::swap(future_obtained,other.future_obtained);
        }


        unique_future<R> get_future()
        {
            if(!task)
            {
                boost::throw_exception(task_moved());
            }
            else if(!future_obtained)
            {
                future_obtained=true;
                return unique_future<R>(task);
            }
            else
            {
                boost::throw_exception(future_already_retrieved());
            }
        }



        void operator()()
        {
            if(!task)
            {
                boost::throw_exception(task_moved());
            }
            task->run();
        }

        template<typename F>
        void set_wait_callback(F f)
        {
            task->set_wait_callback(f,this);
        }

    };

}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/thread.hpp" 2
# 32 "../libbase/string_table.h" 2




namespace gnash {




class string_table
{
public:


 struct svt
 {
  svt(const std::string& val, std::size_t i)
            :
   value(val),
            id(i)
        {}

  std::string value;
  std::size_t id;
 };


    struct StringID {};


    struct StringValue {};






 typedef boost::multi_index_container<svt,
  boost::multi_index::indexed_by<

   boost::multi_index::hashed_unique<
                boost::multi_index::tag<StringValue>,
    boost::multi_index::member<svt, std::string, &svt::value> >,

   boost::multi_index::hashed_unique<
                boost::multi_index::tag<StringID>,
    boost::multi_index::member<svt, std::size_t, &svt::id>

        >
 > > table;

 typedef std::size_t key;
# 95 "../libbase/string_table.h"
 key find(const std::string& to_find, bool insert_unfound = true);






 const std::string& value(key to_find)
 {
  if (_table.empty() || !to_find) return _empty;

  table::index<StringID>::type::iterator r =
            _table.get<StringID>().find(to_find);
  return (r == _table.get<StringID>().end()) ? _empty : r->value;
 }




 key insert(const std::string& to_insert);







 void insert_group(const svt* pList, std::size_t size);





 key already_locked_insert(const std::string& to_insert);


 string_table()
        :
  _highestKey(0)
 {}






    key noCase(key a) const;

private:

 table _table;
 static const std::string _empty;
 boost::mutex _lock;
 std::size_t _highestKey;

    std::map<key, key> _caseTable;
};
# 167 "../libbase/string_table.h"
 bool equal(string_table& st, string_table::key a, string_table::key b,
        bool caseless);

}
# 27 "./as_object.h" 2
# 1 "../libbase/GC.h" 1
# 48 "../libbase/GC.h"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 49 "../libbase/GC.h" 2


namespace gnash {

class GC;
# 62 "../libbase/GC.h"
class GcRoot
{

public:
# 75 "../libbase/GC.h"
    virtual void markReachableResources() const=0;

    virtual ~GcRoot() {}
};





class GcResource
{

public:

    friend class GC;






    GcResource();
# 105 "../libbase/GC.h"
    void setReachable() const
    {

        if ( _reachable )
        {




            return;
        }






        _reachable = true;
        markReachableResources();
    }


    bool isReachable() const { return _reachable; }


    void clearReachable() const { _reachable = false; }

protected:
# 148 "../libbase/GC.h"
    virtual void markReachableResources() const
    {
        ((_reachable) ? static_cast<void> (0) : __assert_fail ("_reachable", "../libbase/GC.h", 150, __PRETTY_FUNCTION__));



    }






    virtual ~GcResource()
    {
    }

private:

    mutable bool _reachable;

};
# 185 "../libbase/GC.h"
class GC
{

public:



    static GC& init(GcRoot& r);






    static void cleanup();






    static GC& get() {
        return *_singleton;
    }
# 227 "../libbase/GC.h"
    void addCollectable(const GcResource* item)
    {

        boost::thread self;
        ((self == mainThread) ? static_cast<void> (0) : __assert_fail ("self == mainThread", "../libbase/GC.h", 231, __PRETTY_FUNCTION__));
        ((item) ? static_cast<void> (0) : __assert_fail ("item", "../libbase/GC.h", 232, __PRETTY_FUNCTION__));
        ((! item->isReachable()) ? static_cast<void> (0) : __assert_fail ("! item->isReachable()", "../libbase/GC.h", 233, __PRETTY_FUNCTION__));




        _resList.push_back(item); ++_resListSize;



    }


    void fuzzyCollect()
    {
# 276 "../libbase/GC.h"
        if ( _resListSize < _lastResCount + maxNewCollectablesCount )
        {



            return;
        }

        runCycle();
    }





    void runCycle();

    typedef std::map<std::string, unsigned int> CollectablesCount;


    void countCollectables(CollectablesCount& count) const;

private:



    static unsigned int maxNewCollectablesCount;


    GC(GcRoot& root)
        :
        _resListSize(0),
        _root(root),
        _lastResCount(0)



    {



    }


    ~GC();


    typedef std::list<const GcResource *> ResList;


    void markReachable()
    {



        _root.markReachableResources();
    }





    size_t cleanUnreachable();


    ResList _resList;





    ResList::size_type _resListSize;

    GcRoot& _root;

    static GC* _singleton;





    boost::thread mainThread;




    ResList::size_type _lastResCount;





};


inline GcResource::GcResource()
    :
    _reachable(false)
{
    GC::get().addCollectable(this);
}

}
# 28 "./as_object.h" 2
# 1 "./PropertyList.h" 1
# 22 "./PropertyList.h"
# 1 "./Property.h" 1
# 23 "./Property.h"
# 1 "./PropFlags.h" 1
# 24 "./PropFlags.h"
namespace gnash {


class PropFlags
{


 int _flags;




public:


 enum Flags {


  dontEnum = 1 << 0,


  dontDelete = 1 << 1,


  readOnly = 1 << 2,


  onlySWF6Up = 1 << 7,


  ignoreSWF6 = 1 << 8,


  onlySWF7Up = 1 << 10,


  onlySWF8Up = 1 << 12,


  onlySWF9Up = 1 << 13

 };


 PropFlags() : _flags(0)
 {
 }


 PropFlags(const bool read_only, const bool dont_delete,
            const bool dont_enum)
  :
  _flags(((read_only) ? readOnly : 0) |
    ((dont_delete) ? dontDelete : 0) |
    ((dont_enum) ? dontEnum : 0))
 {
 }


 PropFlags(const int flags)
  : _flags(flags)
 {
 }

 bool operator== (const PropFlags& o) const
 {
  return ( _flags == o._flags );
 }

 bool operator!= (const PropFlags& o) const
 {
  return ( _flags != o._flags );
 }


 bool get_read_only() const
 {
     return (_flags & readOnly);
 }


 void set_read_only() { _flags |= readOnly; }


 void clear_read_only() { _flags &= ~readOnly; }


 bool get_dont_delete() const
 {
     return (_flags & dontDelete);
 }


 void set_dont_delete() { _flags |= dontDelete; }


 void clear_dont_delete() { _flags &= ~dontDelete; }


 bool get_dont_enum() const
 {
     return (_flags & dontEnum);
 }


 void set_dont_enum() { _flags |= dontEnum; }


 void clear_dont_enum() { _flags &= ~dontEnum; }


 bool get_visible(int swfVersion) const
 {
  if ( _flags & onlySWF6Up && swfVersion < 6 ) return false;
  if ( _flags & ignoreSWF6 && swfVersion == 6 ) return false;
  if ( _flags & onlySWF7Up && swfVersion < 7 ) return false;
  if ( _flags & onlySWF8Up && swfVersion < 8 ) return false;
  if ( _flags & onlySWF9Up && swfVersion < 9 ) return false;
  return true;
 }

 void clear_visible(int swfVersion)
 {
  if ( swfVersion == 6)
  {


   _flags &= ~(onlySWF6Up|ignoreSWF6|onlySWF8Up|onlySWF9Up);
  }
  else
  {
   _flags &= ~(onlySWF6Up|ignoreSWF6|onlySWF7Up|onlySWF8Up|onlySWF9Up);
  }

 }


 int get_flags() const { return _flags; }
# 176 "./PropFlags.h"
 bool set_flags(const int setTrue, const int setFalse = 0)
 {
  _flags &= ~setFalse;
  _flags |= setTrue;
  return true;
 }
};

inline std::ostream&
operator << (std::ostream& os, const PropFlags& fl)
{
 os << "(";
 if ( fl.get_read_only() ) os << " readonly";
 if ( fl.get_dont_delete() ) os << " nodelete";
 if ( fl.get_dont_enum() ) os << " noenum";
 os << " )";

 return os;
}



}
# 24 "./Property.h" 2
# 1 "./as_value.h" 1
# 25 "./Property.h" 2
# 1 "./ObjectURI.h" 1
# 9 "./ObjectURI.h"
namespace gnash {





struct ObjectURI
{

    class Logger;


    ObjectURI(string_table::key name)
        :
        name(name)
    {}

    string_table::key name;
};


inline bool
operator==(const ObjectURI& a, const ObjectURI& b)
{
    return a.name == b.name;
}


inline bool
operator<(const ObjectURI& a, const ObjectURI& b)
{
    return a.name < b.name;
}


inline string_table::key
getName(const ObjectURI& o)
{
    return o.name;
}

class ObjectURI::Logger
{
public:
    Logger(string_table& st) : _st(st) {}

    std::string operator()(const ObjectURI& uri) const {
        const string_table::key name = getName(uri);
        return _st.value(name);
    }
private:
    string_table& _st;
};

}
# 26 "./Property.h" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 29 "./Property.h" 2

namespace gnash {

typedef as_value (*as_c_function_ptr)(const fn_call& fn);

class as_function;
class PropertyList;






class GetterSetter
{
public:


 GetterSetter(as_function* getter, as_function* setter)
  :
  _getset(UserDefinedGetterSetter(getter, setter))
 {}


 GetterSetter(as_c_function_ptr getter, as_c_function_ptr setter)
  :
  _getset(NativeGetterSetter(getter, setter))
 {}


 as_value get(fn_call& fn) const
 {
  switch ( _getset.which() )
  {
   case 0:
    return boost::get<UserDefinedGetterSetter>(_getset).get(fn);
    break;
   case 1:
    return boost::get<NativeGetterSetter>(_getset).get(fn);
    break;
  }
  return as_value();
 }


 void set(fn_call& fn)
 {
  switch ( _getset.which() )
  {
   case 0:
    boost::get<UserDefinedGetterSetter>(_getset).set(fn);
    break;
   case 1:
    boost::get<NativeGetterSetter>(_getset).set(fn);
    break;
  }
 }


 void setCache(const as_value& v)
 {
  switch ( _getset.which() )
  {
   case 0:
    boost::get<UserDefinedGetterSetter>(_getset).setUnderlying(v);
    break;
   case 1:

    break;
  }
 }


 const as_value& getCache() const
 {
  switch (_getset.which())
  {
   case 0:
    return boost::get<UserDefinedGetterSetter>(
                        _getset).getUnderlying();
  }
  static as_value undefVal;
  return undefVal;
 }

 void markReachableResources() const
 {
  if (_getset.which() == 0) {
   boost::get<UserDefinedGetterSetter>(
                    _getset).markReachableResources();
  }
 }

private:


 class UserDefinedGetterSetter
    {
 public:

  UserDefinedGetterSetter(as_function* get, as_function* set)
   :
   _getter(get),
   _setter(set),
   _underlyingValue(),
   _beingAccessed(false)
  {}


  as_value get(fn_call& fn) const;


  void set(fn_call& fn);


  const as_value& getUnderlying() const { return _underlyingValue; }


  void setUnderlying(const as_value& v) { _underlyingValue = v; }

  void markReachableResources() const;

 private:

  as_function* _getter;
  as_function* _setter;

  as_value _underlyingValue;

  mutable bool _beingAccessed;







  class ScopedLock : boost::noncopyable
        {
  public:

   ScopedLock(const UserDefinedGetterSetter& na)
                :
                _a(na),
                _obtainedLock(_a._beingAccessed ? false : true)
   {


                if (_obtainedLock) _a._beingAccessed = true;
   }

   ~ScopedLock() { if ( _obtainedLock) _a._beingAccessed = false; }







   bool obtainedLock() const { return _obtainedLock; }

        private:

   const UserDefinedGetterSetter& _a;
   bool _obtainedLock;

        };
    };


 class NativeGetterSetter {

 public:

  NativeGetterSetter(as_c_function_ptr get, as_c_function_ptr set)
   :
   _getter(get), _setter(set) {}


  as_value get(fn_call& fn) const
  {
   return _getter(fn);
  }


  void set(fn_call& fn)
  {
   _setter(fn);
  }

 private:

  as_c_function_ptr _getter;
  as_c_function_ptr _setter;
 };

 boost::variant<UserDefinedGetterSetter, NativeGetterSetter> _getset;

};
# 236 "./Property.h"
class Property
{
public:

 Property(const ObjectURI& uri)
        :
  _bound(as_value()),
        _destructive(false),
        _uri(uri)
 {}

 Property(const ObjectURI& uri, const as_value& value,
            const PropFlags& flags = PropFlags())
        :
  _flags(flags),
        _bound(value),
        _destructive(false),
  _uri(uri)
 {}

 Property(const ObjectURI& uri,
  as_function *getter, as_function *setter,
  const PropFlags& flags, bool destroy = false)
        :
  _flags(flags),
        _bound(GetterSetter(getter, setter)),
  _destructive(destroy),
        _uri(uri)
 {}

 Property(const ObjectURI& uri, as_function *getter, as_function *setter,
            bool destroy = false)
        :
  _flags(),
        _bound(GetterSetter(getter, setter)),
        _destructive(destroy),
        _uri(uri)
 {}

 Property(const ObjectURI& uri, as_c_function_ptr getter,
            as_c_function_ptr setter, const PropFlags& flags,
            bool destroy = false)
  :
  _flags(flags),
        _bound(GetterSetter(getter, setter)),
        _destructive(destroy),
        _uri(uri)
 {}


 Property(const Property& p)
        :
  _flags(p._flags),
        _bound(p._bound),
        _destructive(p._destructive),
        _uri(p._uri)
 {}


 const PropFlags& getFlags() const { return _flags; }


    void setFlags(const PropFlags& flags) const {
        _flags = flags;
    }
# 311 "./Property.h"
 as_value getValue(const as_object& this_ptr) const;
# 320 "./Property.h"
 const as_value& getCache() const;
# 329 "./Property.h"
 void setCache(const as_value& v);
# 346 "./Property.h"
 void setValue(as_object& this_ptr, const as_value &value) const;


 bool isGetterSetter() const {
        return _bound.which() == TYPE_GETTER_SETTER;
    }


 bool isDestructive() const { return _destructive; }


 void clearVisible(int swfVersion) { _flags.clear_visible(swfVersion); }


    const ObjectURI& uri() const {
        return _uri;
    }


 void setReachable() const;

private:


 as_value getDelayedValue(const as_object& this_ptr) const;


 void setDelayedValue(as_object& this_ptr, const as_value& value) const;

    enum Type {
        TYPE_EMPTY,
        TYPE_VALUE,
        TYPE_GETTER_SETTER
    };


 mutable PropFlags _flags;


 typedef boost::variant<boost::blank, as_value, GetterSetter> BoundType;


 mutable BoundType _bound;




 mutable bool _destructive;


    ObjectURI _uri;

};


inline bool
readOnly(const Property& prop) {
    return prop.getFlags().get_read_only();
}


inline bool
visible(const Property& prop, int version) {
    return prop.getFlags().get_visible(version);
}

}
# 23 "./PropertyList.h" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/set" 1 3
# 58 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/set" 3
       
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/set" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 158 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 174 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 188 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 226 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 274 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 361 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 386 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
# 404 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 431 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 444 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 490 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 506 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 540 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 551 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      void
      clear()
      { _M_t.clear(); }
# 565 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 583 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 604 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 620 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 645 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 674 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 691 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 62 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/set" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 1 3
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 82 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 151 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 167 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 181 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 219 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 267 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 354 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 379 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
# 395 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 419 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 431 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 479 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 495 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 529 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 540 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      void
      clear()
      { _M_t.clear(); }
# 551 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 569 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 590 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 606 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 631 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 661 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 678 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 63 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/set" 2 3
# 25 "./PropertyList.h" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 28 "./PropertyList.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 30 "./PropertyList.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 1
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bidir_node_iterator.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/bidir_node_iterator.hpp"
namespace boost{

namespace multi_index{

namespace detail{





template<typename Node>
class bidir_node_iterator:
  public bidirectional_iterator_helper<
    bidir_node_iterator<Node>,
    typename Node::value_type,
    std::ptrdiff_t,
    const typename Node::value_type*,
    const typename Node::value_type&>
{
public:
  bidir_node_iterator(){}
  explicit bidir_node_iterator(Node* node_):node(node_){}

  const typename Node::value_type& operator*()const
  {
    return node->value();
  }

  bidir_node_iterator& operator++()
  {
    Node::increment(node);
    return *this;
  }

  bidir_node_iterator& operator--()
  {
    Node::decrement(node);
    return *this;
  }






  template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }

  typedef typename Node::base_type node_base_type;

  template<class Archive>
  void save(Archive& ar,const unsigned int)const
  {
    node_base_type* bnode=node;
    ar<<serialization::make_nvp("pointer",bnode);
  }

  template<class Archive>
  void load(Archive& ar,const unsigned int)
  {
    node_base_type* bnode;
    ar>>serialization::make_nvp("pointer",bnode);
    node=static_cast<Node*>(bnode);
  }




  typedef Node node_type;

  Node* get_node()const{return node;}

private:
  Node* node;
};

template<typename Node>
bool operator==(
  const bidir_node_iterator<Node>& x,
  const bidir_node_iterator<Node>& y)
{
  return x.get_node()==y.get_node();
}

}

}

}
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_node.hpp" 1
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_node.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_node.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/uintptr_type.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/uintptr_type.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/uintptr_type.hpp"
template<int N>struct uintptr_candidates;
template<>struct uintptr_candidates<-1>{typedef unsigned int type;};
template<>struct uintptr_candidates<0> {typedef unsigned int type;};
template<>struct uintptr_candidates<1> {typedef unsigned short type;};
template<>struct uintptr_candidates<2> {typedef unsigned long type;};


template<>struct uintptr_candidates<3> {typedef boost::ulong_long_type type;};







template<>struct uintptr_candidates<4> {typedef unsigned int type;};


struct uintptr_aux
{
  static const int index= sizeof(void*)==sizeof(uintptr_candidates<0>::type)?0: sizeof(void*)==sizeof(uintptr_candidates<1>::type)?1: sizeof(void*)==sizeof(uintptr_candidates<2>::type)?2: sizeof(void*)==sizeof(uintptr_candidates<3>::type)?3: sizeof(void*)==sizeof(uintptr_candidates<4>::type)?4:-1




                                                            ;

  static const bool has_uintptr_type=(index>=0);

  typedef uintptr_candidates<index>::type type;
};

typedef mpl::bool_<uintptr_aux::has_uintptr_type> has_uintptr_type;
typedef uintptr_aux::type uintptr_type;

}

}

}
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_node.hpp" 2




namespace boost{

namespace multi_index{

namespace detail{



enum ordered_index_color{red=false,black=true};
enum ordered_index_side{to_left=false,to_right=true};

template<typename Allocator>
struct ordered_index_node_impl;

template<typename Allocator>
struct ordered_index_node_std_base
{
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,
      ordered_index_node_impl<Allocator>
    >::type
  >::type::pointer pointer;
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,
      ordered_index_node_impl<Allocator>
    >::type
  >::type::const_pointer const_pointer;
  typedef ordered_index_color& color_ref;
  typedef pointer& parent_ref;

  ordered_index_color& color(){return color_;}
  ordered_index_color color()const{return color_;}
  pointer& parent(){return parent_;}
  pointer parent()const{return parent_;}
  pointer& left(){return left_;}
  pointer left()const{return left_;}
  pointer& right(){return right_;}
  pointer right()const{return right_;}

private:
  ordered_index_color color_;
  pointer parent_;
  pointer left_;
  pointer right_;
};
# 124 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_node.hpp"
template<typename Allocator>
struct ordered_index_node_compressed_base
{
  typedef ordered_index_node_impl<Allocator>* pointer;
  typedef const ordered_index_node_impl<Allocator>* const_pointer;

  struct color_ref
  {
    color_ref(uintptr_type* r_):r(r_){}

    operator ordered_index_color()const
    {
      return ordered_index_color(*r&uintptr_type(1));
    }

    color_ref& operator=(ordered_index_color c)
    {
      *r&=~uintptr_type(1);
      *r|=uintptr_type(c);
      return *this;
    }

    color_ref& operator=(const color_ref& x)
    {
      return operator=(x.operator ordered_index_color());
    }

  private:
    uintptr_type* r;
  };

  struct parent_ref
  {
    parent_ref(uintptr_type* r_):r(r_){}

    operator pointer()const
    {
      return (pointer)(void*)(*r&~uintptr_type(1));
    }

    parent_ref& operator=(pointer p)
    {
      *r=((uintptr_type)(void*)p)|(*r&uintptr_type(1));
      return *this;
    }

    parent_ref& operator=(const parent_ref& x)
    {
      return operator=(x.operator pointer());
    }

    pointer operator->()const
    {
      return operator pointer();
    }

  private:
    uintptr_type* r;
  };

  color_ref color(){return color_ref(&parentcolor_);}
  ordered_index_color color()const
  {
    return ordered_index_color(parentcolor_&std::size_t(1ul));
  }

  parent_ref parent(){return parent_ref(&parentcolor_);}
  pointer parent()const
  {
    return (pointer)(void*)(parentcolor_&~uintptr_type(1));
  }

  pointer& left(){return left_;}
  pointer left()const{return left_;}
  pointer& right(){return right_;}
  pointer right()const{return right_;}

private:
  uintptr_type parentcolor_;
  pointer left_;
  pointer right_;
};





template<typename Allocator>
struct ordered_index_node_impl_base:


  mpl::if_c<
    !(has_uintptr_type::value)||
    (alignment_of<ordered_index_node_compressed_base<Allocator> >::value%2)||
    !(is_same<
      typename prevent_eti<
        Allocator,
        typename boost::detail::allocator::rebind_to<
          Allocator,
          ordered_index_node_impl<Allocator>
        >::type
      >::type::pointer,
      ordered_index_node_impl<Allocator>*>::value),
    ordered_index_node_std_base<Allocator>,
    ordered_index_node_compressed_base<Allocator>
  >::type




{};

template<typename Allocator>
struct ordered_index_node_impl:ordered_index_node_impl_base<Allocator>
{
private:
  typedef ordered_index_node_impl_base<Allocator> super;

public:
  typedef typename super::color_ref color_ref;
  typedef typename super::parent_ref parent_ref;
  typedef typename super::pointer pointer;
  typedef typename super::const_pointer const_pointer;



  static void increment(pointer& x)
  {
    if(x->right()!=pointer(0)){
      x=x->right();
      while(x->left()!=pointer(0))x=x->left();
    }
    else{
      pointer y=x->parent();
      while(x==y->right()){
        x=y;
        y=y->parent();
      }
      if(x->right()!=y)x=y;
    }
  }

  static void decrement(pointer& x)
  {
    if(x->color()==red&&x->parent()->parent()==x){
      x=x->right();
    }
    else if(x->left()!=pointer(0)){
      pointer y=x->left();
      while(y->right()!=pointer(0))y=y->right();
      x=y;
    }else{
      pointer y=x->parent();
      while(x==y->left()){
        x=y;
        y=y->parent();
      }
      x=y;
    }
  }



  static void rotate_left(pointer x,parent_ref root)
  {
    pointer y=x->right();
    x->right()=y->left();
    if(y->left()!=pointer(0))y->left()->parent()=x;
    y->parent()=x->parent();

    if(x==root) root=y;
    else if(x==x->parent()->left())x->parent()->left()=y;
    else x->parent()->right()=y;
    y->left()=x;
    x->parent()=y;
  }

  static pointer minimum(pointer x)
  {
    while(x->left()!=pointer(0))x=x->left();
    return x;
  }

  static pointer maximum(pointer x)
  {
    while(x->right()!=pointer(0))x=x->right();
    return x;
  }

  static void rotate_right(pointer x,parent_ref root)
  {
    pointer y=x->left();
    x->left()=y->right();
    if(y->right()!=pointer(0))y->right()->parent()=x;
    y->parent()=x->parent();

    if(x==root) root=y;
    else if(x==x->parent()->right())x->parent()->right()=y;
    else x->parent()->left()=y;
    y->right()=x;
    x->parent()=y;
  }

  static void rebalance(pointer x,parent_ref root)
  {
    x->color()=red;
    while(x!=root&&x->parent()->color()==red){
      if(x->parent()==x->parent()->parent()->left()){
        pointer y=x->parent()->parent()->right();
        if(y!=pointer(0)&&y->color()==red){
          x->parent()->color()=black;
          y->color()=black;
          x->parent()->parent()->color()=red;
          x=x->parent()->parent();
        }
        else{
          if(x==x->parent()->right()){
            x=x->parent();
            rotate_left(x,root);
          }
          x->parent()->color()=black;
          x->parent()->parent()->color()=red;
          rotate_right(x->parent()->parent(),root);
        }
      }
      else{
        pointer y=x->parent()->parent()->left();
        if(y!=pointer(0)&&y->color()==red){
          x->parent()->color()=black;
          y->color()=black;
          x->parent()->parent()->color()=red;
          x=x->parent()->parent();
        }
        else{
          if(x==x->parent()->left()){
            x=x->parent();
            rotate_right(x,root);
          }
          x->parent()->color()=black;
          x->parent()->parent()->color()=red;
          rotate_left(x->parent()->parent(),root);
        }
      }
    }
    root->color()=black;
  }

  static void link(
    pointer x,ordered_index_side side,pointer position,pointer header)
  {
    if(side==to_left){
      position->left()=x;
      if(position==header){
        header->parent()=x;
        header->right()=x;
      }
      else if(position==header->left()){
        header->left()=x;
      }
    }
    else{
      position->right()=x;
      if(position==header->right()){
        header->right()=x;
      }
    }
    x->parent()=position;
    x->left()=pointer(0);
    x->right()=pointer(0);
    ordered_index_node_impl::rebalance(x,header->parent());
  }

  static pointer rebalance_for_erase(
    pointer z,parent_ref root,pointer& leftmost,pointer& rightmost)
  {
    pointer y=z;
    pointer x=pointer(0);
    pointer x_parent=pointer(0);
    if(y->left()==pointer(0)){
      x=y->right();
    }
    else{
      if(y->right()==pointer(0)){
        x=y->left();
      }
      else{
        y=y->right();
        while(y->left()!=pointer(0))y=y->left();
        x=y->right();
      }
    }
    if(y!=z){
      z->left()->parent()=y;
      y->left()=z->left();
      if(y!=z->right()){
        x_parent=y->parent();
        if(x!=pointer(0))x->parent()=y->parent();
        y->parent()->left()=x;
        y->right()=z->right();
        z->right()->parent()=y;
      }
      else{
        x_parent=y;
      }

      if(root==z) root=y;
      else if(z->parent()->left()==z)z->parent()->left()=y;
      else z->parent()->right()=y;
      y->parent()=z->parent();
      ordered_index_color c=y->color();
      y->color()=z->color();
      z->color()=c;
      y=z;
    }
    else{
      x_parent=y->parent();
      if(x!=pointer(0))x->parent()=y->parent();
      if(root==z){
        root=x;
      }
      else{
        if(z->parent()->left()==z)z->parent()->left()=x;
        else z->parent()->right()=x;
      }
      if(leftmost==z){
        if(z->right()==pointer(0)){
          leftmost=z->parent();
        }
        else{
          leftmost=minimum(x);
        }
      }
      if(rightmost==z){
        if(z->left()==pointer(0)){
          rightmost=z->parent();
        }
        else{
          rightmost=maximum(x);
        }
      }
    }
    if(y->color()!=red){
      while(x!=root&&(x==pointer(0)|| x->color()==black)){
        if(x==x_parent->left()){
          pointer w=x_parent->right();
          if(w->color()==red){
            w->color()=black;
            x_parent->color()=red;
            rotate_left(x_parent,root);
            w=x_parent->right();
          }
          if((w->left()==pointer(0)||w->left()->color()==black) &&
             (w->right()==pointer(0)||w->right()->color()==black)){
            w->color()=red;
            x=x_parent;
            x_parent=x_parent->parent();
          }
          else{
            if(w->right()==pointer(0 )
                || w->right()->color()==black){
              if(w->left()!=pointer(0)) w->left()->color()=black;
              w->color()=red;
              rotate_right(w,root);
              w=x_parent->right();
            }
            w->color()=x_parent->color();
            x_parent->color()=black;
            if(w->right()!=pointer(0))w->right()->color()=black;
            rotate_left(x_parent,root);
            break;
          }
        }
        else{
          pointer w=x_parent->left();
          if(w->color()==red){
            w->color()=black;
            x_parent->color()=red;
            rotate_right(x_parent,root);
            w=x_parent->left();
          }
          if((w->right()==pointer(0)||w->right()->color()==black) &&
             (w->left()==pointer(0)||w->left()->color()==black)){
            w->color()=red;
            x=x_parent;
            x_parent=x_parent->parent();
          }
          else{
            if(w->left()==pointer(0)||w->left()->color()==black){
              if(w->right()!=pointer(0))w->right()->color()=black;
              w->color()=red;
              rotate_left(w,root);
              w=x_parent->left();
            }
            w->color()=x_parent->color();
            x_parent->color()=black;
            if(w->left()!=pointer(0))w->left()->color()=black;
            rotate_right(x_parent,root);
            break;
          }
        }
      }
      if(x!=pointer(0))x->color()=black;
    }
    return y;
  }

  static void restore(pointer x,pointer position,pointer header)
  {
    if(position->left()==pointer(0)||position->left()==header){
      link(x,to_left,position,header);
    }
    else{
      decrement(position);
      link(x,to_right,position,header);
    }
  }
# 556 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_node.hpp"
};

template<typename Super>
struct ordered_index_node_trampoline:
  prevent_eti<
    Super,
    ordered_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        typename Super::allocator_type,
        char
      >::type
    >
  >::type
{
  typedef typename prevent_eti<
    Super,
    ordered_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        typename Super::allocator_type,
        char
      >::type
    >
  >::type impl_type;
};

template<typename Super>
struct ordered_index_node:Super,ordered_index_node_trampoline<Super>
{
private:
  typedef ordered_index_node_trampoline<Super> trampoline;

public:
  typedef typename trampoline::impl_type impl_type;
  typedef typename trampoline::color_ref impl_color_ref;
  typedef typename trampoline::parent_ref impl_parent_ref;
  typedef typename trampoline::pointer impl_pointer;
  typedef typename trampoline::const_pointer const_impl_pointer;

  impl_color_ref color(){return trampoline::color();}
  ordered_index_color color()const{return trampoline::color();}
  impl_parent_ref parent(){return trampoline::parent();}
  impl_pointer parent()const{return trampoline::parent();}
  impl_pointer& left(){return trampoline::left();}
  impl_pointer left()const{return trampoline::left();}
  impl_pointer& right(){return trampoline::right();}
  impl_pointer right()const{return trampoline::right();}

  impl_pointer impl()
  {
    return static_cast<impl_pointer>(
      static_cast<impl_type*>(static_cast<trampoline*>(this)));
  }

  const_impl_pointer impl()const
  {
    return static_cast<const_impl_pointer>(
      static_cast<const impl_type*>(static_cast<const trampoline*>(this)));
  }

  static ordered_index_node* from_impl(impl_pointer x)
  {
    return static_cast<ordered_index_node*>(
      static_cast<trampoline*>(&*x));
  }

  static const ordered_index_node* from_impl(const_impl_pointer x)
  {
    return static_cast<const ordered_index_node*>(
      static_cast<const trampoline*>(&*x));
  }



  static void increment(ordered_index_node*& x)
  {
    impl_pointer xi=x->impl();
    trampoline::increment(xi);
    x=from_impl(xi);
  }

  static void decrement(ordered_index_node*& x)
  {
    impl_pointer xi=x->impl();
    trampoline::decrement(xi);
    x=from_impl(xi);
  }
};

}

}

}
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_ops.hpp" 1
# 46 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/ord_index_ops.hpp"
namespace boost{

namespace multi_index{

namespace detail{





template<
  typename Node,typename KeyFromValue,
  typename CompatibleKey,typename CompatibleCompare
>
inline Node* ordered_index_find(
  Node* top,Node* y,const KeyFromValue& key,const CompatibleKey& x,
  const CompatibleCompare& comp)
{
  Node* y0=y;

  while (top){
    if(!comp(key(top->value()),x)){
      y=top;
      top=Node::from_impl(top->left());
    }
    else top=Node::from_impl(top->right());
  }

  return (y==y0||comp(x,key(y->value())))?y0:y;
}

template<
  typename Node,typename KeyFromValue,
  typename CompatibleKey,typename CompatibleCompare
>
inline Node* ordered_index_lower_bound(
  Node* top,Node* y,const KeyFromValue& key,const CompatibleKey& x,
  const CompatibleCompare& comp)
{
  while(top){
    if(!comp(key(top->value()),x)){
      y=top;
      top=Node::from_impl(top->left());
    }
    else top=Node::from_impl(top->right());
  }

  return y;
}

template<
  typename Node,typename KeyFromValue,
  typename CompatibleKey,typename CompatibleCompare
>
inline Node* ordered_index_upper_bound(
  Node* top,Node* y,const KeyFromValue& key,const CompatibleKey& x,
  const CompatibleCompare& comp)
{
  while(top){
    if(comp(x,key(top->value()))){
      y=top;
      top=Node::from_impl(top->left());
    }
    else top=Node::from_impl(top->right());
  }

  return y;
}

template<
  typename Node,typename KeyFromValue,
  typename CompatibleKey,typename CompatibleCompare
>
inline std::pair<Node*,Node*> ordered_index_equal_range(
  Node* top,Node* y,const KeyFromValue& key,const CompatibleKey& x,
  const CompatibleCompare& comp)
{
  while(top){
    if(comp(key(top->value()),x)){
      top=Node::from_impl(top->right());
    }
    else if(comp(x,key(top->value()))){
      y=top;
      top=Node::from_impl(top->left());
    }
    else{
      return std::pair<Node*,Node*>(
        ordered_index_lower_bound(Node::from_impl(top->left()),top,key,x,comp),
        ordered_index_upper_bound(Node::from_impl(top->right()),y,key,x,comp));
    }
  }

  return std::pair<Node*,Node*>(y,y);
}

}

}

}
# 57 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/unbounded.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/unbounded.hpp"
namespace boost{

namespace multi_index{
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/unbounded.hpp"
namespace detail{class unbounded_helper;}

detail::unbounded_helper unbounded(detail::unbounded_helper);

namespace detail{

class unbounded_helper
{
  unbounded_helper(){}
  unbounded_helper(const unbounded_helper&){}
  friend unbounded_helper multi_index::unbounded(unbounded_helper);
};

typedef unbounded_helper (*unbounded_type)(unbounded_helper);

}

inline detail::unbounded_helper unbounded(detail::unbounded_helper)
{
  return detail::unbounded_helper();
}




namespace detail{

struct none_unbounded_tag{};
struct lower_unbounded_tag{};
struct upper_unbounded_tag{};
struct both_unbounded_tag{};

}

}

}
# 61 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/value_compare.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/value_compare.hpp"
namespace boost{

namespace multi_index{

namespace detail{

template<typename Value,typename KeyFromValue,typename Compare>
struct value_comparison:std::binary_function<Value,Value,bool>
{
  value_comparison(
    const KeyFromValue& key_=KeyFromValue(),const Compare& comp_=Compare()):
    key(key_),comp(comp_)
  {
  }

  bool operator()(
    typename call_traits<Value>::param_type x,
    typename call_traits<Value>::param_type y)const
  {
    return comp(key(x),key(y));
  }

private:
  KeyFromValue key;
  Compare comp;
};

}

}

}
# 62 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 2
# 71 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/duplicates_iterator.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/duplicates_iterator.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/duplicates_iterator.hpp" 2


namespace boost{

namespace multi_index{

namespace detail{





template<typename Node,typename Predicate>
class duplicates_iterator
{
public:
  typedef typename Node::value_type value_type;
  typedef std::ptrdiff_t difference_type;
  typedef const typename Node::value_type* pointer;
  typedef const typename Node::value_type& reference;
  typedef std::forward_iterator_tag iterator_category;

  duplicates_iterator(Node* node_,Node* end_,Predicate pred_):
    node(node_),begin_chunk(0),end(end_),pred(pred_)
  {
    advance();
  }

  duplicates_iterator(Node* end_,Predicate pred_):
    node(end_),begin_chunk(end_),end(end_),pred(pred_)
  {
  }

  reference operator*()const
  {
    return node->value();
  }

  pointer operator->()const
  {
    return &node->value();
  }

  duplicates_iterator& operator++()
  {
    Node::increment(node);
    sync();
    return *this;
  }

  duplicates_iterator operator++(int)
  {
    duplicates_iterator tmp(*this);
    ++(*this);
    return tmp;
  }

  Node* get_node()const{return node;}

private:
  void sync()
  {
    if(node!=end&&pred(begin_chunk->value(),node->value()))advance();
  }

  void advance()
  {
    for(Node* node2=node;node!=end;node=node2){
      Node::increment(node2);
      if(node2!=end&&!pred(node->value(),node2->value()))break;
    }
    begin_chunk=node;
  }

  Node* node;
  Node* begin_chunk;
  Node* end;
  Predicate pred;
};

template<typename Node,typename Predicate>
bool operator==(
  const duplicates_iterator<Node,Predicate>& x,
  const duplicates_iterator<Node,Predicate>& y)
{
  return x.get_node()==y.get_node();
}

template<typename Node,typename Predicate>
bool operator!=(
  const duplicates_iterator<Node,Predicate>& x,
  const duplicates_iterator<Node,Predicate>& y)
{
  return !(x==y);
}

}

}

}
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp" 2
# 84 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
namespace boost{

namespace multi_index{

namespace detail{
# 97 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
struct ordered_unique_tag{};
struct ordered_non_unique_tag{};

template<
  typename KeyFromValue,typename Compare,
  typename SuperMeta,typename TagList,typename Category
>
class ordered_index:
  protected SuperMeta::type
# 119 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
{
# 130 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
  typedef typename SuperMeta::type super;

protected:
  typedef ordered_index_node<
    typename super::node_type> node_type;

private:
  typedef typename node_type::impl_type node_impl_type;
  typedef typename node_impl_type::pointer node_impl_pointer;

public:


  typedef typename KeyFromValue::result_type key_type;
  typedef typename node_type::value_type value_type;
  typedef KeyFromValue key_from_value;
  typedef Compare key_compare;
  typedef value_comparison<
    value_type,KeyFromValue,Compare> value_compare;
  typedef tuple<key_from_value,key_compare> ctor_args;
  typedef typename super::final_allocator_type allocator_type;
  typedef typename allocator_type::reference reference;
  typedef typename allocator_type::const_reference const_reference;
# 166 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
  typedef bidir_node_iterator<node_type> iterator;


  typedef iterator const_iterator;

  typedef std::size_t size_type;
  typedef std::ptrdiff_t difference_type;
  typedef typename allocator_type::pointer pointer;
  typedef typename allocator_type::const_pointer const_pointer;
  typedef typename
    boost::reverse_iterator<iterator> reverse_iterator;
  typedef typename
    boost::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef TagList tag_list;

protected:
  typedef typename super::final_node_type final_node_type;
  typedef tuples::cons<
    ctor_args,
    typename super::ctor_args_list> ctor_args_list;
  typedef typename mpl::push_front<
    typename super::index_type_list,
    ordered_index>::type index_type_list;
  typedef typename mpl::push_front<
    typename super::iterator_type_list,
    iterator>::type iterator_type_list;
  typedef typename mpl::push_front<
    typename super::const_iterator_type_list,
    const_iterator>::type const_iterator_type_list;
  typedef typename super::copy_map_type copy_map_type;


  typedef typename super::index_saver_type index_saver_type;
  typedef typename super::index_loader_type index_loader_type;


private:
# 213 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
  typedef typename call_traits<
    value_type>::param_type value_param_type;
  typedef typename call_traits<
    key_type>::param_type key_param_type;

public:






  ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& operator=(
    const ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x)
  {
    this->final()=x.final();
    return *this;
  }

  allocator_type get_allocator()const
  {
    return this->final().get_allocator();
  }



  iterator begin(){return make_iterator(leftmost());}
  const_iterator begin()const{return make_iterator(leftmost());}
  iterator end(){return make_iterator(header());}
  const_iterator end()const{return make_iterator(header());}
  reverse_iterator rbegin(){return make_reverse_iterator(end());}
  const_reverse_iterator rbegin()const{return make_reverse_iterator(end());}
  reverse_iterator rend(){return make_reverse_iterator(begin());}
  const_reverse_iterator rend()const{return make_reverse_iterator(begin());}
  const_iterator cbegin()const{return begin();}
  const_iterator cend()const{return end();}
  const_reverse_iterator crbegin()const{return rbegin();}
  const_reverse_iterator crend()const{return rend();}

  iterator iterator_to(const value_type& x)
  {
    return make_iterator(node_from_value<node_type>(&x));
  }

  const_iterator iterator_to(const value_type& x)const
  {
    return make_iterator(node_from_value<node_type>(&x));
  }



  bool empty()const{return this->final_empty_();}
  size_type size()const{return this->final_size_();}
  size_type max_size()const{return this->final_max_size_();}



  std::pair<iterator,bool> insert(value_param_type x)
  {
    ;
    std::pair<final_node_type*,bool> p=this->final_insert_(x);
    return std::pair<iterator,bool>(make_iterator(p.first),p.second);
  }

  iterator insert(iterator position,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ;
    std::pair<final_node_type*,bool> p=this->final_insert_(
      x,static_cast<final_node_type*>(position.get_node()));
    return make_iterator(p.first);
  }

  template<typename InputIterator>
  void insert(InputIterator first,InputIterator last)
  {
    ;
    iterator hint=end();
    for(;first!=last;++first)hint=insert(hint,*first);
  }

  iterator erase(iterator position)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    this->final_erase_(static_cast<final_node_type*>(position++.get_node()));
    return position;
  }

  size_type erase(key_param_type x)
  {
    ;
    std::pair<iterator,iterator> p=equal_range(x);
    size_type s=0;
    while(p.first!=p.second){
      p.first=erase(p.first);
      ++s;
    }
    return s;
  }

  iterator erase(iterator first,iterator last)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    while(first!=last){
      first=erase(first);
    }
    return first;
  }

  bool replace(iterator position,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return this->final_replace_(
      x,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier>
  bool modify(iterator position,Modifier mod)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
# 358 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
    return this->final_modify_(
      mod,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier,typename Rollback>
  bool modify(iterator position,Modifier mod,Rollback back)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
# 379 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
    return this->final_modify_(
      mod,back,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier>
  bool modify_key(iterator position,Modifier mod)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return modify(
      position,modify_key_adaptor<Modifier,value_type,KeyFromValue>(mod,key));
  }

  template<typename Modifier,typename Rollback>
  bool modify_key(iterator position,Modifier mod,Rollback back)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return modify(
      position,
      modify_key_adaptor<Modifier,value_type,KeyFromValue>(mod,key),
      modify_key_adaptor<Rollback,value_type,KeyFromValue>(back,key));
  }

  void swap(ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x)
  {
    ;
    this->final_swap_(x.final());
  }

  void clear()
  {
    ;
    this->final_clear_();
  }



  key_from_value key_extractor()const{return key;}
  key_compare key_comp()const{return comp;}
  value_compare value_comp()const{return value_compare(key,comp);}







  template<typename CompatibleKey>
  iterator find(const CompatibleKey& x)const
  {
    return make_iterator(ordered_index_find(root(),header(),key,x,comp));
  }

  template<typename CompatibleKey,typename CompatibleCompare>
  iterator find(
    const CompatibleKey& x,const CompatibleCompare& comp)const
  {
    return make_iterator(ordered_index_find(root(),header(),key,x,comp));
  }

  template<typename CompatibleKey>
  size_type count(const CompatibleKey& x)const
  {
    return count(x,comp);
  }

  template<typename CompatibleKey,typename CompatibleCompare>
  size_type count(const CompatibleKey& x,const CompatibleCompare& comp)const
  {
    std::pair<iterator,iterator> p=equal_range(x,comp);
    size_type n=std::distance(p.first,p.second);
    return n;
  }

  template<typename CompatibleKey>
  iterator lower_bound(const CompatibleKey& x)const
  {
    return make_iterator(
      ordered_index_lower_bound(root(),header(),key,x,comp));
  }

  template<typename CompatibleKey,typename CompatibleCompare>
  iterator lower_bound(
    const CompatibleKey& x,const CompatibleCompare& comp)const
  {
    return make_iterator(
      ordered_index_lower_bound(root(),header(),key,x,comp));
  }

  template<typename CompatibleKey>
  iterator upper_bound(const CompatibleKey& x)const
  {
    return make_iterator(
      ordered_index_upper_bound(root(),header(),key,x,comp));
  }

  template<typename CompatibleKey,typename CompatibleCompare>
  iterator upper_bound(
    const CompatibleKey& x,const CompatibleCompare& comp)const
  {
    return make_iterator(
      ordered_index_upper_bound(root(),header(),key,x,comp));
  }

  template<typename CompatibleKey>
  std::pair<iterator,iterator> equal_range(
    const CompatibleKey& x)const
  {
    std::pair<node_type*,node_type*> p=
      ordered_index_equal_range(root(),header(),key,x,comp);
    return std::pair<iterator,iterator>(
      make_iterator(p.first),make_iterator(p.second));
  }

  template<typename CompatibleKey,typename CompatibleCompare>
  std::pair<iterator,iterator> equal_range(
    const CompatibleKey& x,const CompatibleCompare& comp)const
  {
    std::pair<node_type*,node_type*> p=
      ordered_index_equal_range(root(),header(),key,x,comp);
    return std::pair<iterator,iterator>(
      make_iterator(p.first),make_iterator(p.second));
  }



  template<typename LowerBounder,typename UpperBounder>
  std::pair<iterator,iterator>
  range(LowerBounder lower,UpperBounder upper)const
  {
    typedef typename mpl::if_<
      is_same<LowerBounder,unbounded_type>,
      typename mpl::if_<
        is_same<UpperBounder,unbounded_type>,
        both_unbounded_tag,
        lower_unbounded_tag
      >::type,
      typename mpl::if_<
        is_same<UpperBounder,unbounded_type>,
        upper_unbounded_tag,
        none_unbounded_tag
      >::type
    >::type dispatch;

    return range(lower,upper,dispatch());
  }

protected:
  ordered_index(const ctor_args_list& args_list,const allocator_type& al):
    super(args_list.get_tail(),al),
    key(tuples::get<0>(args_list.get_head())),
    comp(tuples::get<1>(args_list.get_head()))
  {
    empty_initialize();
  }

  ordered_index(
    const ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x):
    super(x),





    key(x.key),
    comp(x.comp)
  {



  }

  ~ordered_index()
  {

  }






  iterator make_iterator(node_type* node){return iterator(node);}
  const_iterator make_iterator(node_type* node)const
                   {return const_iterator(node);}


  void copy_(
    const ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x,
    const copy_map_type& map)
  {
    if(!x.root()){
      empty_initialize();
    }
    else{
      header()->color()=x.header()->color();

      node_type* root_cpy=map.find(static_cast<final_node_type*>(x.root()));
      header()->parent()=root_cpy->impl();

      node_type* leftmost_cpy=map.find(
        static_cast<final_node_type*>(x.leftmost()));
      header()->left()=leftmost_cpy->impl();

      node_type* rightmost_cpy=map.find(
        static_cast<final_node_type*>(x.rightmost()));
      header()->right()=rightmost_cpy->impl();

      typedef typename copy_map_type::const_iterator copy_map_iterator;
      for(copy_map_iterator it=map.begin(),it_end=map.end();it!=it_end;++it){
        node_type* org=it->first;
        node_type* cpy=it->second;

        cpy->color()=org->color();

        node_impl_pointer parent_org=org->parent();
        if(parent_org==node_impl_pointer(0))cpy->parent()=node_impl_pointer(0);
        else{
          node_type* parent_cpy=map.find(
            static_cast<final_node_type*>(node_type::from_impl(parent_org)));
          cpy->parent()=parent_cpy->impl();
          if(parent_org->left()==org->impl()){
            parent_cpy->left()=cpy->impl();
          }
          else if(parent_org->right()==org->impl()){

            parent_cpy->right()=cpy->impl();
          }
        }

        if(org->left()==node_impl_pointer(0))
          cpy->left()=node_impl_pointer(0);
        if(org->right()==node_impl_pointer(0))
          cpy->right()=node_impl_pointer(0);
      }
    }

    super::copy_(x,map);
  }

  node_type* insert_(value_param_type v,node_type* x)
  {
    link_info inf;
    if(!link_point(key(v),inf,Category())){
      return node_type::from_impl(inf.pos);
    }

    node_type* res=static_cast<node_type*>(super::insert_(v,x));
    if(res==x){
      node_impl_type::link(x->impl(),inf.side,inf.pos,header()->impl());
    }
    return res;
  }

  node_type* insert_(value_param_type v,node_type* position,node_type* x)
  {
    link_info inf;
    if(!hinted_link_point(key(v),position,inf,Category())){
      return node_type::from_impl(inf.pos);
    }

    node_type* res=static_cast<node_type*>(super::insert_(v,position,x));
    if(res==x){
      node_impl_type::link(x->impl(),inf.side,inf.pos,header()->impl());
    }
    return res;
  }

  void erase_(node_type* x)
  {
    node_impl_type::rebalance_for_erase(
      x->impl(),header()->parent(),header()->left(),header()->right());
    super::erase_(x);




  }

  void delete_all_nodes_()
  {
    delete_all_nodes(root());
  }

  void clear_()
  {
    super::clear_();
    empty_initialize();




  }

  void swap_(ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x)
  {
    std::swap(key,x.key);
    std::swap(comp,x.comp);





    super::swap_(x);
  }

  bool replace_(value_param_type v,node_type* x)
  {
    if(in_place(v,x,Category())){
      return super::replace_(v,x);
    }

    node_type* next=x;
    node_type::increment(next);

    node_impl_type::rebalance_for_erase(
      x->impl(),header()->parent(),header()->left(),header()->right());

    { try{
      link_info inf;
      if(link_point(key(v),inf,Category())&&super::replace_(v,x)){
        node_impl_type::link(x->impl(),inf.side,inf.pos,header()->impl());
        return true;
      }
      node_impl_type::restore(x->impl(),next->impl(),header()->impl());
      return false;
    }
    catch(...){
      node_impl_type::restore(x->impl(),next->impl(),header()->impl());
      throw;;
    }
    }
  }

  bool modify_(node_type* x)
  {
    bool b;
    { try{
      b=in_place(x->value(),x,Category());
    }
    catch(...){
      erase_(x);
      throw;;
    }
    }
    if(!b){
      node_impl_type::rebalance_for_erase(
        x->impl(),header()->parent(),header()->left(),header()->right());
      { try{
        link_info inf;
        if(!link_point(key(x->value()),inf,Category())){
          super::erase_(x);




          return false;
        }
        node_impl_type::link(x->impl(),inf.side,inf.pos,header()->impl());
      }
      catch(...){
        super::erase_(x);





        throw;;
      }
      }
    }

    { try{
      if(!super::modify_(x)){
        node_impl_type::rebalance_for_erase(
          x->impl(),header()->parent(),header()->left(),header()->right());





        return false;
      }
      else return true;
    }
    catch(...){
      node_impl_type::rebalance_for_erase(
        x->impl(),header()->parent(),header()->left(),header()->right());





      throw;;
    }
    }
  }

  bool modify_rollback_(node_type* x)
  {
    if(in_place(x->value(),x,Category())){
      return super::modify_rollback_(x);
    }

    node_type* next=x;
    node_type::increment(next);

    node_impl_type::rebalance_for_erase(
      x->impl(),header()->parent(),header()->left(),header()->right());

    { try{
      link_info inf;
      if(link_point(key(x->value()),inf,Category())&&
         super::modify_rollback_(x)){
        node_impl_type::link(x->impl(),inf.side,inf.pos,header()->impl());
        return true;
      }
      node_impl_type::restore(x->impl(),next->impl(),header()->impl());
      return false;
    }
    catch(...){
      node_impl_type::restore(x->impl(),next->impl(),header()->impl());
      throw;;
    }
    }
  }




  template<typename Archive>
  void save_(
    Archive& ar,const unsigned int version,const index_saver_type& sm)const
  {
    save_(ar,version,sm,Category());
  }

  template<typename Archive>
  void load_(Archive& ar,const unsigned int version,const index_loader_type& lm)
  {
    load_(ar,version,lm,Category());
  }
# 877 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
private:
  node_type* header()const{return this->final_header();}
  node_type* root()const{return node_type::from_impl(header()->parent());}
  node_type* leftmost()const{return node_type::from_impl(header()->left());}
  node_type* rightmost()const{return node_type::from_impl(header()->right());}

  void empty_initialize()
  {
    header()->color()=red;


    header()->parent()=node_impl_pointer(0);
    header()->left()=header()->impl();
    header()->right()=header()->impl();
  }

  struct link_info
  {
    link_info():side(to_left){}

    ordered_index_side side;
    node_impl_pointer pos;
  };

  bool link_point(key_param_type k,link_info& inf,ordered_unique_tag)
  {
    node_type* y=header();
    node_type* x=root();
    bool c=true;
    while(x){
      y=x;
      c=comp(k,key(x->value()));
      x=node_type::from_impl(c?x->left():x->right());
    }
    node_type* yy=y;
    if(c){
      if(yy==leftmost()){
        inf.side=to_left;
        inf.pos=y->impl();
        return true;
      }
      else node_type::decrement(yy);
    }

    if(comp(key(yy->value()),k)){
      inf.side=c?to_left:to_right;
      inf.pos=y->impl();
      return true;
    }
    else{
      inf.pos=yy->impl();
      return false;
    }
  }

  bool link_point(key_param_type k,link_info& inf,ordered_non_unique_tag)
  {
    node_type* y=header();
    node_type* x=root();
    bool c=true;
    while (x){
     y=x;
     c=comp(k,key(x->value()));
     x=node_type::from_impl(c?x->left():x->right());
    }
    inf.side=c?to_left:to_right;
    inf.pos=y->impl();
    return true;
  }

  bool lower_link_point(key_param_type k,link_info& inf,ordered_non_unique_tag)
  {
    node_type* y=header();
    node_type* x=root();
    bool c=false;
    while (x){
     y=x;
     c=comp(key(x->value()),k);
     x=node_type::from_impl(c?x->right():x->left());
    }
    inf.side=c?to_right:to_left;
    inf.pos=y->impl();
    return true;
  }

  bool hinted_link_point(
    key_param_type k,node_type* position,link_info& inf,ordered_unique_tag)
  {
    if(position->impl()==header()->left()){
      if(size()>0&&comp(k,key(position->value()))){
        inf.side=to_left;
        inf.pos=position->impl();
        return true;
      }
      else return link_point(k,inf,ordered_unique_tag());
    }
    else if(position==header()){
      if(comp(key(rightmost()->value()),k)){
        inf.side=to_right;
        inf.pos=rightmost()->impl();
        return true;
      }
      else return link_point(k,inf,ordered_unique_tag());
    }
    else{
      node_type* before=position;
      node_type::decrement(before);
      if(comp(key(before->value()),k)&&comp(k,key(position->value()))){
        if(before->right()==node_impl_pointer(0)){
          inf.side=to_right;
          inf.pos=before->impl();
          return true;
        }
        else{
          inf.side=to_left;
          inf.pos=position->impl();
          return true;
        }
      }
      else return link_point(k,inf,ordered_unique_tag());
    }
  }

  bool hinted_link_point(
    key_param_type k,node_type* position,link_info& inf,ordered_non_unique_tag)
  {
    if(position->impl()==header()->left()){
      if(size()>0&&!comp(key(position->value()),k)){
        inf.side=to_left;
        inf.pos=position->impl();
        return true;
      }
      else return lower_link_point(k,inf,ordered_non_unique_tag());
    }
    else if(position==header()){
      if(!comp(k,key(rightmost()->value()))){
        inf.side=to_right;
        inf.pos=rightmost()->impl();
        return true;
      }
      else return link_point(k,inf,ordered_non_unique_tag());
    }
    else{
      node_type* before=position;
      node_type::decrement(before);
      if(!comp(k,key(before->value()))){
        if(!comp(key(position->value()),k)){
          if(before->right()==node_impl_pointer(0)){
            inf.side=to_right;
            inf.pos=before->impl();
            return true;
          }
          else{
            inf.side=to_left;
            inf.pos=position->impl();
            return true;
          }
        }
        else return lower_link_point(k,inf,ordered_non_unique_tag());
      }
      else return link_point(k,inf,ordered_non_unique_tag());
    }
  }

  void delete_all_nodes(node_type* x)
  {
    if(!x)return;

    delete_all_nodes(node_type::from_impl(x->left()));
    delete_all_nodes(node_type::from_impl(x->right()));
    this->final_delete_node_(static_cast<final_node_type*>(x));
  }

  bool in_place(value_param_type v,node_type* x,ordered_unique_tag)
  {
    node_type* y;
    if(x!=leftmost()){
      y=x;
      node_type::decrement(y);
      if(!comp(key(y->value()),key(v)))return false;
    }

    y=x;
    node_type::increment(y);
    return y==header()||comp(key(v),key(y->value()));
  }

  bool in_place(value_param_type v,node_type* x,ordered_non_unique_tag)
  {
    node_type* y;
    if(x!=leftmost()){
      y=x;
      node_type::decrement(y);
      if(comp(key(v),key(y->value())))return false;
    }

    y=x;
    node_type::increment(y);
    return y==header()||!comp(key(y->value()),key(v));
  }
# 1086 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/ordered_index.hpp"
  template<typename LowerBounder,typename UpperBounder>
  std::pair<iterator,iterator>
  range(LowerBounder lower,UpperBounder upper,none_unbounded_tag)const
  {
    node_type* y=header();
    node_type* z=root();

    while(z){
      if(!lower(key(z->value()))){
        z=node_type::from_impl(z->right());
      }
      else if(!upper(key(z->value()))){
        y=z;
        z=node_type::from_impl(z->left());
      }
      else{
        return std::pair<iterator,iterator>(
          make_iterator(
            lower_range(node_type::from_impl(z->left()),z,lower)),
          make_iterator(
            upper_range(node_type::from_impl(z->right()),y,upper)));
      }
    }

    return std::pair<iterator,iterator>(make_iterator(y),make_iterator(y));
  }

  template<typename LowerBounder,typename UpperBounder>
  std::pair<iterator,iterator>
  range(LowerBounder,UpperBounder upper,lower_unbounded_tag)const
  {
    return std::pair<iterator,iterator>(
      begin(),
      make_iterator(upper_range(root(),header(),upper)));
  }

  template<typename LowerBounder,typename UpperBounder>
  std::pair<iterator,iterator>
  range(LowerBounder lower,UpperBounder,upper_unbounded_tag)const
  {
    return std::pair<iterator,iterator>(
      make_iterator(lower_range(root(),header(),lower)),
      end());
  }

  template<typename LowerBounder,typename UpperBounder>
  std::pair<iterator,iterator>
  range(LowerBounder,UpperBounder,both_unbounded_tag)const
  {
    return std::pair<iterator,iterator>(begin(),end());
  }

  template<typename LowerBounder>
  node_type * lower_range(node_type* top,node_type* y,LowerBounder lower)const
  {
    while(top){
      if(lower(key(top->value()))){
        y=top;
        top=node_type::from_impl(top->left());
      }
      else top=node_type::from_impl(top->right());
    }

    return y;
  }

  template<typename UpperBounder>
  node_type * upper_range(node_type* top,node_type* y,UpperBounder upper)const
  {
    while(top){
      if(!upper(key(top->value()))){
        y=top;
        top=node_type::from_impl(top->left());
      }
      else top=node_type::from_impl(top->right());
    }

    return y;
  }


  template<typename Archive>
  void save_(
    Archive& ar,const unsigned int version,const index_saver_type& sm,
    ordered_unique_tag)const
  {
    super::save_(ar,version,sm);
  }

  template<typename Archive>
  void load_(
    Archive& ar,const unsigned int version,const index_loader_type& lm,
    ordered_unique_tag)
  {
    super::load_(ar,version,lm);
  }

  template<typename Archive>
  void save_(
    Archive& ar,const unsigned int version,const index_saver_type& sm,
    ordered_non_unique_tag)const
  {
    typedef duplicates_iterator<node_type,value_compare> dup_iterator;

    sm.save(
      dup_iterator(begin().get_node(),end().get_node(),value_comp()),
      dup_iterator(end().get_node(),value_comp()),
      ar,version);
    super::save_(ar,version,sm);
  }

  template<typename Archive>
  void load_(
    Archive& ar,const unsigned int version,const index_loader_type& lm,
    ordered_non_unique_tag)
  {
    lm.load(
      ::boost::bind(&ordered_index::rearranger,this,_1,_2),
      ar,version);
    super::load_(ar,version,lm);
  }

  void rearranger(node_type* position,node_type *x)
  {
    if(!position||comp(key(position->value()),key(x->value()))){
      position=lower_bound(key(x->value())).get_node();
    }
    else if(comp(key(x->value()),key(position->value()))){

      throw_exception(
        archive::archive_exception(
          archive::archive_exception::other_exception));
    }
    else node_type::increment(position);

    if(position!=x){
      node_impl_type::rebalance_for_erase(
        x->impl(),header()->parent(),header()->left(),header()->right());
      node_impl_type::restore(
        x->impl(),position->impl(),header()->impl());
    }
  }


  key_from_value key;
  key_compare comp;





};



template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator==(
  const ordered_index<KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y)
{
  return x.size()==y.size()&&std::equal(x.begin(),x.end(),y.begin());
}

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator<(
  const ordered_index<KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y)
{
  return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
}

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator!=(
  const ordered_index<KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y)
{
  return !(x==y);
}

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator>(
  const ordered_index<KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y)
{
  return y<x;
}

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator>=(
  const ordered_index<KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y)
{
  return !(x<y);
}

template<
  typename KeyFromValue1,typename Compare1,
  typename SuperMeta1,typename TagList1,typename Category1,
  typename KeyFromValue2,typename Compare2,
  typename SuperMeta2,typename TagList2,typename Category2
>
bool operator<=(
  const ordered_index<KeyFromValue1,Compare1,SuperMeta1,TagList1,Category1>& x,
  const ordered_index<KeyFromValue2,Compare2,SuperMeta2,TagList2,Category2>& y)
{
  return !(x>y);
}



template<
  typename KeyFromValue,typename Compare,
  typename SuperMeta,typename TagList,typename Category
>
void swap(
  ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& x,
  ordered_index<KeyFromValue,Compare,SuperMeta,TagList,Category>& y)
{
  x.swap(y);
}

}



template<typename Arg1,typename Arg2,typename Arg3>
struct ordered_unique
{
  typedef typename detail::ordered_index_args<
    Arg1,Arg2,Arg3> index_args;
  typedef typename index_args::tag_list_type::type tag_list_type;
  typedef typename index_args::key_from_value_type key_from_value_type;
  typedef typename index_args::compare_type compare_type;

  template<typename Super>
  struct node_class
  {
    typedef detail::ordered_index_node<Super> type;
  };

  template<typename SuperMeta>
  struct index_class
  {
    typedef detail::ordered_index<
      key_from_value_type,compare_type,
      SuperMeta,tag_list_type,detail::ordered_unique_tag> type;
  };
};

template<typename Arg1,typename Arg2,typename Arg3>
struct ordered_non_unique
{
  typedef detail::ordered_index_args<
    Arg1,Arg2,Arg3> index_args;
  typedef typename index_args::tag_list_type::type tag_list_type;
  typedef typename index_args::key_from_value_type key_from_value_type;
  typedef typename index_args::compare_type compare_type;

  template<typename Super>
  struct node_class
  {
    typedef detail::ordered_index_node<Super> type;
  };

  template<typename SuperMeta>
  struct index_class
  {
    typedef detail::ordered_index<
      key_from_value_type,compare_type,
      SuperMeta,tag_list_type,detail::ordered_non_unique_tag> type;
  };
};

}

}
# 32 "./PropertyList.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/seq_index_node.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/seq_index_node.hpp"
namespace boost{

namespace multi_index{

namespace detail{



template<typename Allocator>
struct sequenced_index_node_impl
{
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,sequenced_index_node_impl
    >::type
  >::type::pointer pointer;
  typedef typename prevent_eti<
    Allocator,
    typename boost::detail::allocator::rebind_to<
      Allocator,sequenced_index_node_impl
    >::type
  >::type::const_pointer const_pointer;

  pointer& prior(){return prior_;}
  pointer prior()const{return prior_;}
  pointer& next(){return next_;}
  pointer next()const{return next_;}



  static void increment(pointer& x){x=x->next();}
  static void decrement(pointer& x){x=x->prior();}



  static void link(pointer x,pointer header)
  {
    x->prior()=header->prior();
    x->next()=header;
    x->prior()->next()=x->next()->prior()=x;
  };

  static void unlink(pointer x)
  {
    x->prior()->next()=x->next();
    x->next()->prior()=x->prior();
  }

  static void relink(pointer position,pointer x)
  {
    unlink(x);
    x->prior()=position->prior();
    x->next()=position;
    x->prior()->next()=x->next()->prior()=x;
  }

  static void relink(pointer position,pointer x,pointer y)
  {


    if(x!=y){
      pointer z=y->prior();
      x->prior()->next()=y;
      y->prior()=x->prior();
      x->prior()=position->prior();
      z->next()=position;
      x->prior()->next()=x;
      z->next()->prior()=z;
    }
  }

  static void reverse(pointer header)
  {
    pointer x=header;
    do{
      pointer y=x->next();
      std::swap(x->prior(),x->next());
      x=y;
    }while(x!=header);
  }

  static void swap(pointer x,pointer y)
  {





    if(x->next()!=x){
      if(y->next()!=y){
        std::swap(x->next(),y->next());
        std::swap(x->prior(),y->prior());
        x->next()->prior()=x->prior()->next()=x;
        y->next()->prior()=y->prior()->next()=y;
      }
      else{
        y->next()=x->next();
        y->prior()=x->prior();
        x->next()=x->prior()=x;
        y->next()->prior()=y->prior()->next()=y;
      }
    }
    else if(y->next()!=y){
      x->next()=y->next();
      x->prior()=y->prior();
      y->next()=y->prior()=y;
      x->next()->prior()=x->prior()->next()=x;
    }
  }

private:
  pointer prior_;
  pointer next_;
};

template<typename Super>
struct sequenced_index_node_trampoline:
  prevent_eti<
    Super,
    sequenced_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        typename Super::allocator_type,
        char
      >::type
    >
  >::type
{
  typedef typename prevent_eti<
    Super,
    sequenced_index_node_impl<
      typename boost::detail::allocator::rebind_to<
        typename Super::allocator_type,
        char
      >::type
    >
  >::type impl_type;
};

template<typename Super>
struct sequenced_index_node:Super,sequenced_index_node_trampoline<Super>
{
private:
  typedef sequenced_index_node_trampoline<Super> trampoline;

public:
  typedef typename trampoline::impl_type impl_type;
  typedef typename trampoline::pointer impl_pointer;
  typedef typename trampoline::const_pointer const_impl_pointer;

  impl_pointer& prior(){return trampoline::prior();}
  impl_pointer prior()const{return trampoline::prior();}
  impl_pointer& next(){return trampoline::next();}
  impl_pointer next()const{return trampoline::next();}

  impl_pointer impl()
  {
    return static_cast<impl_pointer>(
      static_cast<impl_type*>(static_cast<trampoline*>(this)));
  }

  const_impl_pointer impl()const
  {
    return static_cast<const_impl_pointer>(
      static_cast<const impl_type*>(static_cast<const trampoline*>(this)));
  }

  static sequenced_index_node* from_impl(impl_pointer x)
  {
    return static_cast<sequenced_index_node*>(
      static_cast<trampoline*>(&*x));
  }

  static const sequenced_index_node* from_impl(const_impl_pointer x)
  {
    return static_cast<const sequenced_index_node*>(
      static_cast<const trampoline*>(&*x));
  }



  static void increment(sequenced_index_node*& x)
  {
    impl_pointer xi=x->impl();
    trampoline::increment(xi);
    x=from_impl(xi);
  }

  static void decrement(sequenced_index_node*& x)
  {
    impl_pointer xi=x->impl();
    trampoline::decrement(xi);
    x=from_impl(xi);
  }
};

}

}

}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/seq_index_ops.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/seq_index_ops.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/seq_index_ops.hpp" 2

namespace boost{

namespace multi_index{

namespace detail{





template <typename SequencedIndex,typename Predicate>
void sequenced_index_remove(SequencedIndex& x,Predicate pred)
{
  typedef typename SequencedIndex::iterator iterator;
  iterator first=x.begin(),last=x.end();
  while(first!=last){
    if(pred(*first))x.erase(first++);
    else ++first;
  }
}

template <typename SequencedIndex,class BinaryPredicate>
void sequenced_index_unique(SequencedIndex& x,BinaryPredicate binary_pred)
{
  typedef typename SequencedIndex::iterator iterator;
  iterator first=x.begin();
  iterator last=x.end();
  if(first!=last){
    for(iterator middle=first;++middle!=last;middle=first){
      if(binary_pred(*middle,*first))x.erase(middle);
      else first=middle;
    }
  }
}

template <typename SequencedIndex,typename Compare>
void sequenced_index_merge(SequencedIndex& x,SequencedIndex& y,Compare comp)
{
  typedef typename SequencedIndex::iterator iterator;
  if(&x!=&y){
    iterator first0=x.begin(),last0=x.end();
    iterator first1=y.begin(),last1=y.end();
    while(first0!=last0&&first1!=last1){
      if(comp(*first1,*first0))x.splice(first0,y,first1++);
      else ++first0;
    }
    x.splice(last0,y,first1,last1);
  }
}





template<typename Node,typename Compare>
void sequenced_index_collate(
  typename Node::impl_type* x,
  typename Node::impl_type* y,
  Compare comp
  )
{
  typedef typename Node::impl_type impl_type;
  typedef typename Node::impl_pointer impl_pointer;

  impl_pointer first0=x->next();
  impl_pointer last0=x;
  impl_pointer first1=y->next();
  impl_pointer last1=y;
  while(first0!=last0&&first1!=last1){
    if(comp(
        Node::from_impl(first1)->value(),Node::from_impl(first0)->value())){
      impl_pointer tmp=first1->next();
      impl_type::relink(first0,first1);
      first1=tmp;
    }
    else first0=first0->next();
  }
  impl_type::relink(last0,first1,last1);
}






static const std::size_t sequenced_index_sort_max_fill= (std::size_t)std::numeric_limits<std::size_t>::digits+1


                                                            ;

template<typename Node,typename Compare>
void sequenced_index_sort(Node* header,Compare comp)
{
# 127 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/detail/seq_index_ops.hpp"
  if(header->next()==header->impl()||
     header->next()->next()==header->impl())return;

  typedef typename Node::impl_type impl_type;
  typedef typename Node::impl_pointer impl_pointer;

  typedef typename aligned_storage<
    sizeof(impl_type),
    alignment_of<impl_type>::value
  >::type carry_spc_type;
  carry_spc_type carry_spc;
  impl_type& carry=
    *static_cast<impl_type*>(static_cast<void*>(&carry_spc));
  typedef typename aligned_storage<
    sizeof(
      impl_type
        [sequenced_index_sort_max_fill]),
    alignment_of<
      impl_type
        [sequenced_index_sort_max_fill]
    >::value
  >::type counter_spc_type;
  counter_spc_type counter_spc;
  impl_type* counter=
    static_cast<impl_type*>(static_cast<void*>(&counter_spc));
  std::size_t fill=0;

  carry.prior()=carry.next()=static_cast<impl_pointer>(&carry);
  counter[0].prior()=counter[0].next()=static_cast<impl_pointer>(&counter[0]);

  { try{
    while(header->next()!=header->impl()){
      impl_type::relink(carry.next(),header->next());
      std::size_t i=0;
      while(i<fill&&counter[i].next()!=static_cast<impl_pointer>(&counter[i])){
        sequenced_index_collate<Node>(&carry,&counter[i++],comp);
      }
      impl_type::swap(
        static_cast<impl_pointer>(&carry),
        static_cast<impl_pointer>(&counter[i]));
      if(i==fill){
        ++fill;
        counter[fill].prior()=counter[fill].next()=
          static_cast<impl_pointer>(&counter[fill]);
      }
    }

    for(std::size_t i=1;i<fill;++i){
      sequenced_index_collate<Node>(&counter[i],&counter[i-1],comp);
    }
    impl_type::swap(
      header->impl(),static_cast<impl_pointer>(&counter[fill-1]));
  }
  catch(...)
  {
    impl_type::relink(
      header->impl(),carry.next(),static_cast<impl_pointer>(&carry));
    for(std::size_t i=0;i<=fill;++i){
      impl_type::relink(
        header->impl(),counter[i].next(),
        static_cast<impl_pointer>(&counter[i]));
    }
    throw;;
  }
  }
}

}

}

}
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index_fwd.hpp"
namespace boost{

namespace multi_index{

namespace detail{

template<typename SuperMeta,typename TagList>
class sequenced_index;

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator==(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y);

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator<(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y);

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator!=(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y);

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator>(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y);

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator>=(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y);

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator<=(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y);

template<typename SuperMeta,typename TagList>
void swap(
  sequenced_index<SuperMeta,TagList>& x,
  sequenced_index<SuperMeta,TagList>& y);

}



template <typename TagList=tag<> >
struct sequenced;

}

}
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp" 2
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
namespace boost{

namespace multi_index{

namespace detail{



template<typename SuperMeta,typename TagList>
class sequenced_index:
  protected SuperMeta::type
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
{
# 88 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
  typedef typename SuperMeta::type super;

protected:
  typedef sequenced_index_node<
    typename super::node_type> node_type;

private:
  typedef typename node_type::impl_type node_impl_type;

public:


  typedef typename node_type::value_type value_type;
  typedef tuples::null_type ctor_args;
  typedef typename super::final_allocator_type allocator_type;
  typedef typename allocator_type::reference reference;
  typedef typename allocator_type::const_reference const_reference;
# 118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
  typedef bidir_node_iterator<node_type> iterator;


  typedef iterator const_iterator;

  typedef std::size_t size_type;
  typedef std::ptrdiff_t difference_type;
  typedef typename allocator_type::pointer pointer;
  typedef typename allocator_type::const_pointer const_pointer;
  typedef typename
    boost::reverse_iterator<iterator> reverse_iterator;
  typedef typename
    boost::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef TagList tag_list;

protected:
  typedef typename super::final_node_type final_node_type;
  typedef tuples::cons<
    ctor_args,
    typename super::ctor_args_list> ctor_args_list;
  typedef typename mpl::push_front<
    typename super::index_type_list,
    sequenced_index>::type index_type_list;
  typedef typename mpl::push_front<
    typename super::iterator_type_list,
    iterator>::type iterator_type_list;
  typedef typename mpl::push_front<
    typename super::const_iterator_type_list,
    const_iterator>::type const_iterator_type_list;
  typedef typename super::copy_map_type copy_map_type;


  typedef typename super::index_saver_type index_saver_type;
  typedef typename super::index_loader_type index_loader_type;


private:
# 166 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
  typedef typename call_traits<value_type>::param_type value_param_type;

public:






  sequenced_index<SuperMeta,TagList>& operator=(
    const sequenced_index<SuperMeta,TagList>& x)
  {
    this->final()=x.final();
    return *this;
  }

  template <class InputIterator>
  void assign(InputIterator first,InputIterator last)
  {
    assign_iter(first,last,mpl::not_<is_integral<InputIterator> >());
  }

  void assign(size_type n,value_param_type value)
  {
    ;
    clear();
    for(size_type i=0;i<n;++i)push_back(value);
  }

  allocator_type get_allocator()const
  {
    return this->final().get_allocator();
  }



  iterator begin()
    {return make_iterator(node_type::from_impl(header()->next()));}
  const_iterator begin()const
    {return make_iterator(node_type::from_impl(header()->next()));}
  iterator end(){return make_iterator(header());}
  const_iterator end()const{return make_iterator(header());}
  reverse_iterator rbegin(){return make_reverse_iterator(end());}
  const_reverse_iterator rbegin()const{return make_reverse_iterator(end());}
  reverse_iterator rend(){return make_reverse_iterator(begin());}
  const_reverse_iterator rend()const{return make_reverse_iterator(begin());}
  const_iterator cbegin()const{return begin();}
  const_iterator cend()const{return end();}
  const_reverse_iterator crbegin()const{return rbegin();}
  const_reverse_iterator crend()const{return rend();}

  iterator iterator_to(const value_type& x)
  {
    return make_iterator(node_from_value<node_type>(&x));
  }

  const_iterator iterator_to(const value_type& x)const
  {
    return make_iterator(node_from_value<node_type>(&x));
  }



  bool empty()const{return this->final_empty_();}
  size_type size()const{return this->final_size_();}
  size_type max_size()const{return this->final_max_size_();}

  void resize(size_type n,value_param_type x=value_type())
  {
    ;
    if(n>size())insert(end(),n-size(),x);
    else if(n<size()){
      iterator it;
      if(n<=size()/2){
        it=begin();
        std::advance(it,n);
      }
      else{
        it=end();
        for(size_type m=size()-n;m--;--it){}
      }
      erase(it,end());
    }
  }





  const_reference front()const{return *begin();}
  const_reference back()const{return *--end();}



  std::pair<iterator,bool> push_front(value_param_type x)
                             {return insert(begin(),x);}
  void pop_front(){erase(begin());}
  std::pair<iterator,bool> push_back(value_param_type x)
                             {return insert(end(),x);}
  void pop_back(){erase(--end());}

  std::pair<iterator,bool> insert(iterator position,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ;
    std::pair<final_node_type*,bool> p=this->final_insert_(x);
    if(p.second&&position.get_node()!=header()){
      relink(position.get_node(),p.first);
    }
    return std::pair<iterator,bool>(make_iterator(p.first),p.second);
  }

  void insert(iterator position,size_type n,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ;
    for(size_type i=0;i<n;++i)insert(position,x);
  }

  template<typename InputIterator>
  void insert(iterator position,InputIterator first,InputIterator last)
  {
    insert_iter(position,first,last,mpl::not_<is_integral<InputIterator> >());
  }

  iterator erase(iterator position)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    this->final_erase_(static_cast<final_node_type*>(position++.get_node()));
    return position;
  }

  iterator erase(iterator first,iterator last)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    while(first!=last){
      first=erase(first);
    }
    return first;
  }

  bool replace(iterator position,value_param_type x)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    return this->final_replace_(
      x,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier>
  bool modify(iterator position,Modifier mod)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
# 344 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
    return this->final_modify_(
      mod,static_cast<final_node_type*>(position.get_node()));
  }

  template<typename Modifier,typename Rollback>
  bool modify(iterator position,Modifier mod,Rollback back)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
# 365 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
    return this->final_modify_(
      mod,back,static_cast<final_node_type*>(position.get_node()));
  }

  void swap(sequenced_index<SuperMeta,TagList>& x)
  {
    ;
    this->final_swap_(x.final());
  }

  void clear()
  {
    ;
    this->final_clear_();
  }



  void splice(iterator position,sequenced_index<SuperMeta,TagList>& x)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    iterator first=x.begin(),last=x.end();
    while(first!=last){
      if(insert(position,*first).second)first=x.erase(first);
      else ++first;
    }
  }

  void splice(iterator position,sequenced_index<SuperMeta,TagList>& x,iterator i)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    if(&x==this){
      if(position!=i)relink(position.get_node(),i.get_node());
    }
    else{
      if(insert(position,*i).second){
# 418 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
        x.erase(i);


      }
    }
  }

  void splice(
    iterator position,sequenced_index<SuperMeta,TagList>& x,
    iterator first,iterator last)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    if(&x==this){
      ((void)0);;
      if(position!=last)relink(
        position.get_node(),first.get_node(),last.get_node());
    }
    else{
      while(first!=last){
        if(insert(position,*first).second)first=x.erase(first);
        else ++first;
      }
    }
  }

  void remove(value_param_type value)
  {
    sequenced_index_remove(
      *this,std::bind2nd(std::equal_to<value_type>(),value));
  }

  template<typename Predicate>
  void remove_if(Predicate pred)
  {
    sequenced_index_remove(*this,pred);
  }

  void unique()
  {
    sequenced_index_unique(*this,std::equal_to<value_type>());
  }

  template <class BinaryPredicate>
  void unique(BinaryPredicate binary_pred)
  {
    sequenced_index_unique(*this,binary_pred);
  }

  void merge(sequenced_index<SuperMeta,TagList>& x)
  {
    sequenced_index_merge(*this,x,std::less<value_type>());
  }

  template <typename Compare>
  void merge(sequenced_index<SuperMeta,TagList>& x,Compare comp)
  {
    sequenced_index_merge(*this,x,comp);
  }

  void sort()
  {
    ;
    sequenced_index_sort(header(),std::less<value_type>());
  }

  template <typename Compare>
  void sort(Compare comp)
  {
    ;
    sequenced_index_sort(header(),comp);
  }

  void reverse()
  {
    ;
    node_impl_type::reverse(header()->impl());
  }



  void relocate(iterator position,iterator i)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    if(position!=i)relink(position.get_node(),i.get_node());
  }

  void relocate(iterator position,iterator first,iterator last)
  {
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ((void)0);;
    ;
    if(position!=last)relink(
      position.get_node(),first.get_node(),last.get_node());
  }

  template<typename InputIterator>
  void rearrange(InputIterator first)
  {
    ;
    node_type* pos=header();
    for(size_type s=size();s--;){
      const value_type& v=*first++;
      relink(pos,node_from_value<node_type>(&v));
    }
  }

protected:
  sequenced_index(const ctor_args_list& args_list,const allocator_type& al):
    super(args_list.get_tail(),al)
  {
    empty_initialize();
  }

  sequenced_index(const sequenced_index<SuperMeta,TagList>& x):
    super(x)





  {


  }

  ~sequenced_index()
  {

  }






  iterator make_iterator(node_type* node){return iterator(node);}
  const_iterator make_iterator(node_type* node)const
                   {return const_iterator(node);}


  void copy_(
    const sequenced_index<SuperMeta,TagList>& x,const copy_map_type& map)
  {
    node_type* org=x.header();
    node_type* cpy=header();
    do{
      node_type* next_org=node_type::from_impl(org->next());
      node_type* next_cpy=map.find(static_cast<final_node_type*>(next_org));
      cpy->next()=next_cpy->impl();
      next_cpy->prior()=cpy->impl();
      org=next_org;
      cpy=next_cpy;
    }while(org!=x.header());

    super::copy_(x,map);
  }

  node_type* insert_(value_param_type v,node_type* x)
  {
    node_type* res=static_cast<node_type*>(super::insert_(v,x));
    if(res==x)link(x);
    return res;
  }

  node_type* insert_(value_param_type v,node_type* position,node_type* x)
  {
    node_type* res=static_cast<node_type*>(super::insert_(v,position,x));
    if(res==x)link(x);
    return res;
  }

  void erase_(node_type* x)
  {
    unlink(x);
    super::erase_(x);




  }

  void delete_all_nodes_()
  {
    for(node_type* x=node_type::from_impl(header()->next());x!=header();){
      node_type* y=node_type::from_impl(x->next());
      this->final_delete_node_(static_cast<final_node_type*>(x));
      x=y;
    }
  }

  void clear_()
  {
    super::clear_();
    empty_initialize();




  }

  void swap_(sequenced_index<SuperMeta,TagList>& x)
  {




    super::swap_(x);
  }

  bool replace_(value_param_type v,node_type* x)
  {
    return super::replace_(v,x);
  }

  bool modify_(node_type* x)
  {
    { try{
      if(!super::modify_(x)){
        unlink(x);





        return false;
      }
      else return true;
    }
    catch(...){
      unlink(x);





      throw;;
    }
    }
  }

  bool modify_rollback_(node_type* x)
  {
    return super::modify_rollback_(x);
  }




  template<typename Archive>
  void save_(
    Archive& ar,const unsigned int version,const index_saver_type& sm)const
  {
    sm.save(begin(),end(),ar,version);
    super::save_(ar,version,sm);
  }

  template<typename Archive>
  void load_(
    Archive& ar,const unsigned int version,const index_loader_type& lm)
  {
    lm.load(
      ::boost::bind(&sequenced_index::rearranger,this,_1,_2),
      ar,version);
    super::load_(ar,version,lm);
  }
# 732 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
private:
  node_type* header()const{return this->final_header();}

  void empty_initialize()
  {
    header()->prior()=header()->next()=header()->impl();
  }

  void link(node_type* x)
  {
    node_impl_type::link(x->impl(),header()->impl());
  };

  static void unlink(node_type* x)
  {
    node_impl_type::unlink(x->impl());
  }

  static void relink(node_type* position,node_type* x)
  {
    node_impl_type::relink(position->impl(),x->impl());
  }

  static void relink(node_type* position,node_type* first,node_type* last)
  {
    node_impl_type::relink(
      position->impl(),first->impl(),last->impl());
  }


  void rearranger(node_type* position,node_type *x)
  {
    if(!position)position=header();
    node_type::increment(position);
    if(position!=x)relink(position,x);
  }
# 778 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/sequenced_index.hpp"
  template <class InputIterator>
  void assign_iter(InputIterator first,InputIterator last,mpl::true_)
  {
    ;
    clear();
    for(;first!=last;++first)push_back(*first);
  }

  void assign_iter(size_type n,value_param_type value,mpl::false_)
  {
    ;
    clear();
    for(size_type i=0;i<n;++i)push_back(value);
  }

  template<typename InputIterator>
  void insert_iter(
    iterator position,InputIterator first,InputIterator last,mpl::true_)
  {
    ;
    for(;first!=last;++first)insert(position,*first);
  }

  void insert_iter(
    iterator position,size_type n,value_param_type x,mpl::false_)
  {
    ((void)0);;
    ((void)0);;
    ;
    for(size_type i=0;i<n;++i)insert(position,x);
  }





};



template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator==(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y)
{
  return x.size()==y.size()&&std::equal(x.begin(),x.end(),y.begin());
}

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator<(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y)
{
  return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
}

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator!=(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y)
{
  return !(x==y);
}

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator>(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y)
{
  return y<x;
}

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator>=(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y)
{
  return !(x<y);
}

template<
  typename SuperMeta1,typename TagList1,
  typename SuperMeta2,typename TagList2
>
bool operator<=(
  const sequenced_index<SuperMeta1,TagList1>& x,
  const sequenced_index<SuperMeta2,TagList2>& y)
{
  return !(x>y);
}



template<typename SuperMeta,typename TagList>
void swap(
  sequenced_index<SuperMeta,TagList>& x,
  sequenced_index<SuperMeta,TagList>& y)
{
  x.swap(y);
}

}



template <typename TagList>
struct sequenced
{
  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((detail::is_tag<TagList>::value) == 0 ? false : true) >)> boost_static_assert_typedef_901;

  template<typename Super>
  struct node_class
  {
    typedef detail::sequenced_index_node<Super> type;
  };

  template<typename SuperMeta>
  struct index_class
  {
    typedef detail::sequenced_index<SuperMeta,typename TagList::type> type;
  };
};

}

}
# 33 "./PropertyList.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/key_extractors.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/key_extractors.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/functional/hash_fwd.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/at.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/at.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/rest_n.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/list/at.hpp" 2
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp" 2
# 107 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
namespace boost{

template<class T> class reference_wrapper;

namespace multi_index{

namespace detail{



template<typename CompositeKey,int N>
struct nth_key_from_value
{
  typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
  typedef typename prevent_eti<
    tuples::element<N,key_extractor_tuple>,
    typename mpl::eval_if_c<
      N<tuples::length<key_extractor_tuple>::value,
      tuples::element<N,key_extractor_tuple>,
      mpl::identity<tuples::null_type>
    >::type
  >::type type;
};
# 162 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename KeyFromValue> struct key_equal_to { typedef std::equal_to<typename KeyFromValue::result_type> type; }; template<> struct key_equal_to<tuples::null_type> { typedef tuples::null_type type; }; template<typename CompositeKey,int N> struct nth_composite_key_equal_to { typedef typename nth_key_from_value<CompositeKey,N>::type key_from_value; typedef typename key_equal_to<key_from_value>::type type; };
template<typename KeyFromValue> struct key_less { typedef std::less<typename KeyFromValue::result_type> type; }; template<> struct key_less<tuples::null_type> { typedef tuples::null_type type; }; template<typename CompositeKey,int N> struct nth_composite_key_less { typedef typename nth_key_from_value<CompositeKey,N>::type key_from_value; typedef typename key_less<key_from_value>::type type; };
template<typename KeyFromValue> struct key_greater { typedef std::greater<typename KeyFromValue::result_type> type; }; template<> struct key_greater<tuples::null_type> { typedef tuples::null_type type; }; template<typename CompositeKey,int N> struct nth_composite_key_greater { typedef typename nth_key_from_value<CompositeKey,N>::type key_from_value; typedef typename key_greater<key_from_value>::type type; };
template<typename KeyFromValue> struct key_hash { typedef boost::hash<typename KeyFromValue::result_type> type; }; template<> struct key_hash<tuples::null_type> { typedef tuples::null_type type; }; template<typename CompositeKey,int N> struct nth_composite_key_hash { typedef typename nth_key_from_value<CompositeKey,N>::type key_from_value; typedef typename key_hash<key_from_value>::type type; };





struct generic_operator_equal
{
  template<typename T,typename Q>
  bool operator()(const T& x,const Q& y)const{return x==y;}
};

typedef tuple<
 

 detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal , detail::generic_operator_equal> generic_operator_equal_tuple;

struct generic_operator_less
{
  template<typename T,typename Q>
  bool operator()(const T& x,const Q& y)const{return x<y;}
};

typedef tuple<
 

 detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less , detail::generic_operator_less> generic_operator_less_tuple;
# 202 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename EqualCons
>
struct equal_ckey_ckey;

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename EqualCons
>
struct equal_ckey_ckey_terminal
{
  static bool compare(
    const KeyCons1&,const Value1&,
    const KeyCons2&,const Value2&,
    const EqualCons&)
  {
    return true;
  }
};

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename EqualCons
>
struct equal_ckey_ckey_normal
{
  static bool compare(
    const KeyCons1& c0,const Value1& v0,
    const KeyCons2& c1,const Value2& v1,
    const EqualCons& eq)
  {
    if(!eq.get_head()(c0.get_head()(v0),c1.get_head()(v1)))return false;
    return equal_ckey_ckey<
      typename KeyCons1::tail_type,Value1,
      typename KeyCons2::tail_type,Value2,
      typename EqualCons::tail_type
    >::compare(c0.get_tail(),v0,c1.get_tail(),v1,eq.get_tail());
  }
};

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename EqualCons
>
struct equal_ckey_ckey:
  mpl::if_<
    mpl::or_<
      is_same<KeyCons1,tuples::null_type>,
      is_same<KeyCons2,tuples::null_type>
    >,
    equal_ckey_ckey_terminal<KeyCons1,Value1,KeyCons2,Value2,EqualCons>,
    equal_ckey_ckey_normal<KeyCons1,Value1,KeyCons2,Value2,EqualCons>
  >::type
{
};

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename EqualCons
>
struct equal_ckey_cval;

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename EqualCons
>
struct equal_ckey_cval_terminal
{
  static bool compare(
    const KeyCons&,const Value&,const ValCons&,const EqualCons&)
  {
    return true;
  }

  static bool compare(
    const ValCons&,const KeyCons&,const Value&,const EqualCons&)
  {
    return true;
  }
};

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename EqualCons
>
struct equal_ckey_cval_normal
{
  static bool compare(
    const KeyCons& c,const Value& v,const ValCons& vc,
    const EqualCons& eq)
  {
    if(!eq.get_head()(c.get_head()(v),vc.get_head()))return false;
    return equal_ckey_cval<
      typename KeyCons::tail_type,Value,
      typename ValCons::tail_type,
      typename EqualCons::tail_type
    >::compare(c.get_tail(),v,vc.get_tail(),eq.get_tail());
  }

  static bool compare(
    const ValCons& vc,const KeyCons& c,const Value& v,
    const EqualCons& eq)
  {
    if(!eq.get_head()(vc.get_head(),c.get_head()(v)))return false;
    return equal_ckey_cval<
      typename KeyCons::tail_type,Value,
      typename ValCons::tail_type,
      typename EqualCons::tail_type
    >::compare(vc.get_tail(),c.get_tail(),v,eq.get_tail());
  }
};

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename EqualCons
>
struct equal_ckey_cval:
  mpl::if_<
    mpl::or_<
      is_same<KeyCons,tuples::null_type>,
      is_same<ValCons,tuples::null_type>
    >,
    equal_ckey_cval_terminal<KeyCons,Value,ValCons,EqualCons>,
    equal_ckey_cval_normal<KeyCons,Value,ValCons,EqualCons>
  >::type
{
};

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename CompareCons
>
struct compare_ckey_ckey;

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename CompareCons
>
struct compare_ckey_ckey_terminal
{
  static bool compare(
    const KeyCons1&,const Value1&,
    const KeyCons2&,const Value2&,
    const CompareCons&)
  {
    return false;
  }
};

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename CompareCons
>
struct compare_ckey_ckey_normal
{
  static bool compare(
    const KeyCons1& c0,const Value1& v0,
    const KeyCons2& c1,const Value2& v1,
    const CompareCons& comp)
  {
    if(comp.get_head()(c0.get_head()(v0),c1.get_head()(v1)))return true;
    if(comp.get_head()(c1.get_head()(v1),c0.get_head()(v0)))return false;
    return compare_ckey_ckey<
      typename KeyCons1::tail_type,Value1,
      typename KeyCons2::tail_type,Value2,
      typename CompareCons::tail_type
    >::compare(c0.get_tail(),v0,c1.get_tail(),v1,comp.get_tail());
  }
};

template
<
  typename KeyCons1,typename Value1,
  typename KeyCons2, typename Value2,
  typename CompareCons
>
struct compare_ckey_ckey:
  mpl::if_<
    mpl::or_<
      is_same<KeyCons1,tuples::null_type>,
      is_same<KeyCons2,tuples::null_type>
    >,
    compare_ckey_ckey_terminal<KeyCons1,Value1,KeyCons2,Value2,CompareCons>,
    compare_ckey_ckey_normal<KeyCons1,Value1,KeyCons2,Value2,CompareCons>
  >::type
{
};

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename CompareCons
>
struct compare_ckey_cval;

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename CompareCons
>
struct compare_ckey_cval_terminal
{
  static bool compare(
    const KeyCons&,const Value&,const ValCons&,const CompareCons&)
  {
    return false;
  }

  static bool compare(
    const ValCons&,const KeyCons&,const Value&,const CompareCons&)
  {
    return false;
  }
};

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename CompareCons
>
struct compare_ckey_cval_normal
{
  static bool compare(
    const KeyCons& c,const Value& v,const ValCons& vc,
    const CompareCons& comp)
  {
    if(comp.get_head()(c.get_head()(v),vc.get_head()))return true;
    if(comp.get_head()(vc.get_head(),c.get_head()(v)))return false;
    return compare_ckey_cval<
      typename KeyCons::tail_type,Value,
      typename ValCons::tail_type,
      typename CompareCons::tail_type
    >::compare(c.get_tail(),v,vc.get_tail(),comp.get_tail());
  }

  static bool compare(
    const ValCons& vc,const KeyCons& c,const Value& v,
    const CompareCons& comp)
  {
    if(comp.get_head()(vc.get_head(),c.get_head()(v)))return true;
    if(comp.get_head()(c.get_head()(v),vc.get_head()))return false;
    return compare_ckey_cval<
      typename KeyCons::tail_type,Value,
      typename ValCons::tail_type,
      typename CompareCons::tail_type
    >::compare(vc.get_tail(),c.get_tail(),v,comp.get_tail());
  }
};

template
<
  typename KeyCons,typename Value,
  typename ValCons,typename CompareCons
>
struct compare_ckey_cval:
  mpl::if_<
    mpl::or_<
      is_same<KeyCons,tuples::null_type>,
      is_same<ValCons,tuples::null_type>
    >,
    compare_ckey_cval_terminal<KeyCons,Value,ValCons,CompareCons>,
    compare_ckey_cval_normal<KeyCons,Value,ValCons,CompareCons>
  >::type
{
};

template<typename KeyCons,typename Value,typename HashCons>
struct hash_ckey;

template<typename KeyCons,typename Value,typename HashCons>
struct hash_ckey_terminal
{
  static std::size_t hash(
    const KeyCons&,const Value&,const HashCons&,std::size_t carry)
  {
    return carry;
  }
};

template<typename KeyCons,typename Value,typename HashCons>
struct hash_ckey_normal
{
  static std::size_t hash(
    const KeyCons& c,const Value& v,const HashCons& h,std::size_t carry=0)
  {


    carry^=h.get_head()(c.get_head()(v))+0x9e3779b9+(carry<<6)+(carry>>2);
    return hash_ckey<
      typename KeyCons::tail_type,Value,
      typename HashCons::tail_type
    >::hash(c.get_tail(),v,h.get_tail(),carry);
  }
};

template<typename KeyCons,typename Value,typename HashCons>
struct hash_ckey:
  mpl::if_<
    is_same<KeyCons,tuples::null_type>,
    hash_ckey_terminal<KeyCons,Value,HashCons>,
    hash_ckey_normal<KeyCons,Value,HashCons>
  >::type
{
};

template<typename ValCons,typename HashCons>
struct hash_cval;

template<typename ValCons,typename HashCons>
struct hash_cval_terminal
{
  static std::size_t hash(const ValCons&,const HashCons&,std::size_t carry)
  {
    return carry;
  }
};

template<typename ValCons,typename HashCons>
struct hash_cval_normal
{
  static std::size_t hash(
    const ValCons& vc,const HashCons& h,std::size_t carry=0)
  {
    carry^=h.get_head()(vc.get_head())+0x9e3779b9+(carry<<6)+(carry>>2);
    return hash_cval<
      typename ValCons::tail_type,
      typename HashCons::tail_type
    >::hash(vc.get_tail(),h.get_tail(),carry);
  }
};

template<typename ValCons,typename HashCons>
struct hash_cval:
  mpl::if_<
    is_same<ValCons,tuples::null_type>,
    hash_cval_terminal<ValCons,HashCons>,
    hash_cval_normal<ValCons,HashCons>
  >::type
{
};

}
# 571 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename CompositeKey>
struct composite_key_result
{
  typedef CompositeKey composite_key_type;
  typedef typename composite_key_type::value_type value_type;

  composite_key_result(
    const composite_key_type& composite_key_,const value_type& value_):
    composite_key(composite_key_),value(value_)
  {}

  const composite_key_type& composite_key;
  const value_type& value;
};
# 602 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<
  typename Value,
  typename KeyFromValue0 , typename KeyFromValue1 =tuples::null_type , typename KeyFromValue2 =tuples::null_type , typename KeyFromValue3 =tuples::null_type , typename KeyFromValue4 =tuples::null_type , typename KeyFromValue5 =tuples::null_type , typename KeyFromValue6 =tuples::null_type , typename KeyFromValue7 =tuples::null_type , typename KeyFromValue8 =tuples::null_type , typename KeyFromValue9 =tuples::null_type
>
struct composite_key:
  private tuple< KeyFromValue0 , KeyFromValue1 , KeyFromValue2 , KeyFromValue3 , KeyFromValue4 , KeyFromValue5 , KeyFromValue6 , KeyFromValue7 , KeyFromValue8 , KeyFromValue9>
{
private:
  typedef tuple< KeyFromValue0 , KeyFromValue1 , KeyFromValue2 , KeyFromValue3 , KeyFromValue4 , KeyFromValue5 , KeyFromValue6 , KeyFromValue7 , KeyFromValue8 , KeyFromValue9> super;

public:
  typedef super key_extractor_tuple;
  typedef Value value_type;
  typedef composite_key_result<composite_key> result_type;

  composite_key(
    const KeyFromValue0& k0 = KeyFromValue0() , const KeyFromValue1& k1 = KeyFromValue1() , const KeyFromValue2& k2 = KeyFromValue2() , const KeyFromValue3& k3 = KeyFromValue3() , const KeyFromValue4& k4 = KeyFromValue4() , const KeyFromValue5& k5 = KeyFromValue5() , const KeyFromValue6& k6 = KeyFromValue6() , const KeyFromValue7& k7 = KeyFromValue7() , const KeyFromValue8& k8 = KeyFromValue8() , const KeyFromValue9& k9 = KeyFromValue9()):
    super( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9)
  {}

  composite_key(const key_extractor_tuple& x):super(x){}

  const key_extractor_tuple& key_extractors()const{return *this;}
  key_extractor_tuple& key_extractors(){return *this;}

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const value_type&>,result_type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  result_type operator()(const value_type& x)const
  {
    return result_type(*this,x);
  }

  result_type operator()(const reference_wrapper<const value_type>& x)const
  {
    return result_type(*this,x.get());
  }

  result_type operator()(const reference_wrapper<value_type>& x,int=0)const
  {
    return result_type(*this,x.get());
  }
};





template<typename CompositeKey1,typename CompositeKey2>
inline bool operator==(
  const composite_key_result<CompositeKey1>& x,
  const composite_key_result<CompositeKey2>& y)
{
  typedef typename CompositeKey1::key_extractor_tuple key_extractor_tuple1;
  typedef typename CompositeKey1::value_type value_type1;
  typedef typename CompositeKey2::key_extractor_tuple key_extractor_tuple2;
  typedef typename CompositeKey2::value_type value_type2;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple1>::value== tuples::length<key_extractor_tuple2>::value) == 0 ? false : true) >)>

 boost_static_assert_typedef_673;

  return detail::equal_ckey_ckey<
    key_extractor_tuple1,value_type1,
    key_extractor_tuple2,value_type2,
    detail::generic_operator_equal_tuple
  >::compare(
    x.composite_key.key_extractors(),x.value,
    y.composite_key.key_extractors(),y.value,
    detail::generic_operator_equal_tuple());
}

template<
  typename CompositeKey,
  typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9
>
inline bool operator==(
  const composite_key_result<CompositeKey>& x,
  const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y)
{
  typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
  typedef typename CompositeKey::value_type value_type;
  typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple>::value== tuples::length<key_tuple>::value) == 0 ? false : true) >)>

 boost_static_assert_typedef_699;

  return detail::equal_ckey_cval<
    key_extractor_tuple,value_type,
    key_tuple,detail::generic_operator_equal_tuple
  >::compare(
    x.composite_key.key_extractors(),x.value,
    y,detail::generic_operator_equal_tuple());
}

template
<
  typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,
  typename CompositeKey
>
inline bool operator==(
  const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,
  const composite_key_result<CompositeKey>& y)
{
  typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
  typedef typename CompositeKey::value_type value_type;
  typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple>::value== tuples::length<key_tuple>::value) == 0 ? false : true) >)>

 boost_static_assert_typedef_724;

  return detail::equal_ckey_cval<
    key_extractor_tuple,value_type,
    key_tuple,detail::generic_operator_equal_tuple
  >::compare(
    x,y.composite_key.key_extractors(),
    y.value,detail::generic_operator_equal_tuple());
}



template<typename CompositeKey1,typename CompositeKey2>
inline bool operator<(
  const composite_key_result<CompositeKey1>& x,
  const composite_key_result<CompositeKey2>& y)
{
  typedef typename CompositeKey1::key_extractor_tuple key_extractor_tuple1;
  typedef typename CompositeKey1::value_type value_type1;
  typedef typename CompositeKey2::key_extractor_tuple key_extractor_tuple2;
  typedef typename CompositeKey2::value_type value_type2;

  return detail::compare_ckey_ckey<
   key_extractor_tuple1,value_type1,
   key_extractor_tuple2,value_type2,
   detail::generic_operator_less_tuple
  >::compare(
    x.composite_key.key_extractors(),x.value,
    y.composite_key.key_extractors(),y.value,
    detail::generic_operator_less_tuple());
}

template
<
  typename CompositeKey,
  typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9
>
inline bool operator<(
  const composite_key_result<CompositeKey>& x,
  const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y)
{
  typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
  typedef typename CompositeKey::value_type value_type;
  typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

  return detail::compare_ckey_cval<
    key_extractor_tuple,value_type,
    key_tuple,detail::generic_operator_less_tuple
  >::compare(
    x.composite_key.key_extractors(),x.value,
    y,detail::generic_operator_less_tuple());
}

template
<
  typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,
  typename CompositeKey
>
inline bool operator<(
  const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,
  const composite_key_result<CompositeKey>& y)
{
  typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
  typedef typename CompositeKey::value_type value_type;
  typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

  return detail::compare_ckey_cval<
    key_extractor_tuple,value_type,
    key_tuple,detail::generic_operator_less_tuple
  >::compare(
    x,y.composite_key.key_extractors(),
    y.value,detail::generic_operator_less_tuple());
}
# 821 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename CompositeKey1,typename CompositeKey2> inline bool operator!=(const composite_key_result<CompositeKey1>& x,const composite_key_result<CompositeKey2>& y) { return !(x==y); } template<typename CompositeKey1,typename CompositeKey2> inline bool operator>(const composite_key_result<CompositeKey1>& x,const composite_key_result<CompositeKey2>& y) { return y<x; } template<typename CompositeKey1,typename CompositeKey2> inline bool operator>=(const composite_key_result<CompositeKey1>& x,const composite_key_result<CompositeKey2>& y) { return !(x<y); } template<typename CompositeKey1,typename CompositeKey2> inline bool operator<=(const composite_key_result<CompositeKey1>& x,const composite_key_result<CompositeKey2>& y) { return !(y<x); }






template<typename CompositeKey, typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9> inline bool operator!=(const composite_key_result<CompositeKey>& x,const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y) { return !(x==y); } template<typename CompositeKey, typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9> inline bool operator>(const composite_key_result<CompositeKey>& x,const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y) { return y<x; } template<typename CompositeKey, typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9> inline bool operator>=(const composite_key_result<CompositeKey>& x,const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y) { return !(x<y); } template<typename CompositeKey, typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9> inline bool operator<=(const composite_key_result<CompositeKey>& x,const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y) { return !(y<x); }






template< typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,typename CompositeKey> inline bool operator!=(const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,const composite_key_result<CompositeKey>& y) { return !(x==y); } template< typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,typename CompositeKey> inline bool operator>(const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,const composite_key_result<CompositeKey>& y) { return y<x; } template< typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,typename CompositeKey> inline bool operator>=(const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,const composite_key_result<CompositeKey>& y) { return !(x<y); } template< typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,typename CompositeKey> inline bool operator<=(const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,const composite_key_result<CompositeKey>& y) { return !(y<x); }
# 844 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template
<
  typename Pred0 , typename Pred1 =tuples::null_type , typename Pred2 =tuples::null_type , typename Pred3 =tuples::null_type , typename Pred4 =tuples::null_type , typename Pred5 =tuples::null_type , typename Pred6 =tuples::null_type , typename Pred7 =tuples::null_type , typename Pred8 =tuples::null_type , typename Pred9 =tuples::null_type
>
struct composite_key_equal_to:
  private tuple< Pred0 , Pred1 , Pred2 , Pred3 , Pred4 , Pred5 , Pred6 , Pred7 , Pred8 , Pred9>
{
private:
  typedef tuple< Pred0 , Pred1 , Pred2 , Pred3 , Pred4 , Pred5 , Pred6 , Pred7 , Pred8 , Pred9> super;

public:
  typedef super key_eq_tuple;

  composite_key_equal_to(
    const Pred0& k0 = Pred0() , const Pred1& k1 = Pred1() , const Pred2& k2 = Pred2() , const Pred3& k3 = Pred3() , const Pred4& k4 = Pred4() , const Pred5& k5 = Pred5() , const Pred6& k6 = Pred6() , const Pred7& k7 = Pred7() , const Pred8& k8 = Pred8() , const Pred9& k9 = Pred9()):
    super( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9)
  {}

  composite_key_equal_to(const key_eq_tuple& x):super(x){}

  const key_eq_tuple& key_eqs()const{return *this;}
  key_eq_tuple& key_eqs(){return *this;}

  template<typename CompositeKey1,typename CompositeKey2>
  bool operator()(
    const composite_key_result<CompositeKey1> & x,
    const composite_key_result<CompositeKey2> & y)const
  {
    typedef typename CompositeKey1::key_extractor_tuple key_extractor_tuple1;
    typedef typename CompositeKey1::value_type value_type1;
    typedef typename CompositeKey2::key_extractor_tuple key_extractor_tuple2;
    typedef typename CompositeKey2::value_type value_type2;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple1>::value<= tuples::length<key_eq_tuple>::value&& tuples::length<key_extractor_tuple1>::value== tuples::length<key_extractor_tuple2>::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_881;

    return detail::equal_ckey_ckey<
      key_extractor_tuple1,value_type1,
      key_extractor_tuple2,value_type2,
      key_eq_tuple
    >::compare(
      x.composite_key.key_extractors(),x.value,
      y.composite_key.key_extractors(),y.value,
      key_eqs());
  }

  template
  <
    typename CompositeKey,
    typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9
  >
  bool operator()(
    const composite_key_result<CompositeKey>& x,
    const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y)const
  {
    typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
    typedef typename CompositeKey::value_type value_type;
    typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple>::value<= tuples::length<key_eq_tuple>::value&& tuples::length<key_extractor_tuple>::value== tuples::length<key_tuple>::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_910;

    return detail::equal_ckey_cval<
      key_extractor_tuple,value_type,
      key_tuple,key_eq_tuple
    >::compare(x.composite_key.key_extractors(),x.value,y,key_eqs());
  }

  template
  <
    typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,
    typename CompositeKey
  >
  bool operator()(
    const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,
    const composite_key_result<CompositeKey>& y)const
  {
    typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
    typedef typename CompositeKey::value_type value_type;
    typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_tuple>::value<= tuples::length<key_eq_tuple>::value&& tuples::length<key_tuple>::value== tuples::length<key_extractor_tuple>::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_935;

    return detail::equal_ckey_cval<
      key_extractor_tuple,value_type,
      key_tuple,key_eq_tuple
    >::compare(x,y.composite_key.key_extractors(),y.value,key_eqs());
  }
};



template
<
  typename Compare0 , typename Compare1 =tuples::null_type , typename Compare2 =tuples::null_type , typename Compare3 =tuples::null_type , typename Compare4 =tuples::null_type , typename Compare5 =tuples::null_type , typename Compare6 =tuples::null_type , typename Compare7 =tuples::null_type , typename Compare8 =tuples::null_type , typename Compare9 =tuples::null_type
>
struct composite_key_compare:
  private tuple< Compare0 , Compare1 , Compare2 , Compare3 , Compare4 , Compare5 , Compare6 , Compare7 , Compare8 , Compare9>
{
private:
  typedef tuple< Compare0 , Compare1 , Compare2 , Compare3 , Compare4 , Compare5 , Compare6 , Compare7 , Compare8 , Compare9> super;

public:
  typedef super key_comp_tuple;

  composite_key_compare(
    const Compare0& k0 = Compare0() , const Compare1& k1 = Compare1() , const Compare2& k2 = Compare2() , const Compare3& k3 = Compare3() , const Compare4& k4 = Compare4() , const Compare5& k5 = Compare5() , const Compare6& k6 = Compare6() , const Compare7& k7 = Compare7() , const Compare8& k8 = Compare8() , const Compare9& k9 = Compare9()):
    super( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9)
  {}

  composite_key_compare(const key_comp_tuple& x):super(x){}

  const key_comp_tuple& key_comps()const{return *this;}
  key_comp_tuple& key_comps(){return *this;}

  template<typename CompositeKey1,typename CompositeKey2>
  bool operator()(
    const composite_key_result<CompositeKey1> & x,
    const composite_key_result<CompositeKey2> & y)const
  {
    typedef typename CompositeKey1::key_extractor_tuple key_extractor_tuple1;
    typedef typename CompositeKey1::value_type value_type1;
    typedef typename CompositeKey2::key_extractor_tuple key_extractor_tuple2;
    typedef typename CompositeKey2::value_type value_type2;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple1>::value<= tuples::length<key_comp_tuple>::value|| tuples::length<key_extractor_tuple2>::value<= tuples::length<key_comp_tuple>::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_983;

    return detail::compare_ckey_ckey<
      key_extractor_tuple1,value_type1,
      key_extractor_tuple2,value_type2,
      key_comp_tuple
    >::compare(
      x.composite_key.key_extractors(),x.value,
      y.composite_key.key_extractors(),y.value,
      key_comps());
  }


  template<typename CompositeKey,typename Value>
  bool operator()(
    const composite_key_result<CompositeKey>& x,
    const Value& y)const
  {
    return operator()(x,make_tuple(cref(y)));
  }


  template
  <
    typename CompositeKey,
    typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9
  >
  bool operator()(
    const composite_key_result<CompositeKey>& x,
    const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& y)const
  {
    typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
    typedef typename CompositeKey::value_type value_type;
    typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple>::value<= tuples::length<key_comp_tuple>::value|| tuples::length<key_tuple>::value<= tuples::length<key_comp_tuple>::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_1022;

    return detail::compare_ckey_cval<
      key_extractor_tuple,value_type,
      key_tuple,key_comp_tuple
    >::compare(x.composite_key.key_extractors(),x.value,y,key_comps());
  }


  template<typename Value,typename CompositeKey>
  bool operator()(
    const Value& x,
    const composite_key_result<CompositeKey>& y)const
  {
    return operator()(make_tuple(cref(x)),y);
  }


  template
  <
    typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9,
    typename CompositeKey
  >
  bool operator()(
    const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x,
    const composite_key_result<CompositeKey>& y)const
  {
    typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
    typedef typename CompositeKey::value_type value_type;
    typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_tuple>::value<= tuples::length<key_comp_tuple>::value|| tuples::length<key_extractor_tuple>::value<= tuples::length<key_comp_tuple>::value) == 0 ? false : true) >)>



 boost_static_assert_typedef_1057;

    return detail::compare_ckey_cval<
      key_extractor_tuple,value_type,
      key_tuple,key_comp_tuple
    >::compare(x,y.composite_key.key_extractors(),y.value,key_comps());
  }
};



template
<
  typename Hash0 , typename Hash1 =tuples::null_type , typename Hash2 =tuples::null_type , typename Hash3 =tuples::null_type , typename Hash4 =tuples::null_type , typename Hash5 =tuples::null_type , typename Hash6 =tuples::null_type , typename Hash7 =tuples::null_type , typename Hash8 =tuples::null_type , typename Hash9 =tuples::null_type
>
struct composite_key_hash:
  private tuple< Hash0 , Hash1 , Hash2 , Hash3 , Hash4 , Hash5 , Hash6 , Hash7 , Hash8 , Hash9>
{
private:
  typedef tuple< Hash0 , Hash1 , Hash2 , Hash3 , Hash4 , Hash5 , Hash6 , Hash7 , Hash8 , Hash9> super;

public:
  typedef super key_hasher_tuple;

  composite_key_hash(
    const Hash0& k0 = Hash0() , const Hash1& k1 = Hash1() , const Hash2& k2 = Hash2() , const Hash3& k3 = Hash3() , const Hash4& k4 = Hash4() , const Hash5& k5 = Hash5() , const Hash6& k6 = Hash6() , const Hash7& k7 = Hash7() , const Hash8& k8 = Hash8() , const Hash9& k9 = Hash9()):
    super( k0 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9)
  {}

  composite_key_hash(const key_hasher_tuple& x):super(x){}

  const key_hasher_tuple& key_hash_functions()const{return *this;}
  key_hasher_tuple& key_hash_functions(){return *this;}

  template<typename CompositeKey>
  std::size_t operator()(const composite_key_result<CompositeKey> & x)const
  {
    typedef typename CompositeKey::key_extractor_tuple key_extractor_tuple;
    typedef typename CompositeKey::value_type value_type;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_extractor_tuple>::value== tuples::length<key_hasher_tuple>::value) == 0 ? false : true) >)>

 boost_static_assert_typedef_1099;

    return detail::hash_ckey<
      key_extractor_tuple,value_type,
      key_hasher_tuple
    >::hash(x.composite_key.key_extractors(),x.value,key_hash_functions());
  }

  template< typename Value0 , typename Value1 , typename Value2 , typename Value3 , typename Value4 , typename Value5 , typename Value6 , typename Value7 , typename Value8 , typename Value9>
  std::size_t operator()(
    const tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9>& x)const
  {
    typedef tuple< Value0 , Value1 , Value2 , Value3 , Value4 , Value5 , Value6 , Value7 , Value8 , Value9> key_tuple;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((tuples::length<key_tuple>::value== tuples::length<key_hasher_tuple>::value) == 0 ? false : true) >)>

 boost_static_assert_typedef_1115;

    return detail::hash_cval<
      key_tuple,key_hasher_tuple
    >::hash(x,key_hash_functions());
  }
};
# 1140 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename CompositeKeyResult>
struct composite_key_result_equal_to:
private
composite_key_equal_to< typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,9 >::type >
{
private:
  typedef composite_key_equal_to< typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_equal_to< typename CompositeKeyResult::composite_key_type,9 >::type > super;

public:
  typedef CompositeKeyResult first_argument_type;
  typedef first_argument_type second_argument_type;
  typedef bool result_type;

  using super::operator();
};
# 1166 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename CompositeKeyResult>
struct composite_key_result_less:
private
composite_key_compare< typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,9 >::type >
{
private:
  typedef composite_key_compare< typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_less< typename CompositeKeyResult::composite_key_type,9 >::type > super;

public:
  typedef CompositeKeyResult first_argument_type;
  typedef first_argument_type second_argument_type;
  typedef bool result_type;

  using super::operator();
};
# 1192 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename CompositeKeyResult>
struct composite_key_result_greater:
private
composite_key_compare< typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,9 >::type >
{
private:
  typedef composite_key_compare< typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_greater< typename CompositeKeyResult::composite_key_type,9 >::type > super;

public:
  typedef CompositeKeyResult first_argument_type;
  typedef first_argument_type second_argument_type;
  typedef bool result_type;

  using super::operator();
};
# 1218 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/composite_key.hpp"
template<typename CompositeKeyResult>
struct composite_key_result_hash:
private
composite_key_hash< typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,9 >::type >
{
private:
  typedef composite_key_hash< typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,0 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,1 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,2 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,3 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,4 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,5 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,6 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,7 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,8 >::type , typename detail::nth_composite_key_hash< typename CompositeKeyResult::composite_key_type,9 >::type > super;

public:
  typedef CompositeKeyResult argument_type;
  typedef std::size_t result_type;

  using super::operator();
};

}

}






namespace std{

template<typename CompositeKey>
struct equal_to<boost::multi_index::composite_key_result<CompositeKey> >:
  boost::multi_index::composite_key_result_equal_to<
    boost::multi_index::composite_key_result<CompositeKey>
  >
{
};

template<typename CompositeKey>
struct less<boost::multi_index::composite_key_result<CompositeKey> >:
  boost::multi_index::composite_key_result_less<
    boost::multi_index::composite_key_result<CompositeKey>
  >
{
};

template<typename CompositeKey>
struct greater<boost::multi_index::composite_key_result<CompositeKey> >:
  boost::multi_index::composite_key_result_greater<
    boost::multi_index::composite_key_result<CompositeKey>
  >
{
};

}

namespace boost{

template<typename CompositeKey>
struct hash<boost::multi_index::composite_key_result<CompositeKey> >:
  boost::multi_index::composite_key_result_hash<
    boost::multi_index::composite_key_result<CompositeKey>
  >
{
};

}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/key_extractors.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/global_fun.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/global_fun.hpp"
namespace boost{

template<class T> class reference_wrapper;

namespace multi_index{

namespace detail{
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/global_fun.hpp"
template<class Value,typename Type,Type (*PtrToFunction)(Value)>
struct const_ref_global_fun_base
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,Value>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(Value x)const
  {
    return PtrToFunction(x);
  }

  Type operator()(
    const reference_wrapper<
      typename remove_reference<Value>::type>& x)const
  {
    return operator()(x.get());
  }

  Type operator()(
    const reference_wrapper<
      typename remove_const<
        typename remove_reference<Value>::type>::type>& x,int=0)const
  {
    return operator()(x.get());
  }
};

template<class Value,typename Type,Type (*PtrToFunction)(Value)>
struct non_const_ref_global_fun_base
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<ChainedPtr&,Value>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(Value x)const
  {
    return PtrToFunction(x);
  }

  Type operator()(
    const reference_wrapper<
      typename remove_reference<Value>::type>& x)const
  {
    return operator()(x.get());
  }
};

template<class Value,typename Type,Type (*PtrToFunction)(Value)>
struct non_ref_global_fun_base
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Value&>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(const Value& x)const
  {
    return PtrToFunction(x);
  }

  Type operator()(const reference_wrapper<const Value>& x)const
  {
    return operator()(x.get());
  }

  Type operator()(
    const reference_wrapper<
      typename remove_const<Value>::type>& x,int=0)const
  {
    return operator()(x.get());
  }
};

}

template<class Value,typename Type,Type (*PtrToFunction)(Value)>
struct global_fun:
  mpl::if_c<
    is_reference<Value>::value,
    typename mpl::if_c<
      is_const<typename remove_reference<Value>::type>::value,
      detail::const_ref_global_fun_base<Value,Type,PtrToFunction>,
      detail::non_const_ref_global_fun_base<Value,Type,PtrToFunction>
    >::type,
    detail::non_ref_global_fun_base<Value,Type,PtrToFunction>
  >::type
{
};

}

}
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/key_extractors.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/mem_fun.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/mem_fun.hpp"
namespace boost{

template<class T> class reference_wrapper;

namespace multi_index{
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/mem_fun.hpp"
template<class Class,typename Type,Type (Class::*PtrToMemberFunction)()const>
struct const_mem_fun
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Class&>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(const Class& x)const
  {
    return (x.*PtrToMemberFunction)();
  }

  Type operator()(const reference_wrapper<const Class>& x)const
  {
    return operator()(x.get());
  }

  Type operator()(const reference_wrapper<Class>& x)const
  {
    return operator()(x.get());
  }
};

template<class Class,typename Type,Type (Class::*PtrToMemberFunction)()>
struct mem_fun
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<ChainedPtr&,Class&>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(Class& x)const
  {
    return (x.*PtrToMemberFunction)();
  }

  Type operator()(const reference_wrapper<Class>& x)const
  {
    return operator()(x.get());
  }
};
# 117 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/mem_fun.hpp"
template<
  class Class,typename Type,
  typename PtrToMemberFunctionType,PtrToMemberFunctionType PtrToMemberFunction>
struct const_mem_fun_explicit
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<const ChainedPtr&,const Class&>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(const Class& x)const
  {
    return (x.*PtrToMemberFunction)();
  }

  Type operator()(const reference_wrapper<const Class>& x)const
  {
    return operator()(x.get());
  }

  Type operator()(const reference_wrapper<Class>& x)const
  {
    return operator()(x.get());
  }
};

template<
  class Class,typename Type,
  typename PtrToMemberFunctionType,PtrToMemberFunctionType PtrToMemberFunction>
struct mem_fun_explicit
{
  typedef typename remove_reference<Type>::type result_type;

  template<typename ChainedPtr>


  typename disable_if<
    is_convertible<ChainedPtr&,Class&>,Type>::type




  operator()(const ChainedPtr& x)const
  {
    return operator()(*x);
  }

  Type operator()(Class& x)const
  {
    return (x.*PtrToMemberFunction)();
  }

  Type operator()(const reference_wrapper<Class>& x)const
  {
    return operator()(x.get());
  }
};
# 208 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/mem_fun.hpp"
}

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/multi_index/key_extractors.hpp" 2
# 34 "./PropertyList.h" 2



namespace gnash {
    class as_object;
    class as_environment;
    class as_function;
    struct ObjectURI;
    class as_value;
}

namespace gnash {
# 61 "./PropertyList.h"
class PropertyList : boost::noncopyable
{

public:

    typedef std::set<ObjectURI> PropertyTracker;
    typedef std::pair<Property, string_table::key> value_type;

    struct NameExtractor
    {
        typedef ObjectURI result_type;
        const result_type& operator()(const value_type& r) const {
            return r.first.uri();
        }
        const result_type& operator()(value_type& r) {
            return r.first.uri();
        }
    };

    typedef boost::multi_index::member<value_type, value_type::second_type,
            &value_type::second> KeyExtractor;

    typedef boost::multi_index_container<
        value_type,
        boost::multi_index::indexed_by<
            boost::multi_index::sequenced<>,
            boost::multi_index::ordered_unique<NameExtractor>,
            boost::multi_index::ordered_non_unique<KeyExtractor>
            >
        > container;
    typedef container::iterator iterator;
    typedef container::const_iterator const_iterator;






    PropertyList(as_object& obj)
        :
        _props(),
        _owner(obj)
    {
    }
# 121 "./PropertyList.h"
    template <class U, class V>
    void visitValues(V& visitor, U cmp = U()) const
    {



        for (const_iterator it = _props.begin(), ie = _props.end();
                it != ie; ++it)
        {
            if (!cmp(it->first)) continue;
            as_value val = it->first.getValue(_owner);
            if (!visitor.accept(it->first.uri(), val)) return;
        }
    }
# 145 "./PropertyList.h"
    void enumerateKeys(as_environment& env, PropertyTracker& donelist) const;
# 165 "./PropertyList.h"
    bool setValue(const ObjectURI& uri, const as_value& value,
            const PropFlags& flagsIfMissing = 0);
# 175 "./PropertyList.h"
    Property* getProperty(const ObjectURI& uri) const;
# 189 "./PropertyList.h"
    std::pair<bool,bool> delProperty(const ObjectURI& uri);
# 205 "./PropertyList.h"
    bool addGetterSetter(const ObjectURI& uri, as_function& getter,
        as_function* setter, const as_value& cacheVal,
        const PropFlags& flagsIfMissing = 0);
# 217 "./PropertyList.h"
    bool addGetterSetter(const ObjectURI& uri, as_c_function_ptr getter,
        as_c_function_ptr setter, const PropFlags& flagsIfMissing);
# 228 "./PropertyList.h"
    bool addDestructiveGetter(const ObjectURI& uri, as_function& getter,
        const PropFlags& flagsIfMissing = 0);
# 241 "./PropertyList.h"
    bool addDestructiveGetter(const ObjectURI& uri, as_c_function_ptr getter,
        const PropFlags& flagsIfMissing = 0);






    void setFlags(const ObjectURI& uri, int setTrue, int setFalse);





    void setFlagsAll(int setTrue, int setFalse);


    void clear();


    size_t size() const {
        return _props.size();
    }





    void dump();






    void dump(std::map<std::string, as_value>& to);



    void setReachable() const;

private:

    container _props;

    as_object& _owner;

};


}
# 29 "./as_object.h" 2

# 1 "./Relay.h" 1
# 24 "./Relay.h"
namespace gnash {
    class as_object;
}

namespace gnash {
# 49 "./Relay.h"
class Relay : boost::noncopyable
{
public:
    virtual ~Relay() {};


    virtual void setReachable() {}
};
# 70 "./Relay.h"
class ActiveRelay : public Relay
{
public:

    explicit ActiveRelay(as_object* owner)
        :
        _owner(owner)
    {}


    virtual ~ActiveRelay();


    virtual void update() = 0;




    virtual void setReachable();


    as_object& owner() const {
        return *_owner;
    }

protected:





    virtual void markReachableResources() const {}

private:





    as_object* _owner;

};

}
# 31 "./as_object.h" 2




# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
# 36 "./as_object.h" 2
# 44 "./as_object.h"
namespace gnash {
    class as_function;
    class MovieClip;
    class DisplayObject;
    class as_environment;
    class VM;
    class IOChannel;
    class movie_root;
    class RunResources;
    class Global_as;
    class as_value;
}

namespace gnash {



class AbstractPropertyVisitor {
public:


    virtual bool accept(const ObjectURI& uri, const as_value& val) = 0;
    virtual ~AbstractPropertyVisitor() {}
};


class Trigger
{
public:

    Trigger(const std::string& propname, as_function& trig,
            const as_value& customArg)
        :
        _propname(propname),
        _func(&trig),
        _customArg(customArg),
        _executing(false),
        _dead(false)
    {}
# 95 "./as_object.h"
    as_value call(const as_value& oldval, const as_value& newval,
            as_object& this_obj);


    bool dead() const { return _dead; }

    void kill() {
        _dead = true;
    }

    void setReachable() const;

private:
# 116 "./as_object.h"
    std::string _propname;


    as_function* _func;



    as_value _customArg;


    bool _executing;






    bool _dead;

};
# 172 "./as_object.h"
class as_object : public GcResource, boost::noncopyable
{

public:

    typedef std::pair<std::string, std::string> KeyValuePair;
# 187 "./as_object.h"
    typedef std::deque<KeyValuePair> SortedPropertyList;






    explicit as_object(Global_as& global);






    virtual as_value call(const fn_call& fn);





    virtual const std::string& stringValue() const;




    static const int DefaultFlags = PropFlags::dontDelete |
                                    PropFlags::dontEnum;
# 222 "./as_object.h"
    Property* findProperty(const ObjectURI& uri, as_object **owner = __null);


    VM& vm() const {
        return _vm;
    }
# 236 "./as_object.h"
    void dump_members();
# 245 "./as_object.h"
    void dump_members(std::map<std::string, as_value>& to);
# 257 "./as_object.h"
    virtual bool set_member(const ObjectURI& uri, const as_value& val,
        bool ifFound = false);
# 270 "./as_object.h"
    void init_member(const std::string& name, const as_value& val,
        int flags = DefaultFlags);
# 288 "./as_object.h"
    void init_member(const ObjectURI& uri, const as_value& val,
        int flags = DefaultFlags);
# 312 "./as_object.h"
    void init_property(const std::string& key, as_function& getter,
        as_function& setter, int flags = DefaultFlags);
# 330 "./as_object.h"
    void init_property(const std::string& key, as_c_function_ptr getter,
        as_c_function_ptr setter, int flags = DefaultFlags);
# 346 "./as_object.h"
    void init_property(const ObjectURI& uri, as_function& getter,
        as_function& setter, int flags = DefaultFlags);
# 362 "./as_object.h"
    void init_property(const ObjectURI& uri, as_c_function_ptr getter,
        as_c_function_ptr setter, int flags = DefaultFlags);
# 376 "./as_object.h"
    bool init_destructive_property(const ObjectURI& uri, as_function& getter,
            int flags = PropFlags::dontEnum);
# 390 "./as_object.h"
    bool init_destructive_property(const ObjectURI& uri,
            as_c_function_ptr getter, int flags = PropFlags::dontEnum);
# 406 "./as_object.h"
    void init_readonly_property(const std::string& key, as_function& getter,
            int flags = DefaultFlags);

    void init_readonly_property(const ObjectURI& uri,
            as_function& getter, int flags = DefaultFlags);
# 425 "./as_object.h"
    void init_readonly_property(const std::string& key,
            as_c_function_ptr getter, int flags = DefaultFlags);

    void init_readonly_property(const ObjectURI& uri,
            as_c_function_ptr getter, int flags = DefaultFlags);
# 440 "./as_object.h"
    void enumeratePropertyKeys(as_environment& env) const;
# 452 "./as_object.h"
    bool watch(const ObjectURI& uri, as_function& trig, const as_value& cust);






    bool unwatch(const ObjectURI& uri);
# 471 "./as_object.h"
    virtual bool get_member(const ObjectURI& uri, as_value* val);
# 480 "./as_object.h"
    virtual as_object* get_path_element(string_table::key key);







    virtual as_object* get_super(string_table::key fname = 0);
# 503 "./as_object.h"
    as_value getMember(const ObjectURI& uri);
# 519 "./as_object.h"
    std::pair<bool, bool> delProperty(const ObjectURI& uri);
# 530 "./as_object.h"
    Property* getOwnProperty(const ObjectURI& uri);
# 539 "./as_object.h"
    bool hasOwnProperty(const ObjectURI& uri);
# 548 "./as_object.h"
    void set_member_flags(const ObjectURI& uri, int setTrue, int setFalse = 0);


    virtual as_function* to_function() { return 0; }


    virtual bool isSuper() const { return false; }
# 566 "./as_object.h"
    void addInterface(as_object* ctor);
# 583 "./as_object.h"
    bool instanceOf(as_object* ctor);
# 592 "./as_object.h"
    bool prototypeOf(as_object& instance);
# 603 "./as_object.h"
    void setPropFlags(const as_value& props, int set_false, int set_true);
# 615 "./as_object.h"
    void copyProperties(const as_object& o);


    void clearProperties() {
        _members.clear();
    }
# 632 "./as_object.h"
    template<typename T>
    void visitProperties(AbstractPropertyVisitor& visitor) const {
        _members.visitValues<T>(visitor);
    }
# 645 "./as_object.h"
    void add_property(const std::string& key, as_function& getter,
        as_function* setter);







    as_object* get_prototype() const;





    void set_prototype(const as_value& proto);
# 676 "./as_object.h"
    void setRelay(Relay* p) {
        if (p) _array = false;
        _relay.reset(p);
    }
# 691 "./as_object.h"
    Relay* relay() const {
        return _relay.get();
    }


    bool array() const {
        return _array;
    }


    void setArray(bool array = true) {
        _array = array;
    }





    DisplayObject* displayObject() const {
        return _displayObject;
    }


    void setDisplayObject(DisplayObject* d) {
        _displayObject = d;
    }

protected:
# 730 "./as_object.h"
    explicit as_object(VM& vm);
# 741 "./as_object.h"
    virtual void markReachableResources() const {
        markAsObjectReachable();
    }


    void markAsObjectReachable() const;

private:
# 761 "./as_object.h"
    Property* findUpdatableProperty(const ObjectURI& uri);

    void executeTriggers(Property* prop, const ObjectURI& uri,
            const as_value& val);


    template<typename T> class PrototypeRecursor;





    DisplayObject* _displayObject;
# 782 "./as_object.h"
    bool _array;





    boost::scoped_ptr<Relay> _relay;


    VM& _vm;


    PropertyList _members;





    std::vector<as_object*> _interfaces;

    typedef std::map<ObjectURI, Trigger> TriggerContainer;
    boost::scoped_ptr<TriggerContainer> _trigs;
};


class IsVisible
{
public:
    IsVisible(int version) : _version(version) {}
    bool operator()(const Property& prop) const {
        return visible(prop, _version);
    }
private:
    const int _version;
};

class Exists
{
public:
    Exists() {}
    bool operator()(const Property&) const {
        return true;
    }
};

class IsEnumerable
{
public:
    IsEnumerable() {}
    bool operator()(const Property& p) const {
        return !p.getFlags().get_dont_enum();
    }
};
# 846 "./as_object.h"
void getURLEncodedVars(as_object& o, std::string& data);







template<typename T>
T*
get(as_object* o)
{
    if (!o) return 0;
    return dynamic_cast<T*>(o->displayObject());
}

as_object* getObjectWithPrototype(Global_as& gl, string_table::key c);
# 876 "./as_object.h"
template<typename T>
bool
isNativeType(as_object* obj, T*& relay)
{
    if (!obj) return false;
    relay = dynamic_cast<T*>(obj->relay());
    return relay;
}
# 893 "./as_object.h"
void enumerateProperties(as_object& o, as_object::SortedPropertyList& to);


VM& getVM(const as_object& o);


movie_root& getRoot(const as_object& o);


string_table& getStringTable(const as_object& o);


const RunResources& getRunResources(const as_object& o);


int getSWFVersion(const as_object& o);


Global_as& getGlobal(const as_object& o);


inline bool caseless(const as_object& o) {
    return getSWFVersion(o) < 7;
}

}
# 23 "asobj/Array_as.h" 2


namespace gnash {
 class as_value;
}

namespace gnash {
# 39 "asobj/Array_as.h"
size_t arrayLength(as_object& array);
# 48 "asobj/Array_as.h"
string_table::key arrayKey(string_table& st, size_t i);





class IsStrictArray : public AbstractPropertyVisitor
{
public:
    IsStrictArray(string_table& st) : _strict(true), _st(st) {}
    virtual bool accept(const ObjectURI& uri, const as_value& val);

    bool strict() const {
        return _strict;
    }
private:
    bool _strict;
    string_table& _st;
};







void checkArrayLength(as_object& array, const ObjectURI& uri,
        const as_value& val);

template<typename T>
void foreachArray(as_object& array, T& pred)
{
    size_t size = arrayLength(array);
    if (!size) return;

    string_table& st = getStringTable(array);

    for (size_t i = 0; i < static_cast<size_t>(size); ++i) {
        pred(array.getMember(arrayKey(st, i)));
    }
}


void array_class_init(as_object& global, const ObjectURI& uri);

void registerArrayNative(as_object& global);

}
# 24 "asobj/Array_as.cpp" 2
# 1 "../libbase/log.h" 1
# 23 "../libbase/log.h"
# 1 "../gnashconfig.h" 1
# 24 "../libbase/log.h" 2


# 1 "../libbase/rc.h" 1
# 23 "../libbase/rc.h"
# 1 "../libbase/StringPredicates.h" 1
# 27 "../libbase/StringPredicates.h"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp" 1
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
namespace boost {
    namespace algorithm {
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename RangeT, typename FinderT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find(
            RangeT& Input,
            const FinderT& Finder)
        {
            iterator_range<typename range_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));

            return Finder(::boost::begin(lit_input),::boost::end(lit_input));
        }
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        find_first(
            Range1T& Input,
            const Range2T& Search)
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::first_finder(Search));
        }
# 103 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        ifind_first(
            Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::first_finder(Search,is_iequal(Loc)));
        }
# 130 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        find_last(
            Range1T& Input,
            const Range2T& Search)
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::last_finder(Search));
        }
# 156 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        ifind_last(
            Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::last_finder(Search, is_iequal(Loc)));
        }
# 184 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        find_nth(
            Range1T& Input,
            const Range2T& Search,
            int Nth)
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::nth_finder(Search,Nth));
        }
# 214 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        ifind_nth(
            Range1T& Input,
            const Range2T& Search,
            int Nth,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::nth_finder(Search,Nth,is_iequal(Loc)));
        }
# 246 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename RangeT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find_head(
            RangeT& Input,
            int N)
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::head_finder(N));
        }
# 277 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename RangeT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find_tail(
            RangeT& Input,
            int N)
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::tail_finder(N));
        }
# 306 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/find.hpp"
        template<typename RangeT, typename PredicateT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find_token(
            RangeT& Input,
            PredicateT Pred,
            token_compress_mode_type eCompress=token_compress_off)
        {
            return ::boost::algorithm::find(Input, ::boost::algorithm::token_finder(Pred, eCompress));
        }

    }


    using algorithm::find;
    using algorithm::find_first;
    using algorithm::ifind_first;
    using algorithm::find_last;
    using algorithm::ifind_last;
    using algorithm::find_nth;
    using algorithm::ifind_nth;
    using algorithm::find_head;
    using algorithm::find_tail;
    using algorithm::find_token;

}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/predicate.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/predicate.hpp"
namespace boost {
    namespace algorithm {
        namespace detail {



            template<
                typename ForwardIterator1T,
                typename ForwardIterator2T,
                typename PredicateT>
            inline bool ends_with_iter_select(
                ForwardIterator1T Begin,
                ForwardIterator1T End,
                ForwardIterator2T SubBegin,
                ForwardIterator2T SubEnd,
                PredicateT Comp,
                std::bidirectional_iterator_tag)
            {
                ForwardIterator1T it=End;
                ForwardIterator2T pit=SubEnd;
                for(;it!=Begin && pit!=SubBegin;)
                {
                    if( !(Comp(*(--it),*(--pit))) )
                        return false;
                }

                return pit==SubBegin;
            }

            template<
                typename ForwardIterator1T,
                typename ForwardIterator2T,
                typename PredicateT>
            inline bool ends_with_iter_select(
                ForwardIterator1T Begin,
                ForwardIterator1T End,
                ForwardIterator2T SubBegin,
                ForwardIterator2T SubEnd,
                PredicateT Comp,
                std::forward_iterator_tag)
            {
                if ( SubBegin==SubEnd )
                {

                    return true;
                }

                iterator_range<ForwardIterator1T> Result
                    =last_finder(
                        ::boost::make_iterator_range(SubBegin, SubEnd),
                        Comp)(Begin, End);

                return !Result.empty() && Result.end()==End;
            }

        }
    }
}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
namespace boost {
    namespace algorithm {
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T, typename PredicateT>
            inline bool starts_with(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(::boost::as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(::boost::as_literal(Test));

            typedef typename
                range_const_iterator<Range1T>::type Iterator1T;
            typedef typename
                range_const_iterator<Range2T>::type Iterator2T;

            Iterator1T InputEnd=::boost::end(lit_input);
            Iterator2T TestEnd=::boost::end(lit_test);

            Iterator1T it=::boost::begin(lit_input);
            Iterator2T pit=::boost::begin(lit_test);
            for(;
                it!=InputEnd && pit!=TestEnd;
                ++it,++pit)
            {
                if( !(Comp(*it,*pit)) )
                    return false;
            }

            return pit==TestEnd;
        }





        template<typename Range1T, typename Range2T>
        inline bool starts_with(
            const Range1T& Input,
            const Range2T& Test)
        {
            return ::boost::algorithm::starts_with(Input, Test, is_equal());
        }
# 111 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T>
        inline bool istarts_with(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::starts_with(Input, Test, is_iequal(Loc));
        }
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool ends_with(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(::boost::as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(::boost::as_literal(Test));

            typedef typename
                range_const_iterator<Range1T>::type Iterator1T;
            typedef typename boost::detail::
                iterator_traits<Iterator1T>::iterator_category category;

            return detail::
                ends_with_iter_select(
                    ::boost::begin(lit_input),
                    ::boost::end(lit_input),
                    ::boost::begin(lit_test),
                    ::boost::end(lit_test),
                    Comp,
                    category());
        }






        template<typename Range1T, typename Range2T>
        inline bool ends_with(
            const Range1T& Input,
            const Range2T& Test)
        {
            return ::boost::algorithm::ends_with(Input, Test, is_equal());
        }
# 188 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T>
        inline bool iends_with(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::ends_with(Input, Test, is_iequal(Loc));
        }
# 212 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool contains(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(::boost::as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(::boost::as_literal(Test));

            if (::boost::empty(lit_test))
            {

                return true;
            }


            bool bResult=(::boost::algorithm::first_finder(lit_test,Comp)(::boost::begin(lit_input), ::boost::end(lit_input)));
            return bResult;
        }





        template<typename Range1T, typename Range2T>
        inline bool contains(
            const Range1T& Input,
            const Range2T& Test)
        {
            return ::boost::algorithm::contains(Input, Test, is_equal());
        }
# 256 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T>
        inline bool icontains(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::contains(Input, Test, is_iequal(Loc));
        }
# 283 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool equals(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(::boost::as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(::boost::as_literal(Test));

            typedef typename
                range_const_iterator<Range1T>::type Iterator1T;
            typedef typename
                range_const_iterator<Range2T>::type Iterator2T;

            Iterator1T InputEnd=::boost::end(lit_input);
            Iterator2T TestEnd=::boost::end(lit_test);

            Iterator1T it=::boost::begin(lit_input);
            Iterator2T pit=::boost::begin(lit_test);
            for(;
                it!=InputEnd && pit!=TestEnd;
                ++it,++pit)
            {
                if( !(Comp(*it,*pit)) )
                    return false;
            }

            return (pit==TestEnd) && (it==InputEnd);
        }





        template<typename Range1T, typename Range2T>
        inline bool equals(
            const Range1T& Input,
            const Range2T& Test)
        {
            return ::boost::algorithm::equals(Input, Test, is_equal());
        }
# 340 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T>
        inline bool iequals(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::equals(Input, Test, is_iequal(Loc));
        }
# 369 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool lexicographical_compare(
            const Range1T& Arg1,
            const Range2T& Arg2,
            PredicateT Pred)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_arg1(::boost::as_literal(Arg1));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_arg2(::boost::as_literal(Arg2));

            return std::lexicographical_compare(
                ::boost::begin(lit_arg1),
                ::boost::end(lit_arg1),
                ::boost::begin(lit_arg2),
                ::boost::end(lit_arg2),
                Pred);
        }





        template<typename Range1T, typename Range2T>
            inline bool lexicographical_compare(
            const Range1T& Arg1,
            const Range2T& Arg2)
        {
            return ::boost::algorithm::lexicographical_compare(Arg1, Arg2, is_less());
        }
# 414 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename Range1T, typename Range2T>
        inline bool ilexicographical_compare(
            const Range1T& Arg1,
            const Range2T& Arg2,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::lexicographical_compare(Arg1, Arg2, is_iless(Loc));
        }
# 437 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/predicate.hpp"
        template<typename RangeT, typename PredicateT>
        inline bool all(
            const RangeT& Input,
            PredicateT Pred)
        {
            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));

            typedef typename
                range_const_iterator<RangeT>::type Iterator1T;

            Iterator1T InputEnd=::boost::end(lit_input);
            for( Iterator1T It=::boost::begin(lit_input); It!=InputEnd; ++It)
            {
                if (!Pred(*It))
                    return false;
            }

            return true;
        }

    }


    using algorithm::starts_with;
    using algorithm::istarts_with;
    using algorithm::ends_with;
    using algorithm::iends_with;
    using algorithm::contains;
    using algorithm::icontains;
    using algorithm::equals;
    using algorithm::iequals;
    using algorithm::all;
    using algorithm::lexicographical_compare;
    using algorithm::ilexicographical_compare;

}
# 28 "../libbase/StringPredicates.h" 2

namespace gnash {


class StringNoCaseLessThan {
public:
 bool operator() (const std::string& a, const std::string& b) const
 {
  return std::lexicographical_compare(a.begin(), a.end(),
          b.begin(), b.end(),
          nocase_less());
 }
private:

 class nocase_less
 {
 public:
  nocase_less(const std::locale& locale = std::locale())
   : _locale(locale)
  {}

  bool operator() (const char& a, const char& b) const
  {
   return std::toupper<char>(a, _locale) <
          std::toupper<char>(b, _locale);
  }
 private:
  const std::locale& _locale;
 };
};



class StringNoCaseEqual {
public:

    typedef bool result_type;

 bool operator() (const std::string& a, const std::string& b) const
 {
  return boost::iequals(a, b);
 }
};

}
# 24 "../libbase/rc.h" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iostream" 1 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iostream" 3
       
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iostream" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 28 "../libbase/rc.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 30 "../libbase/rc.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tokenizer.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tokenizer.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/minimum_category.hpp" 1
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/minimum_category.hpp"
namespace boost { namespace detail {
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/minimum_category.hpp"
template <bool GreaterEqual, bool LessEqual>
struct minimum_category_impl
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/minimum_category.hpp"
;

template <class T1, class T2>
struct error_not_related_by_convertibility;

template <>
struct minimum_category_impl<true,false>
{
    template <class T1, class T2> struct apply
    {
        typedef T2 type;
    };
};

template <>
struct minimum_category_impl<false,true>
{
    template <class T1, class T2> struct apply
    {
        typedef T1 type;
    };
};

template <>
struct minimum_category_impl<true,true>
{
    template <class T1, class T2> struct apply
    {
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((is_same<T1,T2>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_62;
        typedef T1 type;
    };
};

template <>
struct minimum_category_impl<false,false>
{
    template <class T1, class T2> struct apply
    : error_not_related_by_convertibility<T1,T2>
    {
    };
};

template <class T1 = mpl::_1, class T2 = mpl::_2>
struct minimum_category
{
    typedef minimum_category_impl<



        ::boost::is_convertible<T1,T2>::value
      , ::boost::is_convertible<T2,T1>::value



    > outer;

    typedef typename outer::template apply<T1,T2> inner;
    typedef typename inner::type type;

   
};

template <>
struct minimum_category<mpl::_1,mpl::_2>
{
    template <class T1, class T2>
    struct apply : minimum_category<T1,T2>
    {};

   
};
# 114 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/minimum_category.hpp"
}}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp" 1
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cctype" 3
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cwctype" 3
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp" 2
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
namespace boost{
# 88 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
  struct escaped_list_error : public std::runtime_error{
    escaped_list_error(const std::string& what_arg):std::runtime_error(what_arg) { }
  };




  template <class Char,
    class Traits = typename std::basic_string<Char>::traits_type >
  class escaped_list_separator {

  private:
    typedef std::basic_string<Char,Traits> string_type;
    struct char_eq {
      Char e_;
      char_eq(Char e):e_(e) { }
      bool operator()(Char c) {
        return Traits::eq(e_,c);
      }
    };
    string_type escape_;
    string_type c_;
    string_type quote_;
    bool last_;

    bool is_escape(Char e) {
      char_eq f(e);
      return std::find_if(escape_.begin(),escape_.end(),f)!=escape_.end();
    }
    bool is_c(Char e) {
      char_eq f(e);
      return std::find_if(c_.begin(),c_.end(),f)!=c_.end();
    }
    bool is_quote(Char e) {
      char_eq f(e);
      return std::find_if(quote_.begin(),quote_.end(),f)!=quote_.end();
    }
    template <typename iterator, typename Token>
    void do_escape(iterator& next,iterator end,Token& tok) {
      if (++next == end)
        throw escaped_list_error(std::string("cannot end with escape"));
      if (Traits::eq(*next,'n')) {
        tok+='\n';
        return;
      }
      else if (is_quote(*next)) {
        tok+=*next;
        return;
      }
      else if (is_c(*next)) {
        tok+=*next;
        return;
      }
      else if (is_escape(*next)) {
        tok+=*next;
        return;
      }
      else
        throw escaped_list_error(std::string("unknown escape sequence"));
    }

    public:

    explicit escaped_list_separator(Char e = '\\',
                                    Char c = ',',Char q = '\"')
      : escape_(1,e), c_(1,c), quote_(1,q), last_(false) { }

    escaped_list_separator(string_type e, string_type c, string_type q)
      : escape_(e), c_(c), quote_(q), last_(false) { }

    void reset() {last_=false;}

    template <typename InputIterator, typename Token>
    bool operator()(InputIterator& next,InputIterator end,Token& tok) {
      bool bInQuote = false;
      tok = Token();

      if (next == end) {
        if (last_) {
          last_ = false;
          return true;
        }
        else
          return false;
      }
      last_ = false;
      for (;next != end;++next) {
        if (is_escape(*next)) {
          do_escape(next,end,tok);
        }
        else if (is_c(*next)) {
          if (!bInQuote) {

            ++next;


            last_ = true;
            return true;
          }
          else tok+=*next;
        }
        else if (is_quote(*next)) {
          bInQuote=!bInQuote;
        }
        else {
          tok += *next;
        }
      }
      return true;
    }
  };





  namespace tokenizer_detail {
# 214 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
  template<typename traits>
  struct traits_extension : public traits {
    typedef typename traits::char_type char_type;
    static bool isspace(char_type c)
    {

      if (sizeof(char_type) == 1)
        return std::isspace(c) != 0;
      else
        return std::iswspace(c) != 0;



    }

    static bool ispunct(char_type c)
    {

      if (sizeof(char_type) == 1)
        return std::ispunct(c) != 0;
      else
        return std::iswpunct(c) != 0;



    }
  };
# 253 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
  template<class IteratorTag>
  struct assign_or_plus_equal {
    template<class Iterator, class Token>
    static void assign(Iterator b, Iterator e, Token &t) {
# 270 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
      t.assign(b, e);


    }

    template<class Token, class Value>
    static void plus_equal(Token &, const Value &) { }




    template<class Token>
    static void clear(Token &) { }
  };

  template <>
  struct assign_or_plus_equal<std::input_iterator_tag> {
    template<class Iterator, class Token>
    static void assign(Iterator b, Iterator e, Token &t) { }
    template<class Token, class Value>
    static void plus_equal(Token &t, const Value &v) {
      t += v;
    }
    template<class Token>
    static void clear(Token &t) {
      t = Token();
    }
  };


  template<class Iterator>
  struct pointer_iterator_category{
    typedef std::random_access_iterator_tag type;
  };


  template<class Iterator>
  struct class_iterator_category{
    typedef typename Iterator::iterator_category type;
  };




  template<class Iterator>
    struct get_iterator_category{
    typedef typename mpl::if_<is_pointer<Iterator>,
      pointer_iterator_category<Iterator>,
      class_iterator_category<Iterator>
    >::type cat;

    typedef typename cat::type iterator_category;
  };


  }






  class offset_separator {
  private:

    std::vector<int> offsets_;
    unsigned int current_offset_;
    bool wrap_offsets_;
    bool return_partial_last_;

  public:
    template <typename Iter>
    offset_separator(Iter begin, Iter end, bool wrap_offsets = true,
                     bool return_partial_last = true)
      : offsets_(begin,end), current_offset_(0),
        wrap_offsets_(wrap_offsets),
        return_partial_last_(return_partial_last) { }

    offset_separator()
      : offsets_(1,1), current_offset_(),
        wrap_offsets_(true), return_partial_last_(true) { }

    void reset() {
      current_offset_ = 0;
    }

    template <typename InputIterator, typename Token>
    bool operator()(InputIterator& next, InputIterator end, Token& tok)
    {
      typedef tokenizer_detail::assign_or_plus_equal<
        typename tokenizer_detail::get_iterator_category<
          InputIterator
        >::iterator_category
      > assigner;

      ((!offsets_.empty()) ? static_cast<void> (0) : __assert_fail ("!offsets_.empty()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp", 365, __PRETTY_FUNCTION__));

      assigner::clear(tok);
      InputIterator start(next);

      if (next == end)
        return false;

      if (current_offset_ == offsets_.size())
      {
        if (wrap_offsets_)
          current_offset_=0;
        else
          return false;
      }

      int c = offsets_[current_offset_];
      int i = 0;
      for (; i < c; ++i) {
        if (next == end)break;
        assigner::plus_equal(tok,*next++);
      }
      assigner::assign(start,next,tok);

      if (!return_partial_last_)
        if (i < (c-1) )
          return false;

      ++current_offset_;
      return true;
    }
  };
# 413 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
  enum empty_token_policy { drop_empty_tokens, keep_empty_tokens };


  template <typename Char,
    typename Tr = typename std::basic_string<Char>::traits_type >
  class char_separator
  {
    typedef tokenizer_detail::traits_extension<Tr> Traits;
    typedef std::basic_string<Char,Traits> string_type;
  public:
    explicit
    char_separator(const Char* dropped_delims,
                   const Char* kept_delims = 0,
                   empty_token_policy empty_tokens = drop_empty_tokens)
      : m_dropped_delims(dropped_delims),
        m_use_ispunct(false),
        m_use_isspace(false),
        m_empty_tokens(empty_tokens),
        m_output_done(false)
    {

      if (kept_delims)
        m_kept_delims = kept_delims;
    }


    explicit
    char_separator()
      : m_use_ispunct(true),
        m_use_isspace(true),
        m_empty_tokens(drop_empty_tokens) { }

    void reset() { }

    template <typename InputIterator, typename Token>
    bool operator()(InputIterator& next, InputIterator end, Token& tok)
    {
      typedef tokenizer_detail::assign_or_plus_equal<
        typename tokenizer_detail::get_iterator_category<
          InputIterator
        >::iterator_category
      > assigner;

      assigner::clear(tok);


      if (m_empty_tokens == drop_empty_tokens)
        for (; next != end && is_dropped(*next); ++next)
          { }

      InputIterator start(next);

      if (m_empty_tokens == drop_empty_tokens) {

        if (next == end)
          return false;



        if (is_kept(*next)) {
          assigner::plus_equal(tok,*next);
          ++next;
        } else

          for (; next != end && !is_dropped(*next) && !is_kept(*next); ++next)
            assigner::plus_equal(tok,*next);
      }
      else {


        if (next == end)
        {
          if (m_output_done == false)
          {
            m_output_done = true;
            assigner::assign(start,next,tok);
            return true;
          }
          else
            return false;
        }

        if (is_kept(*next)) {
          if (m_output_done == false)
            m_output_done = true;
          else {
            assigner::plus_equal(tok,*next);
            ++next;
            m_output_done = false;
          }
        }
        else if (m_output_done == false && is_dropped(*next)) {
          m_output_done = true;
        }
        else {
          if (is_dropped(*next))
            start=++next;
          for (; next != end && !is_dropped(*next) && !is_kept(*next); ++next)
            assigner::plus_equal(tok,*next);
          m_output_done = true;
        }
      }
      assigner::assign(start,next,tok);
      return true;
    }

  private:
    string_type m_kept_delims;
    string_type m_dropped_delims;
    bool m_use_ispunct;
    bool m_use_isspace;
    empty_token_policy m_empty_tokens;
    bool m_output_done;

    bool is_kept(Char E) const
    {
      if (m_kept_delims.length())
        return m_kept_delims.find(E) != string_type::npos;
      else if (m_use_ispunct) {
        return Traits::ispunct(E) != 0;
      } else
        return false;
    }
    bool is_dropped(Char E) const
    {
      if (m_dropped_delims.length())
        return m_dropped_delims.find(E) != string_type::npos;
      else if (m_use_isspace) {
        return Traits::isspace(E) != 0;
      } else
        return false;
    }
  };
# 558 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_functions.hpp"
  template <class Char,
    class Tr = typename std::basic_string<Char>::traits_type >
  class char_delimiters_separator {
  private:

    typedef tokenizer_detail::traits_extension<Tr> Traits;
    typedef std::basic_string<Char,Traits> string_type;
    string_type returnable_;
    string_type nonreturnable_;
    bool return_delims_;
    bool no_ispunct_;
    bool no_isspace_;

    bool is_ret(Char E)const
    {
      if (returnable_.length())
        return returnable_.find(E) != string_type::npos;
      else{
        if (no_ispunct_) {return false;}
        else{
          int r = Traits::ispunct(E);
          return r != 0;
        }
      }
    }
    bool is_nonret(Char E)const
    {
      if (nonreturnable_.length())
        return nonreturnable_.find(E) != string_type::npos;
      else{
        if (no_isspace_) {return false;}
        else{
          int r = Traits::isspace(E);
          return r != 0;
        }
      }
    }

  public:
    explicit char_delimiters_separator(bool return_delims = false,
                                       const Char* returnable = 0,
                                       const Char* nonreturnable = 0)
      : returnable_(returnable ? returnable : string_type().c_str()),
        nonreturnable_(nonreturnable ? nonreturnable:string_type().c_str()),
        return_delims_(return_delims), no_ispunct_(returnable!=0),
        no_isspace_(nonreturnable!=0) { }

    void reset() { }

  public:

     template <typename InputIterator, typename Token>
     bool operator()(InputIterator& next, InputIterator end,Token& tok) {
     tok = Token();



     for (;next!=end && ( is_nonret(*next) || (is_ret(*next)
       && !return_delims_ ) );++next) { }

     if (next == end) {
       return false;
     }



     if (is_ret(*next) && return_delims_) {
       tok+=*next;
       ++next;
     }
     else

       for (;next!=end && !is_nonret(*next) && !is_ret(*next);++next)
         tok+=*next;


     return true;
   }
  };


}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp" 2


namespace boost
{
  template <class TokenizerFunc, class Iterator, class Type>
  class token_iterator
      : public iterator_facade<
            token_iterator<TokenizerFunc, Iterator, Type>
          , Type
          , typename detail::minimum_category<
                forward_traversal_tag
              , typename iterator_traversal<Iterator>::type
            >::type
          , const Type&
        >
  {

      friend class iterator_core_access;

      TokenizerFunc f_;
      Iterator begin_;
      Iterator end_;
      bool valid_;
      Type tok_;

      void increment(){
          ((valid_) ? static_cast<void> (0) : __assert_fail ("valid_", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp", 51, __PRETTY_FUNCTION__));
          valid_ = f_(begin_,end_,tok_);
      }

      const Type& dereference() const {
          ((valid_) ? static_cast<void> (0) : __assert_fail ("valid_", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/token_iterator.hpp", 56, __PRETTY_FUNCTION__));
          return tok_;
      }
      template<class Other>
      bool equal(const Other& a) const{
          return (a.valid_ && valid_)
              ?( (a.begin_==begin_) && (a.end_ == end_) )
              :(a.valid_==valid_);

      }

      void initialize(){
          if(valid_) return;
          f_.reset();
          valid_ = (begin_ != end_)?
              f_(begin_,end_,tok_):false;
      }
  public:
      token_iterator():begin_(),end_(),valid_(false),tok_() { }

      token_iterator(TokenizerFunc f, Iterator begin, Iterator e = Iterator())
          : f_(f),begin_(begin),end_(e),valid_(false),tok_(){ initialize(); }

      token_iterator(Iterator begin, Iterator e = Iterator())
            : f_(),begin_(begin),end_(e),valid_(false),tok_() {initialize();}

      template<class OtherIter>
      token_iterator(
            token_iterator<TokenizerFunc, OtherIter,Type> const& t
            , typename enable_if_convertible<OtherIter, Iterator>::type* = 0)
            : f_(t.tokenizer_function()),begin_(t.base())
            ,end_(t.end()),valid_(!t.at_end()),tok_(t.current_token()) {}

      Iterator base()const{return begin_;}

      Iterator end()const{return end_;};

      TokenizerFunc tokenizer_function()const{return f_;}

      Type current_token()const{return tok_;}

      bool at_end()const{return !valid_;}




  };
    template <
        class TokenizerFunc = char_delimiters_separator<char>,
        class Iterator = std::string::const_iterator,
        class Type = std::string
    >
    class token_iterator_generator {

    private:
    public:
        typedef token_iterator<TokenizerFunc,Iterator,Type> type;
    };




    template<class Type, class Iterator, class TokenizerFunc>
        typename token_iterator_generator<TokenizerFunc,Iterator,Type>::type
    make_token_iterator(Iterator begin, Iterator end,const TokenizerFunc& fun){
        typedef typename
            token_iterator_generator<TokenizerFunc,Iterator,Type>::type ret_type;
        return ret_type(fun,begin,end);
    }

}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/tokenizer.hpp" 2

namespace boost {




  template <
    typename TokenizerFunc = char_delimiters_separator<char>,
    typename Iterator = std::string::const_iterator,
    typename Type = std::string
  >
  class tokenizer {
  private:
    typedef token_iterator_generator<TokenizerFunc,Iterator,Type> TGen;




    typedef typename TGen::type iter;

  public:

    typedef iter iterator;
    typedef iter const_iterator;
    typedef Type value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef const pointer const_pointer;
    typedef void size_type;
    typedef void difference_type;

    tokenizer(Iterator first, Iterator last,
              const TokenizerFunc& f = TokenizerFunc())
      : first_(first), last_(last), f_(f) { }

    template <typename Container>
    tokenizer(const Container& c)
      : first_(c.begin()), last_(c.end()), f_() { }

    template <typename Container>
    tokenizer(const Container& c,const TokenizerFunc& f)
      : first_(c.begin()), last_(c.end()), f_(f) { }

    void assign(Iterator first, Iterator last){
      first_ = first;
      last_ = last;
    }

    void assign(Iterator first, Iterator last, const TokenizerFunc& f){
      assign(first,last);
      f_ = f;
    }

    template <typename Container>
    void assign(const Container& c){
      assign(c.begin(),c.end());
    }


    template <typename Container>
    void assign(const Container& c, const TokenizerFunc& f){
      assign(c.begin(),c.end(),f);
    }

    iter begin() const { return iter(f_,first_,last_); }
    iter end() const { return iter(f_,last_,last_); }

  private:
    Iterator first_;
    Iterator last_;
    TokenizerFunc f_;
  };


}
# 31 "../libbase/rc.h" 2


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/shm.h" 1 3 4
# 25 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/shm.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 26 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/shm.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/ipc.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/ipc.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/ipctypes.h" 1 3 4
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/ipctypes.h" 3 4
typedef long int __ipc_pid_t;
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/ipc.h" 2 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/ipc.h" 1 3 4
# 43 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/ipc.h" 3 4
struct ipc_perm
  {
    __key_t __key;
    unsigned int uid;
    unsigned int gid;
    unsigned int cuid;
    unsigned int cgid;
    unsigned int mode;
    unsigned short int __seq;
    unsigned short int __pad1;
    unsigned long int __unused1;
    unsigned long int __unused2;
};
# 31 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/ipc.h" 2 3 4
# 52 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/ipc.h" 3 4
extern "C" {


extern key_t ftok (__const char *__pathname, int __proj_id) throw ();

}
# 29 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/shm.h" 2 3 4


# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/shm.h" 1 3 4
# 44 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/shm.h" 3 4
typedef unsigned long int shmatt_t;


struct shmid_ds
  {
    struct ipc_perm shm_perm;
    size_t shm_segsz;
    __time_t shm_atime;
    __time_t shm_dtime;
    __time_t shm_ctime;
    __pid_t shm_cpid;
    __pid_t shm_lpid;
    shmatt_t shm_nattch;
    unsigned long int __unused1;
    unsigned long int __unused2;
  };
# 72 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/shm.h" 3 4
struct shminfo
  {
    unsigned long int shmmax;
    unsigned long int shmmin;
    unsigned long int shmmni;
    unsigned long int shmseg;
    unsigned long int shmall;
    unsigned long int __unused1;
    unsigned long int __unused2;
    unsigned long int __unused3;
    unsigned long int __unused4;
  };

struct shm_info
  {
    int used_ids;
    unsigned long int shm_tot;
    unsigned long int shm_rss;
    unsigned long int shm_swp;
    unsigned long int swap_attempts;
    unsigned long int swap_successes;
  };
# 32 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/shm.h" 2 3 4
# 45 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/sys/shm.h" 3 4
extern "C" {





extern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) throw ();


extern int shmget (key_t __key, size_t __size, int __shmflg) throw ();


extern void *shmat (int __shmid, __const void *__shmaddr, int __shmflg)
     throw ();


extern int shmdt (__const void *__shmaddr) throw ();

}
# 34 "../libbase/rc.h" 2






namespace gnash {

class RcInitFile
{
public:


    static RcInitFile& getDefaultInstance();



    void loadFiles();

    bool parseFile(const std::string& filespec);







    bool updateFile(const std::string& filespec);






    bool updateFile();

    bool useSplashScreen() const { return _splashScreen; }
    void useSplashScreen(bool value);

    bool useActionDump() const { return _actionDump; }
    void useActionDump(bool value);

    bool useParserDump() const { return _parserDump; }
    void useParserDump(bool value);

    bool useWriteLog() const { return _writeLog; }
    void useWriteLog(bool value);

    int getTimerDelay() const { return _delay; }
    void setTimerDelay(int x) { _delay = x; }

    bool showASCodingErrors() const { return _verboseASCodingErrors; }
    void showASCodingErrors(bool value);

    bool showMalformedSWFErrors() const { return _verboseMalformedSWF; }
    void showMalformedSWFErrors(bool value);

    bool showMalformedAMFErrors() const { return _verboseMalformedAMF; }
    void showMalformedAMFErrors(bool value);

    int getMovieLibraryLimit() const { return _movieLibraryLimit; }
    void setMovieLibraryLimit(int value) { _movieLibraryLimit = value; }

    bool enableExtensions() const { return _extensionsEnabled; }




    bool startStopped() const { return _startStopped; }
    void startStopped(bool value) { _startStopped = value; }

    bool insecureSSL() const { return _insecureSSL; }
    void insecureSSL(bool value) { _insecureSSL = value; }

    int qualityLevel() const { return _quality; }
    void qualityLevel(int value) { _quality = value; }

    int verbosityLevel() const { return _verbosity; }
    void verbosityLevel(int value) { _verbosity = value; }

    void setDebugLog(const std::string &x) { _log = x; }
    const std::string& getDebugLog() const { return _log; }

    void setDocumentRoot(const std::string &x) { _wwwroot = x; }
    std::string getDocumentRoot() { return _wwwroot; }

    bool useDebugger() const { return _debugger; }
    void useDebugger(bool value) { _debugger = value; }

    bool useSound() const { return _sound; }
    void useSound(bool value) { _sound = value; }



    bool usePluginSound() const { return _pluginSound; }
    void usePluginSound(bool value) { _pluginSound = value; }

    bool popupMessages() const { return _popups; }
    void interfacePopups(bool value) { _popups = value; }

    bool useLocalDomain() const { return _localdomainOnly; }
    void useLocalDomain(bool value);


    bool useLocalHost() const { return _localhostOnly; }


    void useLocalHost(bool value);

    typedef std::vector<std::string> PathList;




    const PathList& getWhiteList() const { return _whitelist; }




    void setWhitelist (const std::vector<std::string>& list) { _whitelist = list; }




    const PathList& getBlackList() const { return _blacklist; }




    void setBlacklist (const std::vector<std::string>& list) {
        _blacklist = list;
    }






    const PathList& getLocalSandboxPath() const { return _localSandboxPath; }


    void addLocalSandboxPath(const std::string& dir)
    {
        _localSandboxPath.push_back(dir);
    }






    void setLocalSandboxPath(const PathList& path)
    {
        _localSandboxPath = path;
    }

    const std::string& getFlashVersionString() const {
        return _flashVersionString;
    }

    void setFlashVersionString(const std::string& value) {
        _flashVersionString = value;
    }

    const std::string& getFlashSystemOS() const {
        return _flashSystemOS;
    }

    void setFlashSystemOS(const std::string& value) {
        _flashSystemOS = value;
    }

    const std::string& getFlashSystemManufacturer() const {
        return _flashSystemManufacturer;
    }

    void setFlashSystemManufacturer(const std::string& value) {
        _flashSystemManufacturer = value;
    }

    const std::string& getGstAudioSink() const { return _gstaudiosink; }

    void setGstAudioSink(const std::string& value) { _gstaudiosink = value; }

    int getRetries() const { return _retries; }

    void setRetries(int x) { _retries = x; }


    double getStreamsTimeout() const { return _streamsTimeout; }


    void setStreamsTimeout(const double &x) { _streamsTimeout = x; }






    const std::string &getURLOpenerFormat() const
    {
        return _urlOpenerFormat;
    }

    void setURLOpenerFormat(const std::string& value)
    {
        _urlOpenerFormat = value;
    }


    const std::string &getHWAccel() const { return _hwaccel; }


    void setHWAccel(const std::string &x) { _hwaccel = x; }


    const std::string& getRenderer() const { return _renderer; }


    void setRenderer(const std::string& x) { _renderer = x; }


    const std::string &getSOLSafeDir() const { return _solsandbox; }


    void setSOLSafeDir(const std::string &x) { _solsandbox = x; }

    bool getSOLLocalDomain() const { return _sollocaldomain; }

    void setSOLLocalDomain(bool x) { _sollocaldomain = x; }

    bool getSOLReadOnly() const { return _solreadonly; }

    void setSOLReadOnly(bool x) { _solreadonly = x; }

    bool getLocalConnection() const { return _lcdisabled; }

    void setLocalConnection(bool x) { _lcdisabled = x; }


    bool getLCTrace() const { return _lctrace; }

    void setLCTrace(bool x) { _lctrace = x; }

    key_t getLCShmKey() const { return static_cast<key_t>(_lcshmkey); }

    void setLCShmKey(bool x) { _lcshmkey = x; }

    bool ignoreFSCommand() const { return _ignoreFSCommand; }

    void ignoreFSCommand(bool value) { _ignoreFSCommand = value; }

    void saveStreamingMedia(bool value) { _saveStreamingMedia = value; }

    bool saveStreamingMedia() const { return _saveStreamingMedia; }

    void saveLoadedMedia(bool value) { _saveLoadedMedia = value; }

    bool saveLoadedMedia() const { return _saveLoadedMedia; }

    void setMediaDir(const std::string& value) { _mediaCacheDir = value; }

    const std::string& getMediaDir() const { return _mediaCacheDir; }

    void setWebcamDevice(int value) {_webcamDevice = value;}

    int getWebcamDevice() const {return _webcamDevice;}

    void setAudioInputDevice(int value) {_microphoneDevice = value;}

    int getAudioInputDevice() {return _microphoneDevice;}


    const std::string& getRootCert() const {
        return _rootcert;
    }

    void setRootCert(const std::string& value) {
        _rootcert = value;
    }


    const std::string& getCertFile() const {
        return _certfile;
    }

    void setCertFile(const std::string& value) {
        _certfile = value;
    }


    const std::string& getCertDir() const {
        return _certdir;
    }

    void setCertDir(const std::string& value) {
        _certdir = value;
    }

    void ignoreShowMenu(bool value) { _ignoreShowMenu= value; }

    bool ignoreShowMenu() const { return _ignoreShowMenu; }

    void dump();

protected:


    void writeList(const PathList& list, std::ostream& o);


    RcInitFile();


    ~RcInitFile();





    static void expandPath(std::string& path);
# 365 "../libbase/rc.h"
    static bool extractSetting(bool &var, const std::string& pattern,
                        const std::string &variable, const std::string &value);
# 377 "../libbase/rc.h"
    template<typename T>
    static bool extractNumber(T& num, const std::string& pattern,
                        const std::string &variable, const std::string &value)
    {

        StringNoCaseEqual noCaseCompare;

        if (noCaseCompare(variable, pattern)) {
            std::istringstream in(value);
            if (in >> num) return true;



            std::cerr << "Conversion overflow in extractNumber: " <<
                value << std::endl;
            num = 0;
            return true;
        }

        return false;
    }
# 408 "../libbase/rc.h"
    static bool extractDouble(double &out, const std::string& pattern,
                        const std::string &variable, const std::string &value);
# 418 "../libbase/rc.h"
    void parseList(std::vector<std::string>& list, const std::string &action,
           const std::string &items);

    typedef boost::char_separator<char> Sep;
    typedef boost::tokenizer< Sep > Tok;


    boost::uint32_t _delay;


    boost::uint32_t _movieLibraryLimit;


    bool _debug;


    bool _debugger;


    boost::uint32_t _verbosity;






    std::string _urlOpenerFormat;


    std::string _flashVersionString;


    std::string _gstaudiosink;




    std::string _flashSystemOS;




    std::string _flashSystemManufacturer;


    bool _actionDump;


    bool _parserDump;


    bool _verboseASCodingErrors;


    bool _verboseMalformedSWF;


    bool _verboseMalformedAMF;


    bool _splashScreen;


    bool _localdomainOnly;


    bool _localhostOnly;


    PathList _whitelist;


    PathList _blacklist;


    std::string _log;


    bool _writeLog;


    std::string _wwwroot;


    int _retries;


    bool _sound;


    bool _pluginSound;


    bool _extensionsEnabled;


    bool _startStopped;


    bool _insecureSSL;


    double _streamsTimeout;



    PathList _localSandboxPath;



    std::string _solsandbox;


    bool _solreadonly;
    bool _sollocaldomain;


    bool _lcdisabled;


    bool _lctrace;



    boost::uint32_t _lcshmkey;



    bool _ignoreFSCommand;


    int _quality;

    bool _saveStreamingMedia;

    bool _saveLoadedMedia;

    std::string _mediaCacheDir;

    bool _popups;

    bool _useXv;



    int _webcamDevice;

    int _microphoneDevice;



    std::string _certfile;



    std::string _certdir;



    std::string _rootcert;



    bool _ignoreShowMenu;




    std::string _hwaccel;




    std::string _renderer;
};


}
# 27 "../libbase/log.h" 2


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3




# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 2 3
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 1 3 4
# 30 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern "C" {



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 35 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 2 3 4
# 75 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 1 3 4
# 32 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/_G_config.h" 1 3 4
# 15 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/_G_config.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 16 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/_G_config.h" 2 3 4




# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/wchar.h" 1 3 4
# 21 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 2 3 4
# 53 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stdarg.h" 1 3 4
# 54 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 2 3 4
# 170 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 490 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 552 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/libio.h" 3 4
}
# 76 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 109 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 161 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/stdio_lim.h" 1 3 4
# 162 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 202 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 224 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 249 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 259 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 292 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 414 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 465 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 524 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 552 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 563 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 596 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 642 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 658 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 719 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 730 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 766 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 785 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 808 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sys_errlist.h" 1 3 4
# 27 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 847 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 866 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 927 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/stdio.h" 1 3 4
# 36 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 928 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 2 3 4
# 936 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/stdio.h" 3 4
}
# 46 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 2 3
# 93 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 150 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 167 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/basic_file.h" 1 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/basic_file.h" 3
       
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/basic_file.h" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++io.h" 1 3
# 36 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++io.h" 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstdio" 2 3
# 37 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++io.h" 2 3
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 38 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;

}
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/mips64el-unknown-linux-gnu/bits/basic_file.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };

}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 66 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 128 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      { this->close(); }





      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 264 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 291 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 323 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 343 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 386 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
  const bool __testin = _M_mode & ios_base::in;
  const bool __testout = _M_mode & ios_base::out;

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(__null, __null);
      }
    };
# 414 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 441 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 454 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 486 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      ~basic_ifstream()
      { }
# 496 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 525 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 563 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 582 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 609 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 623 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 657 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      ~basic_ofstream()
      { }
# 667 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 696 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 736 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 755 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 783 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 795 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(__null), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 826 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      ~basic_fstream()
      { }
# 836 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 865 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 905 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };

}


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/fstream.tcc" 1 3
# 39 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/fstream.tcc" 3
       
# 40 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/fstream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = __null;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = __null;
      _M_ext_buf_size = 0;
      _M_ext_next = __null;
      _M_ext_end = __null;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(__null), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = __null;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return __null;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     _M_file.close();
     throw;
   }
 catch(...)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return __null;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && !_M_writing)
 {



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             );
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && !_M_writing)
 {


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = _M_mode & ios_base::out;
      if (__testout && !_M_reading)
 {
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

   template<typename _CharT, typename _Traits>
     streamsize
     basic_filebuf<_CharT, _Traits>::
     xsgetn(_CharT* __s, streamsize __n)
     {

       streamsize __ret = 0;
       if (_M_pback_init)
  {
    if (__n > 0 && this->gptr() == this->eback())
      {
        *__s++ = *this->gptr();
        this->gbump(1);
        __ret = 1;
        --__n;
      }
    _M_destroy_pback();
  }




       const bool __testin = _M_mode & ios_base::in;
       const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

       if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
    && __testin && !_M_writing)
  {

    const streamsize __avail = this->egptr() - this->gptr();
    if (__avail != 0)
      {
        if (__avail == 1)
   *__s = *this->gptr();
        else
   traits_type::copy(__s, this->gptr(), __avail);
        __s += __avail;
        this->gbump(__avail);
        __ret += __avail;
        __n -= __avail;
      }



    streamsize __len;
    for (;;)
      {
        __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
          __n);
        if (__len == -1)
   __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                               );
        if (__len == 0)
   break;

        __n -= __len;
        __ret += __len;
        if (__n == 0)
   break;

        __s += __len;
      }

    if (__n == 0)
      {
        _M_set_buffer(0);
        _M_reading = true;
      }
    else if (__len == 0)
      {



        _M_set_buffer(-1);
        _M_reading = false;
      }
  }
       else
  __ret += __streambuf_type::xsgetn(__s, __n);

       return __ret;
     }

   template<typename _CharT, typename _Traits>
     streamsize
     basic_filebuf<_CharT, _Traits>::
     xsputn(const _CharT* __s, streamsize __n)
     {



       streamsize __ret = 0;
       const bool __testout = _M_mode & ios_base::out;
       if (__check_facet(_M_codecvt).always_noconv()
    && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 673 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {

   _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       if (_M_codecvt->always_noconv())
  __computed_off += this->gptr() - this->egptr();
       else
  {



    const int __gptr_off =
      _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,
           this->gptr() - this->eback());
    __computed_off += _M_ext_buf + __gptr_off - _M_ext_end;



    __state = _M_state_last;
  }
     }
   __ret = _M_seek(__computed_off, __way, __state);
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {

   __ret = pos_type(_M_file.seekoff(__off, __way));
   if (__ret != pos_type(off_type(-1)))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }





  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;



}
# 917 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/fstream" 2 3
# 30 "../libbase/log.h" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/compat_workarounds.hpp" 1
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/compat_workarounds.hpp"
namespace boost {
    namespace io {



        template<class Tr>
        class CompatTraits;




        template<class Alloc>
        class CompatAlloc;
    }
}


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/config_macros.hpp" 1
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/config_macros.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/workarounds_gcc-2_95.hpp" 1
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/config_macros.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/workarounds_stlport.hpp" 1
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/config_macros.hpp" 2
# 86 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/config_macros.hpp"
namespace boost { namespace io { namespace detail {

    typedef ::std:: locale locale_t;



} } }
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/compat_workarounds.hpp" 2
# 65 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/compat_workarounds.hpp"
namespace boost {
    namespace io {


        template<class Tr>
        class CompatTraits
        {
        public:
            typedef Tr compatible_type;
        };


        template<class Alloc>
        class CompatAlloc
        {
        public:
            typedef Alloc compatible_type;
        };

    }
}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_fwd.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_fwd.hpp"
namespace boost {

    template <class Ch,


        class Tr = ::std:: char_traits<Ch>, class Alloc = std::allocator<Ch> >



    class basic_format;

    typedef basic_format<char > format;



    typedef basic_format<wchar_t > wformat;


    namespace io {
        enum format_error_bits { bad_format_string_bit = 1,
                                 too_few_args_bit = 2, too_many_args_bit = 4,
                                 out_of_range_bit = 8,
                                 all_error_bits = 255, no_error_bits=0 };

    }

}
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals_fwd.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals_fwd.hpp"
namespace boost {
namespace io {

namespace detail {
  template<class Ch, class Tr> struct stream_format_state;
    template<class Ch, class Tr, class Alloc> struct format_item;





    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self,
                      int itemN, T manipulator);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self,
                   int argN, const T& val);


    template<class Ch, class Tr, class T>
    void apply_manip_body (stream_format_state<Ch, Tr>& self,
                           T manipulator);


    template<class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x);

}

}
}
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream.hpp" 2

namespace boost {
    namespace io {

        template<class Ch, class Tr=::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_altstringbuf;

        template<class Ch, class Tr =::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_oaltstringstream;


        template<class Ch, class Tr, class Alloc>
        class basic_altstringbuf
            : public ::std::basic_streambuf<Ch, Tr>
        {
            typedef ::std::basic_streambuf<Ch, Tr> streambuf_t;
            typedef typename CompatAlloc<Alloc>::compatible_type compat_allocator_type;
            typedef typename CompatTraits<Tr>::compatible_type compat_traits_type;
        public:
            typedef Ch char_type;
            typedef Tr traits_type;
            typedef typename compat_traits_type::int_type int_type;
            typedef typename compat_traits_type::pos_type pos_type;
            typedef typename compat_traits_type::off_type off_type;
            typedef Alloc allocator_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;

            typedef ::std::streamsize streamsize;


            explicit basic_altstringbuf(std::ios_base::openmode mode
                                        = std::ios_base::in | std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                {}
            explicit basic_altstringbuf(const string_type& s,
                                        ::std::ios_base::openmode mode
                                        = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }
            virtual ~basic_altstringbuf()
                { dealloc(); }
            using streambuf_t::pbase;
            using streambuf_t::pptr;
            using streambuf_t::epptr;
            using streambuf_t::eback;
            using streambuf_t::gptr;
            using streambuf_t::egptr;

            void clear_buffer();
            void str(const string_type& s);


            Ch * begin() const;
            size_type size() const;
            size_type cur_size() const;
            Ch * pend() const
                { return ((putend_ < pptr()) ? pptr() : putend_); }
            size_type pcount() const
                { return static_cast<size_type>( pptr() - pbase()) ;}


            string_type str() const
                { return string_type(begin(), size()); }
            string_type cur_str() const
                { return string_type(begin(), cur_size()); }
        protected:
            explicit basic_altstringbuf (basic_altstringbuf * s,
                                         ::std::ios_base::openmode mode
                                         = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }

            virtual pos_type seekoff(off_type off, ::std::ios_base::seekdir way,
                                     ::std::ios_base::openmode which
                                     = ::std::ios_base::in | ::std::ios_base::out);
            virtual pos_type seekpos (pos_type pos,
                                      ::std::ios_base::openmode which
                                      = ::std::ios_base::in | ::std::ios_base::out);
            virtual int_type underflow();
            virtual int_type pbackfail(int_type meta = compat_traits_type::eof());
            virtual int_type overflow(int_type meta = compat_traits_type::eof());
            void dealloc();
        private:
            enum { alloc_min = 256};

            Ch *putend_;
            bool is_allocated_;
            ::std::ios_base::openmode mode_;
            compat_allocator_type alloc_;
        };



        template <class Ch, class Tr, class Alloc>
        class basic_oaltstringstream
            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
              public ::std::basic_ostream<Ch, Tr>
        {
            class No_Op {

            public:
                template<class T>
                const T & operator()(const T & arg) { return arg; }
            };
            typedef ::std::basic_ostream<Ch, Tr> stream_t;
            typedef boost::base_from_member<boost::shared_ptr<
                basic_altstringbuf<Ch,Tr, Alloc> > >
                pbase_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;
            typedef basic_altstringbuf<Ch, Tr, Alloc> stringbuf_t;
        public:
            typedef Alloc allocator_type;
            basic_oaltstringstream()
                : pbase_type(new stringbuf_t), stream_t(rdbuf())
                { }
            basic_oaltstringstream(::boost::shared_ptr<stringbuf_t> buf)
                : pbase_type(buf), stream_t(rdbuf())
                { }
            basic_oaltstringstream(stringbuf_t * buf)
                : pbase_type(buf, No_Op() ), stream_t(rdbuf())
                { }
            stringbuf_t * rdbuf() const
                { return pbase_type::member.get(); }
            void clear_buffer()
                { rdbuf()->clear_buffer(); }


            Ch * begin() const
                { return rdbuf()->begin(); }
            size_type size() const
                { return rdbuf()->size(); }
            size_type cur_size() const
                { return rdbuf()->cur_size(); }


            string_type str() const
                { return rdbuf()->str(); }
            string_type cur_str() const
                { return rdbuf()->cur_str(); }
            void str(const string_type& s)
                { rdbuf()->str(s); }
        };

    }
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream_impl.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream_impl.hpp"
namespace boost {
    namespace io {


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        clear_buffer () {
            const Ch * p = pptr();
            const Ch * b = pbase();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::out);
            }
            p = gptr();
            b = eback();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::in);
            }
        }

        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        str (const string_type& s) {
            size_type sz=s.size();
            if(sz != 0 && mode_ & (::std::ios_base::in | ::std::ios_base::out) ) {




                Ch *new_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);


                dealloc();
                sz = s.copy(new_ptr, sz);
                putend_ = new_ptr + sz;
                if(mode_ & ::std::ios_base::in)
                    streambuf_t::setg(new_ptr, new_ptr, new_ptr + sz);
                if(mode_ & ::std::ios_base::out) {
                    streambuf_t::setp(new_ptr, new_ptr + sz);
                    if(mode_ & (::std::ios_base::app | ::std::ios_base::ate))
                        streambuf_t::pbump(static_cast<int>(sz));
                    if(gptr() == __null)
                        streambuf_t::setg(new_ptr, __null, new_ptr);
                }
                is_allocated_ = true;
            }
            else
                dealloc();
        }
        template<class Ch, class Tr, class Alloc>
        Ch* basic_altstringbuf<Ch, Tr, Alloc>::
        begin () const {
            if(mode_ & ::std::ios_base::out && pptr() != __null)
                return pbase();
            else if(mode_ & ::std::ios_base::in && gptr() != __null)
                return eback();
            return __null;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<size_type>(pend() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<size_type>(egptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        cur_size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<streamsize>( pptr() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<streamsize>( gptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekoff (off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) {
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(which & ::std::ios_base::in && gptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - gptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(eback() - gptr());
                else if(way != ::std::ios_base::cur || (which & ::std::ios_base::out) )

                    return pos_type(off_type(-1));
                if(eback() <= off+gptr() && off+gptr() <= putend_ ) {

                    streambuf_t::gbump(static_cast<int>(off));
                    if(which & ::std::ios_base::out && pptr() != __null)

                        streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                }
                else
                    off = off_type(-1);
            }
            else if(which & ::std::ios_base::out && pptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - pptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(pbase() - pptr());
                else if(way != ::std::ios_base::beg)
                    return pos_type(off_type(-1));
                if(pbase() <= off+pptr() && off+pptr() <= putend_)

                    streambuf_t::pbump(static_cast<int>(off));
                else
                    off = off_type(-1);
            }
            else
                off = off_type(-1);
            return (pos_type(off));
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekpos (pos_type pos, ::std::ios_base::openmode which) {
            off_type off = off_type(pos);
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(off != off_type(-1)) {
                if(which & ::std::ios_base::in && gptr() != __null) {

                    if(0 <= off && off <= putend_ - eback()) {
                        streambuf_t::gbump(static_cast<int>(eback() - gptr() + off));
                        if(which & ::std::ios_base::out && pptr() != __null) {

                            streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                        }
                    }
                    else
                        off = off_type(-1);
                }
                else if(which & ::std::ios_base::out && pptr() != __null) {

                    if(0 <= off && off <= putend_ - eback())
                        streambuf_t::pbump(static_cast<int>(eback() - pptr() + off));
                    else
                        off = off_type(-1);
                }
                else
                    off = off_type(-1);
                return (pos_type(off));
            }
            else {
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream_impl.hpp", 176, __PRETTY_FUNCTION__));
                return pos_type(off_type(-1));
            }
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        underflow () {
            if(gptr() == __null)
                return (compat_traits_type::eof());
            else if(gptr() < egptr())
                return (compat_traits_type::to_int_type(*gptr()));
            else if(mode_ & ::std::ios_base::in && pptr() != __null
                    && (gptr() < pptr() || gptr() < putend_) )
                {
                    if(putend_ < pptr())
                        putend_ = pptr();
                    streambuf_t::setg(eback(), gptr(), putend_);
                    return (compat_traits_type::to_int_type(*gptr()));
                }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        pbackfail (int_type meta) {
            if(gptr() != __null && (eback() < gptr())
               && (mode_ & (::std::ios_base::out)
                   || compat_traits_type::eq_int_type(compat_traits_type::eof(), meta)
                   || compat_traits_type::eq(compat_traits_type::to_char_type(meta), gptr()[-1]) ) ) {
                streambuf_t::gbump(-1);
                if(!compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))

                    *gptr() = compat_traits_type::to_char_type(meta);
                return (compat_traits_type::not_eof(meta));
            }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        overflow (int_type meta) {




            if(compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))
                return compat_traits_type::not_eof(meta);
            else if(pptr() != __null && pptr() < epptr()) {
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }
            else if(! (mode_ & ::std::ios_base::out))

                return compat_traits_type::eof();
            else {
                std::size_t prev_size = pptr() == __null ? 0 : epptr() - eback();
                std::size_t new_size = prev_size;

                std::size_t add_size = new_size / 2;
                if(add_size < alloc_min)
                    add_size = alloc_min;
                Ch * newptr = __null, *oldptr = eback();


                while (0 < add_size && ((std::numeric_limits<std::size_t>::max)()
                                        - add_size < new_size) )
                    add_size /= 2;
                if(0 < add_size) {
                    new_size += add_size;




                    newptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);

                }

                if(0 < prev_size)
                    compat_traits_type::copy(newptr, oldptr, prev_size);
                if(is_allocated_)
                    alloc_.deallocate(oldptr, prev_size);
                is_allocated_=true;

                if(prev_size == 0) {
                    putend_ = newptr;
                    streambuf_t::setp(newptr, newptr + new_size);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr, newptr + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                else {
                    putend_ = putend_ - oldptr + newptr;
                    int pptr_count = static_cast<int>(pptr()-pbase());
                    int gptr_count = static_cast<int>(gptr()-eback());
                    streambuf_t::setp(pbase() - oldptr + newptr, newptr + new_size);
                    streambuf_t::pbump(pptr_count);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr + gptr_count, pptr() + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }



        }


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>:: dealloc() {
            if(is_allocated_)
                alloc_.deallocate(eback(), (pptr() != __null ? epptr() : egptr()) - eback());
            is_allocated_ = false;
            streambuf_t::setg(0, 0, 0);
            streambuf_t::setp(0, 0);
            putend_ = __null;
        }

    }
}
# 174 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/alt_sstream.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals.hpp" 2

namespace boost {
namespace io {
namespace detail {





    template<class Ch, class Tr>
    struct stream_format_state
    {
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;

        stream_format_state(Ch fill) { reset(fill); }


        void reset(Ch fill);
        void set_by_stream(const basic_ios& os);
        void apply_on(basic_ios & os,
                      boost::io::detail::locale_t * loc_default = 0) const;
        template<class T>
        void apply_manip(T manipulator)
            { apply_manip_body<Ch, Tr, T>( *this, manipulator) ; }


        std::streamsize width_;
        std::streamsize precision_;
        Ch fill_;
        std::ios_base::fmtflags flags_;
        std::ios_base::iostate rdstate_;
        std::ios_base::iostate exceptions_;
        boost::optional<boost::io::detail::locale_t> loc_;
    };





    template<class Ch, class Tr, class Alloc>
    struct format_item
    {
        enum pad_values { zeropad = 1, spacepad =2, centered=4, tabulation = 8 };



        enum arg_values { argN_no_posit = -1,
                          argN_tabulation = -2,
                          argN_ignored = -3
        };
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;
        typedef detail::stream_format_state<Ch, Tr> stream_format_state;
        typedef ::std::basic_string<Ch, Tr, Alloc> string_type;

        format_item(Ch fill) :argN_(argN_no_posit), fmtstate_(fill),
                              truncate_(max_streamsize()), pad_scheme_(0) {}
        void reset(Ch fill);
        void compute_states();

        static std::streamsize max_streamsize() {
            return (std::numeric_limits<std::streamsize>::max)();
        }


        int argN_;

        string_type res_;
        string_type appendix_;

        stream_format_state fmtstate_;

        std::streamsize truncate_;
        unsigned int pad_scheme_;
    };






    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: apply_on (basic_ios & os,
                      boost::io::detail::locale_t * loc_default) const {

        if(width_ != -1)
            os.width(width_);
        if(precision_ != -1)
            os.precision(precision_);
        if(fill_ != 0)
            os.fill(fill_);
        os.flags(flags_);
        os.clear(rdstate_);
        os.exceptions(exceptions_);

        if(loc_)
            os.imbue(loc_.get());
        else if(loc_default)
            os.imbue(*loc_default);



    }

    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: set_by_stream(const basic_ios& os) {

        flags_ = os.flags();
        width_ = os.width();
        precision_ = os.precision();
        fill_ = os.fill();
        rdstate_ = os.rdstate();
        exceptions_ = os.exceptions();
    }


    template<class Ch, class Tr, class T>
    void apply_manip_body( stream_format_state<Ch, Tr>& self,
                           T manipulator) {

        basic_oaltstringstream<Ch, Tr> ss;
        self.apply_on( ss );
        ss << manipulator;
        self.set_by_stream( ss );
    }

    template<class Ch, class Tr> inline
    void stream_format_state<Ch,Tr>:: reset(Ch fill) {

        width_=0; precision_=6;
        fill_=fill;
        flags_ = std::ios_base::dec | std::ios_base::skipws;

        exceptions_ = std::ios_base::goodbit;
        rdstate_ = std::ios_base::goodbit;
    }




    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    reset (Ch fill) {
        argN_=argN_no_posit; truncate_ = max_streamsize(); pad_scheme_ =0;
        res_.resize(0); appendix_.resize(0);
        fmtstate_.reset(fill);
    }

    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    compute_states() {


        if(pad_scheme_ & zeropad) {

            if(fmtstate_.flags_ & std::ios_base::left) {
              ((!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))) ? static_cast<void> (0) : __assert_fail ("!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/internals.hpp", 179, __PRETTY_FUNCTION__));

              pad_scheme_ = pad_scheme_ & (~zeropad);
            }
            else {
                pad_scheme_ &= ~spacepad;
                fmtstate_.fill_='0';
                fmtstate_.flags_ = (fmtstate_.flags_ & ~std::ios_base::adjustfield)
                    | std::ios_base::internal;

            }
        }
        if(pad_scheme_ & spacepad) {
            if(fmtstate_.flags_ & std::ios_base::showpos)
                pad_scheme_ &= ~spacepad;
        }
    }


} } }
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_class.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_class.hpp"
namespace boost {

    template<class Ch, class Tr, class Alloc>
    class basic_format
    {
        typedef typename io::CompatTraits<Tr>::compatible_type compat_traits;
    public:
        typedef Ch CharT;
        typedef std::basic_string<Ch, Tr, Alloc> string_type;
        typedef typename string_type::size_type size_type;
        typedef io::detail::format_item<Ch, Tr, Alloc> format_item_t;
        typedef io::basic_altstringbuf<Ch, Tr, Alloc> internal_streambuf_t;


        explicit basic_format(const Ch* str=__null);
        explicit basic_format(const string_type& s);
        basic_format(const basic_format& x);
        basic_format& operator= (const basic_format& x);
        void swap(basic_format& x);


        explicit basic_format(const Ch* str, const std::locale & loc);
        explicit basic_format(const string_type& s, const std::locale & loc);

        io::detail::locale_t getloc() const;

        basic_format& clear();
        basic_format& clear_binds();
        basic_format& parse(const string_type&);


        size_type size() const;
        string_type str() const;


        template<class T>
        basic_format& operator%(const T& x)
            { return io::detail::feed<CharT, Tr, Alloc, const T&>(*this,x); }


        template<class T> basic_format& operator%(T& x)
            { return io::detail::feed<CharT, Tr, Alloc, T&>(*this,x); }





        basic_format& operator%(const int& x)
            { return io::detail::feed<CharT, Tr, Alloc, const int&>(*this,x); }


        basic_format& operator%(int& x)
            { return io::detail::feed<CharT, Tr, Alloc, int&>(*this,x); }




        int expected_args() const
            { return num_args_; }

        int bound_args() const;

        int fed_args() const;

        int cur_arg() const;

        int remaining_args() const;



        template<class T>
        basic_format& bind_arg(int argN, const T& val)
            { return io::detail::bind_arg_body(*this, argN, val); }
        basic_format& clear_bind(int argN);
        template<class T>
        basic_format& modify_item(int itemN, T manipulator)
            { return io::detail::modify_item_body<Ch,Tr, Alloc, T> (*this, itemN, manipulator);}


        unsigned char exceptions() const;
        unsigned char exceptions(unsigned char newexcept);
# 116 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_class.hpp"
        template<class Ch2, class Tr2, class Alloc2>
        friend std::basic_ostream<Ch2, Tr2> &
        operator<<( std::basic_ostream<Ch2, Tr2> & ,
                    const basic_format<Ch2, Tr2, Alloc2>& );







        template<class Ch2, class Tr2, class Alloc2, class T>
        friend basic_format<Ch2, Tr2, Alloc2>&
        io::detail::feed (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        void io::detail::distribute (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::modify_item_body (basic_format<Ch2, Tr2, Alloc2>&, int, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::bind_arg_body (basic_format<Ch2, Tr2, Alloc2>&, int, const T&);

    private:

        typedef io::detail::stream_format_state<Ch, Tr> stream_format_state;

        enum style_values { ordered = 1,
                             special_needs = 4 };

        void make_or_reuse_data(std::size_t nbitems);


        std::vector<format_item_t> items_;
        std::vector<bool> bound_;

        int style_;
        int cur_arg_;
        int num_args_;
        mutable bool dumped_;
        string_type prefix_;
        unsigned char exceptions_;
        internal_streambuf_t buf_;
        boost::optional<io::detail::locale_t> loc_;
    };

}
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/exceptions.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/exceptions.hpp"
namespace boost {

    namespace io {



        class format_error : public std::exception
        {
        public:
            format_error() {}
            virtual const char *what() const throw() {
                return "boost::format_error: "
                    "format generic failure";
            }
        };

        class bad_format_string : public format_error
        {
            std::size_t pos_, next_;
        public:
            bad_format_string(std::size_t pos, std::size_t size)
                : pos_(pos), next_(size) {}
            std::size_t get_pos() const { return pos_; }
            std::size_t get_next() const { return next_; }
            virtual const char *what() const throw() {
                return "boost::bad_format_string: format-string is ill-formed";
            }
        };

        class too_few_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_few_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_few_args: "
                    "format-string referred to more arguments than were passed";
            }
        };

        class too_many_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_many_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_many_args: "
                    "format-string referred to less arguments than were passed";
            }
        };


        class out_of_range : public format_error
        {
            int index_, beg_, end_;
        public:
            out_of_range(int index, int beg, int end)
                : index_(index), beg_(beg), end_(end) {}
            int get_index() const { return index_; }
            int get_beg() const { return beg_; }
            int get_end() const { return end_; }
            virtual const char *what() const throw() {
                return "boost::out_of_range: "
                    "tried to refer to an argument (or item) number which"
                    " is out of range, according to the format string";
            }
        };


    }

}
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp" 2



namespace boost {



    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        if( s)
            parse( s );
    }


    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        if(s) parse( s );
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    io::detail::locale_t basic_format<Ch, Tr, Alloc>::
    getloc() const {
        return loc_ ? loc_.get() : io::detail::locale_t();
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const basic_format& x)
        : items_(x.items_), bound_(x.bound_), style_(x.style_),
          cur_arg_(x.cur_arg_), num_args_(x.num_args_), dumped_(x.dumped_),
          prefix_(x.prefix_), exceptions_(x.exceptions_), loc_(x.loc_)
    {
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    operator= (const basic_format& x) {
        if(this == &x)
            return *this;
        (basic_format<Ch, Tr, Alloc>(x)).swap(*this);
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    swap (basic_format & x) {
        std::swap(exceptions_, x.exceptions_);
        std::swap(style_, x.style_);
        std::swap(cur_arg_, x.cur_arg_);
        std::swap(num_args_, x.num_args_);
        std::swap(dumped_, x.dumped_);

        items_.swap(x.items_);
        prefix_.swap(x.prefix_);
        bound_.swap(x.bound_);
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions() const {
        return exceptions_;
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions(unsigned char newexcept) {
        unsigned char swp = exceptions_;
        exceptions_ = newexcept;
        return swp;
    }

    template<class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    make_or_reuse_data (std::size_t nbitems) {

        Ch fill = ( std::use_facet< std::ctype<Ch> >(getloc()) ). widen(' ');



        if(items_.size() == 0)
            items_.assign( nbitems, format_item_t(fill) );
        else {
            if(nbitems>items_.size())
                items_.resize(nbitems, format_item_t(fill));
            bound_.resize(0);
            for(std::size_t i=0; i < nbitems; ++i)
                items_[i].reset(fill);
        }
        prefix_.resize(0);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear () {



        ((bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())) ? static_cast<void> (0) : __assert_fail ("bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp", 135, __PRETTY_FUNCTION__));

        for(unsigned long i=0; i<items_.size(); ++i) {

            if( bound_.size()==0 || items_[i].argN_<0 || !bound_[ items_[i].argN_ ] )
                items_[i].res_.resize(0);
        }
        cur_arg_=0; dumped_=false;

        if(bound_.size() != 0) {
            for(; cur_arg_ < num_args_ && bound_[cur_arg_]; ++cur_arg_)
                {}
        }
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_binds () {

        bound_.resize(0);
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_bind (int argN) {

        if(argN<1 || argN > num_args_ || bound_.size()==0 || !bound_[argN-1] ) {
            if( exceptions() & io::out_of_range_bit)
                boost::throw_exception(io::out_of_range(argN, 1, num_args_+1 ) );
            else return *this;
        }
        bound_[argN-1]=false;
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    bound_args() const {
        if(bound_.size()==0)
            return 0;
        int n=0;
        for(int i=0; i<num_args_ ; ++i)
            if(bound_[i])
                ++n;
        return n;
    }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    fed_args() const {
        if(bound_.size()==0)
            return cur_arg_;
        int n=0;
        for(int i=0; i<cur_arg_ ; ++i)
            if(!bound_[i])
                ++n;
        return n;
    }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    cur_arg() const {
      return cur_arg_+1; }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    remaining_args() const {
        if(bound_.size()==0)
            return num_args_-cur_arg_;
        int n=0;
        for(int i=cur_arg_; i<num_args_ ; ++i)
            if(!bound_[i])
                ++n;
        return n;
    }

    template< class Ch, class Tr, class Alloc>
    typename basic_format<Ch, Tr, Alloc>::string_type
    basic_format<Ch,Tr, Alloc>::
    str () const {
        if(items_.size()==0)
            return prefix_;
        if( cur_arg_ < num_args_)
            if( exceptions() & io::too_few_args_bit )

                boost::throw_exception(io::too_few_args(cur_arg_, num_args_));

        unsigned long i;
        string_type res;
        res.reserve(size());
        res += prefix_;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            res += item.res_;
            if( item.argN_ == format_item_t::argN_tabulation) {
                ((item.pad_scheme_ & format_item_t::tabulation) ? static_cast<void> (0) : __assert_fail ("item.pad_scheme_ & format_item_t::tabulation", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp", 234, __PRETTY_FUNCTION__));
                if( static_cast<size_type>(item.fmtstate_.width_) > res.size() )
                    res.append( static_cast<size_type>(item.fmtstate_.width_) - res.size(),
                                        item.fmtstate_.fill_ );
            }
            res += item.appendix_;
        }
        dumped_=true;
        return res;
    }
    template< class Ch, class Tr, class Alloc>
    typename std::basic_string<Ch, Tr, Alloc>::size_type basic_format<Ch,Tr, Alloc>::
    size () const {







        using std::max;
        size_type sz = prefix_.size();
        unsigned long i;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            sz += item.res_.size();
            if( item.argN_ == format_item_t::argN_tabulation)
                sz = max (sz,
                                        static_cast<size_type>(item.fmtstate_.width_) );
            sz += item.appendix_.size();
        }
        return sz;



    }

namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self, int argN, const T& val) {


        if(self.dumped_)
            self.clear();
        if(argN<1 || argN > self.num_args_) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(argN, 1, self.num_args_+1 ) );
            else return self;
        }
        if(self.bound_.size()==0)
            self.bound_.assign(self.num_args_,false);
        else
            ((self.num_args_ == static_cast<signed int>(self.bound_.size())) ? static_cast<void> (0) : __assert_fail ("self.num_args_ == static_cast<signed int>(self.bound_.size())", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp", 289, __PRETTY_FUNCTION__));
        int o_cur_arg = self.cur_arg_;
        self.cur_arg_ = argN-1;

        self.bound_[self.cur_arg_]=false;
        self.operator%(val);



        self.cur_arg_ = o_cur_arg;
        self.bound_[argN-1]=true;
        if(self.cur_arg_ == argN-1 ) {

            while(self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_])
                ++self.cur_arg_;
        }

        ((self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]) ? static_cast<void> (0) : __assert_fail ("self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/format_implementation.hpp", 306, __PRETTY_FUNCTION__));
        return self;
    }

    template<class Ch, class Tr, class Alloc, class T> basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self, int itemN, T manipulator) {


        if(itemN<1 || itemN > static_cast<signed int>(self.items_.size() )) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(itemN, 1, static_cast<int>(self.items_.size()) ));
            else return self;
        }
        self.items_[itemN-1].fmtstate_. template apply_manip<T> ( manipulator );
        return self;
    }

}
}
}
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/group.hpp" 1
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/group.hpp"
namespace boost {
namespace io {


namespace detail {



struct group0
{
    group0() {}
};

template <class Ch, class Tr>
inline
::std:: basic_ostream<Ch, Tr>&
operator << ( ::std:: basic_ostream<Ch, Tr>& os,
             const group0& )
{
   return os;
}

template <class T1>
struct group1
{
    T1 a1_;
    group1(T1 a1)
      : a1_(a1)
      {}
private:
   group1& operator=(const group1&);
};

template <class Ch, class Tr, class T1>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group1<T1>& x)
{
   os << x.a1_;
   return os;
}




template <class T1,class T2>
struct group2
{
    T1 a1_;
    T2 a2_;
    group2(T1 a1,T2 a2)
      : a1_(a1),a2_(a2)
      {}
private:
   group2& operator=(const group2&);
};

template <class Ch, class Tr, class T1,class T2>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group2<T1,T2>& x)
{
   os << x.a1_<< x.a2_;
   return os;
}

template <class T1,class T2,class T3>
struct group3
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    group3(T1 a1,T2 a2,T3 a3)
      : a1_(a1),a2_(a2),a3_(a3)
      {}
private:
   group3& operator=(const group3&);
};

template <class Ch, class Tr, class T1,class T2,class T3>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group3<T1,T2,T3>& x)
{
   os << x.a1_<< x.a2_<< x.a3_;
   return os;
}

template <class T1,class T2,class T3,class T4>
struct group4
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    group4(T1 a1,T2 a2,T3 a3,T4 a4)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4)
      {}
private:
   group4& operator=(const group4&);
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group4<T1,T2,T3,T4>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5>
struct group5
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    group5(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group5<T1,T2,T3,T4,T5>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
struct group6
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    group6(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group6<T1,T2,T3,T4,T5,T6>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
struct group7
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    group7(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group7<T1,T2,T3,T4,T5,T6,T7>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
struct group8
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    group8(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group8<T1,T2,T3,T4,T5,T6,T7,T8>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
struct group9
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    group9(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
struct group10
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    T10 a10_;
    group10(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9,T10 a10)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9),a10_(a10)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_<< x.a10_;
   return os;
}




template <class T1,class T2>
inline
group1<T1>
group_head( group2<T1,T2> const& x)
{
   return group1<T1> (x.a1_);
}

template <class T1,class T2>
inline
group1<T2>
group_last( group2<T1,T2> const& x)
{
   return group1<T2> (x.a2_);
}



template <class T1,class T2,class T3>
inline
group2<T1,T2>
group_head( group3<T1,T2,T3> const& x)
{
   return group2<T1,T2> (x.a1_,x.a2_);
}

template <class T1,class T2,class T3>
inline
group1<T3>
group_last( group3<T1,T2,T3> const& x)
{
   return group1<T3> (x.a3_);
}



template <class T1,class T2,class T3,class T4>
inline
group3<T1,T2,T3>
group_head( group4<T1,T2,T3,T4> const& x)
{
   return group3<T1,T2,T3> (x.a1_,x.a2_,x.a3_);
}

template <class T1,class T2,class T3,class T4>
inline
group1<T4>
group_last( group4<T1,T2,T3,T4> const& x)
{
   return group1<T4> (x.a4_);
}



template <class T1,class T2,class T3,class T4,class T5>
inline
group4<T1,T2,T3,T4>
group_head( group5<T1,T2,T3,T4,T5> const& x)
{
   return group4<T1,T2,T3,T4> (x.a1_,x.a2_,x.a3_,x.a4_);
}

template <class T1,class T2,class T3,class T4,class T5>
inline
group1<T5>
group_last( group5<T1,T2,T3,T4,T5> const& x)
{
   return group1<T5> (x.a5_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group5<T1,T2,T3,T4,T5>
group_head( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group5<T1,T2,T3,T4,T5> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group1<T6>
group_last( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group1<T6> (x.a6_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group6<T1,T2,T3,T4,T5,T6>
group_head( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group6<T1,T2,T3,T4,T5,T6> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group1<T7>
group_last( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group1<T7> (x.a7_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group7<T1,T2,T3,T4,T5,T6,T7>
group_head( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group7<T1,T2,T3,T4,T5,T6,T7> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group1<T8>
group_last( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group1<T8> (x.a8_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group8<T1,T2,T3,T4,T5,T6,T7,T8>
group_head( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group8<T1,T2,T3,T4,T5,T6,T7,T8> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group1<T9>
group_last( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group1<T9> (x.a9_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>
group_head( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_,x.a9_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group1<T10>
group_last( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group1<T10> (x.a10_);
}





}






inline detail::group1< detail::group0 >
group() { return detail::group1< detail::group0 > ( detail::group0() ); }

template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var const&> >
  group(T1 a1, Var const& var)
{
   return detail::group1< detail::group2<T1, Var const&> >
                   ( detail::group2<T1, Var const&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var const&> >
  group(T1 a1,T2 a2, Var const& var)
{
   return detail::group1< detail::group3<T1,T2, Var const&> >
                   ( detail::group3<T1,T2, Var const&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var const&> >
  group(T1 a1,T2 a2,T3 a3, Var const& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var const&> >
                   ( detail::group4<T1,T2,T3, Var const&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var const& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
                   ( detail::group5<T1,T2,T3,T4, Var const&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var const& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var const&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var const& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var const&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var const& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var const& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var const& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}




template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var&> >
  group(T1 a1, Var& var)
{
   return detail::group1< detail::group2<T1, Var&> >
                   ( detail::group2<T1, Var&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var&> >
  group(T1 a1,T2 a2, Var& var)
{
   return detail::group1< detail::group3<T1,T2, Var&> >
                   ( detail::group3<T1,T2, Var&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var&> >
  group(T1 a1,T2 a2,T3 a3, Var& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var&> >
                   ( detail::group4<T1,T2,T3, Var&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
                   ( detail::group5<T1,T2,T3,T4, Var&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}





}

}
# 49 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/msvc_disambiguater.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp" 2

namespace boost {
namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc>
    void mk_str( std::basic_string<Ch,Tr, Alloc> & res,
                 const Ch * beg,
                 typename std::basic_string<Ch,Tr,Alloc>::size_type size,
                 std::streamsize w,
                 const Ch fill_char,
                 std::ios_base::fmtflags f,
                 const Ch prefix_space,
                 bool center)


    {
        typedef typename std::basic_string<Ch,Tr,Alloc>::size_type size_type;
        res.resize(0);
        if(w<=0 || static_cast<size_type>(w) <=size) {

            res.reserve(size + !!prefix_space);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
        }
        else {
            std::streamsize n=static_cast<std::streamsize>(w-size-!!prefix_space);
            std::streamsize n_after = 0, n_before = 0;
            res.reserve(static_cast<size_type>(w));
            if(center)
                n_after = n/2, n_before = n - n_after;
            else
                if(f & std::ios_base::left)
                    n_after = n;
                else
                    n_before = n;

            if(n_before) res.append(static_cast<size_type>(n_before), fill_char);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
            if(n_after) res.append(static_cast<size_type>(n_after), fill_char);
        }
    }
# 89 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp"
    template< class Ch, class Tr, class T> inline
    void put_head (::std:: basic_ostream<Ch, Tr> &, const T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_head(x.a1_);
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const T& x ) {
        os << x ;
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_last(x.a1_);
    }


    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> &, T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, T& x) {
        os << x ;
    }




    template< class Ch, class Tr, class Alloc, class T>
    void put( T x,
              const format_item<Ch, Tr, Alloc>& specs,
              typename basic_format<Ch, Tr, Alloc>::string_type& res,
              typename basic_format<Ch, Tr, Alloc>::internal_streambuf_t & buf,
              io::detail::locale_t *loc_p = __null)
    {
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp"
        typedef typename basic_format<Ch, Tr, Alloc>::string_type string_type;
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;
        typedef typename string_type::size_type size_type;

        basic_oaltstringstream<Ch, Tr, Alloc> oss( &buf);
        specs.fmtstate_.apply_on(oss, loc_p);


        put_head( oss, x );



        const std::ios_base::fmtflags fl=oss.flags();
        const bool internal = (fl & std::ios_base::internal) != 0;
        const std::streamsize w = oss.width();
        const bool two_stepped_padding= internal && (w!=0);

        res.resize(0);
        if(! two_stepped_padding) {
            if(w>0)
                oss.width(0);
            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            Ch prefix_space = 0;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = oss.widen(' ');
            size_type res_size = (std::min)(
                static_cast<size_type>(specs.truncate_ - !!prefix_space),
                buf.pcount() );
            mk_str(res, res_beg, res_size, w, oss.fill(), fl,
                   prefix_space, (specs.pad_scheme_ & format_item_t::centered) !=0 );
        }
        else {



            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            size_type res_size = buf.pcount();
            bool prefix_space=false;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = true;
            if(res_size == static_cast<size_type>(w) && w<=specs.truncate_ && !prefix_space) {

                res.assign(res_beg, res_size);
            }
            else {



                res.assign(res_beg, res_size);
                res_beg=__null;


                buf.clear_buffer();
                basic_oaltstringstream<Ch, Tr, Alloc> oss2( &buf);
                specs.fmtstate_.apply_on(oss2, loc_p);
                put_head( oss2, x );

                oss2.width(0);
                if(prefix_space)
                    oss2 << ' ';
                put_last(oss2, x );
                if(buf.pcount()==0 && specs.pad_scheme_ & format_item_t::spacepad) {
                    prefix_space =true;
                    oss2 << ' ';
                }

                const Ch * tmp_beg = buf.pbase();
                size_type tmp_size = (std::min)(static_cast<size_type>(specs.truncate_),
                                                buf.pcount() );


                if(static_cast<size_type>(w) <= tmp_size) {

                        res.assign(tmp_beg, tmp_size);
                }
                else {

                    size_type sz = (std::min)(res_size + (prefix_space ? 1 : 0), tmp_size);
                    size_type i = prefix_space;
                    for(; i<sz && tmp_beg[i] == res[i - (prefix_space ? 1 : 0)]; ++i) {}
                    if(i>=tmp_size) i=prefix_space;
                    res.assign(tmp_beg, i);
                                        std::streamsize d = w - static_cast<std::streamsize>(tmp_size);
                                        ((d>0) ? static_cast<void> (0) : __assert_fail ("d>0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp", 227, __PRETTY_FUNCTION__));
                    res.append(static_cast<size_type>( d ), oss2.fill());
                    res.append(tmp_beg+i, tmp_size-i);
                    ((i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)) ? static_cast<void> (0) : __assert_fail ("i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)",
 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp"
# 230 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp"
                    ,
 231
# 230 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp"
                    , __PRETTY_FUNCTION__))
                                                              ;
                    ((res.size() == static_cast<size_type>(w)) ? static_cast<void> (0) : __assert_fail ("res.size() == static_cast<size_type>(w)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/feed_args.hpp", 232, __PRETTY_FUNCTION__));
                }
            }
        }
        buf.clear_buffer();



    }


    template< class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x) {

        if(self.cur_arg_ >= self.num_args_) {
            if( self.exceptions() & too_many_args_bit )
                boost::throw_exception(too_many_args(self.cur_arg_, self.num_args_));
            else return;
        }
        for(unsigned long i=0; i < self.items_.size(); ++i) {
            if(self.items_[i].argN_ == self.cur_arg_) {
                put<Ch, Tr, Alloc, T> (x, self.items_[i], self.items_[i].res_,
                                self.buf_, boost::get_pointer(self.loc_) );
            }
        }
    }

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x) {
        if(self.dumped_) self.clear();
        distribute<Ch, Tr, Alloc, T> (self, x);
        ++self.cur_arg_;
        if(self.bound_.size() != 0) {
                while( self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_] )
                    ++self.cur_arg_;
        }
        return self;
    }

}
}
}
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp" 2


namespace boost {
namespace io {
namespace detail {
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp"
    template<class T>
    const T& const_or_not(const T& x) {
        return x;
    }


    template<class Ch, class Facet> inline
    char wrap_narrow(const Facet& fac, Ch c, char deflt) {
        return const_or_not(fac).narrow(c, deflt);
    }

    template<class Ch, class Facet> inline
    bool wrap_isdigit(const Facet& fac, Ch c) {

        return fac.is(std::ctype<Ch>::digit, c);





    }

    template<class Iter, class Facet>
    Iter wrap_scan_notdigit(const Facet & fac, Iter beg, Iter end) {
        using namespace std;
        for( ; beg!=end && wrap_isdigit(fac, *beg); ++beg) ;
        return beg;
    }






    template<class Res, class Iter, class Facet>
    Iter str2int (const Iter & start, const Iter & last, Res & res,
                 const Facet& fac)
    {
        using namespace std;
        Iter it;
        res=0;
        for(it=start; it != last && wrap_isdigit(fac, *it); ++it ) {
            char cur_ch = wrap_narrow(fac, *it, 0);
            res *= 10;
            res += cur_ch - '0';
        }
        return it;
    }






    template<class Iter, class Facet>
    Iter skip_asterisk(Iter start, Iter last, const Facet& fac)
    {
        using namespace std;
        ++ start;
        start = wrap_scan_notdigit(fac, start, last);
        if(start!=last && *start== const_or_not(fac).widen( '$') )
            ++start;
        return start;
    }





    inline void maybe_throw_exception(unsigned char exceptions,
                                      std::size_t pos, std::size_t size)
    {
        if(exceptions & io::bad_format_string_bit)
            boost::throw_exception(io::bad_format_string(pos, size) );
    }
# 122 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp"
    template<class Ch, class Tr, class Alloc, class Iter, class Facet>
    bool parse_printf_directive(Iter & start, const Iter& last,
                                detail::format_item<Ch, Tr, Alloc> * fpar,
                                const Facet& fac,
                                std::size_t offset, unsigned char exceptions)
    {
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;

        fpar->argN_ = format_item_t::argN_no_posit;
        bool precision_set = false;
        bool in_brackets=false;
        Iter start0 = start;
        std::size_t fstring_size = last-start0+offset;

        if(start>= last) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
        }

        if(*start== const_or_not(fac).widen( '|')) {
            in_brackets=true;
            if( ++start >= last ) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
            }
        }


        if(*start== const_or_not(fac).widen( '0'))
            goto parse_flags;


        if(wrap_isdigit(fac, *start)) {
            int n;
            start = str2int(start, last, n, fac);
            if( start >= last ) {
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
                return false;
            }


            if( *start == const_or_not(fac).widen( '%') ) {
                fpar->argN_ = n-1;
                ++start;
                if( in_brackets)
                    maybe_throw_exception(exceptions, start-start0+offset, fstring_size);

                else
                    return true;
            }

            if ( *start== const_or_not(fac).widen( '$') ) {
                fpar->argN_ = n-1;
                ++start;
            }
            else {

                fpar->fmtstate_.width_ = n;
                fpar->argN_ = format_item_t::argN_no_posit;
                goto parse_precision;
            }
        }

      parse_flags:

        while ( start != last) {

            switch ( wrap_narrow(fac, *start, 0)) {
            case '\'' : break;
            case 'l':
            case 'h':
                break;
            case '-':
                fpar->fmtstate_.flags_ |= std::ios_base::left;
                break;
            case '=':
                fpar->pad_scheme_ |= format_item_t::centered;
                break;
            case '_':
                fpar->fmtstate_.flags_ |= std::ios_base::internal;
                break;
            case ' ':
                fpar->pad_scheme_ |= format_item_t::spacepad;
                break;
            case '+':
                fpar->fmtstate_.flags_ |= std::ios_base::showpos;
                break;
            case '0':
                fpar->pad_scheme_ |= format_item_t::zeropad;


                break;
            case '#':
                fpar->fmtstate_.flags_ |= std::ios_base::showpoint | std::ios_base::showbase;
                break;
            default:
                goto parse_width;
            }
            ++start;
        }

        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
      parse_width:


        if(*start == const_or_not(fac).widen( '*') )
            start = skip_asterisk(start, last, fac);
        if(start!=last && wrap_isdigit(fac, *start))
            start = str2int(start, last, fpar->fmtstate_.width_, fac);

      parse_precision:
        if( start>= last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if (*start== const_or_not(fac).widen( '.')) {
            ++start;
            if(start != last && *start == const_or_not(fac).widen( '*') )
                start = skip_asterisk(start, last, fac);
            if(start != last && wrap_isdigit(fac, *start)) {
                start = str2int(start, last, fpar->fmtstate_.precision_, fac);
                precision_set = true;
            }
            else
                fpar->fmtstate_.precision_ =0;
        }


        while( start != last && ( *start== const_or_not(fac).widen( 'l')
                                  || *start== const_or_not(fac).widen( 'L')
                                  || *start== const_or_not(fac).widen( 'h')) )
            ++start;
        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if( in_brackets && *start== const_or_not(fac).widen( '|') ) {
            ++start;
            return true;
        }
        switch ( wrap_narrow(fac, *start, 0) ) {
        case 'X':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'p':
        case 'x':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::hex;
            break;

        case 'o':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::oct;
            break;

        case 'E':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'e':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::scientific;

            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'f':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::fixed;
        case 'u':
        case 'd':
        case 'i':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'T':
            ++start;
            if( start >= last)
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            else
                fpar->fmtstate_.fill_ = *start;
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;
        case 't':
            fpar->fmtstate_.fill_ = const_or_not(fac).widen( ' ');
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;

        case 'G':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
            break;
        case 'g':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;


            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            break;

        case 'C':
        case 'c':
            fpar->truncate_ = 1;
            break;
        case 'S':
        case 's':
            if(precision_set)
                fpar->truncate_ = fpar->fmtstate_.precision_;
            fpar->fmtstate_.precision_ = 6;
            break;
        case 'n' :
            fpar->argN_ = format_item_t::argN_ignored;
            break;
        default:
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        ++start;

        if( in_brackets ) {
            if( start != last && *start== const_or_not(fac).widen( '|') ) {
                ++start;
                return true;
            }
            else maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        return true;
    }


    template<class String, class Facet>
    int upper_bound_from_fstring(const String& buf,
                                 const typename String::value_type arg_mark,
                                 const Facet& fac,
                                 unsigned char exceptions)
    {


        using namespace boost::io;
        typename String::size_type i1=0;
        int num_items=0;
        while( (i1=buf.find(arg_mark,i1)) != String::npos ) {
            if( i1+1 >= buf.size() ) {
                if(exceptions & bad_format_string_bit)
                    boost::throw_exception(bad_format_string(i1, buf.size() ));
                else {
                  ++num_items;
                  break;
                }
            }
            if(buf[i1+1] == buf[i1] ) {
                i1+=2; continue;
            }

            ++i1;

            i1 = detail::wrap_scan_notdigit(fac, buf.begin()+i1, buf.end()) - buf.begin();
            if( i1 < buf.size() && buf[i1] == arg_mark )
                ++i1;
            ++num_items;
        }
        return num_items;
    }
    template<class String> inline
    void append_string(String& dst, const String& src,
                       const typename String::size_type beg,
                       const typename String::size_type end) {

        dst.append(src.begin()+beg, src.begin()+end);



    }

}
}






    template<class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    parse (const string_type& buf) {

        using namespace std;

        const std::ctype<Ch> & fac = std::use_facet< std::ctype<Ch> >(getloc());





        const Ch arg_mark = io::detail::const_or_not(fac).widen( '%');
        bool ordered_args=true;
        int max_argN=-1;


        int num_items = io::detail::upper_bound_from_fstring(buf, arg_mark, fac, exceptions());
        make_or_reuse_data(num_items);


        num_items=0;
        typename string_type::size_type i0=0, i1=0;
        typename string_type::const_iterator it;
        bool special_things=false;
        int cur_item=0;
        while( (i1=buf.find(arg_mark,i1)) != string_type::npos ) {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            if( buf[i1+1] == buf[i1] ) {
                io::detail::append_string(piece, buf, i0, i1+1);
                i1+=2; i0=i1;
                continue;
            }
            ((static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0) ? static_cast<void> (0) : __assert_fail ("static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp", 441, __PRETTY_FUNCTION__));

            if(i1!=i0) {
                io::detail::append_string(piece, buf, i0, i1);
                i0=i1;
            }
            ++i1;
            it = buf.begin()+i1;
            bool parse_ok = io::detail::parse_printf_directive(
                it, buf.end(), &items_[cur_item], fac, i1, exceptions());
            i1 = it - buf.begin();
            if( ! parse_ok )
                continue;
            i0=i1;
            items_[cur_item].compute_states();

            int argN=items_[cur_item].argN_;
            if(argN == format_item_t::argN_ignored)
                continue;
            if(argN ==format_item_t::argN_no_posit)
                ordered_args=false;
            else if(argN == format_item_t::argN_tabulation) special_things=true;
            else if(argN > max_argN) max_argN = argN;
            ++num_items;
            ++cur_item;
        }
        ((cur_item == num_items) ? static_cast<void> (0) : __assert_fail ("cur_item == num_items", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/parsing.hpp", 467, __PRETTY_FUNCTION__));


        {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            io::detail::append_string(piece, buf, i0, buf.size());
        }

        if( !ordered_args) {
            if(max_argN >= 0 ) {
                if(exceptions() & io::bad_format_string_bit)
                    boost::throw_exception(io::bad_format_string(max_argN, 0));

            }

            int non_ordered_items = 0;
            for(int i=0; i< num_items; ++i)
                if(items_[i].argN_ == format_item_t::argN_no_posit) {
                    items_[i].argN_ = non_ordered_items;
                    ++non_ordered_items;
                }
            max_argN = non_ordered_items-1;
        }


        items_.resize(num_items, format_item_t(io::detail::const_or_not(fac).widen( ' ')) );

        if(special_things) style_ |= special_needs;
        num_args_ = max_argN + 1;
        if(ordered_args) style_ |= ordered;
        else style_ &= ~ordered;
        return *this;
    }

}
# 51 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/free_funcs.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/free_funcs.hpp"
namespace boost {

    template<class Ch, class Tr, class Alloc> inline
    std::basic_string<Ch, Tr, Alloc> str(const basic_format<Ch, Tr, Alloc>& f) {

        return f.str();
    }
    namespace io {
         using ::boost::str;
    }


        template<class Ch, class Tr, class Alloc>
        std::basic_ostream<Ch, Tr> &
        operator<<( std::basic_ostream<Ch, Tr> & os,
                    const basic_format<Ch, Tr, Alloc>& f)







    {
        typedef boost::basic_format<Ch, Tr, Alloc> format_t;
        if(f.items_.size()==0)
            os << f.prefix_;
        else {
            if(f.cur_arg_ < f.num_args_)
                if( f.exceptions() & io::too_few_args_bit )

                    boost::throw_exception(io::too_few_args(f.cur_arg_, f.num_args_));
            if(f.style_ & format_t::special_needs)
                os << f.str();
            else {

                os << f.prefix_;
                for(unsigned long i=0; i<f.items_.size(); ++i) {
                    const typename format_t::format_item_t& item = f.items_[i];
                    os << item.res_;
                    os << item.appendix_;
                }
            }
        }
        f.dumped_=true;
        return os;
    }

}
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format/detail/unset_macros.hpp" 1
# 58 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/format.hpp" 2
# 33 "../libbase/log.h" 2





# 1 "../libbase/gettext.h" 1
# 39 "../libbase/log.h" 2
# 53 "../libbase/log.h"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/preprocessor/seq/for_each.hpp" 1
# 54 "../libbase/log.h" 2







namespace gnash {


class LogFile
{
public:

    static LogFile& getDefaultInstance();

    ~LogFile();

    enum LogLevel {
        LOG_SILENT,
        LOG_NORMAL,
        LOG_DEBUG,
        LOG_EXTRA
    };

    enum FileState {
        CLOSED,
        OPEN,
        INPROGRESS,
        IDLE
    };
# 94 "../libbase/log.h"
    void log(const std::string& label, const std::string& msg);






    void log(const std::string& msg);





    bool removeLog();





    bool closeLog();







    void setLogFilename(const std::string& fname);


    void setVerbosity() {
        ++_verbose;
    }

    void setVerbosity(int x) {
        _verbose = x;
    }

    int getVerbosity() const {
        return _verbose;
    }

    void setActionDump(int x) {
        _actiondump = x;
    }

    void setNetwork(int x) {
        _network = x;
    }

    int getActionDump() const {
        return _actiondump;
    }

    int getNetwork() const {
        return _network;
    }

    void setParserDump (int x) {
        _parserdump = x;
    }

    int getParserDump() const {
        return _parserdump;
    }

    void setStamp (bool b) {
        _stamp = b;
    }

    bool getStamp() const {
        return _stamp;
    }


    void setWriteDisk(bool b);

    bool getWriteDisk() const {
        return _write;
    }

    typedef void (*logListener)(const std::string& s);

    void registerLogCallback(logListener l) { _listener = l; }

private:







    bool openLog(const std::string& filespec);
# 199 "../libbase/log.h"
    bool openLogIfNeeded();


    LogFile ();


    boost::mutex _ioMutex;


    std::ofstream _outstream;


    int _verbose;


    bool _actiondump;


    bool _network;


    bool _parserdump;


    FileState _state;

    bool _stamp;


    bool _write;

    std::string _filespec;

    std::string _logFilename;

    logListener _listener;

};

 void processLog_network(const boost::format& fmt);
 void processLog_error(const boost::format& fmt);
 void processLog_unimpl(const boost::format& fmt);
 void processLog_trace(const boost::format& fmt);
 void processLog_debug(const boost::format& fmt);
 void processLog_action(const boost::format& fmt);
 void processLog_parse(const boost::format& fmt);
 void processLog_security(const boost::format& fmt);
 void processLog_swferror(const boost::format& fmt);
 void processLog_amferror(const boost::format& fmt);
 void processLog_aserror(const boost::format& fmt);
 void processLog_abc(const boost::format& fmt);
# 316 "../libbase/log.h"
template< typename T0>inline void log_error( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f );} template< typename T0 , typename T1>inline void log_error( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_error( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_error(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_debug( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f );} template< typename T0 , typename T1>inline void log_debug( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_debug( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_debug(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_unimpl( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f );} template< typename T0 , typename T1>inline void log_unimpl( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_unimpl( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_unimpl(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_aserror( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f );} template< typename T0 , typename T1>inline void log_aserror( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_aserror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_aserror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_swferror( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f );} template< typename T0 , typename T1>inline void log_swferror( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_swferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_swferror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_amferror( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f );} template< typename T0 , typename T1>inline void log_amferror( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_amferror( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_amferror(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_security( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f );} template< typename T0 , typename T1>inline void log_security( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_security( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_security(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_action( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f );} template< typename T0 , typename T1>inline void log_action( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_action( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_action(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_parse( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f );} template< typename T0 , typename T1>inline void log_parse( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_parse( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_parse(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_trace( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f );} template< typename T0 , typename T1>inline void log_trace( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_trace( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_trace(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_abc( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f );} template< typename T0 , typename T1>inline void log_abc( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_abc( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_abc(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);} template< typename T0>inline void log_network( const T0& t0) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f );} template< typename T0 , typename T1>inline void log_network( const T0& t0 , const T1& t1) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1);} template< typename T0 , typename T1 , typename T2>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2);} template< typename T0 , typename T1 , typename T2 , typename T3>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3 % t4);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3 % t4 % t5);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3 % t4 % t5 % t6);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3 % t4 % t5 % t6 % t7);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8);} template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>inline void log_network( const T0& t0 , const T1& t1 , const T2& t2 , const T3& t3 , const T4& t4 , const T5& t5 , const T6& t6 , const T7& t7 , const T8& t8 , const T9& t9) { if (LogFile::getDefaultInstance().getVerbosity() == 0) return; boost::format f(t0); using namespace boost::io; f.exceptions(all_error_bits ^ (too_many_args_bit | too_few_args_bit | bad_format_string_bit)); processLog_network(f % t1 % t2 % t3 % t4 % t5 % t6 % t7 % t8 % t9);}
# 331 "../libbase/log.h"
 std::string hexify(const unsigned char *bytes, size_t length,
        bool ascii);
# 403 "../libbase/log.h"
class __Host_Function_Report__
{
public:
    const char *func;



    __Host_Function_Report__(void) {
        log_debug("entering");
    }

    __Host_Function_Report__(char *_func) {
        func = _func;
        log_debug("%s enter", func);
    }

    __Host_Function_Report__(const char *_func) {
        func = _func;
        if (func) {
            log_debug("%s enter", func);
        }
        else {
            log_debug("No Function Name! enter");
        }
    }

    ~__Host_Function_Report__(void) {
        log_debug("%s returning", func);
    }
};
# 460 "../libbase/log.h"
}
# 25 "asobj/Array_as.cpp" 2
# 1 "./builtin_function.h" 1
# 22 "./builtin_function.h"
# 1 "./UserFunction.h" 1
# 21 "./UserFunction.h"
# 1 "./as_function.h" 1
# 23 "./as_function.h"
# 1 "./as_object.h" 1
# 24 "./as_function.h" 2


namespace gnash {
    class NativeFunction;
    class Global_as;
    template <typename T> class FunctionArgs;
}

namespace gnash {
# 61 "./as_function.h"
class as_function : public as_object
{
public:


 virtual ~as_function() {}


 as_function* to_function() { return this; }




 virtual as_value call(const fn_call& fn) = 0;

    virtual const std::string& stringValue() const;
# 98 "./as_function.h"
    as_object* construct(as_object& newobj, const as_environment& env,
            FunctionArgs<as_value>& args);


 virtual bool isBuiltin() { return false; }


 static NativeFunction* getFunctionConstructor();

protected:





 as_function(Global_as& gl);

};
# 129 "./as_function.h"
as_object* constructInstance(as_function& ctor, const as_environment& env,
        FunctionArgs<as_value>& args);


void function_class_init(as_object& global, const ObjectURI& uri);
void registerFunctionNative(as_object& global);

}
# 22 "./UserFunction.h" 2

namespace gnash {
    class Global_as;
}

namespace gnash {
# 37 "./UserFunction.h"
class UserFunction : public as_function
{
public:





    virtual boost::uint8_t registers() const = 0;

protected:

    UserFunction(Global_as& gl) : as_function(gl) {}


    virtual ~UserFunction() = 0;

};

inline UserFunction::~UserFunction() {}

}
# 23 "./builtin_function.h" 2
# 1 "./as_environment.h" 1
# 24 "./as_environment.h"
# 1 "../libcore/vm/SafeStack.h" 1
# 26 "../libcore/vm/SafeStack.h"
namespace gnash {

class StackException {};
# 39 "../libcore/vm/SafeStack.h"
template <class T>
class SafeStack
{

 typedef std::vector<T*> StackType;

public:


    typedef typename StackType::size_type StackSize;




 const T& top(StackSize i) const
 {

  if (i >= size()) throw StackException();
  const StackSize offset = _end - i;
  return _data[offset >> _chunkShift][offset & _chunkMod];
 }





 T& top(StackSize i)
 {

  if (i >= size()) throw StackException();
  const StackSize offset = _end - i;
  return _data[offset >> _chunkShift][offset & _chunkMod];
 }




 const T& at(StackSize i) const
 {

  if (i >= totalSize()) throw StackException();
  const StackSize offset = _end - i;
  return _data[offset >> _chunkShift][offset & _chunkMod];
 }






 T& at(StackSize i)
 {

  if (i >= totalSize()) throw StackException();
  const StackSize offset = _end - i;
  return _data[offset >> _chunkShift][offset & _chunkMod];
 }



 T& value(StackSize i)
 {
  if (i >= size()) throw StackException();

  StackSize offset = _downstop + i + 2;
  return _data[offset >> _chunkShift][offset & _chunkMod];
 }

 const T& value(StackSize i) const
 {
  if (i >= size()) throw StackException();

  StackSize offset = _downstop + i + 2;
  return _data[offset >> _chunkShift][offset & _chunkMod];
 }


 void assign(StackSize i, T val)
 {
  if (i >= size()) throw StackException();

  StackSize offset = _downstop + i + 2;
  _data[offset >> _chunkShift][offset & _chunkMod] = val;
 }




 void drop(StackSize i)
    {
        if (i > size()) throw StackException();
        _end -= i;
    }


 void clear()
 {
        _downstop = 0;
        _end = 1;
    }



 void push(const T t)
 {
        grow(1);
        top(0) = t;
    }


 T& pop()
 {
        T& ret = top(0);
        drop(1);
        return ret;
    }



 void grow(StackSize i)
 {
  StackSize available = (1 << _chunkShift) * _data.size() - _end + 1;
  StackSize n = size()+i;
  while (available < n)
  {

   _data.push_back(new T[1 << _chunkShift]);
   available += 1 << _chunkShift;
  }
  _end += i;
 }


 StackSize getDownstop() const
 {
        return _downstop;
    }


 StackSize size() const { return _end - _downstop - 1; }


 bool empty() const { return size() == 0; }




 StackSize fixDownstop()
 {
        StackSize ret = _downstop;
        _downstop = _end - 1;
        return ret;
    }



 void setDownstop(StackSize i)
 {
        if (i > _end) throw StackException();
        _downstop = i;
    }





 StackSize totalSize() const { return _end - 1; }



 void setAllSizes(StackSize total, StackSize downstop)
 {
        _end = total + 1;
        _downstop = downstop;
    }


 SafeStack() : _data(), _downstop(0), _end(1) {}


 ~SafeStack()
 {
  for (StackSize i = 0; i < _data.size(); ++i) delete [] _data[i];
 }

private:
 StackType _data;
 StackSize _downstop;
 StackSize _end;


 static const StackSize _chunkShift = 6;
 static const StackSize _chunkMod = (1 << _chunkShift) - 1;
};

}
# 25 "./as_environment.h" 2




namespace gnash {


class DisplayObject;
class VM;
class Global_as;
class movie_root;
class string_table;
class UserFunction;


class as_environment
{

public:


    typedef std::vector<as_object*> ScopeStack;

    as_environment(VM& vm);

    VM& getVM() const { return _vm; }

    DisplayObject* get_target() const { return m_target; }
# 61 "./as_environment.h"
    void set_target(DisplayObject* target);

    void set_original_target(DisplayObject* target) {
        _original_target = target;
    }

    DisplayObject* get_original_target() { return _original_target; }


    void reset_target() { m_target = _original_target; }


    void push(const as_value& val) {
        _stack.push(val);
    }


    as_value pop()
    {
        try {
            return _stack.pop();
        } catch (StackException&) {
            return undefVal;
        }
    }







    as_value& top(size_t dist)
    {
        try {
            return _stack.top(dist);
        } catch (StackException&) {
            return undefVal;
        }
    }







    as_value& bottom(size_t index) const
    {
        try {
            return _stack.value(index);
        } catch (StackException&) {
            return undefVal;
        }
    }


    void drop(size_t count)
    {


        _stack.drop(std::min(count, _stack.size()));
    }

    size_t stack_size() const { return _stack.size(); }
# 141 "./as_environment.h"
    bool delVariableRaw(const std::string& varname,
            const ScopeStack& scopeStack);
# 161 "./as_environment.h"
    as_value get_variable(const std::string& varname,
        const ScopeStack& scopeStack, as_object** retTarget=__null) const;
# 182 "./as_environment.h"
    void set_variable(const std::string& path, const as_value& val,
        const ScopeStack& scopeStack);
# 192 "./as_environment.h"
    void markReachableResources() const;







    DisplayObject* find_target(const std::string& path) const;






    as_object* find_object(const std::string& path,
            const ScopeStack* scopeStack = 0) const;







    int get_version() const;

private:

    VM& _vm;


    SafeStack<as_value>& _stack;


    DisplayObject* m_target;


    DisplayObject* _original_target;
# 242 "./as_environment.h"
    void set_variable_raw(const std::string& path, const as_value& val,
        const ScopeStack& scopeStack);







    as_value get_variable_raw(const std::string& varname,
        const ScopeStack& scopeStack, as_object** retTarget=__null) const;

    static as_value undefVal;

};
# 277 "./as_environment.h"
bool parsePath(const std::string& var_path, std::string& path,
        std::string& var);

inline VM&
getVM(const as_environment& env)
{
    return env.getVM();
}

movie_root& getRoot(const as_environment& env);
string_table& getStringTable(const as_environment& env);
int getSWFVersion(const as_environment& env);
Global_as& getGlobal(const as_environment &env);

}
# 24 "./builtin_function.h" 2
# 1 "../libcore/vm/fn_call.h" 1
# 22 "../libcore/vm/fn_call.h"
# 1 "./as_environment.h" 1
# 23 "../libcore/vm/fn_call.h" 2


# 1 "../libcore/vm/VM.h" 1
# 24 "../libcore/vm/VM.h"
# 1 "../gnashconfig.h" 1
# 25 "../libcore/vm/VM.h" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 32 "../libcore/vm/VM.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/disable_warnings.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp" 2

namespace boost {
namespace random {







namespace detail {

  template<bool is_signed>
  struct do_add
  { };

  template<>
  struct do_add<true>
  {
    template<class IntType>
    static IntType add(IntType m, IntType x, IntType c)
    {
      if (x < m - c)
        return x + c;
      else
        return x - (m-c);
    }
  };

  template<>
  struct do_add<false>
  {
    template<class IntType>
    static IntType add(IntType, IntType, IntType)
    {

      ((!"const_mod::add with c too large") ? static_cast<void> (0) : __assert_fail ("!\"const_mod::add with c too large\"", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp", 62, __PRETTY_FUNCTION__));
      return 0;
    }
  };
}



template<class IntType, IntType m>
class const_mod
{
public:
  static IntType add(IntType x, IntType c)
  {
    if(c == 0)
      return x;
    else if(c <= traits::const_max - m)
      return add_small(x, c);
    else
      return detail::do_add<traits::is_signed>::add(m, x, c);
  }

  static IntType mult(IntType a, IntType x)
  {
    if(a == 1)
      return x;
    else if(m <= traits::const_max/a)
      return mult_small(a, x);
    else if(traits::is_signed && (m%a < m/a))
      return mult_schrage(a, x);
    else {

      ((!"const_mod::mult with a too large") ? static_cast<void> (0) : __assert_fail ("!\"const_mod::mult with a too large\"", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp", 94, __PRETTY_FUNCTION__));
      return 0;
    }
  }

  static IntType mult_add(IntType a, IntType x, IntType c)
  {
    if(m <= (traits::const_max-c)/a)
      return (a*x+c) % m;
    else
      return add(mult(a, x), c);
  }

  static IntType invert(IntType x)
  { return x == 0 ? 0 : invert_euclidian(x); }

private:
  typedef integer_traits<IntType> traits;

  const_mod();

  static IntType add_small(IntType x, IntType c)
  {
    x += c;
    if(x >= m)
      x -= m;
    return x;
  }

  static IntType mult_small(IntType a, IntType x)
  {
    return a*x % m;
  }

  static IntType mult_schrage(IntType a, IntType value)
  {
    const IntType q = m / a;
    const IntType r = m % a;

    ((r < q) ? static_cast<void> (0) : __assert_fail ("r < q", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp", 133, __PRETTY_FUNCTION__));

    value = a*(value%q) - r*(value/q);


    for(;;) {
      if (value > 0)
        break;
      value += m;
    }
    return value;
  }


  static IntType invert_euclidian(IntType c)
  {

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((m > 0) == 0 ? false : true) >)> boost_static_assert_typedef_150;



    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((boost::integer_traits<IntType>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_154;

    ((c > 0) ? static_cast<void> (0) : __assert_fail ("c > 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp", 156, __PRETTY_FUNCTION__));
    IntType l1 = 0;
    IntType l2 = 1;
    IntType n = c;
    IntType p = m;
    for(;;) {
      IntType q = p / n;
      l1 -= q * l2;
      p -= q * n;
      if(p == 0)
        return (l2 < 1 ? l2 + m : l2);
      IntType q2 = n / p;
      l2 -= q2 * l1;
      n -= q2 * p;
      if(n == 0)
        return (l1 < 1 ? l1 + m : l1);
    }
  }
};




template<>
class const_mod<unsigned int, 0>
{
  typedef unsigned int IntType;
public:
  static IntType add(IntType x, IntType c) { return x+c; }
  static IntType mult(IntType a, IntType x) { return a*x; }
  static IntType mult_add(IntType a, IntType x, IntType c) { return a*x+c; }


private:
  const_mod();
};

template<>
class const_mod<unsigned long, 0>
{
  typedef unsigned long IntType;
public:
  static IntType add(IntType x, IntType c) { return x+c; }
  static IntType mult(IntType a, IntType x) { return a*x; }
  static IntType mult_add(IntType a, IntType x, IntType c) { return a*x+c; }


private:
  const_mod();
};




template<>
class const_mod<uint64_t, uint64_t(1) << 48>
{
  typedef uint64_t IntType;
public:
  static IntType add(IntType x, IntType c) { return c == 0 ? x : mod(x+c); }
  static IntType mult(IntType a, IntType x) { return mod(a*x); }
  static IntType mult_add(IntType a, IntType x, IntType c)
    { return mod(a*x+c); }
  static IntType mod(IntType x) { return x &= ((uint64_t(1) << 48)-1); }


private:
  const_mod();
};
# 358 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp"
}
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/enable_warnings.hpp" 1
# 362 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/const_mod.hpp" 2
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/disable_warnings.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp" 2

namespace boost {
namespace random {
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
template<class IntType, IntType a, IntType c, IntType m, IntType val>
class linear_congruential
{
public:
  typedef IntType result_type;

  static const bool has_fixed_range = true;
  static const result_type min_value = ( c == 0 ? 1 : 0 );
  static const result_type max_value = m-1;



  static const IntType multiplier = a;
  static const IntType increment = c;
  static const IntType modulus = m;
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  explicit linear_congruential(IntType x0 = 1)
  {
    seed(x0);



    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<IntType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_84;

  }
# 96 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  template<class It>
  linear_congruential(It& first, It last)
  {
      seed(first, last);
  }
# 110 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  void seed(IntType x0 = 1)
  {

    if(modulus == 0) {
      _x = x0;
    } else {
      _x = x0 % modulus;
    }

    if(_x <= 0 && _x != 0) {
      _x += modulus;
    }

    if(increment == 0 && _x == 0) {
      _x = 1;
    }
    ((_x >= (min)()) ? static_cast<void> (0) : __assert_fail ("_x >= (min)()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp", 126, __PRETTY_FUNCTION__));
    ((_x <= (max)()) ? static_cast<void> (0) : __assert_fail ("_x <= (max)()", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp", 127, __PRETTY_FUNCTION__));
  }
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  template<class It>
  void seed(It& first, It last)
  {
    if(first == last)
      throw std::invalid_argument("linear_congruential::seed");
    seed(*first++);
  }





  result_type min () const { return c == 0 ? 1 : 0; }




  result_type max () const { return modulus-1; }


  IntType operator()()
  {
    _x = const_mod<IntType, m>::mult_add(a, _x, c);
    return _x;
  }

  static bool validation(IntType x) { return val == x; }
# 175 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  friend bool operator==(const linear_congruential& x,
                         const linear_congruential& y)
  { return x._x == y._x; }
  friend bool operator!=(const linear_congruential& x,
                         const linear_congruential& y)
  { return !(x == y); }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os,
             const linear_congruential& lcg)
  {
    return os << lcg._x;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is,
             linear_congruential& lcg)
  {
    return is >> lcg._x;
  }

private:



  IntType _x;
};
# 243 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
template<class IntType, IntType a, IntType c, IntType m, IntType val>
const bool linear_congruential<IntType, a, c, m, val>::has_fixed_range;
template<class IntType, IntType a, IntType c, IntType m, IntType val>
const typename linear_congruential<IntType, a, c, m, val>::result_type linear_congruential<IntType, a, c, m, val>::min_value;
template<class IntType, IntType a, IntType c, IntType m, IntType val>
const typename linear_congruential<IntType, a, c, m, val>::result_type linear_congruential<IntType, a, c, m, val>::max_value;
template<class IntType, IntType a, IntType c, IntType m, IntType val>
const IntType linear_congruential<IntType,a,c,m,val>::modulus;


}
# 273 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
typedef random::linear_congruential<int32_t, 16807, 0, 2147483647,
  1043618065> minstd_rand0;
# 284 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
typedef random::linear_congruential<int32_t, 48271, 0, 2147483647,
  399268537> minstd_rand;
# 298 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
class rand48
{
public:
  typedef int32_t result_type;

  static const bool has_fixed_range = true;
  static const int32_t min_value = 0;
  static const int32_t max_value = integer_traits<int32_t>::const_max;






  int32_t min () const { return 0; }



  int32_t max () const { return std::numeric_limits<int32_t>::max (); }
# 326 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  rand48() : lcf(cnv(static_cast<int32_t>(1))) {}
  template<class T> explicit rand48(T x0) : lcf(cnv(x0)) { }

  template<class It> rand48(It& first, It last) : lcf(first, last) { }
# 341 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp"
  void seed() { seed(static_cast<int32_t>(1)); }
  template<class T> void seed(T x0) { lcf.seed(cnv(x0)); }

  template<class It> void seed(It& first, It last) { lcf.seed(first,last); }




  int32_t operator()() { return static_cast<int32_t>(lcf() >> 17); }

  static bool validation(int32_t x) { return x == 1993516219; }




  template<class CharT,class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const rand48& r)
  { os << r.lcf; return os; }

  template<class CharT,class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, rand48& r)
  { is >> r.lcf; return is; }


  friend bool operator==(const rand48& x, const rand48& y)
  { return x.lcf == y.lcf; }
  friend bool operator!=(const rand48& x, const rand48& y)
  { return !(x == y); }







private:

  random::linear_congruential<uint64_t,
    uint64_t(0xDEECE66DUL) | (uint64_t(0x5) << 32),
    0xB, uint64_t(1)<<48, 0> lcf;
  template<class T>
  static uint64_t cnv(T x)
  {
    if(sizeof(T) < sizeof(uint64_t)) {
      return (static_cast<uint64_t>(x) << 16) | 0x330e;
    } else {
      return(static_cast<uint64_t>(x));
    }
  }
  static uint64_t cnv(float x) { return(static_cast<uint64_t>(x)); }
  static uint64_t cnv(double x) { return(static_cast<uint64_t>(x)); }
  static uint64_t cnv(long double x) { return(static_cast<uint64_t>(x)); }

};


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/enable_warnings.hpp" 1
# 402 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_congruential.hpp" 2
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp" 2


namespace boost {
namespace random {
# 47 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
template<class MLCG1, class MLCG2,

  typename MLCG1::result_type



  val>
class additive_combine
{
public:
  typedef MLCG1 first_base;
  typedef MLCG2 second_base;
  typedef typename MLCG1::result_type result_type;

  static const bool has_fixed_range = true;
  static const result_type min_value = 1;
  static const result_type max_value = MLCG1::max_value-1;






  result_type min () const { return 1; }



  result_type max () const { return (_mlcg1.max)()-1; }





  additive_combine() : _mlcg1(), _mlcg2() { }




  explicit additive_combine(result_type aseed)
    : _mlcg1(aseed), _mlcg2(aseed) { }





  additive_combine(typename MLCG1::result_type seed1,
                   typename MLCG2::result_type seed2)
    : _mlcg1(seed1), _mlcg2(seed2) { }
# 105 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
  template<class It> additive_combine(It& first, It last)
    : _mlcg1(first, last), _mlcg2(first, last) { }





  void seed()
  {
    _mlcg1.seed();
    _mlcg2.seed();
  }





  void seed(result_type aseed)
  {
    _mlcg1.seed(aseed);
    _mlcg2.seed(aseed);
  }





  void seed(typename MLCG1::result_type seed1,
            typename MLCG2::result_type seed2)
  {
    _mlcg1.seed(seed1);
    _mlcg2.seed(seed2);
  }
# 149 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
  template<class It> void seed(It& first, It last)
  {
    _mlcg1.seed(first, last);
    _mlcg2.seed(first, last);
  }




  result_type operator()() {
    result_type z = _mlcg1() - _mlcg2();
    if(z < 1)
      z += MLCG1::modulus-1;
    return z;
  }

  static bool validation(result_type x) { return val == x; }
# 177 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const additive_combine& r)
  { os << r._mlcg1 << " " << r._mlcg2; return os; }





  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, additive_combine& r)
  { is >> r._mlcg1 >> std::ws >> r._mlcg2; return is; }






  friend bool operator==(const additive_combine& x, const additive_combine& y)
  { return x._mlcg1 == y._mlcg1 && x._mlcg2 == y._mlcg2; }




  friend bool operator!=(const additive_combine& x, const additive_combine& y)
  { return !(x == y); }
# 212 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
private:
  MLCG1 _mlcg1;
  MLCG2 _mlcg2;
};

}
# 227 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/additive_combine.hpp"
typedef random::additive_combine<
    random::linear_congruential<int32_t, 40014, 0, 2147483563, 0>,
    random::linear_congruential<int32_t, 40692, 0, 2147483399, 0>,
  2060321752> ecuyer1988;

}
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp" 2


namespace boost {
namespace random {
# 60 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp"
template<class IntType, IntType a, IntType b, IntType p, IntType val>
class inversive_congruential
{
public:
  typedef IntType result_type;

  static const bool has_fixed_range = true;
  static const result_type min_value = (b == 0 ? 1 : 0);
  static const result_type max_value = p-1;



  static const result_type multiplier = a;
  static const result_type increment = b;
  static const result_type modulus = p;

  result_type min () const { return b == 0 ? 1 : 0; }
  result_type max () const { return p-1; }





  explicit inversive_congruential(IntType y0 = 1) : value(y0)
  {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((b >= 0) == 0 ? false : true) >)> boost_static_assert_typedef_85;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((p > 1) == 0 ? false : true) >)> boost_static_assert_typedef_86;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((a >= 1) == 0 ? false : true) >)> boost_static_assert_typedef_87;
    if(b == 0)
      ((y0 > 0) ? static_cast<void> (0) : __assert_fail ("y0 > 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp", 89, __PRETTY_FUNCTION__));
  }
  template<class It> inversive_congruential(It& first, It last)
  { seed(first, last); }


  void seed(IntType y0 = 1) { value = y0; if(b == 0) ((y0 > 0) ? static_cast<void> (0) : __assert_fail ("y0 > 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp", 95, __PRETTY_FUNCTION__)); }
  template<class It> void seed(It& first, It last)
  {
    if(first == last)
      throw std::invalid_argument("inversive_congruential::seed");
    value = *first++;
  }
  IntType operator()()
  {
    typedef const_mod<IntType, p> do_mod;
    value = do_mod::mult_add(a, do_mod::invert(value), b);
    return value;
  }

  static bool validation(result_type x) { return val == x; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, inversive_congruential x)
  { os << x.value; return os; }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, inversive_congruential& x)
  { is >> x.value; return is; }


  friend bool operator==(inversive_congruential x, inversive_congruential y)
  { return x.value == y.value; }
  friend bool operator!=(inversive_congruential x, inversive_congruential y)
  { return !(x == y); }







private:
  IntType value;
};



template<class IntType, IntType a, IntType b, IntType p, IntType val>
const bool inversive_congruential<IntType, a, b, p, val>::has_fixed_range;
template<class IntType, IntType a, IntType b, IntType p, IntType val>
const typename inversive_congruential<IntType, a, b, p, val>::result_type inversive_congruential<IntType, a, b, p, val>::min_value;
template<class IntType, IntType a, IntType b, IntType p, IntType val>
const typename inversive_congruential<IntType, a, b, p, val>::result_type inversive_congruential<IntType, a, b, p, val>::max_value;
template<class IntType, IntType a, IntType b, IntType p, IntType val>
const typename inversive_congruential<IntType, a, b, p, val>::result_type inversive_congruential<IntType, a, b, p, val>::multiplier;
template<class IntType, IntType a, IntType b, IntType p, IntType val>
const typename inversive_congruential<IntType, a, b, p, val>::result_type inversive_congruential<IntType, a, b, p, val>::increment;
template<class IntType, IntType a, IntType b, IntType p, IntType val>
const typename inversive_congruential<IntType, a, b, p, val>::result_type inversive_congruential<IntType, a, b, p, val>::modulus;


}
# 168 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/inversive_congruential.hpp"
typedef random::inversive_congruential<int32_t, 9102, 2147483647-36884165,
  2147483647, 0> hellekalek1995;

}
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp" 1
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp" 2


namespace boost {
namespace random {
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp"
template<class UniformRandomNumberGenerator, int k,

  typename UniformRandomNumberGenerator::result_type



  val = 0>
class shuffle_output
{
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef typename base_type::result_type result_type;

  static const bool has_fixed_range = false;
  static const int buffer_size = k;







  shuffle_output() : _rng() { init(); }
# 89 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp"
  template<class T>
  explicit shuffle_output(T s) : _rng(s) { init(); }
# 100 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp"
  explicit shuffle_output(const base_type & rng) : _rng(rng) { init(); }
  template<class It> shuffle_output(It& first, It last)
    : _rng(first, last) { init(); }
  void seed() { _rng.seed(); init(); }






  template<class T>
  void seed(T s) { _rng.seed(s); init(); }
  template<class It> void seed(It& first, It last)
  {
    _rng.seed(first, last);
    init();
  }

  const base_type& base() const { return _rng; }

  result_type operator()() {


    result_type range = (max)()-(min)()+1;
    int j = k*(y-(min)())/range;

    y = v[j];
    v[j] = _rng();
    return y;
  }

  result_type min () const { return (_rng.min)(); }
  result_type max () const { return (_rng.max)(); }
  static bool validation(result_type x) { return val == x; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const shuffle_output& s)
  {
    os << s._rng << " " << s.y << " ";
    for(int i = 0; i < s.buffer_size; ++i)
      os << s.v[i] << " ";
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, shuffle_output& s)
  {
    is >> s._rng >> std::ws >> s.y >> std::ws;
    for(int i = 0; i < s.buffer_size; ++i)
      is >> s.v[i] >> std::ws;
    return is;
  }


  friend bool operator==(const shuffle_output& x, const shuffle_output& y)
  { return x._rng == y._rng && x.y == y.y && std::equal(x.v, x.v+k, y.v); }
  friend bool operator!=(const shuffle_output& x, const shuffle_output& y)
  { return !(x == y); }







private:
  void init()
  {

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<result_type>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_174;

    result_type range = (max)()-(min)();
    ((range > 0) ? static_cast<void> (0) : __assert_fail ("range > 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp", 177, __PRETTY_FUNCTION__));
    if(static_cast<unsigned long>(k * range) <
       static_cast<unsigned long>(range))

      ((!"overflow will occur") ? static_cast<void> (0) : __assert_fail ("!\"overflow will occur\"", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp", 181, __PRETTY_FUNCTION__));


    for(result_type * p = v; p != v+k; ++p)
      *p = _rng();
    y = _rng();
  }

  base_type _rng;
  result_type v[k];
  result_type y;
};



template<class UniformRandomNumberGenerator, int k,

  typename UniformRandomNumberGenerator::result_type



  val>
const bool shuffle_output<UniformRandomNumberGenerator, k, val>::has_fixed_range;

template<class UniformRandomNumberGenerator, int k,

  typename UniformRandomNumberGenerator::result_type



  val>
const int shuffle_output<UniformRandomNumberGenerator, k, val>::buffer_size;


}
# 227 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/shuffle_output.hpp"
typedef random::shuffle_output<
    random::linear_congruential<uint32_t, 1366, 150889, 714025, 0>,
  97, 139726> kreutzer1986;


}
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/ptr_helper.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/ptr_helper.hpp"
namespace boost {
namespace random {
namespace detail {


template<class T>
struct ptr_helper
{
  typedef T value_type;
  typedef T& reference_type;
  typedef const T& rvalue_type;
  static reference_type ref(T& r) { return r; }
  static const T& ref(const T& r) { return r; }
};


template<class T>
struct ptr_helper<T&>
{
  typedef T value_type;
  typedef T& reference_type;
  typedef T& rvalue_type;
  static reference_type ref(T& r) { return r; }
  static const T& ref(const T& r) { return r; }
};

template<class T>
struct ptr_helper<T*>
{
  typedef T value_type;
  typedef T& reference_type;
  typedef T* rvalue_type;
  static reference_type ref(T * p) { return *p; }
  static const T& ref(const T * p) { return *p; }
};


}
}
}
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/seed.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/seed.hpp"
namespace boost {
namespace random {
namespace detail {

template<class T>
struct disable_seed : boost::disable_if<boost::is_arithmetic<T> > {};

template<class Engine, class T>
struct disable_constructor : disable_seed<T> {};

template<class Engine>
struct disable_constructor<Engine, Engine> {};
# 52 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/seed.hpp"
}
}
}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp" 2

namespace boost {
namespace random {
# 64 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
class mersenne_twister
{
public:
  typedef UIntType result_type;
  static const int word_size = w;
  static const int state_size = n;
  static const int shift_size = m;
  static const int mask_bits = r;
  static const UIntType parameter_a = a;
  static const int output_u = u;
  static const int output_s = s;
  static const UIntType output_b = b;
  static const int output_t = t;
  static const UIntType output_c = c;
  static const int output_l = l;

  static const bool has_fixed_range = false;




  mersenne_twister() { seed(); }




  explicit mersenne_twister(const UIntType& value)
  { seed(value); }
  template<class It> mersenne_twister(It& first, It last) { seed(first,last); }
# 104 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
  template<class Generator> explicit mersenne_twister(Generator& gen, typename ::boost::random::detail::disable_constructor<mersenne_twister, Generator>::type* = 0)
  { seed(gen); }




  void seed() { seed(UIntType(5489)); }






  void seed(const UIntType& value)
  {




    const UIntType mask = ~0u;
    x[0] = value & mask;
    for (i = 1; i < n; i++) {

      x[i] = (1812433253UL * (x[i-1] ^ (x[i-1] >> (w-2))) + i) & mask;
    }
  }







  template<class Generator> void seed(Generator& gen, typename ::boost::random::detail::disable_seed<Generator>::type* = 0)
  {

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<result_type>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_140;


    for(int j = 0; j < n; j++)
      x[j] = gen();
    i = n;
  }

  template<class It>
  void seed(It& first, It last)
  {
    int j;
    for(j = 0; j < n && first != last; ++j, ++first)
      x[j] = *first;
    i = n;
    if(first == last && j < n)
      throw std::invalid_argument("mersenne_twister::seed");
  }

  result_type min () const { return 0; }
  result_type max () const
  {

    result_type res = 0;
    for(int j = 0; j < w; ++j)
      res |= (1u << j);
    return res;
  }

  result_type operator()();
  static bool validation(result_type v) { return val == v; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const mersenne_twister& mt)
  {
    for(int j = 0; j < mt.state_size; ++j)
      os << mt.compute(j) << " ";
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, mersenne_twister& mt)
  {
    for(int j = 0; j < mt.state_size; ++j)
      is >> mt.x[j] >> std::ws;



    mt.i = mt.state_size;
    return is;
  }


  friend bool operator==(const mersenne_twister& x, const mersenne_twister& y)
  {
    for(int j = 0; j < state_size; ++j)
      if(x.compute(j) != y.compute(j))
        return false;
    return true;
  }

  friend bool operator!=(const mersenne_twister& x, const mersenne_twister& y)
  { return !(x == y); }
# 222 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
private:


  UIntType compute(unsigned int index) const
  {

    return x[ (i + n + index) % (2*n) ];
  }
  void twist(int block);
# 239 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
  UIntType x[2*n];
  int i;
};



template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const bool mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::has_fixed_range;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::state_size;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::shift_size;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::mask_bits;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::parameter_a;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_u;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_s;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_b;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_t;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_c;
template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_l;



template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
void mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::twist(int block)
{
  const UIntType upper_mask = (~0u) << r;
  const UIntType lower_mask = ~upper_mask;

  if(block == 0) {
    for(int j = n; j < 2*n; j++) {
      UIntType y = (x[j-n] & upper_mask) | (x[j-(n-1)] & lower_mask);
      x[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);
    }
  } else if (block == 1) {

    {
      for(int j = 0; j < n-m; j++) {
        UIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);
        x[j] = x[j+n+m] ^ (y >> 1) ^ (y&1 ? a : 0);
      }
    }

    for(int j = n-m; j < n-1; j++) {
      UIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);
      x[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);
    }

    UIntType y = (x[2*n-1] & upper_mask) | (x[0] & lower_mask);
    x[n-1] = x[m-1] ^ (y >> 1) ^ (y&1 ? a : 0);
    i = 0;
  }
}


template<class UIntType, int w, int n, int m, int r, UIntType a, int u,
  int s, UIntType b, int t, UIntType c, int l, UIntType val>
inline typename mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::result_type
mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::operator()()
{
  if(i == n)
    twist(0);
  else if(i >= 2*n)
    twist(1);

  UIntType z = x[i];
  ++i;
  z ^= (z >> u);
  z ^= ((z << s) & b);
  z ^= ((z << t) & c);
  z ^= (z >> l);
  return z;
}

}
# 346 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
typedef random::mersenne_twister<uint32_t,32,351,175,19,0xccab8ee7,11,
  7,0x31b6ab00,15,0xffe50000,17, 0xa37d3c92> mt11213b;
# 360 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/mersenne_twister.hpp"
typedef random::mersenne_twister<uint32_t,32,624,397,31,0x9908b0df,11,
  7,0x9d2c5680,15,0xefc60000,18, 3346425566U> mt19937;

}


# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/pass_through_engine.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/pass_through_engine.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/disable_warnings.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/pass_through_engine.hpp" 2

namespace boost {
namespace random {
namespace detail {

template<class UniformRandomNumberGenerator>
class pass_through_engine
{
private:
  typedef ptr_helper<UniformRandomNumberGenerator> helper_type;

public:
  typedef typename helper_type::value_type base_type;
  typedef typename base_type::result_type result_type;

  explicit pass_through_engine(UniformRandomNumberGenerator rng)

    : _rng(static_cast<typename helper_type::rvalue_type>(rng))
  { }

  result_type min () const { return (base().min)(); }
  result_type max () const { return (base().max)(); }
  base_type& base() { return helper_type::ref(_rng); }
  const base_type& base() const { return helper_type::ref(_rng); }

  result_type operator()() { return base()(); }

private:
  UniformRandomNumberGenerator _rng;
};



template<class UniformRandomNumberGenerator, class CharT, class Traits>
std::basic_ostream<CharT,Traits>&
operator<<(
    std::basic_ostream<CharT,Traits>& os
    , const pass_through_engine<UniformRandomNumberGenerator>& ud
    )
{
    return os << ud.base();
}

template<class UniformRandomNumberGenerator, class CharT, class Traits>
std::basic_istream<CharT,Traits>&
operator>>(
    std::basic_istream<CharT,Traits>& is
    , const pass_through_engine<UniformRandomNumberGenerator>& ud
    )
{
    return is >> ud.base();
}
# 93 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/pass_through_engine.hpp"
}
}
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/enable_warnings.hpp" 1
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/pass_through_engine.hpp" 2
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/disable_warnings.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp" 2

namespace boost {
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp"
namespace detail {

template<class RealType>
class new_uniform_01
{
public:
  typedef RealType input_type;
  typedef RealType result_type;

  result_type min () const { return result_type(0); }
  result_type max () const { return result_type(1); }
  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng) {
    for (;;) {
      typedef typename Engine::result_type base_result;
      result_type factor = result_type(1) /
              (result_type((eng.max)()-(eng.min)()) +
               result_type(std::numeric_limits<base_result>::is_integer ? 1 : 0));
      result_type result = result_type(eng() - (eng.min)()) * factor;
      if (result < result_type(1))
        return result;
    }
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const new_uniform_01&)
  {
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, new_uniform_01&)
  {
    return is;
  }

};

template<class UniformRandomNumberGenerator, class RealType>
class backward_compatible_uniform_01
{
  typedef boost::random::detail::ptr_helper<UniformRandomNumberGenerator> traits;
  typedef boost::random::detail::pass_through_engine<UniformRandomNumberGenerator> internal_engine_type;
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef RealType result_type;

  static const bool has_fixed_range = false;


  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_132;


  explicit backward_compatible_uniform_01(typename traits::rvalue_type rng)
    : _rng(rng),
      _factor(result_type(1) /
              (result_type((_rng.max)()-(_rng.min)()) +
               result_type(std::numeric_limits<base_result>::is_integer ? 1 : 0)))
  {
  }


  result_type min () const { return result_type(0); }
  result_type max () const { return result_type(1); }
  typename traits::value_type& base() { return _rng.base(); }
  const typename traits::value_type& base() const { return _rng.base(); }
  void reset() { }

  result_type operator()() {
    for (;;) {
      result_type result = result_type(_rng() - (_rng.min)()) * _factor;
      if (result < result_type(1))
        return result;
    }
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const backward_compatible_uniform_01& u)
  {
    os << u._rng;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, backward_compatible_uniform_01& u)
  {
    is >> u._rng;
    return is;
  }


private:
  typedef typename internal_engine_type::result_type base_result;
  internal_engine_type _rng;
  result_type _factor;
};



template<class UniformRandomNumberGenerator, class RealType>
const bool backward_compatible_uniform_01<UniformRandomNumberGenerator, RealType>::has_fixed_range;


template<class UniformRandomNumberGenerator>
struct select_uniform_01
{
  template<class RealType>
  struct apply
  {
    typedef backward_compatible_uniform_01<UniformRandomNumberGenerator, RealType> type;
  };
};

template<>
struct select_uniform_01<float>
{
  template<class RealType>
  struct apply
  {
    typedef new_uniform_01<float> type;
  };
};

template<>
struct select_uniform_01<double>
{
  template<class RealType>
  struct apply
  {
    typedef new_uniform_01<double> type;
  };
};

template<>
struct select_uniform_01<long double>
{
  template<class RealType>
  struct apply
  {
    typedef new_uniform_01<long double> type;
  };
};

}




template<class UniformRandomNumberGenerator = double, class RealType = double>
class uniform_01
  : public detail::select_uniform_01<UniformRandomNumberGenerator>::template apply<RealType>::type
{
  typedef typename detail::select_uniform_01<UniformRandomNumberGenerator>::template apply<RealType>::type impl_type;
  typedef boost::random::detail::ptr_helper<UniformRandomNumberGenerator> traits;
public:

  uniform_01() {}

  explicit uniform_01(typename traits::rvalue_type rng)
    : impl_type(rng)
  {
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const uniform_01& u)
  {
    os << static_cast<const impl_type&>(u);
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, uniform_01& u)
  {
    is >> static_cast<impl_type&>(u);
    return is;
  }

};



}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/enable_warnings.hpp" 1
# 272 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_01.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp" 2



namespace boost {
namespace random {
# 89 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
template<class UIntType, int w, unsigned int p, unsigned int q,
         UIntType val = 0>
class lagged_fibonacci
{
public:
  typedef UIntType result_type;
  static const bool has_fixed_range = false;
  static const int word_size = w;
  static const unsigned int long_lag = p;
  static const unsigned int short_lag = q;




  result_type min () const { return 0; }



  result_type max () const { return wordmask; }




  lagged_fibonacci() { init_wordmask(); seed(); }



  explicit lagged_fibonacci(uint32_t value) { init_wordmask(); seed(value); }



  template<class It> lagged_fibonacci(It& first, It last)
  { init_wordmask(); seed(first, last); }


private:

  void init_wordmask()
  {
    wordmask = 0;
    for(int j = 0; j < w; ++j)
      wordmask |= (1u << j);
  }


public:




  void seed(uint32_t value = 331u)
  {
    minstd_rand0 gen(value);
    for(unsigned int j = 0; j < long_lag; ++j)
      x[j] = gen() & wordmask;
    i = long_lag;
  }






  template<class It>
  void seed(It& first, It last)
  {

    unsigned int j;
    for(j = 0; j < long_lag && first != last; ++j, ++first)
      x[j] = *first & wordmask;
    i = long_lag;
    if(first == last && j < long_lag)
      throw std::invalid_argument("lagged_fibonacci::seed");
  }




  result_type operator()()
  {
    if(i >= long_lag)
      fill();
    return x[i++];
  }

  static bool validation(result_type x)
  {
    return x == val;
  }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const lagged_fibonacci& f)
  {
    os << f.i << " ";
    for(unsigned int i = 0; i < f.long_lag; ++i)
      os << f.x[i] << " ";
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, lagged_fibonacci& f)
  {



      is >> f.i >> std::ws;
      for(unsigned int i = 0; i < f.long_lag; ++i)
          is >> f.x[i] >> std::ws;
      return is;

  }


  friend bool operator==(const lagged_fibonacci& x, const lagged_fibonacci& y)
  { return x.i == y.i && std::equal(x.x, x.x+long_lag, y.x); }
  friend bool operator!=(const lagged_fibonacci& x,
                         const lagged_fibonacci& y)
  { return !(x == y); }
# 220 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
private:

  void fill();


  UIntType wordmask;
  unsigned int i;
  UIntType x[long_lag];
};



template<class UIntType, int w, unsigned int p, unsigned int q, UIntType val>
const bool lagged_fibonacci<UIntType, w, p, q, val>::has_fixed_range;
template<class UIntType, int w, unsigned int p, unsigned int q, UIntType val>
const unsigned int lagged_fibonacci<UIntType, w, p, q, val>::long_lag;
template<class UIntType, int w, unsigned int p, unsigned int q, UIntType val>
const unsigned int lagged_fibonacci<UIntType, w, p, q, val>::short_lag;




template<class UIntType, int w, unsigned int p, unsigned int q, UIntType val>
void lagged_fibonacci<UIntType, w, p, q, val>::fill()
{

  {
  for(unsigned int j = 0; j < short_lag; ++j)
    x[j] = (x[j] + x[j+(long_lag-short_lag)]) & wordmask;
  }
  for(unsigned int j = short_lag; j < long_lag; ++j)
    x[j] = (x[j] + x[j-short_lag]) & wordmask;
  i = 0;
}







template<class T, unsigned int p, unsigned int q>
struct fibonacci_validation
{
  static const bool is_specialized = false;
  static T value() { return 0; }
  static T tolerance() { return 0; }
};



template<class T, unsigned int p, unsigned int q>
const bool fibonacci_validation<T, p, q>::is_specialized;
# 288 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
template<> struct fibonacci_validation<double, 607, 273> { static const bool is_specialized = true; static double value() { return 0.4293817707235914; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 1279, 418> { static const bool is_specialized = true; static double value() { return 0.9421630240437659; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 2281, 1252> { static const bool is_specialized = true; static double value() { return 0.1768114046909004; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 3217, 576> { static const bool is_specialized = true; static double value() { return 0.1956232694868209; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 4423, 2098> { static const bool is_specialized = true; static double value() { return 0.9499762202147172; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 9689, 5502> { static const bool is_specialized = true; static double value() { return 0.05737836943695162; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 19937, 9842> { static const bool is_specialized = true; static double value() { return 0.5076528587449834; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 23209, 13470> { static const bool is_specialized = true; static double value() { return 0.5414473810619185; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
template<> struct fibonacci_validation<double, 44497, 21034> { static const bool is_specialized = true; static double value() { return 0.254135073399297; } static double tolerance() { return (std::max)(1e-14, static_cast<double>(5*std::numeric_limits<double>::epsilon())); } };
# 324 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
template<class RealType, int w, unsigned int p, unsigned int q>
class lagged_fibonacci_01
{
public:
  typedef RealType result_type;
  static const bool has_fixed_range = false;
  static const int word_size = w;
  static const unsigned int long_lag = p;
  static const unsigned int short_lag = q;


  lagged_fibonacci_01() { init_modulus(); seed(); }

  explicit lagged_fibonacci_01(const uint32_t& value)
  { init_modulus(); seed(value); }

  template<class Generator> explicit lagged_fibonacci_01(Generator& gen, typename ::boost::random::detail::disable_constructor<lagged_fibonacci_01, Generator>::type* = 0)
  { init_modulus(); seed(gen); }
  template<class It> lagged_fibonacci_01(It& first, It last)
  { init_modulus(); seed(first, last); }


private:

  void init_modulus()
  {


    using std::pow;

    _modulus = pow(RealType(2), word_size);
  }


public:

  void seed() { seed(331u); }







  void seed(const uint32_t& value)
  {
    minstd_rand0 intgen(value);
    seed(intgen);
  }







  template<class Generator> void seed(Generator& gen, typename ::boost::random::detail::disable_seed<Generator>::type* = 0)
  {

    typedef detail::pass_through_engine<Generator&> ref_gen;
    uniform_01<ref_gen, RealType> gen01 =
      uniform_01<ref_gen, RealType>(ref_gen(gen));

    for(unsigned int j = 0; j < long_lag; ++j)
      x[j] = gen01();
    i = long_lag;
  }

  template<class It>
  void seed(It& first, It last)
  {


    using std::fmod;
    using std::pow;

    unsigned long mask = ~((~0u) << (w%32));
    RealType two32 = pow(RealType(2), 32);
    unsigned int j;
    for(j = 0; j < long_lag && first != last; ++j) {
      x[j] = RealType(0);
      for(int k = 0; k < w/32 && first != last; ++k, ++first)
        x[j] += *first / pow(two32,k+1);
      if(first != last && mask != 0) {
        x[j] += fmod((*first & mask) / _modulus, RealType(1));
        ++first;
      }
    }
    i = long_lag;
    if(first == last && j < long_lag)
      throw std::invalid_argument("lagged_fibonacci_01::seed");
  }

  result_type min () const { return result_type(0); }
  result_type max () const { return result_type(1); }

  result_type operator()()
  {
    if(i >= long_lag)
      fill();
    return x[i++];
  }

  static bool validation(result_type x)
  {
    result_type v = fibonacci_validation<result_type, p, q>::value();
    result_type epsilon = fibonacci_validation<result_type, p, q>::tolerance();




    return x > v - epsilon && x < v + epsilon;
  }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const lagged_fibonacci_01&f)
  {


    using std::pow;

    os << f.i << " ";
    std::ios_base::fmtflags oldflags = os.flags(os.dec | os.fixed | os.left);
    for(unsigned int i = 0; i < f.long_lag; ++i)
      os << f.x[i] * f._modulus << " ";
    os.flags(oldflags);
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, lagged_fibonacci_01& f)
    {



        is >> f.i >> std::ws;
        for(unsigned int i = 0; i < f.long_lag; ++i) {
            typename lagged_fibonacci_01::result_type value;
            is >> value >> std::ws;
            f.x[i] = value / f._modulus;
        }
        return is;

    }


  friend bool operator==(const lagged_fibonacci_01& x,
                         const lagged_fibonacci_01& y)
  { return x.i == y.i && std::equal(x.x, x.x+long_lag, y.x); }
  friend bool operator!=(const lagged_fibonacci_01& x,
                         const lagged_fibonacci_01& y)
  { return !(x == y); }
# 489 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
private:

  void fill();

  unsigned int i;
  RealType x[long_lag];
  RealType _modulus;
};



template<class RealType, int w, unsigned int p, unsigned int q>
const bool lagged_fibonacci_01<RealType, w, p, q>::has_fixed_range;
template<class RealType, int w, unsigned int p, unsigned int q>
const unsigned int lagged_fibonacci_01<RealType, w, p, q>::long_lag;
template<class RealType, int w, unsigned int p, unsigned int q>
const unsigned int lagged_fibonacci_01<RealType, w, p, q>::short_lag;
template<class RealType, int w, unsigned int p, unsigned int q>
const int lagged_fibonacci_01<RealType,w,p,q>::word_size;




template<class RealType, int w, unsigned int p, unsigned int q>
void lagged_fibonacci_01<RealType, w, p, q>::fill()
{

  {
  for(unsigned int j = 0; j < short_lag; ++j) {
    RealType t = x[j] + x[j+(long_lag-short_lag)];
    if(t >= RealType(1))
      t -= RealType(1);
    x[j] = t;
  }
  }
  for(unsigned int j = short_lag; j < long_lag; ++j) {
    RealType t = x[j] + x[j-short_lag];
    if(t >= RealType(1))
      t -= RealType(1);
    x[j] = t;
  }
  i = 0;
}


}
# 564 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lagged_fibonacci.hpp"
typedef random::lagged_fibonacci_01<double, 48, 607, 273> lagged_fibonacci607;



typedef random::lagged_fibonacci_01<double, 48, 1279, 418> lagged_fibonacci1279;



typedef random::lagged_fibonacci_01<double, 48, 2281, 1252> lagged_fibonacci2281;



typedef random::lagged_fibonacci_01<double, 48, 3217, 576> lagged_fibonacci3217;



typedef random::lagged_fibonacci_01<double, 48, 4423, 2098> lagged_fibonacci4423;



typedef random::lagged_fibonacci_01<double, 48, 9689, 5502> lagged_fibonacci9689;



typedef random::lagged_fibonacci_01<double, 48, 19937, 9842> lagged_fibonacci19937;



typedef random::lagged_fibonacci_01<double, 48, 23209, 13470> lagged_fibonacci23209;



typedef random::lagged_fibonacci_01<double, 48, 44497, 21034> lagged_fibonacci44497;






}
# 42 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/ranlux.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/ranlux.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp" 2




namespace boost {
namespace random {
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp"
template<class IntType, IntType m, unsigned int s, unsigned int r,
  IntType val>
class subtract_with_carry
{
public:
  typedef IntType result_type;
  static const bool has_fixed_range = true;
  static const result_type min_value = 0;
  static const result_type max_value = m-1;
  static const result_type modulus = m;
  static const unsigned int long_lag = r;
  static const unsigned int short_lag = s;

  subtract_with_carry() {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<result_type>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_94;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<result_type>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_95;

    seed();
  }
  explicit subtract_with_carry(const uint32_t& value)
  { seed(value); }
  template<class Generator> explicit subtract_with_carry(Generator& gen, typename ::boost::random::detail::disable_constructor<subtract_with_carry, Generator>::type* = 0)
  { seed(gen); }
  template<class It> subtract_with_carry(It& first, It last) { seed(first,last); }



  void seed() { seed(19780503u); }
  void seed(const uint32_t& value)
  {
    random::linear_congruential<int32_t, 40014, 0, 2147483563, 0> intgen(value);
    seed(intgen);
  }




  template<class Generator> void seed(Generator& gen, typename ::boost::random::detail::disable_seed<Generator>::type* = 0)
  {

    for(unsigned int j = 0; j < long_lag; ++j)
      x[j] = gen() % modulus;
    carry = (x[long_lag-1] == 0);
    k = 0;
  }

  template<class It>
  void seed(It& first, It last)
  {
    unsigned int j;
    for(j = 0; j < long_lag && first != last; ++j, ++first)
      x[j] = *first % modulus;
    if(first == last && j < long_lag)
      throw std::invalid_argument("subtract_with_carry::seed");
    carry = (x[long_lag-1] == 0);
    k = 0;
   }

  result_type min () const { return min_value; }
  result_type max () const { return max_value; }

  result_type operator()()
  {
    int short_index = k - short_lag;
    if(short_index < 0)
      short_index += long_lag;
    IntType delta;
    if (x[short_index] >= x[k] + carry) {

      delta = x[short_index] - (x[k] + carry);
      carry = 0;
    } else {

      delta = modulus - x[k] - carry + x[short_index];
      carry = 1;
    }
    x[k] = delta;
    ++k;
    if(k >= long_lag)
      k = 0;
    return delta;
  }

public:
  static bool validation(result_type x) { return x == val; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os,
             const subtract_with_carry& f)
  {
    for(unsigned int j = 0; j < f.long_lag; ++j)
      os << f.compute(j) << " ";
    os << f.carry << " ";
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, subtract_with_carry& f)
  {
    for(unsigned int j = 0; j < f.long_lag; ++j)
      is >> f.x[j] >> std::ws;
    is >> f.carry >> std::ws;
    f.k = 0;
    return is;
  }


  friend bool operator==(const subtract_with_carry& x, const subtract_with_carry& y)
  {
    for(unsigned int j = 0; j < r; ++j)
      if(x.compute(j) != y.compute(j))
        return false;
    return true;
  }

  friend bool operator!=(const subtract_with_carry& x, const subtract_with_carry& y)
  { return !(x == y); }
# 216 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp"
private:


  IntType compute(unsigned int index) const
  {
    return x[(k+index) % long_lag];
  }
# 239 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp"
  IntType x[long_lag];
  unsigned int k;
  int carry;
};



template<class IntType, IntType m, unsigned int s, unsigned int r, IntType val>
const bool subtract_with_carry<IntType, m, s, r, val>::has_fixed_range;
template<class IntType, IntType m, unsigned int s, unsigned int r, IntType val>
const IntType subtract_with_carry<IntType, m, s, r, val>::min_value;
template<class IntType, IntType m, unsigned int s, unsigned int r, IntType val>
const IntType subtract_with_carry<IntType, m, s, r, val>::max_value;
template<class IntType, IntType m, unsigned int s, unsigned int r, IntType val>
const IntType subtract_with_carry<IntType, m, s, r, val>::modulus;
template<class IntType, IntType m, unsigned int s, unsigned int r, IntType val>
const unsigned int subtract_with_carry<IntType, m, s, r, val>::long_lag;
template<class IntType, IntType m, unsigned int s, unsigned int r, IntType val>
const unsigned int subtract_with_carry<IntType, m, s, r, val>::short_lag;





template<class RealType, int w, unsigned int s, unsigned int r, int val=0>
class subtract_with_carry_01
{
public:
  typedef RealType result_type;
  static const bool has_fixed_range = false;
  static const int word_size = w;
  static const unsigned int long_lag = r;
  static const unsigned int short_lag = s;


  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<result_type>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_274;


  subtract_with_carry_01() { init_modulus(); seed(); }
  explicit subtract_with_carry_01(uint32_t value)
  { init_modulus(); seed(value); }
  template<class It> subtract_with_carry_01(It& first, It last)
  { init_modulus(); seed(first,last); }

private:

  void init_modulus()
  {


    using std::pow;

    _modulus = pow(RealType(2), word_size);
  }


public:


  void seed(uint32_t value = 19780503u)
  {


    using std::fmod;

    random::linear_congruential<int32_t, 40014, 0, 2147483563, 0> gen(value);
    unsigned long array[(w+31)/32 * long_lag];
    for(unsigned int j = 0; j < sizeof(array)/sizeof(unsigned long); ++j)
      array[j] = gen();
    unsigned long * start = array;
    seed(start, array + sizeof(array)/sizeof(unsigned long));
  }

  template<class It>
  void seed(It& first, It last)
  {


    using std::fmod;
    using std::pow;

    unsigned long mask = ~((~0u) << (w%32));
    RealType two32 = pow(RealType(2), 32);
    unsigned int j;
    for(j = 0; j < long_lag && first != last; ++j) {
      x[j] = RealType(0);
      for(int i = 0; i < w/32 && first != last; ++i, ++first)
        x[j] += *first / pow(two32,i+1);
      if(first != last && mask != 0) {
        x[j] += fmod((*first & mask) / _modulus, RealType(1));
        ++first;
      }
    }
    if(first == last && j < long_lag)
      throw std::invalid_argument("subtract_with_carry_01::seed");
    carry = (x[long_lag-1] ? 0 : 1 / _modulus);
    k = 0;
  }

  result_type min () const { return result_type(0); }
  result_type max () const { return result_type(1); }

  result_type operator()()
  {
    int short_index = k - short_lag;
    if(short_index < 0)
      short_index += long_lag;
    RealType delta = x[short_index] - x[k] - carry;
    if(delta < 0) {
      delta += RealType(1);
      carry = RealType(1)/_modulus;
    } else {
      carry = 0;
    }
    x[k] = delta;
    ++k;
    if(k >= long_lag)
      k = 0;
    return delta;
  }

  static bool validation(result_type x)
  { return x == val/pow(RealType(2), word_size); }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os,
             const subtract_with_carry_01& f)
  {


    using std::pow;

    std::ios_base::fmtflags oldflags = os.flags(os.dec | os.fixed | os.left);
    for(unsigned int j = 0; j < f.long_lag; ++j)
      os << (f.compute(j) * f._modulus) << " ";
    os << (f.carry * f._modulus);
    os.flags(oldflags);
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, subtract_with_carry_01& f)
  {






    typename subtract_with_carry_01::result_type value;
    for(unsigned int j = 0; j < long_lag; ++j) {
      is >> value >> std::ws;
      f.x[j] = value / f._modulus;
    }
    is >> value >> std::ws;
    f.carry = value / f._modulus;

    f.k = 0;
    return is;
  }


  friend bool operator==(const subtract_with_carry_01& x,
                         const subtract_with_carry_01& y)
  {
    for(unsigned int j = 0; j < r; ++j)
      if(x.compute(j) != y.compute(j))
        return false;
    return true;
  }

  friend bool operator!=(const subtract_with_carry_01& x,
                         const subtract_with_carry_01& y)
  { return !(x == y); }
# 432 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/subtract_with_carry.hpp"
private:

  RealType compute(unsigned int index) const;

  unsigned int k;
  RealType carry;
  RealType x[long_lag];
  RealType _modulus;
};



template<class RealType, int w, unsigned int s, unsigned int r, int val>
const bool subtract_with_carry_01<RealType, w, s, r, val>::has_fixed_range;
template<class RealType, int w, unsigned int s, unsigned int r, int val>
const int subtract_with_carry_01<RealType, w, s, r, val>::word_size;
template<class RealType, int w, unsigned int s, unsigned int r, int val>
const unsigned int subtract_with_carry_01<RealType, w, s, r, val>::long_lag;
template<class RealType, int w, unsigned int s, unsigned int r, int val>
const unsigned int subtract_with_carry_01<RealType, w, s, r, val>::short_lag;



template<class RealType, int w, unsigned int s, unsigned int r, int val>
RealType subtract_with_carry_01<RealType, w, s, r, val>::compute(unsigned int index) const
{
  return x[(k+index) % long_lag];
}


}
}
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/ranlux.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/discard_block.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/discard_block.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/discard_block.hpp" 2


namespace boost {
namespace random {
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/discard_block.hpp"
template<class UniformRandomNumberGenerator, unsigned int p, unsigned int r>
class discard_block
{
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef typename base_type::result_type result_type;

  static const bool has_fixed_range = false;
  static const unsigned int total_block = p;
  static const unsigned int returned_block = r;


  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((total_block >= returned_block) == 0 ? false : true) >)> boost_static_assert_typedef_50;


  discard_block() : _rng(), _n(0) { }
  explicit discard_block(const base_type & rng) : _rng(rng), _n(0) { }
  template<class T> explicit discard_block(T s) : _rng(s), _n(0) {}
  template<class It> discard_block(It& first, It last)
    : _rng(first, last), _n(0) { }
  void seed() { _rng.seed(); _n = 0; }
  template<class T> void seed(T s) { _rng.seed(s); _n = 0; }
  template<class It> void seed(It& first, It last)
  { _n = 0; _rng.seed(first, last); }

  const base_type& base() const { return _rng; }

  result_type operator()()
  {
    if(_n >= returned_block) {

      for( ; _n < total_block; ++_n)
        _rng();
      _n = 0;
    }
    ++_n;
    return _rng();
  }

  result_type min () const { return (_rng.min)(); }
  result_type max () const { return (_rng.max)(); }
  static bool validation(result_type x) { return true; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const discard_block& s)
  {
    os << s._rng << " " << s._n << " ";
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, discard_block& s)
  {
    is >> s._rng >> std::ws >> s._n >> std::ws;
    return is;
  }


  friend bool operator==(const discard_block& x, const discard_block& y)
  { return x._rng == y._rng && x._n == y._n; }
  friend bool operator!=(const discard_block& x, const discard_block& y)
  { return !(x == y); }
# 113 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/discard_block.hpp"
private:
  base_type _rng;
  unsigned int _n;
};



template<class UniformRandomNumberGenerator, unsigned int p, unsigned int r>
const bool discard_block<UniformRandomNumberGenerator, p, r>::has_fixed_range;
template<class UniformRandomNumberGenerator, unsigned int p, unsigned int r>
const unsigned int discard_block<UniformRandomNumberGenerator, p, r>::total_block;
template<class UniformRandomNumberGenerator, unsigned int p, unsigned int r>
const unsigned int discard_block<UniformRandomNumberGenerator, p, r>::returned_block;


}

}
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/ranlux.hpp" 2

namespace boost {

namespace random {
  typedef subtract_with_carry<int, (1<<24), 10, 24, 0> ranlux_base;
  typedef subtract_with_carry_01<float, 24, 10, 24> ranlux_base_01;
  typedef subtract_with_carry_01<double, 48, 10, 24> ranlux64_base_01;
}

namespace random {
namespace detail {
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/ranlux.hpp"
class ranlux_documentation {};
}
}


typedef random::discard_block<random::ranlux_base, 223, 24> ranlux3;

typedef random::discard_block<random::ranlux_base, 389, 24> ranlux4;


typedef random::discard_block<random::ranlux_base_01, 223, 24> ranlux3_01;

typedef random::discard_block<random::ranlux_base_01, 389, 24> ranlux4_01;


typedef random::discard_block<random::ranlux64_base_01, 223, 24> ranlux64_3_01;

typedef random::discard_block<random::ranlux64_base_01, 389, 24> ranlux64_4_01;


namespace random {
  typedef random::subtract_with_carry<int64_t, (int64_t(1)<<48), 10, 24, 0> ranlux64_base;
}

typedef random::discard_block<random::ranlux64_base, 223, 24> ranlux64_3;

typedef random::discard_block<random::ranlux64_base, 389, 24> ranlux64_4;


}
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp" 2

namespace boost {
namespace random {
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp"
template<class UIntType, int w, int k, int q, int s, UIntType val>
class linear_feedback_shift
{
public:
  typedef UIntType result_type;

  static const bool has_fixed_range = false;
  static const int word_size = w;
  static const int exponent1 = k;
  static const int exponent2 = q;
  static const int step_size = s;

  result_type min () const { return 0; }
  result_type max () const { return wordmask; }
# 61 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp"
  explicit linear_feedback_shift(UIntType s0 = 341) : wordmask(0)
  {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<UIntType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_65;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<UIntType>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_66;



    for(int i = 0; i < w; ++i)
      wordmask |= (1u << i);
    seed(s0);
  }

  template<class It> linear_feedback_shift(It& first, It last) : wordmask(0)
  {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<UIntType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_79;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<UIntType>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_80;



    for(int i = 0; i < w; ++i)
      wordmask |= (1u << i);
    seed(first, last);
  }

  void seed(UIntType s0 = 341) {
      if(s0 < (1 << (w-k))) {
          s0 += 1 << (w-k);
      }
      value = s0;
  }
  template<class It> void seed(It& first, It last)
  {
    if(first == last)
      throw std::invalid_argument("linear_feedback_shift::seed");
    value = *first++;
    ((value >= (1 << (w-k))) ? static_cast<void> (0) : __assert_fail ("value >= (1 << (w-k))", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp", 100, __PRETTY_FUNCTION__));
  }

  result_type operator()()
  {
    const UIntType b = (((value << q) ^ value) & wordmask) >> (k-s);
    const UIntType mask = ( (~static_cast<UIntType>(0)) << (w-k) ) & wordmask;
    value = ((value & mask) << s) ^ b;
    return value;
  }
  static bool validation(result_type x) { return val == x; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, linear_feedback_shift x)
  { os << x.value; return os; }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, linear_feedback_shift& x)
  { is >> x.value; return is; }


  friend bool operator==(linear_feedback_shift x, linear_feedback_shift y)
  { return x.value == y.value; }
  friend bool operator!=(linear_feedback_shift x, linear_feedback_shift y)
  { return !(x == y); }
# 138 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/linear_feedback_shift.hpp"
private:
  UIntType wordmask;
  UIntType value;
};



template<class UIntType, int w, int k, int q, int s, UIntType val>
const bool linear_feedback_shift<UIntType, w, k, q, s, val>::has_fixed_range;
template<class UIntType, int w, int k, int q, int s, UIntType val>
const int linear_feedback_shift<UIntType, w, k, q, s, val>::word_size;
template<class UIntType, int w, int k, int q, int s, UIntType val>
const int linear_feedback_shift<UIntType, w, k, q, s, val>::exponent1;
template<class UIntType, int w, int k, int q, int s, UIntType val>
const int linear_feedback_shift<UIntType, w, k, q, s, val>::exponent2;
template<class UIntType, int w, int k, int q, int s, UIntType val>
const int linear_feedback_shift<UIntType, w, k, q, s, val>::step_size;


}
}
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp" 2


namespace boost {
namespace random {
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp"
template<class URNG1, int s1, class URNG2, int s2

, typename URNG1::result_type val = 0

>
class xor_combine
{
public:
  typedef URNG1 base1_type;
  typedef URNG2 base2_type;
  typedef typename base1_type::result_type result_type;

  static const bool has_fixed_range = false;
  static const int shift1 = s1;
  static const int shift2 = s2;





  xor_combine() : _rng1(), _rng2()
  { }



  xor_combine(const base1_type & rng1, const base2_type & rng2)
    : _rng1(rng1), _rng2(rng2) { }




  xor_combine(const result_type & v)
    : _rng1(v), _rng2(v) { }







  template<class It> xor_combine(It& first, It last)
    : _rng1(first, last), _rng2( first, last) { }



  void seed() { _rng1.seed(); _rng2.seed(); }



  void seed(const result_type & v) { _rng1.seed(v); _rng2.seed(v); }






  template<class It> void seed(It& first, It last)
  {
    _rng1.seed(first, last);
    _rng2.seed(first, last);
  }


  const base1_type& base1() { return _rng1; }

  const base2_type& base2() { return _rng2; }


  result_type operator()()
  {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<typename base1_type::result_type>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_115;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<typename base2_type::result_type>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_116;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<typename base1_type::result_type>::digits >= std::numeric_limits<typename base2_type::result_type>::digits) == 0 ? false : true) >)> boost_static_assert_typedef_117;

    return (_rng1() << s1) ^ (_rng2() << s2);
  }




  result_type min () const { return std::min ((_rng1.min)(), (_rng2.min)()); }



  result_type max () const { return std::max ((_rng1.min)(), (_rng2.max)()); }
  static bool validation(result_type x) { return val == x; }




  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const xor_combine& s)
  {
    os << s._rng1 << " " << s._rng2 << " ";
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, xor_combine& s)
  {
    is >> s._rng1 >> std::ws >> s._rng2 >> std::ws;
    return is;
  }


  friend bool operator==(const xor_combine& x, const xor_combine& y)
  { return x._rng1 == y._rng1 && x._rng2 == y._rng2; }
  friend bool operator!=(const xor_combine& x, const xor_combine& y)
  { return !(x == y); }
# 164 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/xor_combine.hpp"
private:
  base1_type _rng1;
  base2_type _rng2;
};



template<class URNG1, int s1, class URNG2, int s2, typename URNG1::result_type val>
const bool xor_combine<URNG1, s1, URNG2, s2, val>::has_fixed_range;
template<class URNG1, int s1, class URNG2, int s2, typename URNG1::result_type val>
const int xor_combine<URNG1, s1, URNG2, s2, val>::shift1;
template<class URNG1, int s1, class URNG2, int s2, typename URNG1::result_type val>
const int xor_combine<URNG1, s1, URNG2, s2, val>::shift2;




}
}
# 45 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/uniform_int_float.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/uniform_int_float.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/uniform_int_float.hpp" 2



namespace boost {
namespace random {
namespace detail {

template<class UniformRandomNumberGenerator, class IntType = unsigned long>
class uniform_int_float
{
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef IntType result_type;

  uniform_int_float(base_type rng, IntType min_arg = 0, IntType max_arg = 0xffffffff)
    : _rng(rng), _min(min_arg), _max(max_arg)
  {
    init();
  }

  result_type min () const { return _min; }
  result_type max () const { return _max; }
  base_type& base() { return _rng.base(); }
  const base_type& base() const { return _rng.base(); }

  result_type operator()()
  {
    return static_cast<IntType>(_rng() * _range) + _min;
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const uniform_int_float& ud)
  {
    os << ud._min << " " << ud._max;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, uniform_int_float& ud)
  {
    is >> std::ws >> ud._min >> std::ws >> ud._max;
    ud.init();
    return is;
  }


private:
  void init()
  {
    _range = static_cast<base_result>(_max-_min)+1;
  }

  typedef typename base_type::result_type base_result;
  uniform_01<base_type> _rng;
  result_type _min, _max;
  base_result _range;
};


}
}
}
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp" 2
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/disable_warnings.hpp" 1
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp" 2

namespace boost {



namespace random {
namespace detail {

template<bool have_int, bool want_int>
struct engine_helper;


template<>
struct engine_helper<true, true>
{
  template<class Engine, class DistInputType>
  struct impl
  {
    typedef pass_through_engine<Engine> type;
  };
};

template<>
struct engine_helper<false, false>
{
  template<class Engine, class DistInputType>
  struct impl
  {
    typedef uniform_01<Engine, DistInputType> type;
  };
};

template<>
struct engine_helper<true, false>
{
  template<class Engine, class DistInputType>
  struct impl
  {
    typedef uniform_01<Engine, DistInputType> type;
  };
};

template<>
struct engine_helper<false, true>
{
  template<class Engine, class DistInputType>
  struct impl
  {
    typedef uniform_int_float<Engine, unsigned long> type;
  };
};

}
}
# 113 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp"
template<class Engine, class Distribution>
class variate_generator
{
private:
  typedef random::detail::pass_through_engine<Engine> decorated_engine;

public:
  typedef typename decorated_engine::base_type engine_value_type;
  typedef Engine engine_type;
  typedef Distribution distribution_type;
  typedef typename Distribution::result_type result_type;
# 133 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp"
  variate_generator(Engine e, Distribution d)
    : _eng(decorated_engine(e)), _dist(d) { }
# 159 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp"
  result_type operator()() { return _dist(_eng); }




  template<class T>
  result_type operator()(T value) { return _dist(_eng, value); }




  engine_value_type& engine() { return _eng.base().base(); }



  const engine_value_type& engine() const { return _eng.base().base(); }




  distribution_type& distribution() { return _dist; }



  const distribution_type& distribution() const { return _dist; }






  result_type min () const { return (distribution().min)(); }





  result_type max () const { return (distribution().max)(); }

private:






  enum {
    have_int = std::numeric_limits<typename decorated_engine::result_type>::is_integer,
    want_int = std::numeric_limits<typename Distribution::input_type>::is_integer
  };
  typedef typename random::detail::engine_helper<have_int, want_int>::template impl<decorated_engine, typename Distribution::input_type>::type internal_engine_type;


  internal_engine_type _eng;
  distribution_type _dist;
};

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/disable_warnings.hpp" 1
# 219 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/variate_generator.hpp" 2
# 48 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2

namespace boost {
# 59 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp"
  typedef random::xor_combine<random::xor_combine<random::linear_feedback_shift<uint32_t, 32, 31, 13, 12, 0>, 0,
    random::linear_feedback_shift<uint32_t, 32, 29, 2, 4, 0>, 0, 0>, 0,
                      random::linear_feedback_shift<uint32_t, 32, 28, 3, 17, 0>, 0, 0> taus88;
}


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/random_number_generator.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/random_number_generator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp" 2





# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 27 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/signed_unsigned_tools.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/signed_unsigned_tools.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_signed.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_signed.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_signed.hpp" 2

namespace boost {



namespace detail{



template <class T>
struct is_signed_values
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_signed_helper
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};

template <bool integral_type>
struct is_signed_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_signed_helper<T> type;
   };
};

template <>
struct is_signed_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_signed_imp
{
   typedef is_signed_select_helper<
      ::boost::type_traits::ice_or<
         ::boost::is_integral<T>::value,
         ::boost::is_enum<T>::value>::value
   > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;



   static const bool value = type::value;

};
# 121 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_signed.hpp"
}






template< typename T > struct is_signed : ::boost::integral_constant<bool,::boost::detail::is_signed_imp<T>::value> { };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 134 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_signed.hpp" 2
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_unsigned.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_unsigned.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_unsigned.hpp" 2

namespace boost {



namespace detail{



template <class T>
struct is_unsigned_values
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_ununsigned_helper
{
   static const bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};

template <bool integral_type>
struct is_ununsigned_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_ununsigned_helper<T> type;
   };
};

template <>
struct is_ununsigned_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_unsigned_imp
{
   typedef is_ununsigned_select_helper<
      ::boost::type_traits::ice_or<
         ::boost::is_integral<T>::value,
         ::boost::is_enum<T>::value>::value
   > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};
# 116 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_unsigned.hpp"
}






template< typename T > struct is_unsigned : ::boost::integral_constant<bool,::boost::detail::is_unsigned_imp<T>::value> { };


}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 129 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/is_unsigned.hpp" 2
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp" 2
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 15 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp" 2

namespace boost {

namespace detail {

template <class T>
struct make_unsigned_imp
{
   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_enum<T>::value>::value)) == 0 ? false : true) >)>
 boost_static_assert_typedef_39;

   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((::boost::type_traits::ice_not< ::boost::is_same< typename remove_cv<T>::type, bool>::value>::value)) == 0 ? false : true) >)>

 boost_static_assert_typedef_43;


   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename mpl::if_c<
      (::boost::type_traits::ice_and<
         ::boost::is_unsigned<T>::value,
         ::boost::is_integral<T>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value >::value),
      T,
      typename mpl::if_c<
         (::boost::type_traits::ice_and<
            ::boost::is_integral<T>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value>
         ::value),
         typename mpl::if_<
            is_same<t_no_cv, signed char>,
            unsigned char,
            typename mpl::if_<
               is_same<t_no_cv, short>,
               unsigned short,
               typename mpl::if_<
                  is_same<t_no_cv, int>,
                  unsigned int,
                  typename mpl::if_<
                     is_same<t_no_cv, long>,
                     unsigned long,

                     boost::ulong_long_type





                  >::type
               >::type
            >::type
         >::type,

         typename mpl::if_c<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename mpl::if_c<
               sizeof(t_no_cv) == sizeof(unsigned short),
               unsigned short,
               typename mpl::if_c<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  unsigned int,
                  typename mpl::if_c<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     unsigned long,

                     boost::ulong_long_type





                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename mpl::if_<
      is_const<T>,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;


   typedef typename mpl::if_<
      is_volatile<T>,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};


}

template< typename T > struct make_unsigned { typedef typename boost::detail::make_unsigned_imp<T>::type type; };

}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 135 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/type_traits/make_unsigned.hpp" 2
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/signed_unsigned_tools.hpp" 2

namespace boost {
namespace random {
namespace detail {






template<class T, bool sgn = std::numeric_limits<T>::is_signed>
struct subtract { };

template<class T>
struct subtract<T, false>
{
  typedef T result_type;
  result_type operator()(T x, T y) { return x - y; }
};

template<class T>
struct subtract<T, true>
{
  typedef typename make_unsigned<T>::type result_type;
  result_type operator()(T x, T y)
  {
    if (y >= 0)
      return result_type(x) - result_type(y);
    if (x >= 0)

      return result_type(x) + result_type(-(y+1)) + 1;

    return result_type(x - y);
  }
};





template<class T1, class T2, bool sgn = std::numeric_limits<T2>::is_signed>
struct add { };

template<class T1, class T2>
struct add<T1, T2, false>
{
  typedef T2 result_type;
  result_type operator()(T1 x, T2 y) { return T2(x) + y; }
};

template<class T1, class T2>
struct add<T1, T2, true>
{
  typedef T2 result_type;
  result_type operator()(T1 x, T2 y)
  {
    if (y >= 0)
      return T2(x) + y;

    if (x >= T1(-(y+1)))

      return T2(x - T1(-(y+1)) - 1);

    return T2(x) + y;
  }
};

}
}
}
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp" 2


namespace boost {
# 39 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
template<class IntType = int>
class uniform_int
{
public:
  typedef IntType input_type;
  typedef IntType result_type;


  typedef typename make_unsigned<result_type>::type range_type;
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
  explicit uniform_int(IntType min_arg = 0, IntType max_arg = 9)
    : _min(min_arg), _max(max_arg)
  {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<IntType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_61;

    ((min_arg <= max_arg) ? static_cast<void> (0) : __assert_fail ("min_arg <= max_arg", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp", 63, __PRETTY_FUNCTION__));
    init();
  }




  result_type min () const { return _min; }



  result_type max () const { return _max; }
  void reset() { }


  template<class Engine>
  result_type operator()(Engine& eng)
  {
      return generate(eng, _min, _max, _range);
  }

  template<class Engine>
  result_type operator()(Engine& eng, result_type n)
  {
      ((n > 0) ? static_cast<void> (0) : __assert_fail ("n > 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp", 87, __PRETTY_FUNCTION__));

      if (n == 1)
      {
        return 0;
      }

      return generate(eng, 0, n - 1, n - 1);
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const uniform_int& ud)
  {
    os << ud._min << " " << ud._max;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, uniform_int& ud)
  {
    is >> std::ws >> ud._min >> std::ws >> ud._max;
    ud.init();
    return is;
  }


private:
# 126 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
  template<class Engine>
  static result_type generate(Engine& eng, result_type min_value, result_type , range_type range)
  {
    typedef typename Engine::result_type base_result;

    typedef typename make_unsigned<base_result>::type base_unsigned;
    const base_result bmin = (eng.min)();
    const base_unsigned brange =
      random::detail::subtract<base_result>()((eng.max)(), (eng.min)());

    if(range == 0) {
      return min_value;
    } else if(brange == range) {


      base_unsigned v = random::detail::subtract<base_result>()(eng(), bmin);
      return random::detail::add<base_unsigned, result_type>()(v, min_value);
    } else if(brange < range) {

      for(;;) {





        range_type limit;
        if(range == (std::numeric_limits<range_type>::max)()) {
          limit = range/(range_type(brange)+1);
          if(range % (range_type(brange)+1) == range_type(brange))
            ++limit;
        } else {
          limit = (range+1)/(range_type(brange)+1);
        }



        range_type result = range_type(0);
        range_type mult = range_type(1);




        while(mult <= limit) {
# 189 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
          result += static_cast<range_type>(random::detail::subtract<base_result>()(eng(), bmin) * mult);


          if(mult * range_type(brange) == range - mult + 1) {


              return(result);
          }
# 209 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
          mult *= range_type(brange)+range_type(1);
        }
# 237 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_int.hpp"
        range_type result_increment = uniform_int<range_type>(0, range/mult)(eng);
        if((std::numeric_limits<range_type>::max)() / mult < result_increment) {

          continue;
        }
        result_increment *= mult;

        result += result_increment;
        if(result < result_increment) {

          continue;
        }
        if(result > range) {

          continue;
        }
        return random::detail::add<range_type, result_type>()(result, min_value);
      }
    } else {
      base_unsigned bucket_size;




      if(brange == (std::numeric_limits<base_unsigned>::max)()) {
        bucket_size = brange / (static_cast<base_unsigned>(range)+1);
        if(brange % (static_cast<base_unsigned>(range)+1) == static_cast<base_unsigned>(range)) {
          ++bucket_size;
        }
      } else {
        bucket_size = (brange+1) / (static_cast<base_unsigned>(range)+1);
      }
      for(;;) {
        base_unsigned result =
          random::detail::subtract<base_result>()(eng(), bmin);
        result /= bucket_size;


        if(result <= static_cast<base_unsigned>(range))
          return random::detail::add<base_unsigned, result_type>()(result, min_value);
      }
    }
  }





  void init()
  {
    _range = random::detail::subtract<result_type>()(_max, _min);
  }





  result_type _min, _max;
  range_type _range;
};

}
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/random_number_generator.hpp" 2


namespace boost {
# 35 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/random_number_generator.hpp"
template<class UniformRandomNumberGenerator, class IntType = long>
class random_number_generator
{
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef IntType argument_type;
  typedef IntType result_type;





  random_number_generator(base_type& rng) : _rng(rng)
  {

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<result_type>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_50;

  }






  result_type operator()(argument_type n)
  {
    typedef uniform_int<IntType> dist_type;
    return variate_generator<base_type&, dist_type>(_rng, dist_type(0, n-1))();
  }

private:
  base_type& _rng;
};

}
# 66 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_smallint.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_smallint.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_smallint.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_smallint.hpp" 2



namespace boost {
# 79 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_smallint.hpp"
template<class IntType = int>
class uniform_smallint
{
public:
  typedef IntType input_type;
  typedef IntType result_type;





  explicit uniform_smallint(IntType min_arg = 0, IntType max_arg = 9)
    : _min(min_arg), _max(max_arg)
  {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<IntType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_95;

 }

  result_type min () const { return _min; }
  result_type max () const { return _max; }
  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng)
  {
    typedef typename Engine::result_type base_result;
    base_result _range = static_cast<base_result>(_max-_min)+1;
    base_result _factor = 1;





    base_result r_base = (eng.max)() - (eng.min)();
    if(r_base == (std::numeric_limits<base_result>::max)()) {
      _factor = 2;
      r_base /= 2;
    }
    r_base += 1;
    if(r_base % _range == 0) {

      _factor = r_base / _range;
    } else {

      for( ; r_base/_range/32 >= _range; _factor *= 2)
        r_base /= 2;
    }

    return static_cast<result_type>(((eng() - (eng.min)()) / _factor) % _range + _min);
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const uniform_smallint& ud)
  {
    os << ud._min << " " << ud._max;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, uniform_smallint& ud)
  {
    is >> std::ws >> ud._min >> std::ws >> ud._max;
    return is;
  }


private:

  result_type _min;
  result_type _max;
};

}
# 69 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp" 2




# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp" 2

namespace boost {
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp"
template<class RealType = double>
class uniform_real
{
public:
  typedef RealType input_type;
  typedef RealType result_type;







  explicit uniform_real(RealType min_arg = RealType(0),
                        RealType max_arg = RealType(1))
    : _min(min_arg), _max(max_arg)
  {

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_58;

    ((min_arg <= max_arg) ? static_cast<void> (0) : __assert_fail ("min_arg <= max_arg", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp", 60, __PRETTY_FUNCTION__));
  }






  result_type min () const { return _min; }



  result_type max () const { return _max; }
  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng) {
    result_type numerator = static_cast<result_type>(eng() - eng.min ());
    result_type divisor = static_cast<result_type>(eng.max () - eng.min ());
    ((divisor > 0) ? static_cast<void> (0) : __assert_fail ("divisor > 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp", 79, __PRETTY_FUNCTION__));
    ((numerator >= 0 && numerator <= divisor) ? static_cast<void> (0) : __assert_fail ("numerator >= 0 && numerator <= divisor", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_real.hpp", 80, __PRETTY_FUNCTION__));
    return numerator / divisor * (_max - _min) + _min;
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const uniform_real& ud)
  {
    os << ud._min << " " << ud._max;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, uniform_real& ud)
  {
    is >> std::ws >> ud._min >> std::ws >> ud._max;
    return is;
  }


private:
  RealType _min, _max;
};

}
# 72 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/triangle_distribution.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/triangle_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/triangle_distribution.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/triangle_distribution.hpp" 2


namespace boost {







template<class RealType = double>
class triangle_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;







  explicit triangle_distribution(result_type a_arg = result_type(0),
                                 result_type b_arg = result_type(0.5),
                                 result_type c_arg = result_type(1))
    : _a(a_arg), _b(b_arg), _c(c_arg)
  {
    ((_a <= _b && _b <= _c) ? static_cast<void> (0) : __assert_fail ("_a <= _b && _b <= _c", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/triangle_distribution.hpp", 50, __PRETTY_FUNCTION__));
    init();
  }




  result_type a() const { return _a; }

  result_type b() const { return _b; }

  result_type c() const { return _c; }

  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng)
  {

    using std::sqrt;

    result_type u = eng();
    if( u <= q1 )
      return _a + p1*sqrt(u);
    else
      return _c - d3*sqrt(d2*u-d1);
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const triangle_distribution& td)
  {
    os << td._a << " " << td._b << " " << td._c;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, triangle_distribution& td)
  {
    is >> std::ws >> td._a >> std::ws >> td._b >> std::ws >> td._c;
    td.init();
    return is;
  }


private:

  void init()
  {

    using std::sqrt;

    d1 = _b - _a;
    d2 = _c - _a;
    d3 = sqrt(_c - _b);
    q1 = d1 / d2;
    p1 = sqrt(d1 * d2);
  }


  result_type _a, _b, _c;
  result_type d1, d2, d3, q1, p1;
};

}
# 73 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/bernoulli_distribution.hpp" 1
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/bernoulli_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/bernoulli_distribution.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/bernoulli_distribution.hpp" 2

namespace boost {







template<class RealType = double>
class bernoulli_distribution
{
public:



  typedef int input_type;
  typedef bool result_type;







  explicit bernoulli_distribution(const RealType& p_arg = RealType(0.5))
    : _p(p_arg)
  {
    ((_p >= 0) ? static_cast<void> (0) : __assert_fail ("_p >= 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/bernoulli_distribution.hpp", 50, __PRETTY_FUNCTION__));
    ((_p <= 1) ? static_cast<void> (0) : __assert_fail ("_p <= 1", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/bernoulli_distribution.hpp", 51, __PRETTY_FUNCTION__));
  }






  RealType p() const { return _p; }




  void reset() { }





  template<class Engine>
  result_type operator()(Engine& eng)
  {
    if(_p == RealType(0))
      return false;
    else
      return RealType(eng() - (eng.min)()) <= _p * RealType((eng.max)()-(eng.min)());
  }





  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const bernoulli_distribution& bd)
  {
    os << bd._p;
    return os;
  }




  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, bernoulli_distribution& bd)
  {
    is >> std::ws >> bd._p;
    return is;
  }


private:
  RealType _p;
};

}
# 74 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/cauchy_distribution.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/cauchy_distribution.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/cauchy_distribution.hpp" 2

namespace boost {
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/cauchy_distribution.hpp"
template<class RealType = double>
class cauchy_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;


  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_49;






  explicit cauchy_distribution(result_type median_arg = result_type(0),
                               result_type sigma_arg = result_type(1))
    : _median(median_arg), _sigma(sigma_arg) { }






  result_type median() const { return _median; }



  result_type sigma() const { return _sigma; }




  void reset() { }





  template<class Engine>
  result_type operator()(Engine& eng)
  {

    const result_type pi = result_type(3.14159265358979323846);

    using std::tan;

    return _median + _sigma * tan(pi*(eng()-result_type(0.5)));
  }





  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const cauchy_distribution& cd)
  {
    os << cd._median << " " << cd._sigma;
    return os;
  }




  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, cauchy_distribution& cd)
  {
    is >> std::ws >> cd._median >> std::ws >> cd._sigma;
    return is;
  }


private:
  result_type _median, _sigma;
};

}
# 75 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/exponential_distribution.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/exponential_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/exponential_distribution.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/exponential_distribution.hpp" 2

namespace boost {






template<class RealType = double>
class exponential_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;


  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_41;


  explicit exponential_distribution(result_type lambda_arg = result_type(1))
    : _lambda(lambda_arg) { ((_lambda > result_type(0)) ? static_cast<void> (0) : __assert_fail ("_lambda > result_type(0)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/exponential_distribution.hpp", 45, __PRETTY_FUNCTION__)); }



  result_type lambda() const { return _lambda; }

  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng)
  {

    using std::log;

    return -result_type(1) / _lambda * log(result_type(1)-eng());
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const exponential_distribution& ed)
  {
    os << ed._lambda;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, exponential_distribution& ed)
  {
    is >> std::ws >> ed._lambda;
    return is;
  }


private:
  result_type _lambda;
};

}
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/geometric_distribution.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/geometric_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/geometric_distribution.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/geometric_distribution.hpp" 2


namespace boost {
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/geometric_distribution.hpp"
template<class IntType = int, class RealType = double>
class geometric_distribution
{
public:
  typedef RealType input_type;
  typedef IntType result_type;






  explicit geometric_distribution(const RealType& p = RealType(0.5))
    : _p(p)
  {
    ((RealType(0) < _p && _p < RealType(1)) ? static_cast<void> (0) : __assert_fail ("RealType(0) < _p && _p < RealType(1)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/geometric_distribution.hpp", 56, __PRETTY_FUNCTION__));
    init();
  }






  RealType p() const { return _p; }
  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng)
  {

    using std::log;
    using std::floor;

    return IntType(floor(log(RealType(1)-eng()) / _log_p)) + IntType(1);
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const geometric_distribution& gd)
  {
    os << gd._p;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, geometric_distribution& gd)
  {
    is >> std::ws >> gd._p;
    gd.init();
    return is;
  }


private:



  void init()
  {

    using std::log;

    _log_p = log(_p);
  }



  RealType _p;
  RealType _log_p;
};

}
# 77 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp" 2

namespace boost {
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp"
template<class RealType = double>
class normal_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_44;
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp"
  explicit normal_distribution(const result_type& mean_arg = result_type(0),
                               const result_type& sigma_arg = result_type(1))
    : _mean(mean_arg), _sigma(sigma_arg), _valid(false)
  {
    ((_sigma >= result_type(0)) ? static_cast<void> (0) : __assert_fail ("_sigma >= result_type(0)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/normal_distribution.hpp", 57, __PRETTY_FUNCTION__));
  }


  normal_distribution(const normal_distribution& other)
    : _mean(other._mean), _sigma(other._sigma), _valid(false)
  {
  }






  RealType mean() const { return _mean; }



  RealType sigma() const { return _sigma; }

  void reset() { _valid = false; }

  template<class Engine>
  result_type operator()(Engine& eng)
  {


    using std::sqrt; using std::log; using std::sin; using std::cos;

    if(!_valid) {
      _r1 = eng();
      _r2 = eng();
      _cached_rho = sqrt(-result_type(2) * log(result_type(1)-_r2));
      _valid = true;
    } else {
      _valid = false;
    }

    const result_type pi = result_type(3.14159265358979323846);

    return _cached_rho * (_valid ?
                          cos(result_type(2)*pi*_r1) :
                          sin(result_type(2)*pi*_r1))
      * _sigma + _mean;
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const normal_distribution& nd)
  {
    os << nd._mean << " " << nd._sigma << " "
       << nd._valid << " " << nd._cached_rho << " " << nd._r1;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, normal_distribution& nd)
  {
    is >> std::ws >> nd._mean >> std::ws >> nd._sigma
       >> std::ws >> nd._valid >> std::ws >> nd._cached_rho
       >> std::ws >> nd._r1;
    return is;
  }

private:
  result_type _mean, _sigma;
  result_type _r1, _r2, _cached_rho;
  bool _valid;
};

}
# 78 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 21 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp" 2
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp"
namespace boost {
# 50 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp"
template<class RealType = double>
class lognormal_distribution
{
public:
  typedef typename normal_distribution<RealType>::input_type input_type;
  typedef RealType result_type;


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_58;






  explicit lognormal_distribution(result_type mean_arg = result_type(1),
                                  result_type sigma_arg = result_type(1))
    : _mean(mean_arg), _sigma(sigma_arg)
  {
    ((_mean > result_type(0)) ? static_cast<void> (0) : __assert_fail ("_mean > result_type(0)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/lognormal_distribution.hpp", 69, __PRETTY_FUNCTION__));
    init();
  }



  RealType mean() const { return _mean; }
  RealType sigma() const { return _sigma; }
  void reset() { _normal.reset(); }

  template<class Engine>
  result_type operator()(Engine& eng)
  {


    using std::exp;

    return exp(_normal(eng) * _nsigma + _nmean);
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const lognormal_distribution& ld)
  {
    os << ld._normal << " " << ld._mean << " " << ld._sigma;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, lognormal_distribution& ld)
  {
    is >> std::ws >> ld._normal >> std::ws >> ld._mean >> std::ws >> ld._sigma;
    ld.init();
    return is;
  }


private:


  void init()
  {


    using std::exp; using std::log; using std::sqrt;

    _nmean = log(_mean*_mean/sqrt(_sigma*_sigma + _mean*_mean));
    _nsigma = sqrt(log(_sigma*_sigma/_mean/_mean+result_type(1)));
  }


  RealType _mean, _sigma;
  RealType _nmean, _nsigma;
  normal_distribution<result_type> _normal;
};

}
# 79 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/poisson_distribution.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/poisson_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/poisson_distribution.hpp" 2



# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/poisson_distribution.hpp" 2

namespace boost {
# 33 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/poisson_distribution.hpp"
template<class IntType = int, class RealType = double>
class poisson_distribution
{
public:
  typedef RealType input_type;
  typedef IntType result_type;






  explicit poisson_distribution(const RealType& mean_arg = RealType(1))
    : _mean(mean_arg)
  {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<IntType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_50;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_51;


    ((_mean > RealType(0)) ? static_cast<void> (0) : __assert_fail ("_mean > RealType(0)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/poisson_distribution.hpp", 54, __PRETTY_FUNCTION__));
    init();
  }






  RealType mean() const { return _mean; }
  void reset() { }

  template<class Engine>
  result_type operator()(Engine& eng)
  {

    RealType product = RealType(1);
    for(result_type m = 0; ; ++m) {
      product *= eng();
      if(product <= _exp_mean)
        return m;
    }
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const poisson_distribution& pd)
  {
    os << pd._mean;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, poisson_distribution& pd)
  {
    is >> std::ws >> pd._mean;
    pd.init();
    return is;
  }


private:

  void init()
  {


    using std::exp;

    _exp_mean = exp(-_mean);
  }


  RealType _mean;

  RealType _exp_mean;
};

}
# 80 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/gamma_distribution.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/gamma_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/gamma_distribution.hpp" 2


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/gamma_distribution.hpp" 2


namespace boost {
# 34 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/gamma_distribution.hpp"
template<class RealType = double>
class gamma_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;


  typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<RealType>::is_integer) == 0 ? false : true) >)> boost_static_assert_typedef_42;


  explicit gamma_distribution(const result_type& alpha_arg = result_type(1))
    : _exp(result_type(1)), _alpha(alpha_arg)
  {
    ((_alpha > result_type(0)) ? static_cast<void> (0) : __assert_fail ("_alpha > result_type(0)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/gamma_distribution.hpp", 48, __PRETTY_FUNCTION__));
    init();
  }



  RealType alpha() const { return _alpha; }

  void reset() { _exp.reset(); }

  template<class Engine>
  result_type operator()(Engine& eng)
  {


    using std::tan; using std::sqrt; using std::exp; using std::log;
    using std::pow;

    if(_alpha == result_type(1)) {
      return _exp(eng);
    } else if(_alpha > result_type(1)) {

      const result_type pi = result_type(3.14159265358979323846);
      for(;;) {
        result_type y = tan(pi * eng());
        result_type x = sqrt(result_type(2)*_alpha-result_type(1))*y
          + _alpha-result_type(1);
        if(x <= result_type(0))
          continue;
        if(eng() >
           (result_type(1)+y*y) * exp((_alpha-result_type(1))
                                        *log(x/(_alpha-result_type(1)))
                                        - sqrt(result_type(2)*_alpha
                                               -result_type(1))*y))
          continue;
        return x;
      }
    } else {
      for(;;) {
        result_type u = eng();
        result_type y = _exp(eng);
        result_type x, q;
        if(u < _p) {
          x = exp(-y/_alpha);
          q = _p*exp(-x);
        } else {
          x = result_type(1)+y;
          q = _p + (result_type(1)-_p) * pow(x, _alpha-result_type(1));
        }
        if(u >= q)
          continue;
        return x;
      }
    }
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const gamma_distribution& gd)
  {
    os << gd._alpha;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, gamma_distribution& gd)
  {
    is >> std::ws >> gd._alpha;
    gd.init();
    return is;
  }


private:

  void init()
  {


    using std::exp;

    _p = exp(result_type(1)) / (_alpha + exp(result_type(1)));
  }


  exponential_distribution<RealType> _exp;
  result_type _alpha;

  result_type _p;
};

}
# 81 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 20 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp" 2


namespace boost {
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp"
template<class IntType = int, class RealType = double>
class binomial_distribution
{
public:
  typedef typename bernoulli_distribution<RealType>::input_type input_type;
  typedef IntType result_type;







  explicit binomial_distribution(IntType t = 1,
                                 const RealType& p = RealType(0.5))
    : _bernoulli(p), _t(t)
  {
    ((_t >= 0) ? static_cast<void> (0) : __assert_fail ("_t >= 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp", 49, __PRETTY_FUNCTION__));
    ((RealType(0) <= p && p <= RealType(1)) ? static_cast<void> (0) : __assert_fail ("RealType(0) <= p && p <= RealType(1)", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/binomial_distribution.hpp", 50, __PRETTY_FUNCTION__));
  }




  IntType t() const { return _t; }

  RealType p() const { return _bernoulli.p(); }




  void reset() { }





  template<class Engine>
  result_type operator()(Engine& eng)
  {

    result_type n = 0;
    for(IntType i = 0; i < _t; ++i)
      if(_bernoulli(eng))
        ++n;
    return n;
  }





  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const binomial_distribution& bd)
  {
    os << bd._bernoulli << " " << bd._t;
    return os;
  }




  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, binomial_distribution& bd)
  {
    is >> std::ws >> bd._bernoulli >> std::ws >> bd._t;
    return is;
  }


private:
  bernoulli_distribution<RealType> _bernoulli;
  IntType _t;
};

}
# 82 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_on_sphere.hpp" 1
# 22 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_on_sphere.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/detail/config.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_on_sphere.hpp" 2


namespace boost {
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random/uniform_on_sphere.hpp"
template<class RealType = double, class Cont = std::vector<RealType> >
class uniform_on_sphere
{
public:
  typedef RealType input_type;
  typedef Cont result_type;





  explicit uniform_on_sphere(int dim = 2) : _container(dim), _dim(dim) { }



  void reset() { _normal.reset(); }

  template<class Engine>
  const result_type & operator()(Engine& eng)
  {
    RealType sqsum = 0;
    for(typename Cont::iterator it = _container.begin();
        it != _container.end();
        ++it) {
      RealType val = _normal(eng);
      *it = val;
      sqsum += val * val;
    }

    using std::sqrt;


    std::transform(_container.begin(), _container.end(), _container.begin(),
                   std::bind2nd(std::divides<RealType>(), sqrt(sqsum)));
    return _container;
  }


  template<class CharT, class Traits>
  friend std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& os, const uniform_on_sphere& sd)
  {
    os << sd._dim;
    return os;
  }

  template<class CharT, class Traits>
  friend std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& is, uniform_on_sphere& sd)
  {
    is >> std::ws >> sd._dim;
    sd._container.resize(sd._dim);
    return is;
  }


private:
  normal_distribution<RealType> _normal;
  result_type _container;
  int _dim;
};

}
# 83 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/random.hpp" 2
# 33 "../libcore/vm/VM.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/intrusive_ptr.hpp" 1
# 16 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/intrusive_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp" 1
# 23 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 24 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp" 2
# 38 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp"
namespace boost
{
# 56 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp"
template<class T> class intrusive_ptr
{
private:

    typedef intrusive_ptr this_type;

public:

    typedef T element_type;

    intrusive_ptr(): px( 0 )
    {
    }

    intrusive_ptr( T * p, bool add_ref = true ): px( p )
    {
        if( px != 0 && add_ref ) intrusive_ptr_add_ref( px );
    }



    template<class U>


    intrusive_ptr( intrusive_ptr<U> const & rhs, typename boost::detail::sp_enable_if_convertible<U,T>::type = boost::detail::sp_empty() )






    : px( rhs.get() )
    {
        if( px != 0 ) intrusive_ptr_add_ref( px );
    }



    intrusive_ptr(intrusive_ptr const & rhs): px( rhs.px )
    {
        if( px != 0 ) intrusive_ptr_add_ref( px );
    }

    ~intrusive_ptr()
    {
        if( px != 0 ) intrusive_ptr_release( px );
    }



    template<class U> intrusive_ptr & operator=(intrusive_ptr<U> const & rhs)
    {
        this_type(rhs).swap(*this);
        return *this;
    }
# 131 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp"
    intrusive_ptr & operator=(intrusive_ptr const & rhs)
    {
        this_type(rhs).swap(*this);
        return *this;
    }

    intrusive_ptr & operator=(T * rhs)
    {
        this_type(rhs).swap(*this);
        return *this;
    }

    void reset()
    {
        this_type().swap( *this );
    }

    void reset( T * rhs )
    {
        this_type( rhs ).swap( *this );
    }

    T * get() const
    {
        return px;
    }

    T & operator*() const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp", 160, __PRETTY_FUNCTION__));
        return *px;
    }

    T * operator->() const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp", 166, __PRETTY_FUNCTION__));
        return px;
    }


# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp" 1
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/detail/operator_bool.hpp"
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 172 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp" 2

    void swap(intrusive_ptr & rhs)
    {
        T * tmp = px;
        px = rhs.px;
        rhs.px = tmp;
    }

private:

    T * px;
};

template<class T, class U> inline bool operator==(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b)
{
    return a.get() != b.get();
}

template<class T, class U> inline bool operator==(intrusive_ptr<T> const & a, U * b)
{
    return a.get() == b;
}

template<class T, class U> inline bool operator!=(intrusive_ptr<T> const & a, U * b)
{
    return a.get() != b;
}

template<class T, class U> inline bool operator==(T * a, intrusive_ptr<U> const & b)
{
    return a == b.get();
}

template<class T, class U> inline bool operator!=(T * a, intrusive_ptr<U> const & b)
{
    return a != b.get();
}
# 226 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp"
template<class T> inline bool operator<(intrusive_ptr<T> const & a, intrusive_ptr<T> const & b)
{
    return std::less<T *>()(a.get(), b.get());
}

template<class T> void swap(intrusive_ptr<T> & lhs, intrusive_ptr<T> & rhs)
{
    lhs.swap(rhs);
}



template<class T> T * get_pointer(intrusive_ptr<T> const & p)
{
    return p.get();
}

template<class T, class U> intrusive_ptr<T> static_pointer_cast(intrusive_ptr<U> const & p)
{
    return static_cast<T *>(p.get());
}

template<class T, class U> intrusive_ptr<T> const_pointer_cast(intrusive_ptr<U> const & p)
{
    return const_cast<T *>(p.get());
}

template<class T, class U> intrusive_ptr<T> dynamic_pointer_cast(intrusive_ptr<U> const & p)
{
    return dynamic_cast<T *>(p.get());
}
# 280 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/smart_ptr/intrusive_ptr.hpp"
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, intrusive_ptr<Y> const & p)

{
    os << p.get();
    return os;
}







}
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/intrusive_ptr.hpp" 2
# 35 "../libcore/vm/VM.h" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp" 1
# 40 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 41 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 1
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp"
# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/assert.hpp" 2
# 43 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/swap.hpp" 1
# 10 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/swap.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/swap.hpp" 1
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/swap.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 26 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/utility/swap.hpp" 2

namespace boost_swap_impl
{
  template<class T>
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>
  void swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/swap.hpp" 2
# 44 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp" 2
# 54 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp"
namespace boost {

    template<class T, std::size_t N>
    class array {
      public:
        T elems[N];

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return elems; }
        const_iterator begin() const { return elems; }
        iterator end() { return elems+N; }
        const_iterator end() const { return elems+N; }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 98 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp"
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type i)
        {
            ((i < N && "out of range") ? static_cast<void> (0) : __assert_fail ("i < N && \"out of range\"", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp", 110, __PRETTY_FUNCTION__));
            return elems[i];
        }

        const_reference operator[](size_type i) const
        {
            ((i < N && "out of range") ? static_cast<void> (0) : __assert_fail ("i < N && \"out of range\"", "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp", 116, __PRETTY_FUNCTION__));
            return elems[i];
        }


        reference at(size_type i) { rangecheck(i); return elems[i]; }
        const_reference at(size_type i) const { rangecheck(i); return elems[i]; }


        reference front()
        {
            return elems[0];
        }

        const_reference front() const
        {
            return elems[0];
        }

        reference back()
        {
            return elems[N-1];
        }

        const_reference back() const
        {
            return elems[N-1];
        }


        static size_type size() { return N; }
        static bool empty() { return false; }
        static size_type max_size() { return N; }
        enum { static_size = N };


        void swap (array<T,N>& y) {
            for (size_type i = 0; i < N; ++i)
                boost::swap(elems[i],y.elems[i]);
        }


        const T* data() const { return elems; }
        T* data() { return elems; }


        T* c_array() { return elems; }


        template <typename T2>
        array<T,N>& operator= (const array<T2,N>& rhs) {
            std::copy(rhs.begin(),rhs.end(), begin());
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& value)
        {
            std::fill_n(begin(),size(),value);
        }


        static void rangecheck (size_type i) {
            if (i >= size()) {
                std::out_of_range e("array<>: index out of range");
                boost::throw_exception(e);
            }
        }

    };


    template< class T >
    class array< T, 0 > {

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return iterator( reinterpret_cast< T * >( this ) ); }
        const_iterator begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
        iterator end() { return begin(); }
        const_iterator end() const { return begin(); }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 229 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp"
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type )
        {
            return failed_rangecheck();
        }

        const_reference operator[](size_type ) const
        {
            return failed_rangecheck();
        }


        reference at(size_type ) { return failed_rangecheck(); }
        const_reference at(size_type ) const { return failed_rangecheck(); }


        reference front()
        {
            return failed_rangecheck();
        }

        const_reference front() const
        {
            return failed_rangecheck();
        }

        reference back()
        {
            return failed_rangecheck();
        }

        const_reference back() const
        {
            return failed_rangecheck();
        }


        static size_type size() { return 0; }
        static bool empty() { return true; }
        static size_type max_size() { return 0; }
        enum { static_size = 0 };

        void swap (array<T,0>& ) {
        }


        const T* data() const { return 0; }
        T* data() { return 0; }


        T* c_array() { return 0; }


        template <typename T2>
        array<T,0>& operator= (const array<T2,0>& ) {
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& ) {}


        static reference failed_rangecheck () {
                std::out_of_range e("attempt to access element of an empty array");
                boost::throw_exception(e);






                static T placeholder;
                return placeholder;

            }
    };



    template<class T, std::size_t N>
    bool operator== (const array<T,N>& x, const array<T,N>& y) {
        return std::equal(x.begin(), x.end(), y.begin());
    }
    template<class T, std::size_t N>
    bool operator< (const array<T,N>& x, const array<T,N>& y) {
        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
    }
    template<class T, std::size_t N>
    bool operator!= (const array<T,N>& x, const array<T,N>& y) {
        return !(x==y);
    }
    template<class T, std::size_t N>
    bool operator> (const array<T,N>& x, const array<T,N>& y) {
        return y<x;
    }
    template<class T, std::size_t N>
    bool operator<= (const array<T,N>& x, const array<T,N>& y) {
        return !(y<x);
    }
    template<class T, std::size_t N>
    bool operator>= (const array<T,N>& x, const array<T,N>& y) {
        return !(x<y);
    }


    template<class T, std::size_t N>
    inline void swap (array<T,N>& x, array<T,N>& y) {
        x.swap(y);
    }


    template <typename T, std::size_t N>
    T(&get_c_array(boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }


    template <typename T, std::size_t N>
    const T(&get_c_array(const boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }
# 381 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/array.hpp"
}
# 36 "../libcore/vm/VM.h" 2



# 1 "../libcore/vm/SafeStack.h" 1
# 40 "../libcore/vm/VM.h" 2
# 1 "../libcore/vm/CallStack.h" 1
# 28 "../libcore/vm/CallStack.h"
namespace gnash {
    class as_object;
    class UserFunction;
}

namespace gnash {
# 43 "../libcore/vm/CallStack.h"
class CallFrame
{
public:

    typedef std::vector<as_value> Registers;






    CallFrame(UserFunction* func);


    CallFrame(const CallFrame& other)
        :
        _locals(other._locals),
        _func(other._func),
        _registers(other._registers)
    {}


    CallFrame& operator=(const CallFrame& other) {
        _locals = other._locals;
        _func = other._func;
        _registers = other._registers;
        return *this;
    }


    as_object& locals() {
        return *_locals;
    }


    UserFunction& function() {
        return *_func;
    }






    const as_value* getLocalRegister(size_t i) const {
        if (i >= _registers.size()) return 0;
        return &_registers[i];
    }







    void setLocalRegister(size_t i, const as_value& val);





    bool hasRegisters() const {
        return !_registers.empty();
    }





    void markReachableResources() const;


private:

    friend std::ostream& operator<<(std::ostream&, const CallFrame&);


    as_object* _locals;

    UserFunction* _func;


    Registers _registers;

};







void declareLocal(CallFrame& c, string_table::key name);
# 144 "../libcore/vm/CallStack.h"
void setLocal(CallFrame& c, string_table::key name, const as_value& val);

typedef std::vector<CallFrame> CallStack;

std::ostream& operator<<(std::ostream& o, const CallFrame& fr);

}
# 41 "../libcore/vm/VM.h" 2




namespace gnash {
 class Global_as;
 class VM;
 class fn_call;
 class movie_root;
 class NativeFunction;
    class SharedObjectLibrary;
 class as_value;
 class as_object;
 class VirtualClock;
    class UserFunction;
}

namespace gnash {


class VmGcRoot : public GcRoot
{
public:
 VmGcRoot(VM& vm) : _vm(vm) {}
 virtual void markReachableResources() const;

private:
    VM& _vm;
};
# 87 "../libcore/vm/VM.h"
class VM : boost::noncopyable
{

public:

 typedef as_value (*as_c_function_ptr)(const fn_call& fn);
# 111 "../libcore/vm/VM.h"
 static VM& init(int version, movie_root& root, VirtualClock& clock);

 SafeStack<as_value>& getStack() {
  return _stack;
 }
# 124 "../libcore/vm/VM.h"
    VirtualClock& getClock() {
        return _clock;
    }


 static bool isInitialized();
# 140 "../libcore/vm/VM.h"
    void clear();
# 149 "../libcore/vm/VM.h"
 static VM& get();





 int getSWFVersion() const;


 void setSWFVersion(int v);


 unsigned long int getTime() const;


 string_table& getStringTable() const { return _stringTable; }






 const std::string& getPlayerVersion() const;





 const std::string getOSName();




 const std::string getSystemLanguage();
# 199 "../libcore/vm/VM.h"
 typedef boost::mt11213b RNG;
# 208 "../libcore/vm/VM.h"
 RNG& randomNumberGenerator() const;


 movie_root& getRoot() const;





    SharedObjectLibrary& getSharedObjectLibrary() const {
        ((_shLib.get()) ? static_cast<void> (0) : __assert_fail ("_shLib.get()", "../libcore/vm/VM.h", 218, __PRETTY_FUNCTION__));
        return *_shLib;
    }


 Global_as* getGlobal() const;
# 233 "../libcore/vm/VM.h"
 void markReachableResources() const;

 void registerNative(as_c_function_ptr fun, unsigned int x, unsigned int y);


 NativeFunction* getNative(unsigned int x, unsigned int y) const;
# 257 "../libcore/vm/VM.h"
    const as_value* getRegister(size_t index);
# 276 "../libcore/vm/VM.h"
    void setRegister(size_t index, const as_value& val);







    CallFrame& pushCallFrame(UserFunction& f);




    void popCallFrame();





    CallFrame& currentCall();


    bool calling() const {
        return !_callStack.empty();
    }


    void dumpState(std::ostream& o, size_t limit = 0);


 void addStatic(GcResource* res)
 {
  _statics.push_back(res);
 }






private:

 friend class VmGcRoot;





 VM(int version, movie_root& root, VirtualClock& clock);



 ~VM();



 friend class std::auto_ptr<VM>;
 static std::auto_ptr<VM> _singleton;


 movie_root& _rootMovie;


 Global_as* _global;


 int _swfversion;





 void setGlobal(Global_as*);







 typedef std::vector< boost::intrusive_ptr<GcResource> > ResVect;
 ResVect _statics;


 typedef std::map<unsigned int, as_c_function_ptr> FuncMap;
 typedef std::map<unsigned int, FuncMap> AsNativeTable;
 AsNativeTable _asNativeTable;


 mutable string_table _stringTable;

 VirtualClock& _clock;

 SafeStack<as_value> _stack;

    typedef boost::array<as_value, 4> GlobalRegisters;
    GlobalRegisters _globalRegisters;

 CallStack _callStack;


    std::auto_ptr<SharedObjectLibrary> _shLib;

};




class FrameGuard
{
public:

    FrameGuard(VM& vm, UserFunction& func)
        :
        _vm(vm),
        _callFrame(_vm.pushCallFrame(func))
    {
    }


    CallFrame& callFrame() {
        return _callFrame;
    }

    ~FrameGuard() {
        _vm.popCallFrame();
    }

private:
    VM& _vm;
    CallFrame& _callFrame;
};
# 432 "../libcore/vm/VM.h"
void newAdd(as_value& op1, const as_value& op2, VM& vm);






void subtract(as_value& op1, const as_value& op2, VM& vm);






as_value newLessThan(const as_value& op1, const as_value& op2, VM& vm);

}
# 26 "../libcore/vm/fn_call.h" 2
# 1 "../libbase/GnashException.h" 1
# 26 "../libbase/GnashException.h"
namespace gnash
{


class GnashException: public std::runtime_error
{

public:

 GnashException(const std::string& s)
  :
        std::runtime_error(s)
 {}

 GnashException()
  :
        std::runtime_error("Generic error")
 {}

 virtual ~GnashException() throw() {}
};


class MediaException : public GnashException
{

public:

 MediaException(const std::string& s)
  :
  GnashException(s)
 {}

 MediaException()
  :
  GnashException("Media error")
 {}

 virtual ~MediaException() throw() {}

};


class SoundException : public GnashException
{

public:

 SoundException(const std::string& s)
  :
  GnashException(s)
 {}

 SoundException()
  :
  GnashException("Audio error")
 {}

 virtual ~SoundException() throw() {}

};


class ParserException : public GnashException
{

public:

 ParserException(const std::string& s)
  :
  GnashException(s)
 {}

 ParserException()
  :
  GnashException("Parser error")
 {}

 virtual ~ParserException() throw() {}

};


class ActionException: public GnashException
{

protected:

 ActionException(const std::string& s)
  :
  GnashException(s)
 {}

 ActionException()
  :
  GnashException("ActionScript error")
 {}

public:

 virtual ~ActionException() throw() {}

};






class ActionLimitException: public ActionException
{

public:

 ActionLimitException(const std::string& s)
  :
  ActionException(s)
 {}

 ActionLimitException()
  :
  ActionException("ActionScript limit hit")
 {}

 virtual ~ActionLimitException() throw() {}

};







class ActionTypeError: public ActionException
{

public:

 ActionTypeError(const std::string& s)
  :
  ActionException(s)
 {}

 ActionTypeError()
  :
  ActionException("ActionTypeError")
 {}

 virtual ~ActionTypeError() throw() {}

};



class ActionParserException: public ActionException
{

public:

 ActionParserException(const std::string& s)
  :
  ActionException(s)
 {}

 ActionParserException()
  :
  ActionException("Action parser exception")
 {}

 virtual ~ActionParserException() throw() {}

};



class ActionScriptException: public ActionException
{

public:

 ActionScriptException(const std::string& s)
  :
  ActionException(s)
 {}

 ActionScriptException()
  :
  ActionException("Unhandled ActionScript exception")
 {}

 virtual ~ActionScriptException() throw() {}

};


}
# 27 "../libcore/vm/fn_call.h" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 31 "../libcore/vm/fn_call.h" 2





namespace gnash {
    class as_environment;
    class as_function;
    class movie_definition;
}

namespace gnash {
# 56 "../libcore/vm/fn_call.h"
template<typename T>
class FunctionArgs
{
public:

    typedef typename std::vector<T>::size_type size_type;
    typedef std::vector<T> container_type;
    typedef T value_type;

    FunctionArgs() {}


    FunctionArgs(const FunctionArgs& other)
        :
        _v(other._v)
    {}

    FunctionArgs& operator+=(const T& t) {
        _v.push_back(t);
        return *this;
    }

    FunctionArgs& operator,(const T& t) {
        _v.push_back(t);
        return *this;
    }





    void setReachable() const {
        std::for_each(_v.begin(), _v.end(),
                      std::mem_fun_ref(&as_value::setReachable));
    }

    void swap(std::vector<T>& to) {
        std::swap(_v, to);
    }

    size_type size() const {
        return _v.size();
    }

private:
    std::vector<T> _v;
};





class fn_call
{
public:

    typedef FunctionArgs<as_value> Args;
# 122 "../libcore/vm/fn_call.h"
    fn_call(as_object* this_in, const as_environment& env_in,
            Args& args, as_object* sup = 0, bool isNew = false)
        :
        this_ptr(this_in),
        super(sup),
        nargs(args.size()),
        callerDef(0),
        _env(env_in),
        _new(isNew)
    {
        args.swap(_args);
    }

    fn_call(as_object* this_in, const as_environment& env_in)
        :
        this_ptr(this_in),
        super(0),
        nargs(0),
        callerDef(0),
        _env(env_in),
        _new(false)
 {
 }


    fn_call(const fn_call& fn)
        :
        this_ptr(fn.this_ptr),
        super(fn.super),
        nargs(fn.nargs),
        callerDef(fn.callerDef),
        _env(fn._env),
        _args(fn._args),
        _new(false)
 {
 }



    as_object* this_ptr;




    as_object* super;


    Args::size_type nargs;


    const movie_definition* callerDef;


    VM& getVM() const {
        return _env.getVM();
    }


    bool isInstantiation() const {
        return _new;
 }


    const Args::value_type& arg(unsigned int n) const {
        ((n < nargs) ? static_cast<void> (0) : __assert_fail ("n < nargs", "../libcore/vm/fn_call.h", 186, __PRETTY_FUNCTION__));
        return _args[n];
 }

    const Args::container_type& getArgs() const {
        return _args;
    }

    void drop_bottom() {
        ((!_args.empty()) ? static_cast<void> (0) : __assert_fail ("!_args.empty()", "../libcore/vm/fn_call.h", 195, __PRETTY_FUNCTION__));
        _args.erase(_args.begin());
        --nargs;
 }

    const as_environment& env() const {
        return _env;
 }


    void dump_args(std::ostream& os) const {
        for (size_t i = 0; i < nargs; ++i) {
            if ( i ) os << ", ";
            os << arg(i).toDebugString();
        }
 }

    void resetArgs() {
        nargs = 0;
        _args.clear();
 }

    void pushArg(const Args::value_type& arg) {
        ++nargs;
        _args.push_back(arg);
 }

private:



    const as_environment& _env;


    Args::container_type _args;

    bool _new;

};





template<typename T>
struct ThisIs
{
    typedef T value_type;
    value_type* operator()(as_object* o) const {
        return dynamic_cast<value_type*>(o);
    }
};





template<typename T>
struct ThisIsNative
{
    typedef T value_type;
    value_type* operator()(as_object* o) const {
        return dynamic_cast<value_type*>(o->relay());
    }
};




template<typename T = DisplayObject>
struct IsDisplayObject
{
    typedef T value_type;
    value_type* operator()(as_object* o) const {
        if (!o) return 0;
        return dynamic_cast<T*>(o->displayObject());
    }
};


struct ValidThis
{
    typedef as_object value_type;
    value_type* operator()(as_object* o) const {
        return o;
    }
};
# 301 "../libcore/vm/fn_call.h"
template<typename T>
typename T::value_type*
ensure(const fn_call& fn)
{
    as_object* obj = fn.this_ptr;
    if (!obj) throw ActionTypeError();

    typename T::value_type* ret = T()(obj);

    if (!ret) {
        std::string target = typeName(ret);
        std::string source = typeName(obj);

        std::string msg = "Function requiring " + target + " as 'this' "
            "called from " + source + " instance.";

        throw ActionTypeError(msg);
    }
    return ret;
}

inline string_table&
getStringTable(const fn_call& fn)
{
    return fn.getVM().getStringTable();
}

inline movie_root&
getRoot(const fn_call& fn)
{
    return fn.getVM().getRoot();
}

inline int
getSWFVersion(const fn_call& fn)
{
    return fn.getVM().getSWFVersion();
}

inline VM&
getVM(const fn_call& fn)
{
    return fn.getVM();
}

inline Global_as&
getGlobal(const fn_call& fn)
{
    return *fn.getVM().getGlobal();
}

}
# 25 "./builtin_function.h" 2

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 27 "./builtin_function.h" 2

namespace gnash {
# 39 "./builtin_function.h"
class builtin_function : public UserFunction
{
    typedef as_value (*ASFunction)(const fn_call& fn);

public:
# 52 "./builtin_function.h"
 builtin_function(Global_as& gl, ASFunction func)
  :
  UserFunction(gl),
  _func(func)
 {
 }




    virtual boost::uint8_t registers() const {
        return 0;
    }


 virtual as_value call(const fn_call& fn)
 {
  FrameGuard guard(getVM(fn), *this);

  ((_func) ? static_cast<void> (0) : __assert_fail ("_func", "./builtin_function.h", 71, __PRETTY_FUNCTION__));
  return _func(fn);
 }

 bool isBuiltin() { return true; }

private:

 ASFunction _func;
};

}
# 26 "asobj/Array_as.cpp" 2
# 1 "./NativeFunction.h" 1
# 24 "./NativeFunction.h"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 1 3
# 43 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3
       
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 3

# 1 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 1 3 4
# 66 "/nix/store/1bph8b0f1w6h0h6lm6ya1n96par01ykf-glibc-2.12.1/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cassert" 2 3
# 25 "./NativeFunction.h" 2

namespace gnash {
    class fn_call;
}

namespace gnash {
# 40 "./NativeFunction.h"
class NativeFunction : public as_function
{
    typedef as_value (*ASFunction)(const fn_call& fn);

public:
# 54 "./NativeFunction.h"
    NativeFunction(Global_as& gl, ASFunction func)
  :
  as_function(gl),
  _func(func)
 {
 }


 virtual as_value call(const fn_call& fn)
 {
  ((_func) ? static_cast<void> (0) : __assert_fail ("_func", "./NativeFunction.h", 64, __PRETTY_FUNCTION__));
  return _func(fn);
 }

 bool isBuiltin() { return true; }

private:

 ASFunction _func;
};

}
# 27 "asobj/Array_as.cpp" 2
# 1 "./as_function.h" 1
# 28 "asobj/Array_as.cpp" 2

# 1 "asobj/Global_as.h" 1
# 35 "asobj/Global_as.h"
namespace gnash {
 class builtin_function;
 class as_value;
 class VM;
 class ClassHierarchy;
}

namespace gnash {
# 52 "asobj/Global_as.h"
class Global_as : public as_object
{
public:

    typedef as_value(*ASFunction)(const fn_call& fn);
    typedef void(*Properties)(as_object&);

    virtual const ClassHierarchy& classHierarchy() const = 0;
    virtual ClassHierarchy& classHierarchy() = 0;

    explicit Global_as(VM& vm)
        :
        as_object(vm)
    {}


    virtual builtin_function* createFunction(ASFunction function) = 0;






    virtual as_object* createClass(ASFunction ctor, as_object* prototype) = 0;






    virtual as_object* createString(const std::string& s) = 0;






    virtual as_object* createNumber(double d) = 0;






    virtual as_object* createBoolean(bool b) = 0;




    virtual as_object* createArray() = 0;
# 113 "asobj/Global_as.h"
    virtual as_object* createObject() = 0;

    virtual Global_as& global() {
        return *this;
    }

    virtual VM& getVM() const = 0;
};
# 139 "asobj/Global_as.h"
inline as_object*
registerBuiltinObject(as_object& where, Global_as::Properties p,
        const ObjectURI& uri)
{


    Global_as& gl = getGlobal(where);
    as_object* obj = gl.createObject();
    if (p) p(*obj);

    where.init_member(uri, obj, as_object::DefaultFlags);

    return obj;
}
# 171 "asobj/Global_as.h"
inline as_object*
registerBuiltinClass(as_object& where, Global_as::ASFunction ctor,
        Global_as::Properties p, Global_as::Properties c, const ObjectURI& uri)
{
    Global_as& gl = getGlobal(where);
    as_object* proto = gl.createObject();
    as_object* cl = gl.createClass(ctor, proto);


    if (c) c(*cl);


    if (p) p(*proto);


    where.init_member(uri, cl, as_object::DefaultFlags);
    return cl;
}




inline as_value
invoke(const as_value& method, const as_environment& env, as_object* this_ptr,
        fn_call::Args& args, as_object* super = 0,
        const movie_definition* callerDef = 0)
{

 as_value val;
 fn_call call(this_ptr, env, args);
 call.super = super;
    call.callerDef = callerDef;

 try {
  if (as_object* func = method.to_object(getGlobal(env))) {

      val = func->call(call);
  }
  else {
            { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror("Attempt to call a value which is not " "a function (%s)", method);; } }


             ;
            return val;
  }
 }
 catch (ActionTypeError& e) {
  ((val.is_undefined()) ? static_cast<void> (0) : __assert_fail ("val.is_undefined()", "asobj/Global_as.h", 218, __PRETTY_FUNCTION__));
  { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror("%s", e.what());; } }

   ;
 }
 return val;
}
# 262 "asobj/Global_as.h"
inline as_value callMethod(as_object* obj, string_table::key key ) { if (!obj) return as_value(); as_value func; if (!obj->get_member(key, &func)) return as_value(); fn_call::Args args; return invoke(func, as_environment(getVM(*obj)), obj, args);} inline as_value callMethod(as_object* obj, string_table::key key , const as_value& arg0) { if (!obj) return as_value(); as_value func; if (!obj->get_member(key, &func)) return as_value(); fn_call::Args args; (args += arg0); return invoke(func, as_environment(getVM(*obj)), obj, args);} inline as_value callMethod(as_object* obj, string_table::key key , const as_value& arg0 , const as_value& arg1) { if (!obj) return as_value(); as_value func; if (!obj->get_member(key, &func)) return as_value(); fn_call::Args args; (args += arg0 , arg1); return invoke(func, as_environment(getVM(*obj)), obj, args);} inline as_value callMethod(as_object* obj, string_table::key key , const as_value& arg0 , const as_value& arg1 , const as_value& arg2) { if (!obj) return as_value(); as_value func; if (!obj->get_member(key, &func)) return as_value(); fn_call::Args args; (args += arg0 , arg1 , arg2); return invoke(func, as_environment(getVM(*obj)), obj, args);} inline as_value callMethod(as_object* obj, string_table::key key , const as_value& arg0 , const as_value& arg1 , const as_value& arg2 , const as_value& arg3) { if (!obj) return as_value(); as_value func; if (!obj->get_member(key, &func)) return as_value(); fn_call::Args args; (args += arg0 , arg1 , arg2 , arg3); return invoke(func, as_environment(getVM(*obj)), obj, args);}




inline as_function*
getClassConstructor(const fn_call& fn, const std::string& s)
{
    const as_value ctor(fn.env().find_object(s));
    return ctor.to_function();
}

}
# 30 "asobj/Array_as.cpp" 2

# 1 "../libcore/vm/VM.h" 1
# 32 "asobj/Array_as.cpp" 2
# 1 "../libbase/GnashNumeric.h" 1
# 25 "../libbase/GnashNumeric.h"
# 1 "../gnashconfig.h" 1
# 26 "../libbase/GnashNumeric.h" 2






# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
# 33 "../libbase/GnashNumeric.h" 2

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/cstdint.hpp" 1
# 35 "../libbase/GnashNumeric.h" 2


namespace gnash {




static const double PI = 3.14159265358979323846;

inline bool
isFinite(double d)
{





    using namespace std;
    return (isfinite(d));

}

inline double
infinite_to_zero(double x)
{
    return isFinite(x) ? x : 0.0;
}

template <typename T>
inline T
clamp(T i, T min, T max)
{
 ((min <= max) ? static_cast<void> (0) : __assert_fail ("min <= max", "../libbase/GnashNumeric.h", 67, __PRETTY_FUNCTION__));
 return std::max<T>(min, std::min<T>(i, max));
}

template<typename T>
inline T
lerp(T a, T b, T f)
{
    return (b - a) * f + a;
}

inline int
frnd(float f)
{
    return static_cast<int>(f + 0.5f);
}

inline double
twipsToPixels(int i)
{
    return static_cast<double>(i / 20.0);
}

template<size_t Factor>
boost::int32_t
truncateWithFactor(double a)
{

    const double factor = static_cast<double>(Factor);
# 104 "../libbase/GnashNumeric.h"
    static const double upperUnsignedLimit =
                std::numeric_limits<boost::uint32_t>::max() + 1.0;
    static const double upperSignedLimit =
                std::numeric_limits<boost::int32_t>::max() / factor;
    static const double lowerSignedLimit =
                std::numeric_limits<boost::int32_t>::min() / factor;

    if (a >= lowerSignedLimit && a <= upperSignedLimit) {
        return static_cast<boost::int32_t>(a * factor);
    }


    return a >= 0 ?
        static_cast<boost::uint32_t>(
                std::fmod(a * factor, upperUnsignedLimit))
        :
        -static_cast<boost::uint32_t>(
                std::fmod(-a * factor, upperUnsignedLimit));
}


inline boost::int32_t
pixelsToTwips(double a)
{
    return truncateWithFactor<20>(a);
}

}
# 33 "asobj/Array_as.cpp" 2
# 1 "./namedStrings.h" 1
# 23 "./namedStrings.h"
namespace gnash {

class string_table;
# 47 "./namedStrings.h"
namespace NSV {

enum NamedStrings {
        CLASS_ACCESSIBILITY = 1,
        CLASS_ANTIALIASTYPE,
        CLASS_ARRAY,
        CLASS_AS_BROADCASTER,
        CLASS_BITMAP,
        CLASS_BOOLEAN,
        CLASS_BUTTON,
        CLASS_CAMERA,
        CLASS_COLOR,
        CLASS_CONTEXTMENU,
        CLASS_CONTEXTMENUITEM,
        CLASS_CUSTOM_ACTIONS,
        CLASS_CSMTEXTSETTINGS,
        CLASS_DATE,
        CLASS_DISPLAYOBJECT,
        CLASS_DISPLAYOBJECTCONTAINER,
        CLASS_ERROR,
        CLASS_EVENT,
        CLASS_EVENTDISPATCHER,
        CLASS_FONT,
        CLASS_FONTSTYLE,
        CLASS_FUNCTION,
        CLASS_GRIDFITTYPE,
        CLASS_INT,
        CLASS_INTERACTIVEOBJECT,
        CLASS_KEY,
        CLASS_KEYBOARD,
        CLASS_LOAD_VARS,
        CLASS_LOCALCONNECTION,
        CLASS_MATH,
        CLASS_MICROPHONE,
        CLASS_MOUSE,
        CLASS_MOVIE_CLIP,
        CLASS_MOVIE_CLIP_LOADER,
        CLASS_NAMESPACE,
        CLASS_NET_CONNECTION,
        CLASS_NET_STREAM,
        CLASS_NUMBER,
        CLASS_OBJECT,
        CLASS_QNAME,
        CLASS_SELECTION,
        CLASS_SHAPE,
        CLASS_SHARED_OBJECT,
        CLASS_SIMPLE_BUTTON,
        CLASS_SOUND,
        CLASS_SPRITE,
        CLASS_STAGE,
        CLASS_STATICTEXT,
        CLASS_STRING,
        CLASS_STYLESHEET,
        CLASS_SYSTEM,
        CLASS_TEXTCOLORTYPE,
        CLASS_TEXTDISPLAYMODE,
        CLASS_TEXT_FIELD,
        CLASS_TEXTFIELDTYPE,
        CLASS_TEXT_FORMAT,
        CLASS_TEXTFORMATALIGN,
        CLASS_TEXT_SNAPSHOT,
        CLASS_TEXTFIELDAUTOSIZE,
        CLASS_TEXTLINEMETRICS,
        CLASS_TEXTRENDERER,
        CLASS_VIDEO,
        CLASS_XML,
        CLASS_XML_DOCUMENT,
        CLASS_XMLNODE,
        CLASS_XMLSOCKET,
        NS_ADOBE_UTILS,
        NS_FLASH_ACCESSIBILITY,
        NS_FLASH_DISPLAY,
        NS_FLASH_EVENTS,
        NS_FLASH_ERRORS,
        NS_FLASH_GEOM,
        NS_FLASH_MEDIA,
        NS_FLASH_NET,
        NS_FLASH_SYSTEM,
        NS_FLASH_TEXT,
        NS_FLASH_UI,
        NS_FLASH_UTILS,
        NS_FLASH_XML,
        PROP_A,
        PROP_ADD_LISTENER,
        PROP_ALIGN,
        PROP_AS_NATIVE,
        PROP_AS_SET_PROP_FLAGS,
        PROP_B,
        PROP_BLOCK_INDENT,
        PROP_BOLD,
        PROP_BROADCAST_MESSAGE,
        PROP_BULLET,
        PROP_uBYTES_TOTAL,
        PROP_uBYTES_LOADED,
        PROP_C,
        PROP_CALLEE,
        PROP_CALLER,
        PROP_COLOR,
        PROP_CONCAT,
        PROP_CONSTRUCTOR,
        PROP_CONTENT_TYPE,
        PROP_D,
        PROP_DATA,
        PROP_DECODE,
        PROP_E,
        PROP_ENABLED,
        PROP_ESCAPE,
        PROP_FOCUS_ENABLED,
        PROP_G,
        PROP_H,
        PROP_HEIGHT,
        PROP_HTML_TEXT,
        PROP_INDENT,
        PROP_ITALIC,
        PROP_LEADING,
        PROP_LEFT_MARGIN,
        PROP_LENGTH,
        PROP_LOADED,
        PROP_MATRIX_TYPE,
        PROP_METH,
        PROP_ON_CLOSE,
        PROP_ON_CONNECT,
        PROP_ON_CONSTRUCT,
        PROP_ON_DATA,
        PROP_ON_DRAG_OUT,
        PROP_ON_DRAG_OVER,
        PROP_ON_ENTER_FRAME,
        PROP_ON_FULLSCREEN,
        PROP_ON_INITIALIZE,
        PROP_ON_KEY_DOWN,
        PROP_ON_KEY_PRESS,
        PROP_ON_KEY_UP,
        PROP_ON_KILL_FOCUS,
        PROP_ON_LOAD,
        PROP_ON_LOAD_ERROR,
        PROP_ON_LOAD_INIT,
        PROP_ON_LOAD_PROGRESS,
        PROP_ON_LOAD_START,
        PROP_ON_META_DATA,
        PROP_ON_MOUSE_DOWN,
        PROP_ON_MOUSE_MOVE,
        PROP_ON_MOUSE_UP,
        PROP_ON_PRESS,
        PROP_ON_RELEASE,
        PROP_ON_RELEASE_OUTSIDE,
        PROP_ON_RESIZE,
        PROP_ON_RESULT,
        PROP_ON_ROLL_OUT,
        PROP_ON_ROLL_OVER,
        PROP_ON_SELECT,
        PROP_ON_SET_FOCUS,
        PROP_ON_SOUND_COMPLETE,
        PROP_ON_STATUS,
        PROP_ON_TIMER,
        PROP_ON_UNLOAD,
        PROP_ON_XML,
        PROP_PARSE_XML,
        PROP_PROTOTYPE,
        PROP_PUSH,
        PROP_R,
        PROP_REMOVE_LISTENER,
        PROP_RIGHT_MARGIN,
        PROP_SCALE_MODE,
        PROP_SIZE,
        PROP_SPLICE,
        PROP_STATUS,
        PROP_SUPER,
        PROP_TARGET,
        PROP_TEXT,
        PROP_TEXT_COLOR,
        PROP_TEXT_HEIGHT,
        PROP_TEXT_WIDTH,
        PROP_THIS,
        PROP_TO_LOWER_CASE,
        PROP_TO_STRING,
        PROP_TX,
        PROP_TY,
        PROP_uALPHA,
        PROP_uCURRENTFRAME,
        PROP_uCUSTOM_HEADERS,
        PROP_uDROPTARGET,
        PROP_uFOCUSRECT,
        PROP_uFRAMESLOADED,
        PROP_uGLOBAL,
        PROP_uHEIGHT,
        PROP_uHIGHQUALITY,
        PROP_uQUALITY,
        PROP_uLISTENERS,
        PROP_uNAME,
        PROP_UNDERLINE,
        PROP_uPARENT,
        PROP_uROOT,
        PROP_uROTATION,
        PROP_USEHANDCURSOR,
        PROP_uSOUNDBUFTIME,
        PROP_uTARGET,
        PROP_uTOTALFRAMES,
        PROP_uuCONSTRUCTORuu,
        PROP_uuPROTOuu,
        PROP_uuRESOLVE,
        PROP_uURL,
        PROP_uVISIBLE,
        PROP_uWIDTH,
        PROP_uX,
        PROP_uXMOUSE,
        PROP_uXSCALE,
        PROP_uY,
        PROP_uYMOUSE,
        PROP_uYSCALE,
        PROP_VALUE_OF,
        PROP_W,
        PROP_WIDTH,
        PROP_X,
        PROP_Y,
        PROP_ON_SYNC,
        INTERNAL_INTERFACES,
        INTERNAL_STACK_PARENT,
        INTERNAL_TYPE
    };


void loadStrings(string_table &table);

}
}
# 34 "asobj/Array_as.cpp" 2



# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cmath" 3
# 38 "asobj/Array_as.cpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/transform_iterator.hpp" 1
# 28 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/transform_iterator.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_def.hpp" 1
# 29 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/transform_iterator.hpp" 2


namespace boost
{
  template <class UnaryFunction, class Iterator, class Reference = use_default, class Value = use_default>
  class transform_iterator;

  namespace detail
  {

    template <class UnaryFunc>
    struct function_object_result
    {
      typedef typename UnaryFunc::result_type type;
    };


    template <class Return, class Argument>
    struct function_object_result<Return(*)(Argument)>
    {
      typedef Return type;
    };



    template <class UnaryFunc, class Iterator, class Reference, class Value>
    struct transform_iterator_base
    {
     private:




        typedef typename ia_dflt_help<
            Reference
          , function_object_result<UnaryFunc>
        >::type reference;






        typedef typename ia_dflt_help<
            Value
          , remove_reference<reference>
        >::type cv_value_type;

     public:
        typedef iterator_adaptor<
            transform_iterator<UnaryFunc, Iterator, Reference, Value>
          , Iterator
          , cv_value_type
          , use_default
          , reference
        > type;
    };
  }

  template <class UnaryFunc, class Iterator, class Reference, class Value>
  class transform_iterator
    : public boost::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
  {
    typedef typename
    boost::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
    super_t;

    friend class iterator_core_access;

  public:
    transform_iterator() { }

    transform_iterator(Iterator const& x, UnaryFunc f)
      : super_t(x), m_f(f) { }

    explicit transform_iterator(Iterator const& x)
      : super_t(x)
    {





        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((is_class<UnaryFunc>::value) == 0 ? false : true) >)> boost_static_assert_typedef_112;

    }

    template<
        class OtherUnaryFunction
      , class OtherIterator
      , class OtherReference
      , class OtherValue>
    transform_iterator(
         transform_iterator<OtherUnaryFunction, OtherIterator, OtherReference, OtherValue> const& t
       , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0

       , typename enable_if_convertible<OtherUnaryFunction, UnaryFunc>::type* = 0

    )
      : super_t(t.base()), m_f(t.functor())
   {}

    UnaryFunc functor() const
      { return m_f; }

  private:
    typename super_t::reference dereference() const
    { return m_f(*this->base()); }



    UnaryFunc m_f;
  };

  template <class UnaryFunc, class Iterator>
  transform_iterator<UnaryFunc, Iterator>
  make_transform_iterator(Iterator it, UnaryFunc fun)
  {
      return transform_iterator<UnaryFunc, Iterator>(it, fun);
  }
# 157 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/transform_iterator.hpp"
  template <class UnaryFunc, class Iterator>



  typename iterators::enable_if<

      is_class<UnaryFunc>
    , transform_iterator<UnaryFunc, Iterator>



  >::type
  make_transform_iterator(Iterator it)
  {
      return transform_iterator<UnaryFunc, Iterator>(it, UnaryFunc());
  }
# 183 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/transform_iterator.hpp"
}

# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/detail/config_undef.hpp" 1
# 186 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/iterator/transform_iterator.hpp" 2
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp" 2






# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/case_conv.hpp" 1
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/case_conv.hpp"
namespace boost {
    namespace algorithm {
        namespace detail {
# 30 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/case_conv.hpp"
            template<typename CharT>
            struct to_lowerF : public std::unary_function<CharT, CharT>
            {

                to_lowerF( const std::locale& Loc ) : m_Loc( &Loc ) {}


                CharT operator ()( CharT Ch ) const
                {



                        return std::tolower<CharT>( Ch, *m_Loc );

                }
            private:
                const std::locale* m_Loc;
            };


            template<typename CharT>
            struct to_upperF : public std::unary_function<CharT, CharT>
            {

                to_upperF( const std::locale& Loc ) : m_Loc( &Loc ) {}


                CharT operator ()( CharT Ch ) const
                {



                        return std::toupper<CharT>( Ch, *m_Loc );

                }
            private:
                const std::locale* m_Loc;
            };
# 76 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/detail/case_conv.hpp"
            template<typename OutputIteratorT, typename RangeT, typename FunctorT>
            OutputIteratorT transform_range_copy(
                OutputIteratorT Output,
                const RangeT& Input,
                FunctorT Functor)
            {
                return std::transform(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    Output,
                    Functor);
            }


            template<typename RangeT, typename FunctorT>
            void transform_range(
                const RangeT& Input,
                FunctorT Functor)
            {
                std::transform(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    ::boost::begin(Input),
                    Functor);
            }

            template<typename SequenceT, typename RangeT, typename FunctorT>
            inline SequenceT transform_range_copy(
                const RangeT& Input,
                FunctorT Functor)
            {
                return SequenceT(
                    ::boost::make_transform_iterator(
                        ::boost::begin(Input),
                        Functor),
                    ::boost::make_transform_iterator(
                        ::boost::end(Input),
                        Functor));
            }

        }
    }
}
# 25 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp" 2







namespace boost {
    namespace algorithm {
# 53 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp"
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT
        to_lower_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy(
               Output,
               ::boost::as_literal(Input),
               ::boost::algorithm::detail::to_lowerF<
                    typename range_value<RangeT>::type >(Loc));
        }





        template<typename SequenceT>
        inline SequenceT to_lower_copy(
            const SequenceT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy<SequenceT>(
                Input,
                ::boost::algorithm::detail::to_lowerF<
                    typename range_value<SequenceT>::type >(Loc));
        }
# 90 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp"
        template<typename WritableRangeT>
        inline void to_lower(
            WritableRangeT& Input,
            const std::locale& Loc=std::locale())
        {
            ::boost::algorithm::detail::transform_range(
                ::boost::as_literal(Input),
                ::boost::algorithm::detail::to_lowerF<
                    typename range_value<WritableRangeT>::type >(Loc));
        }
# 118 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp"
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT
        to_upper_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy(
               Output,
               ::boost::as_literal(Input),
               ::boost::algorithm::detail::to_upperF<
                    typename range_value<RangeT>::type >(Loc));
        }





        template<typename SequenceT>
        inline SequenceT to_upper_copy(
            const SequenceT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy<SequenceT>(
                Input,
                ::boost::algorithm::detail::to_upperF<
                    typename range_value<SequenceT>::type >(Loc));
        }
# 155 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/algorithm/string/case_conv.hpp"
        template<typename WritableRangeT>
        inline void to_upper(
            WritableRangeT& Input,
            const std::locale& Loc=std::locale())
        {
            ::boost::algorithm::detail::transform_range(
                ::boost::as_literal(Input),
                ::boost::algorithm::detail::to_upperF<
                    typename range_value<WritableRangeT>::type >(Loc));
        }

    }


    using algorithm::to_lower;
    using algorithm::to_lower_copy;
    using algorithm::to_upper;
    using algorithm::to_upper_copy;

}
# 39 "asobj/Array_as.cpp" 2
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp" 1
# 17 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 1 3 4
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 2 3
# 18 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp" 2
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 3


# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include/stddef.h" 1 3 4
# 45 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/cstddef" 2 3
# 19 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp" 2
# 31 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
# 1 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/lcast_precision.hpp" 1
# 11 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/lcast_precision.hpp"
# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 1 3
# 41 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 3
       
# 42 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 3

# 1 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/include-fixed/limits.h" 1 3 4
# 44 "/nix/store/g8clpkpcyxsqkv03w40ikc6lyx8xark2-gcc-4.5.1/lib/gcc/mips64el-unknown-linux-gnu/4.5.1/../../../../include/c++/4.5.1/climits" 2 3
# 12 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/lcast_precision.hpp" 2
# 36 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/lcast_precision.hpp"
namespace boost { namespace detail {

class lcast_abstract_stub {};





template<class T>
struct lcast_precision
{



    typedef typename boost::mpl::if_<
        boost::is_abstract<T>
      , std::numeric_limits<lcast_abstract_stub>
      , std::numeric_limits<T>
      >::type limits;


    static const bool use_default_precision = !limits::is_specialized || limits::is_exact

         ;

    static const bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0


         ;

    static const bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0


         ;

    static const std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max

         ;

    static const unsigned int precision_dec = limits::digits10 + 1U;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!is_specialized_dec || precision_dec <= streamsize_max + 0UL) == 0 ? false : true) >)>

 boost_static_assert_typedef_79;

    static const unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL

         ;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!is_specialized_bin || (limits::digits + 0UL < (2147483647L * 2UL + 1UL) / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)) == 0 ? false : true) >)>



 boost_static_assert_typedef_89;

    static const std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec : 6


         ;
};


template<class T>
inline std::streamsize lcast_get_precision(T* = 0)
{

    return lcast_precision<T>::value;
# 165 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/detail/lcast_precision.hpp"
}

template<class T>
inline void lcast_set_precision(std::ios_base& stream, T*)
{
    stream.precision(lcast_get_precision<T>());
}

template<class Source, class Target>
inline void lcast_set_precision(std::ios_base& stream, Source*, Target*)
{
    std::streamsize const s = lcast_get_precision(static_cast<Source*>(0));
    std::streamsize const t = lcast_get_precision(static_cast<Target*>(0));
    stream.precision(s > t ? s : t);
}

}}
# 32 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp" 2
# 55 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
namespace boost
{

    class bad_lexical_cast : public std::bad_cast






    {
    public:
        bad_lexical_cast() :

          source(&typeid(void)), target(&typeid(void))



        {
        }

        bad_lexical_cast(
            const std::type_info &source_type_arg,
            const std::type_info &target_type_arg) :
            source(&source_type_arg), target(&target_type_arg)
        {
        }

        const std::type_info &source_type() const
        {
            return *source;
        }
        const std::type_info &target_type() const
        {
            return *target;
        }

        virtual const char *what() const throw()
        {
            return "bad lexical cast: "
                   "source type value could not be interpreted as target";
        }
        virtual ~bad_lexical_cast() throw()
        {
        }
    private:
        const std::type_info *source;
        const std::type_info *target;
    };

    namespace detail
    {
        template<typename Type>
        struct stream_char
        {
            typedef char type;
        };


        template<class CharT, class Traits, class Alloc>
        struct stream_char< std::basic_string<CharT,Traits,Alloc> >
        {
            typedef CharT type;
        };




        template<>
        struct stream_char<wchar_t>
        {
            typedef wchar_t type;
        };


        template<>
        struct stream_char<wchar_t *>
        {
            typedef wchar_t type;
        };

        template<>
        struct stream_char<const wchar_t *>
        {
            typedef wchar_t type;
        };
# 151 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<typename TargetChar, typename SourceChar>
        struct widest_char
        {
            typedef TargetChar type;
        };

        template<>
        struct widest_char<char, wchar_t>
        {
            typedef wchar_t type;
        };
    }

    namespace detail
    {

        template<class CharT, class Target, class Source>
        struct deduce_char_traits
        {
            typedef std::char_traits<CharT> type;
        };

        template<class CharT, class Traits, class Alloc, class Source>
        struct deduce_char_traits< CharT
                                 , std::basic_string<CharT,Traits,Alloc>
                                 , Source
                                 >
        {
            typedef Traits type;
        };

        template<class CharT, class Target, class Traits, class Alloc>
        struct deduce_char_traits< CharT
                                 , Target
                                 , std::basic_string<CharT,Traits,Alloc>
                                 >
        {
            typedef Traits type;
        };

        template<class CharT, class Traits, class Alloc1, class Alloc2>
        struct deduce_char_traits< CharT
                                 , std::basic_string<CharT,Traits,Alloc1>
                                 , std::basic_string<CharT,Traits,Alloc2>
                                 >
        {
            typedef Traits type;
        };

    }

    namespace detail
    {
# 213 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template< class CharT
                , class Source
                >
        struct lcast_src_length
        {
            static const std::size_t value = 0;


            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char, bool>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char, char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
# 247 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<>
        struct lcast_src_length<wchar_t, bool>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<wchar_t, char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };


        template<>
        struct lcast_src_length<wchar_t, wchar_t>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };



        template<>
        struct lcast_src_length<char, char const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char, char*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };


        template<>
        struct lcast_src_length<wchar_t, wchar_t const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<wchar_t, wchar_t*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };



        template<class CharT, class Traits, class Alloc>
        struct lcast_src_length< CharT, std::basic_string<CharT,Traits,Alloc> >
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
# 339 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<class Source>
        struct lcast_src_length_integral
        {

            static const std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2



               ;




        };
# 367 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<> struct lcast_src_length<char, short> : lcast_src_length_integral<short> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, short> : lcast_src_length_integral<short> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned short> : lcast_src_length_integral<unsigned short> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned short> : lcast_src_length_integral<unsigned short> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, int> : lcast_src_length_integral<int> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, int> : lcast_src_length_integral<int> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned int> : lcast_src_length_integral<unsigned int> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned int> : lcast_src_length_integral<unsigned int> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, long> : lcast_src_length_integral<long> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, long> : lcast_src_length_integral<long> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned long> : lcast_src_length_integral<unsigned long> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned long> : lcast_src_length_integral<unsigned long> { static void check_coverage() {} };

        template<> struct lcast_src_length<char, boost::ulong_long_type> : lcast_src_length_integral<boost::ulong_long_type> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, boost::ulong_long_type> : lcast_src_length_integral<boost::ulong_long_type> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, boost::long_long_type> : lcast_src_length_integral<boost::long_long_type> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, boost::long_long_type> : lcast_src_length_integral<boost::long_long_type> { static void check_coverage() {} };
# 395 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<class Source>
        struct lcast_src_length_floating
        {
            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L) == 0 ? false : true) >)>


 boost_static_assert_typedef_401;
            static const std::size_t value = 5 + lcast_precision<Source>::value + 6

                 ;
        };

        template<>
        struct lcast_src_length<char,float>
          : lcast_src_length_floating<float>
        {
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char,double>
          : lcast_src_length_floating<double>
        {
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char,long double>
          : lcast_src_length_floating<long double>
        {
            static void check_coverage() {}
        };


    template<>
    struct lcast_src_length<wchar_t,float>
      : lcast_src_length_floating<float>
    {
        static void check_coverage() {}
    };

    template<>
    struct lcast_src_length<wchar_t,double>
      : lcast_src_length_floating<double>
    {
        static void check_coverage() {}
    };

    template<>
    struct lcast_src_length<wchar_t,long double>
      : lcast_src_length_floating<long double>
    {
        static void check_coverage() {}
    };



    }

    namespace detail
    {
        template<typename CharT> struct lcast_char_constants;

        template<>
        struct lcast_char_constants<char>
        {
            static const char zero = '0';
            static const char minus = '-';
        };


        template<>
        struct lcast_char_constants<wchar_t>
        {
            static const wchar_t zero = L'0';
            static const wchar_t minus = L'-';
        };

    }

    namespace detail
    {
        struct lexical_streambuf_fake
        {
        };
    }

    namespace detail
    {







        template<class T>
        inline
        typename make_unsigned<T>::type lcast_to_unsigned(T value)
        {
            typedef typename make_unsigned<T>::type result_type;
            result_type uvalue = static_cast<result_type>(value);
            return value < 0 ? -uvalue : uvalue;
        }





    }

    namespace detail
    {
        template<class Traits, class T, class CharT>
        CharT* lcast_put_unsigned(T n, CharT* finish)
        {

            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<T>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_512;




            std::locale loc;
            typedef std::numpunct<CharT> numpunct;
            numpunct const& np = std::use_facet< numpunct >(loc);
            std::string const& grouping = np.grouping();
            std::string::size_type const grouping_size = grouping.size();
            CharT thousands_sep = grouping_size ? np.thousands_sep() : 0;
            std::string::size_type group = 0;
            char last_grp_size = grouping[0] <= 0 ? 127 : grouping[0];




            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<T>::digits10 < 127) == 0 ? false : true) >)> boost_static_assert_typedef_529;


            char left = last_grp_size;


            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            int_type const zero = Traits::to_int_type(czero);

            do
            {

                if(left == 0)
                {
                    ++group;
                    if(group < grouping_size)
                    {
                        char const grp_size = grouping[group];
                        last_grp_size = grp_size <= 0 ? 127 : grp_size;
                    }

                    left = last_grp_size;
                    --finish;
                    Traits::assign(*finish, thousands_sep);
                }

                --left;


                --finish;
                int_type const digit = static_cast<int_type>(n % 10U);
                Traits::assign(*finish, Traits::to_char_type(zero + digit));
                n /= 10;
            } while(n);

            return finish;
        }
    }

    namespace detail
    {
        template<typename Target, typename Source, typename Traits>
        class lexical_stream
        {
        private:
            typedef typename widest_char<
                typename stream_char<Target>::type,
                typename stream_char<Source>::type>::type char_type;

            typedef Traits traits_type;

        public:
            lexical_stream(char_type* = 0, char_type* = 0)
            {
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<Source*>(0), static_cast<Target*>(0) );
            }
            ~lexical_stream()
            {



            }
            bool operator<<(const Source &input)
            {
                return !(stream << input).fail();
            }
            template<typename InputStreamable>
            bool operator>>(InputStreamable &output)
            {
                return !is_pointer<InputStreamable>::value &&
                       stream >> output &&
                       stream.get() ==







                           traits_type::eof();

            }
# 633 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
            bool operator>>(std::basic_string<char_type,traits_type>& output)
            {
                stream.str().swap(output);
                return true;
            }

            template<class Alloc>
            bool operator>>(std::basic_string<char_type,traits_type,Alloc>& out)
            {
                std::basic_string<char_type,traits_type> str(stream.str());
                out.assign(str.begin(), str.end());
                return true;
            }

        private:





            std::basic_stringstream<char_type,traits_type> stream;

        };
    }

    namespace detail
    {

        template< class CharT
                , class Base
                , class Traits
                >
        class lexical_stream_limited_src : public Base
        {



            CharT* start;
            CharT* finish;

        private:

            static void widen_and_assign(char*p, char ch)
            {
                Traits::assign(*p, ch);
            }


            static void widen_and_assign(wchar_t* p, char ch)
            {

                std::locale loc;
                wchar_t w = std::use_facet< std::ctype<wchar_t> >(loc).widen(ch);
                Traits::assign(*p, w);
            }

            static void widen_and_assign(wchar_t* p, wchar_t ch)
            {
                Traits::assign(*p, ch);
            }

            static void widen_and_assign(char*, wchar_t ch);


            template<class OutputStreamable>
            bool lcast_put(const OutputStreamable& input)
            {
                this->setp(start, finish);
                std::basic_ostream<CharT> stream(static_cast<Base*>(this));
                lcast_set_precision(stream, static_cast<OutputStreamable*>(0));
                bool const result = !(stream << input).fail();
                finish = this->pptr();
                return result;
            }


            lexical_stream_limited_src(lexical_stream_limited_src const&);
            void operator=(lexical_stream_limited_src const&);

        public:

            lexical_stream_limited_src(CharT* sta, CharT* fin)
              : start(sta)
              , finish(fin)
            {}

        public:

            template<class Alloc>
            bool operator<<(std::basic_string<CharT,Traits,Alloc> const& str)
            {
                start = const_cast<CharT*>(str.data());
                finish = start + str.length();
                return true;
            }

            bool operator<<(bool);
            bool operator<<(char);

            bool operator<<(wchar_t);

            bool operator<<(CharT const*);
            bool operator<<(short);
            bool operator<<(int);
            bool operator<<(long);
            bool operator<<(unsigned short);
            bool operator<<(unsigned int);
            bool operator<<(unsigned long);

            bool operator<<(boost::ulong_long_type);
            bool operator<<(boost::long_long_type );






            bool operator<<(float);
            bool operator<<(double);
            bool operator<<(long double);

        public:



            template<typename InputStreamable>
            bool operator>>(InputStreamable& output)
            {





                if(is_pointer<InputStreamable>::value)
                    return false;

                this->setg(start, start, finish);
                std::basic_istream<CharT> stream(static_cast<Base*>(this));
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<InputStreamable*>(0));



                return stream >> output &&
                    stream.get() ==







                Traits::eof();

            }

            bool operator>>(CharT&);
# 801 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
            template<class Alloc>
            bool operator>>(std::basic_string<CharT,Traits,Alloc>& str)
            {
                str.assign(start, finish);
                return true;
            }

        };

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                bool value)
        {
            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            int_type const zero = Traits::to_int_type(czero);
            Traits::assign(*start, Traits::to_char_type(zero + value));
            finish = start + 1;
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                char ch)
        {
            widen_and_assign(start, ch);
            finish = start + 1;
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                wchar_t ch)
        {
            widen_and_assign(start, ch);
            finish = start + 1;
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                short n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                int n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                long n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                boost::long_long_type n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }
# 914 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned short n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned int n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned long n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                boost::ulong_long_type n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }
# 956 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                float val)
        {
            return this->lcast_put(val);
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                double val)
        {
            return this->lcast_put(val);
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                long double val)
        {
            return this->lcast_put(val);
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                CharT const* str)
        {
            start = const_cast<CharT*>(str);
            finish = start + Traits::length(str);
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator>>(
                CharT& output)
        {
            bool const ok = (finish - start == 1);
            if(ok)
                Traits::assign(output, *start);
            return ok;
        }
# 1015 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
    }

    namespace detail
    {

        template<class Source>
        struct lcast_streambuf_for_source
        {
            static const bool value = false;
        };

        template<>
        struct lcast_streambuf_for_source<float>
        {
            static const bool value = true;
        };

        template<>
        struct lcast_streambuf_for_source<double>
        {
            static const bool value = true;
        };

        template<>
        struct lcast_streambuf_for_source<long double>
        {
            static const bool value = true;
        };
    }

    namespace detail
    {

        template<class Target>
        struct lcast_streambuf_for_target
        {
            static const bool value = true;
        };

        template<>
        struct lcast_streambuf_for_target<char>
        {
            static const bool value = false;
        };


        template<>
        struct lcast_streambuf_for_target<wchar_t>
        {
            static const bool value = false;
        };



        template<class Traits, class Alloc>
        struct lcast_streambuf_for_target<
                    std::basic_string<char,Traits,Alloc> >
        {
            static const bool value = false;
        };


        template<class Traits, class Alloc>
        struct lcast_streambuf_for_target<
                    std::basic_string<wchar_t,Traits,Alloc> >
        {
            static const bool value = false;
        };
# 1099 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
    }





    namespace detail
    {
        template<class T>
        struct array_to_pointer_decay
        {
            typedef T type;
        };

        template<class T, std::size_t N>
        struct array_to_pointer_decay<T[N]>
        {
            typedef const T * type;
        };







        template< typename Target
                , typename Source
                , bool Unlimited
                , typename CharT
                >
        Target lexical_cast(
            typename boost::call_traits<Source>::param_type arg,
            CharT* buf, std::size_t src_len)
        {
            typedef typename
                deduce_char_traits<CharT,Target,Source>::type traits;

            typedef typename boost::mpl::if_c<
                lcast_streambuf_for_target<Target>::value ||
                lcast_streambuf_for_source<Source>::value
              , std::basic_streambuf<CharT>
              , lexical_streambuf_fake
              >::type base;

            typename boost::mpl::if_c<
                Unlimited
              , detail::lexical_stream<Target,Source,traits>
              , detail::lexical_stream_limited_src<CharT,base,traits>
              >::type interpreter(buf, buf + src_len);

            Target result;
            if(!(interpreter << arg && interpreter >> result))
                throw_exception(bad_lexical_cast(typeid(Source), typeid(Target)));
            return result;
        }



    }

    template<typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        typedef typename detail::array_to_pointer_decay<Source>::type src;

        typedef typename detail::widest_char<
            typename detail::stream_char<Target>::type
          , typename detail::stream_char<src>::type
          >::type char_type;

        typedef detail::lcast_src_length<char_type, src> lcast_src_length;
        std::size_t const src_len = lcast_src_length::value;
        char_type buf[src_len + 1];
        lcast_src_length::check_coverage();
        return detail::lexical_cast<Target, src, !src_len>(arg, buf, src_len);
    }
# 1203 "/nix/store/yr078pjvyayxsmnnqvh084fqp5y3lna3-boost-1.44.0/include/boost/lexical_cast.hpp"
}
# 40 "asobj/Array_as.cpp" 2

namespace gnash {


namespace {


enum SortFlags {

    SORT_CASE_INSENSITIVE = (1<<0),

    SORT_DESCENDING = (1<<1),




    SORT_UNIQUE = (1<<2),



    SORT_RETURN_INDEX = (1<<3),

    SORT_NUMERIC = (1<<4)
};

struct indexed_as_value;

typedef boost::function2<bool, const as_value&, const as_value&> as_cmp_fn;

as_object* getArrayInterface();
void attachArrayInterface(as_object& proto);
void attachArrayStatics(as_object& proto);

as_value join(as_object* array, const std::string& separator);

as_value array_new(const fn_call& fn);
as_value array_slice(const fn_call& fn);
as_value array_concat(const fn_call& fn);
as_value array_toString(const fn_call& fn);
as_value array_join(const fn_call& fn);
as_value array_reverse(const fn_call& fn);
as_value array_shift(const fn_call& fn);
as_value array_pop(const fn_call& fn);
as_value array_unshift(const fn_call& fn);
as_value array_push(const fn_call& fn);
as_value array_sortOn(const fn_call& fn);
as_value array_sort(const fn_call& fn);
as_value array_splice(const fn_call& fn);

string_table::key getKey(const fn_call& fn, size_t i);
int isIndex(const std::string& name);


template<typename T> void foreachArray(as_object& array, int start,
           int end, T& pred);

inline bool int_lt_or_eq (int a) {
    return a <= 0;
}

inline bool int_gt (int a) {
    return a > 0;
}

void getIndexedElements(as_object& array, std::vector<indexed_as_value>& v);

void pushIndices(as_object& o, const std::vector<indexed_as_value>& index);


void setArrayLength(as_object& o, const int size);

    void resizeArray(as_object& o, const int size);
}


namespace {

struct indexed_as_value : public as_value
{
    int vec_index;

    indexed_as_value(const as_value& val, int index)
 : as_value(val)
 {
     vec_index = index;
 }
};

class PushToArray
{
public:
    PushToArray(as_object& obj) : _obj(obj) {}
    void operator()(const as_value& val) {
        callMethod(&_obj, NSV::PROP_PUSH, val);
    }
private:
    as_object& _obj;
};

template<typename T>
class PushToContainer
{
public:
    PushToContainer(T& v) : _v(v) {}
    void operator()(const as_value& val) {
        _v.push_back(val);
    }
private:
    T& _v;
};


class PushToIndexedVector
{
public:
    PushToIndexedVector(std::vector<indexed_as_value>& v) : _v(v), _i(0) {}
    void operator()(const as_value& val) {
        _v.push_back(indexed_as_value(val, _i));
        ++_i;
    }
private:
    std::vector<indexed_as_value>& _v;
    size_t _i;
};
# 180 "asobj/Array_as.cpp"
template <class AVCMP, class AVEQ>
bool sort(as_object& o, AVCMP avc, AVEQ ave)
{
# 199 "asobj/Array_as.cpp"
    typedef std::list<as_value> SortContainer;

    SortContainer v;
    PushToContainer<SortContainer> pv(v);
    foreachArray(o, pv);

    const size_t size = v.size();

    v.sort(avc);

    if (std::adjacent_find(v.begin(), v.end(), ave) != v.end()) return false;

    string_table& st = getStringTable(o);

    SortContainer::const_iterator it = v.begin();

    for (size_t i = 0; i < size; ++i) {
        if (i >= v.size()) {
            break;
        }
        o.set_member(arrayKey(st, i), *it);
        ++it;
    }
    return true;
}


template <class AVCMP>
void
sort(as_object& o, AVCMP avc)
{

    typedef std::list<as_value> SortContainer;

    SortContainer v;
    PushToContainer<SortContainer> pv(v);
    foreachArray(o, pv);

    const size_t size = v.size();

    v.sort(avc);

    string_table& st = getStringTable(o);

    SortContainer::const_iterator it = v.begin();

    for (size_t i = 0; i < size; ++i) {
        if (it == v.end()) {
            break;
        }
        o.set_member(arrayKey(st, i), *it);
        ++it;
    }
}
# 267 "asobj/Array_as.cpp"
template <class AVCMP, class AVEQ>
as_value sortIndexed(as_object& array, AVCMP avc, AVEQ ave)
{
    std::vector<indexed_as_value> v;

    getIndexedElements(array, v);

    std::sort(v.begin(), v.end(), avc);

    if (std::adjacent_find(v.begin(), v.end(), ave) != v.end()) {
        return as_value(0.0);
    }

    as_object* o = getGlobal(array).createArray();
    pushIndices(*o, v);
    return o;
}
# 292 "asobj/Array_as.cpp"
template <class AVCMP>
as_object*
sortIndexed(as_object& array, AVCMP avc)
{
    std::vector<indexed_as_value> v;
    getIndexedElements(array, v);
    std::sort(v.begin(), v.end(), avc);
    as_object* o = getGlobal(array).createArray();
    pushIndices(*o, v);
    return o;
}




struct as_value_lt
{
    int _version;

    as_value_lt(int version) : _version(version) {}

    inline int str_cmp(const as_value& a, const as_value& b)
    {
        std::string s = a.to_string(_version);
        return s.compare(b.to_string(_version));
    }

    inline int str_nocase_cmp(const as_value& a, const as_value& b)
    {
        using namespace boost::algorithm;

        std::string c = to_upper_copy(a.to_string(_version));
        std::string d = to_upper_copy(b.to_string(_version));
        return c.compare(d);
    }

    inline bool as_value_numLT (const as_value& a, const as_value& b)
    {
        if (a.is_undefined()) return false;
        if (b.is_undefined()) return true;
        if (a.is_null()) return false;
        if (b.is_null()) return true;
        double aval = a.to_number();
        double bval = b.to_number();
        if (isNaN(aval)) return false;
        if (isNaN(bval)) return true;
        return aval < bval;
    }

    inline bool as_value_numGT (const as_value& a, const as_value& b)
    {
        if (b.is_undefined()) return false;
        if (a.is_undefined()) return true;
        if (b.is_null()) return false;
        if (a.is_null()) return true;
        double aval = a.to_number();
        double bval = b.to_number();
        if (isNaN(bval)) return false;
        if (isNaN(aval)) return true;
        return aval > bval;
    }

    inline bool as_value_numEQ (const as_value& a, const as_value& b)
    {
        if (a.is_undefined() && b.is_undefined()) return true;
        if (a.is_null() && b.is_null()) return true;
        double aval = a.to_number();
        double bval = b.to_number();
        if (isNaN(aval) && isNaN(bval)) return true;
        return aval == bval;
    }

    bool operator() (const as_value& a, const as_value& b)
    {
        return str_cmp(a, b) < 0;
    }
};


struct as_value_gt : public as_value_lt
{
    as_value_gt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        return str_cmp(a, b) > 0;
    }
};


struct as_value_eq : public as_value_lt
{
    as_value_eq(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        return str_cmp(a, b) == 0;
    }
};


struct as_value_nocase_lt : public as_value_lt
{
    as_value_nocase_lt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        return str_nocase_cmp(a, b) < 0;
    }
};


struct as_value_nocase_gt : public as_value_lt
{
    as_value_nocase_gt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        return str_nocase_cmp(a, b) > 0;
    }
};


struct as_value_nocase_eq : public as_value_lt
{
    as_value_nocase_eq(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        return str_nocase_cmp(a, b) == 0;
    }
};


struct as_value_num_lt : public as_value_lt
{
    as_value_num_lt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        if (a.is_string() || b.is_string())
            return str_cmp(a, b) < 0;
        return as_value_numLT(a, b);
    }
};


struct as_value_num_gt : public as_value_lt
{
    as_value_num_gt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        if (a.is_string() || b.is_string())
            return str_cmp(a, b) > 0;
        return as_value_numGT(a, b);
    }
};


struct as_value_num_eq : public as_value_lt
{
    as_value_num_eq(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        if (a.is_string() || b.is_string())
            return str_cmp(a, b) == 0;
        return as_value_numEQ(a, b);
    }
};


struct as_value_num_nocase_lt : public as_value_lt
{
    as_value_num_nocase_lt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        if (a.is_string() || b.is_string())
            return str_nocase_cmp(a, b) < 0;
        return as_value_numLT(a, b);
    }
};


struct as_value_num_nocase_gt : public as_value_lt
{
    as_value_num_nocase_gt(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        if (a.is_string() || b.is_string())
            return str_nocase_cmp(a, b) > 0;
        return as_value_numGT(a, b);
    }
};


struct as_value_num_nocase_eq : public as_value_lt
{
    as_value_num_nocase_eq(int version) : as_value_lt(version) {}
    bool operator() (const as_value& a, const as_value& b)
    {
        if (a.is_string() || b.is_string())
            return str_nocase_cmp(a, b) == 0;
        return as_value_numEQ(a, b);
    }
};




as_cmp_fn
get_basic_cmp(boost::uint8_t flags, int version)
{
    as_cmp_fn f;


    ((flags^SORT_UNIQUE) ? static_cast<void> (0) : __assert_fail ("flags^SORT_UNIQUE", "asobj/Array_as.cpp", 501, __PRETTY_FUNCTION__));
    ((flags^SORT_RETURN_INDEX) ? static_cast<void> (0) : __assert_fail ("flags^SORT_RETURN_INDEX", "asobj/Array_as.cpp", 502, __PRETTY_FUNCTION__));

    switch ( flags )
    {
        case 0:
            f = as_value_lt(version);
            return f;

        case SORT_DESCENDING:
            f = as_value_gt(version);
            return f;

        case SORT_CASE_INSENSITIVE:
            f = as_value_nocase_lt(version);
            return f;

        case SORT_CASE_INSENSITIVE |
                SORT_DESCENDING:
            f = as_value_nocase_gt(version);
            return f;

        case SORT_NUMERIC:
            f = as_value_num_lt(version);
            return f;

        case SORT_NUMERIC | SORT_DESCENDING:
            f = as_value_num_gt(version);
            return f;

        case SORT_CASE_INSENSITIVE |
                SORT_NUMERIC:
            f = as_value_num_nocase_lt(version);
            return f;

        case SORT_CASE_INSENSITIVE |
                SORT_NUMERIC |
                SORT_DESCENDING:
            f = as_value_num_nocase_gt(version);
            return f;

        default:
            log_unimpl(gettext ("Unhandled sort flags: %d (0x%X)"), (int)flags, (int)flags);
            f = as_value_lt(version);
            return f;
    }
}




as_cmp_fn
get_basic_eq(boost::uint8_t flags, int version)
{
    as_cmp_fn f;
    flags &= ~(SORT_DESCENDING);

    switch ( flags )
    {
        case 0:
            f = as_value_eq(version);
            return f;

        case SORT_CASE_INSENSITIVE:
            f = as_value_nocase_eq(version);
            return f;

        case SORT_NUMERIC:
            f = as_value_num_eq(version);
            return f;

        case SORT_CASE_INSENSITIVE |
                SORT_NUMERIC:
            f = as_value_num_nocase_eq(version);
            return f;

        default:
            f = as_value_eq(version);
            return f;
    }
}


class as_value_custom
{
public:
    as_function& _comp;
    as_object* _object;
    bool (*_zeroCmp)(const int);
    const as_environment& _env;

    as_value_custom(as_function& comparator, bool (*zc)(const int),
            as_object* this_ptr, const as_environment& env)
        :
        _comp(comparator),
        _zeroCmp(zc),
        _env(env)
    {
        _object = this_ptr;
    }

    bool operator() (const as_value& a, const as_value& b)
    {
        as_value cmp_method(&_comp);
        as_value ret(0.0);
        fn_call::Args args;
        args += b, a;
        ret = invoke(cmp_method, _env, _object, args);

        return (*_zeroCmp)(toInt(ret));
    }
};


class as_value_prop
{
public:


    as_value_prop(string_table::key name, as_cmp_fn cmpfn, const as_object& o)
        :
        _comp(cmpfn),
        _prop(name),
        _obj(o)
    {
    }

    bool operator() (const as_value& a, const as_value& b)
    {
        as_value av, bv;


        boost::intrusive_ptr<as_object> ao = a.to_object(getGlobal(_obj));
        boost::intrusive_ptr<as_object> bo = b.to_object(getGlobal(_obj));

        ao->get_member(_prop, &av);
        bo->get_member(_prop, &bv);
        return _comp(av, bv);
    }
private:
    as_cmp_fn _comp;
    string_table::key _prop;
    const as_object& _obj;
};


class as_value_multiprop
{
public:
    typedef std::vector<as_cmp_fn> Comps;
    Comps& _cmps;

    typedef std::vector<string_table::key> Props;
    Props& _prps;

    const as_object& _obj;


    as_value_multiprop(std::vector<string_table::key>& prps,
        std::vector<as_cmp_fn>& cmps, const as_object& o)
        :
        _cmps(cmps),
        _prps(prps),
        _obj(o)
    {
    }

    bool operator() (const as_value& a, const as_value& b)
    {
        if (_cmps.empty()) return false;

        std::vector<as_cmp_fn>::iterator cmp = _cmps.begin();


        as_object* ao = a.to_object(getGlobal(_obj));
        as_object* bo = b.to_object(getGlobal(_obj));



        if (!ao || !bo) return false;

        for (Props::iterator pit = _prps.begin(), pend = _prps.end();
                pit != pend; ++pit, ++cmp) {
            as_value av, bv;

            ao->get_member(*pit, &av);
            bo->get_member(*pit, &bv);

            if ((*cmp)(av, bv)) return true;
            if ((*cmp)(bv, av)) return false;



        }

        return false;
    }
};

class as_value_multiprop_eq : public as_value_multiprop
{
public:
    as_value_multiprop_eq(std::vector<string_table::key>& prps,
        std::vector<as_cmp_fn>& cmps, const as_object& o)
        :
        as_value_multiprop(prps, cmps, o),
        _obj(o)
    {
    }

    bool operator() (const as_value& a, const as_value& b)
    {
        if ( _cmps.empty() ) return false;

        Comps::const_iterator cmp = _cmps.begin();


        as_object* ao = a.to_object(getGlobal(_obj));
        as_object* bo = b.to_object(getGlobal(_obj));

        for (Props::iterator pit = _prps.begin(), pend = _prps.end();
                pit != pend; ++pit, ++cmp)
        {
            as_value av, bv;
            ao->get_member(*pit, &av);
            bo->get_member(*pit, &bv);

            if ( !(*cmp)(av, bv) ) return false;
        }

        return true;
    }
private:
    const as_object& _obj;
};



inline boost::uint8_t
flag_preprocess(boost::uint8_t flgs, bool* douniq, bool* doindex)
{
    *douniq = (flgs & SORT_UNIQUE);
    *doindex = (flgs & SORT_RETURN_INDEX);
    flgs &= ~(SORT_RETURN_INDEX);
    flgs &= ~(SORT_UNIQUE);
    return flgs;
}


class GetKeys
{
public:
    GetKeys(std::vector<string_table::key>& v, string_table& st, int version)
        :
        _v(v),
        _st(st),
        _version(version)
    {}
    void operator()(const as_value& val) {
        _v.push_back(_st.find(val.to_string(_version)));
    }
private:
    std::vector<string_table::key>& _v;
    string_table& _st;
    const int _version;
};





class GetMultiFlags
{
public:
    GetMultiFlags(std::vector<boost::uint8_t>& v)
        :
        _v(v),
        _i(0),
        _uniq(false),
        _index(false)
    {}
    void operator()(const as_value& val) {

        if (!_i) {
            boost::uint8_t flag = static_cast<boost::uint8_t>(val.to_number());
            flag = flag_preprocess(flag, &_uniq, &_index);
            _v.push_back(flag);
            ++_i;
            return;
        }
        boost::uint8_t flag = static_cast<boost::uint8_t>(val.to_number());
        flag &= ~(SORT_RETURN_INDEX);
        flag &= ~(SORT_UNIQUE);
        _v.push_back(flag);
        ++_i;
    }
    bool unique() const { return _uniq; }
    bool index() const { return _index; }

private:
    std::vector<boost::uint8_t>& _v;
    size_t _i;
    bool _uniq;
    bool _index;
};

}

bool
IsStrictArray::accept(const ObjectURI& uri, const as_value& )
{

    if (isIndex(_st.value(getName(uri))) >= 0) return true;
    _strict = false;
    return false;
}

void
checkArrayLength(as_object& array, const ObjectURI& uri, const as_value& val)
{
    const string_table::key name = getName(uri);
    if (name == NSV::PROP_LENGTH) {
        resizeArray(array, toInt(val));
        return;
    }

    const int index = isIndex(getStringTable(array).value(name));


    if (index >= 0) {
        if (static_cast<size_t>(index) >= arrayLength(array)) {
            setArrayLength(array, index + 1);
        }
    }
}

size_t
arrayLength(as_object& array)
{
    as_value length;
    if (!array.get_member(NSV::PROP_LENGTH, &length)) return 0;

    const int size = toInt(length);
    if (size < 0) return 0;
    return size;
}

void
registerArrayNative(as_object& global)
{
    VM& vm = getVM(global);
    vm.registerNative(array_new, 252, 0);
    vm.registerNative(array_push, 252, 1);
    vm.registerNative(array_pop, 252, 2);
    vm.registerNative(array_concat, 252, 3);
    vm.registerNative(array_shift, 252, 4);
    vm.registerNative(array_unshift, 252, 5);
    vm.registerNative(array_slice, 252, 6);
    vm.registerNative(array_join, 252, 7);
    vm.registerNative(array_splice, 252, 8);
    vm.registerNative(array_toString, 252, 9);
    vm.registerNative(array_sort, 252, 10);
    vm.registerNative(array_reverse, 252, 11);
    vm.registerNative(array_sortOn, 252, 12);
}

void
array_class_init(as_object& where, const ObjectURI& uri)
{


    VM& vm = getVM(where);
    Global_as& gl = getGlobal(where);

    as_object* proto = gl.createObject();

    as_object* cl = vm.getNative(252, 0);

    cl->init_member(NSV::PROP_PROTOTYPE, proto);
    proto->init_member(NSV::PROP_CONSTRUCTOR, cl);

    attachArrayInterface(*proto);
    attachArrayStatics(*cl);

    const int flags = PropFlags::dontEnum;
    where.init_member(uri, cl, flags);
}


string_table::key
arrayKey(string_table& st, size_t i)
{
    return st.find(boost::lexical_cast<std::string>(i));
}

namespace {

void
attachArrayStatics(as_object& proto)
{
    int flags = 0;
    proto.init_member("CASEINSENSITIVE", SORT_CASE_INSENSITIVE, flags);
    proto.init_member("DESCENDING", SORT_DESCENDING, flags);
    proto.init_member("UNIQUESORT", SORT_UNIQUE, flags);
    proto.init_member("RETURNINDEXEDARRAY", SORT_RETURN_INDEX, flags);
    proto.init_member("NUMERIC", SORT_NUMERIC, flags);
}

void
attachArrayInterface(as_object& proto)
{
    VM& vm = getVM(proto);

    proto.init_member("push", vm.getNative(252, 1));
    proto.init_member("pop", vm.getNative(252, 2));
    proto.init_member("concat", vm.getNative(252, 3));
    proto.init_member("shift", vm.getNative(252, 4));
    proto.init_member("unshift", vm.getNative(252, 5));
    proto.init_member("slice", vm.getNative(252, 6));
    proto.init_member("join", vm.getNative(252, 7));
    proto.init_member("splice", vm.getNative(252, 8));
    proto.init_member("toString", vm.getNative(252, 9));
    proto.init_member("sort", vm.getNative(252, 10));
    proto.init_member("reverse", vm.getNative(252, 11));
    proto.init_member("sortOn", vm.getNative(252, 12));
}

as_value
array_splice(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    if (fn.nargs < 1) {
        { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror(gettext ("Array.splice() needs at least 1 argument, " "call ignored"));; } }


         ;
        return as_value();
    }

    const size_t size = arrayLength(*array);





    int start = toInt(fn.arg(0));
    if (start < 0) start = size + start;
    start = clamp<int>(start, 0, size);


    size_t remove = size - start;

    if (fn.nargs > 1) {
        int remval = toInt(fn.arg(1));
        if (remval < 0) {
            { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror(gettext ("Array.splice(%d,%d): negative length " "given, call ignored"), start, remval);; } }


             ;
            return as_value();
        }
        remove = clamp<int>(remval, 0, size - start);
    }

    Global_as& gl = getGlobal(fn);
    as_object* ret = gl.createArray();




    typedef std::vector<as_value> TempContainer;
    TempContainer v;
    PushToContainer<TempContainer> pv(v);
    foreachArray(*array, pv);

    const size_t newelements = fn.nargs > 2 ? fn.nargs - 2 : 0;


    for (size_t i = 0; i < remove; ++i) {
        const size_t key = getKey(fn, start + i);
        callMethod(ret, NSV::PROP_PUSH, array->getMember(key));
    }



    for (size_t i = 0; i < static_cast<size_t>(size - remove); ++i) {
        const bool started = (i >= static_cast<size_t>(start));
        const size_t index = started ? i + remove : i;
        const size_t target = started ? i + newelements : i;
        array->set_member(getKey(fn, target), v[index]);
    }


    for (size_t i = 0; i < newelements; ++i) {
        array->set_member(getKey(fn, start + i), fn.arg(i + 2));
    }


    array->set_member(NSV::PROP_LENGTH, size + newelements - remove);

    return as_value(ret);
}

as_value
array_sort(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    const int version = getSWFVersion(*array);

    if (!fn.nargs) {
        sort(*array, as_value_lt(version));
        return as_value(array);
    }

    if (fn.arg(0).is_undefined()) return as_value();

    boost::uint8_t flags = 0;

    if (fn.nargs == 1 && fn.arg(0).is_number()) {
        flags = static_cast<boost::uint8_t>(fn.arg(0).to_number());
    }
    else if (fn.arg(0).is_function()) {

        as_function* as_func = fn.arg(0).to_function();

        ((as_func) ? static_cast<void> (0) : __assert_fail ("as_func", "asobj/Array_as.cpp", 1028, __PRETTY_FUNCTION__));

        bool (*icmp)(int);

        if (fn.nargs == 2 && fn.arg(1).is_number()) {
            flags=static_cast<boost::uint8_t>(fn.arg(1).to_number());
        }

        if (flags & SORT_DESCENDING) icmp = &int_lt_or_eq;
        else icmp = &int_gt;

        const as_environment& env = fn.env();

        as_value_custom avc =
            as_value_custom(*as_func, icmp, fn.this_ptr, env);

        if ((flags & SORT_RETURN_INDEX)) {
            return sortIndexed(*array, avc);
        }

        sort(*array, avc);
        return as_value(array);


    }
    else
    {
        { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror(gettext ("Sort called with invalid arguments."));; } }


        return as_value(array);
    }

    bool do_unique, do_index;
    flags = flag_preprocess(flags, &do_unique, &do_index);
    as_cmp_fn comp = get_basic_cmp(flags, version);

    if (do_unique) {
        as_cmp_fn eq = get_basic_eq(flags, version);
        if (do_index) return sortIndexed(*array, comp, eq);
        return sort(*array, comp, eq) ? as_value(array) : as_value(0.0);
    }
    if (do_index) return sortIndexed(*array, comp);
    sort(*array, comp);
    return as_value(array);
}

as_value
array_sortOn(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    bool do_unique = false, do_index = false;
    boost::uint8_t flags = 0;

    const int version = getSWFVersion(fn);
    string_table& st = getStringTable(fn);

    if (fn.nargs == 0) return as_value();


    if (fn.arg(0).is_string())
    {
        string_table::key propField =
            st.find(fn.arg(0).to_string(version));

        if (fn.nargs > 1 && fn.arg(1).is_number()) {
            flags = static_cast<boost::uint8_t>(fn.arg(1).to_number());
            flags = flag_preprocess(flags, &do_unique, &do_index);
        }

        as_value_prop avc(propField, get_basic_cmp(flags, version),
                getGlobal(fn));

        if (do_unique) {
            as_value_prop ave(propField, get_basic_eq(flags, version),
                    getGlobal(fn));
            if (do_index)
                return sortIndexed(*array, avc, ave);
            return sort(*array, avc, ave) ? as_value(array) : as_value(0.0);
        }

        if (do_index) {
            return sortIndexed(*array, avc);
        }

        sort(*array, avc);
        return as_value(array);
    }


    if (fn.arg(0).is_object())
    {
        as_object* props = fn.arg(0).to_object(getGlobal(fn));
        ((props) ? static_cast<void> (0) : __assert_fail ("props", "asobj/Array_as.cpp", 1122, __PRETTY_FUNCTION__));

        std::vector<string_table::key> prp;
        GetKeys gk(prp, st, version);
        foreachArray(*props, gk);

        std::vector<as_cmp_fn> cmp;
        std::vector<as_cmp_fn> eq;


        const size_t optnum = prp.size();


        if (fn.nargs == 1) {

            as_cmp_fn c = get_basic_cmp(0, version);
            cmp.assign(optnum, c);
        }

        else if (fn.arg(1).is_object()) {

            as_object* farray = fn.arg(1).to_object(getGlobal(fn));


            if (farray->array() && arrayLength(*farray) == optnum) {

                std::vector<boost::uint8_t> flgs;
                GetMultiFlags mf(flgs);
                foreachArray(*farray, mf);
                do_unique = mf.unique();
                do_index = mf.index();

                std::vector<boost::uint8_t>::const_iterator it =
                    flgs.begin();

                while (it != flgs.end()) {
                    cmp.push_back(get_basic_cmp(*it++, version));
                }

                if (do_unique) {
                    it = flgs.begin();
                    while (it != flgs.end())
                        eq.push_back(get_basic_eq(*it++, version));
                }
            }
            else {
                as_cmp_fn c = get_basic_cmp(0, version);
                cmp.assign(optnum, c);
            }
        }

        else {
            boost::uint8_t flags =
                static_cast<boost::uint8_t>(toInt(fn.arg(1)));
            flags = flag_preprocess(flags, &do_unique, &do_index);
            as_cmp_fn c = get_basic_cmp(flags, version);

            cmp.assign(optnum, c);

            if (do_unique) {
                as_cmp_fn e = get_basic_eq(flags, version);
                eq.assign(optnum, e);
            }
        }
        as_value_multiprop avc(prp, cmp, getGlobal(fn));

        if (do_unique) {
            as_value_multiprop_eq ave(prp, eq, getGlobal(fn));
            if (do_index) return sortIndexed(*array, avc, ave);
            return sort(*array, avc, ave) ? as_value(array) : as_value(0.0);
        }
        if (do_index) return sortIndexed(*array, avc);
        sort(*array, avc);
        return as_value(array);

    }

    { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror(gettext ("SortOn called with invalid arguments."));; } }



    return as_value(array);
}


as_value
array_push(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    if (!fn.nargs) return as_value();

    const size_t shift = fn.nargs;

    const size_t size = arrayLength(*array);

    for (size_t i = 0; i < shift; ++i) {
        array->set_member(getKey(fn, size + i), fn.arg(i));
    }

    return as_value(size + shift);
}


as_value
array_unshift(const fn_call& fn)
{

    as_object* array = ensure<ValidThis>(fn);

    if (!fn.nargs) return as_value();

    const size_t shift = fn.nargs;

    const size_t size = arrayLength(*array);

    string_table& st = getStringTable(fn);
    as_value ret = array->getMember(st.find("0"));

    for (size_t i = size + shift - 1; i >= shift ; --i) {
        const string_table::key nextkey = getKey(fn, i - shift);
        const string_table::key currentkey = getKey(fn, i);
        array->delProperty(currentkey);
        array->set_member(currentkey, array->getMember(nextkey));
    }

    for (size_t i = shift; i > 0; --i) {
        const size_t index = i - 1;
        array->set_member(getKey(fn, index), fn.arg(index));
    }

    setArrayLength(*array, size + shift);

    return as_value(size + shift);
}


as_value
array_pop(const fn_call& fn)
{

    as_object* array = ensure<ValidThis>(fn);

    const size_t size = arrayLength(*array);
    if (size < 1) return as_value();

    const string_table::key ind = getKey(fn, size - 1);
    as_value ret = array->getMember(ind);
    array->delProperty(ind);

    setArrayLength(*array, size - 1);

    return ret;
}


as_value
array_shift(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    const size_t size = arrayLength(*array);

    if (size < 1) return as_value();

    as_value ret = array->getMember(getKey(fn, 0));

    for (size_t i = 0; i < static_cast<size_t>(size - 1); ++i) {
        const string_table::key nextkey = getKey(fn, i + 1);
        const string_table::key currentkey = getKey(fn, i);
        array->delProperty(currentkey);
        array->set_member(currentkey, array->getMember(nextkey));
    }

    setArrayLength(*array, size - 1);

    return ret;
}


as_value
array_reverse(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    const size_t size = arrayLength(*array);

    if (size < 2) return as_value();

    for (size_t i = 0; i < static_cast<size_t>(size) / 2; ++i) {
        const string_table::key bottomkey = getKey(fn, i);
        const string_table::key topkey = getKey(fn, size - i - 1);
        const as_value top = array->getMember(topkey);
        const as_value bottom = array->getMember(bottomkey);
        array->delProperty(topkey);
        array->delProperty(bottomkey);
        array->set_member(bottomkey, top);
        array->set_member(topkey, bottom);
    }

    return array;
}
as_value
array_join(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    const int version = getSWFVersion(fn);
    const std::string separator =
        fn.nargs ? fn.arg(0).to_string(version) : ",";

    return join(array, separator);
}


as_value
array_toString(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);
    return join(array, ",");
}






as_value
array_concat(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    Global_as& gl = getGlobal(fn);
    as_object* newarray = gl.createArray();

    PushToArray push(*newarray);
    foreachArray(*array, push);

    for (size_t i = 0; i < fn.nargs; ++i) {



        const as_value& arg = fn.arg(i);

        Global_as& gl = getGlobal(fn);
        as_object* other = arg.to_object(gl);

        if (other) {


            if (other->instanceOf(getClassConstructor(fn, "Array"))) {

                foreachArray(*other, push);
                continue;
            }
        }
        callMethod(newarray, NSV::PROP_PUSH, fn.arg(i));
    }

    return as_value(newarray);
}



as_value
array_slice(const fn_call& fn)
{
    as_object* array = ensure<ValidThis>(fn);

    if (fn.nargs > 2) {
        { if ( gnash::RcInitFile::getDefaultInstance().showASCodingErrors() ) { log_aserror(gettext ("More than 2 arguments to Array.slice, " "and I don't know what to do with them.  " "Ignoring them"));; } }



         ;
    }

    int startindex = fn.nargs ? toInt(fn.arg(0)) : 0;


    int endindex = fn.nargs > 1 ? toInt(fn.arg(1)) :
        std::numeric_limits<int>::max();

    Global_as& gl = getGlobal(fn);
    as_object* newarray = gl.createArray();

    PushToArray push(*newarray);

    foreachArray(*array, startindex, endindex, push);

    return as_value(newarray);
}

as_value
array_new(const fn_call& fn)
{

    as_object* ao = fn.isInstantiation() ? ensure<ValidThis>(fn) :
                                           getGlobal(fn).createArray();

    ao->setRelay(0);
    ao->setArray();

    ao->init_member(NSV::PROP_LENGTH, 0.0);

    if (fn.nargs == 0) {
        return as_value(ao);
    }

    if (fn.nargs == 1 && fn.arg(0).is_number()) {
        int newSize = toInt(fn.arg(0));
        if (newSize < 0) newSize = 0;
        else {
            ao->set_member(NSV::PROP_LENGTH, newSize);
        }
        return as_value(ao);
    }


    for (size_t i = 0; i < fn.nargs; i++) {
        callMethod(ao, NSV::PROP_PUSH, fn.arg(i));
    }


    return as_value(ao);
}

as_value
join(as_object* array, const std::string& separator)
{
    const size_t size = arrayLength(*array);
    as_value length;
    if (size < 1) return as_value("");

    std::string s;

    string_table& st = getStringTable(*array);
    const int version = getSWFVersion(*array);

    for (size_t i = 0; i < size; ++i) {
        std::ostringstream os;
        os << i;
        if (i) s += separator;
        as_value el;
        array->get_member(st.find(os.str()), &el);
        s += el.to_string(version);
    }
    return as_value(s);
}

string_table::key
getKey(const fn_call& fn, size_t i)
{
    string_table& st = getStringTable(fn);
    return arrayKey(st, i);
}

template<typename T>
void foreachArray(as_object& array, int start, int end, T& pred)
{
    const int size = arrayLength(array);
    if (!size) return;

    if (start < 0) start = size + start;
    if (start >= size) return;
    start = std::max(start, 0);

    if (end < 0) end = size + end;
    end = std::max(start, end);
    end = std::min<size_t>(end, size);

    ((start >= 0) ? static_cast<void> (0) : __assert_fail ("start >= 0", "asobj/Array_as.cpp", 1493, __PRETTY_FUNCTION__));
    ((end >= start) ? static_cast<void> (0) : __assert_fail ("end >= start", "asobj/Array_as.cpp", 1494, __PRETTY_FUNCTION__));
    ((size >= end) ? static_cast<void> (0) : __assert_fail ("size >= end", "asobj/Array_as.cpp", 1495, __PRETTY_FUNCTION__));

    string_table& st = getStringTable(array);

    for (size_t i = start; i < static_cast<size_t>(end); ++i) {
        pred(array.getMember(arrayKey(st, i)));
    }
}

void
pushIndices(as_object& o, const std::vector<indexed_as_value>& elems)
{
    for (std::vector<indexed_as_value>::const_iterator it = elems.begin();
        it != elems.end(); ++it) {
        callMethod(&o, NSV::PROP_PUSH, it->vec_index);
    }
}

void
getIndexedElements(as_object& array, std::vector<indexed_as_value>& v)
{
    PushToIndexedVector pv(v);
    foreachArray(array, pv);
}

void
resizeArray(as_object& o, const int size)
{

    size_t realSize = std::max(size, 0);

    const size_t currentSize = arrayLength(o);
    if (realSize < currentSize) {
        string_table& st = getStringTable(o);
        for (size_t i = realSize; i < currentSize; ++i) {
            o.delProperty(arrayKey(st, i));
        }
    }
}

void
setArrayLength(as_object& array, const int size)
{
    if (!array.array()) return;

    resizeArray(array, size);

    array.set_member(NSV::PROP_LENGTH, size);
}

int
isIndex(const std::string& nameString)
{
    try {
        return boost::lexical_cast<int>(nameString);
    }
    catch (boost::bad_lexical_cast& e) {
        return -1;
    }
}

}

}
