# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp"
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/netwerk/cache//"
# 1 "<command-line>"
# 1 "/builds/slave/try-l64-0000000000000000000000/build/config/gcc_hidden.h" 1





#pragma GCC visibility push(hidden)
# 1 "<command-line>" 2
# 1 "./../../mozilla-config.h" 1
# 1 "<command-line>" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp"






# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 1
# 22 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h"
# 1 "../../dist/system_wrappers/prlog.h" 1
       
# 2 "../../dist/system_wrappers/prlog.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlog.h" 1 3
# 9 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlog.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 1 3
# 26 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcpucfg.h" 1 3
# 27 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 2 3


# 1 "../../dist/system_wrappers/stddef.h" 1 3
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 150 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 213 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 423 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 30 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 2 3
# 206 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
extern "C" {
# 246 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef unsigned char PRUint8;
# 260 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef signed char PRInt8;
# 285 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef unsigned short PRUint16;
typedef short PRInt16;
# 310 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef unsigned int PRUint32;
typedef int PRInt32;
# 365 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef long PRInt64;
typedef unsigned long PRUint64;
# 410 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef int PRIntn;
typedef unsigned int PRUintn;
# 421 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef double PRFloat64;






typedef size_t PRSize;







typedef PRInt32 PROffset32;
typedef PRInt64 PROffset64;







typedef ptrdiff_t PRPtrdiff;
# 456 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef unsigned long PRUptrdiff;
# 467 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef PRIntn PRBool;
# 477 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef PRUint8 PRPackedBool;





typedef enum { PR_FAILURE = -1, PR_SUCCESS = 0 } PRStatus;






typedef PRUint16 PRUnichar;
# 509 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
typedef long PRWord;
typedef unsigned long PRUword;
# 562 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 3
}
# 10 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlog.h" 2 3

extern "C" {
# 106 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlog.h" 3
typedef enum PRLogModuleLevel {
    PR_LOG_NONE = 0,
    PR_LOG_ALWAYS = 1,
    PR_LOG_ERROR = 2,
    PR_LOG_WARNING = 3,
    PR_LOG_DEBUG = 4,

    PR_LOG_NOTICE = PR_LOG_DEBUG,
    PR_LOG_WARN = PR_LOG_WARNING,
    PR_LOG_MIN = PR_LOG_DEBUG,
    PR_LOG_MAX = PR_LOG_DEBUG
} PRLogModuleLevel;






typedef struct PRLogModuleInfo {
    const char *name;
    PRLogModuleLevel level;
    struct PRLogModuleInfo *next;
} PRLogModuleInfo;




extern __attribute__((visibility("default"))) PRLogModuleInfo* PR_NewLogModule(const char *name);





extern __attribute__((visibility("default"))) PRBool PR_SetLogFile(const char *name);





extern __attribute__((visibility("default"))) void PR_SetLogBuffering(PRIntn buffer_size);







extern __attribute__((visibility("default"))) void PR_LogPrint(const char *fmt, ...);




extern __attribute__((visibility("default"))) void PR_LogFlush(void);

extern __attribute__((visibility("default"))) void PR_Assert(const char *s, const char *file, PRIntn ln);
# 219 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlog.h" 3
}
# 4 "../../dist/system_wrappers/prlog.h" 2 3
#pragma GCC visibility pop
# 23 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 2
# 1 "../../dist/include/nsISupports.h" 1
# 10 "../../dist/include/nsISupports.h"
# 1 "../../dist/include/nsrootidl.h" 1
# 13 "../../dist/include/nsrootidl.h"
# 1 "../../dist/include/nscore.h" 1
# 14 "../../dist/include/nscore.h"
# 1 "../../dist/include/xpcom-config.h" 1
# 15 "../../dist/include/nscore.h" 2




# 1 "../../dist/include/mozilla/mozalloc.h" 1
# 15 "../../dist/include/mozilla/mozalloc.h"
# 1 "../../dist/system_wrappers/stdlib.h" 1
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/features.h" 1 3 4
# 361 "/usr/include/features.h" 3 4
# 1 "../../dist/system_wrappers/sys/cdefs.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/cdefs.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 365 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 366 "/usr/include/sys/cdefs.h" 2 3 4
# 4 "../../dist/system_wrappers/sys/cdefs.h" 2 3
#pragma GCC visibility pop
# 362 "/usr/include/features.h" 2 3 4
# 385 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 386 "/usr/include/features.h" 2 3 4
# 4 "../../dist/system_wrappers/features.h" 2 3
#pragma GCC visibility pop
# 26 "/usr/include/stdlib.h" 2 3 4







# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 65 "/usr/include/bits/waitstatus.h" 3 4
# 1 "../../dist/system_wrappers/endian.h" 1 3 4
       
# 2 "../../dist/system_wrappers/endian.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/endian.h" 1 3 4
# 22 "/usr/include/endian.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/endian.h" 2 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 4 "../../dist/system_wrappers/endian.h" 2 3
#pragma GCC visibility pop
# 66 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 236 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 237 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;





extern __inline __attribute__ ((__gnu_inline__)) double
atof (__const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
extern __inline __attribute__ ((__gnu_inline__)) int
atoi (__const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
atol (__const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
atoll (__const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "../../dist/system_wrappers/sys/types.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/types.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/types.h" 1 3 4
# 26 "/usr/include/sys/types.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/sys/types.h" 2 3 4

extern "C" {

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 31 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "../../dist/system_wrappers/time.h" 1 3 4
       
# 2 "../../dist/system_wrappers/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 4 "../../dist/system_wrappers/time.h" 2 3
#pragma GCC visibility pop
# 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 217 "/usr/include/sys/types.h" 3 4
# 1 "../../dist/system_wrappers/endian.h" 1 3 4
       
# 2 "../../dist/system_wrappers/endian.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 218 "/usr/include/sys/types.h" 2 3 4


# 1 "../../dist/system_wrappers/sys/select.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/select.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/select.h" 1 3 4
# 25 "/usr/include/sys/select.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 26 "/usr/include/sys/select.h" 2 3 4





# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "../../dist/system_wrappers/time.h" 1 3 4
       
# 2 "../../dist/system_wrappers/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 4 "../../dist/system_wrappers/time.h" 2 3
#pragma GCC visibility pop
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 75 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 4 "../../dist/system_wrappers/sys/select.h" 2 3
#pragma GCC visibility pop
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/sys/sysmacros.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/sys/sysmacros.h" 2 3 4





__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();


__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned long long int
gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 263 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 272 "/usr/include/sys/types.h" 2 3 4


}
# 4 "../../dist/system_wrappers/sys/types.h" 2 3
#pragma GCC visibility pop
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "../../dist/system_wrappers/alloca.h" 1 3 4
       
# 2 "../../dist/system_wrappers/alloca.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/alloca.h" 1 3 4
# 22 "/usr/include/alloca.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/alloca.h" 2 3 4


# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 4 "../../dist/system_wrappers/alloca.h" 2 3
#pragma GCC visibility pop
# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 964 "/usr/include/stdlib.h" 3 4
}
# 4 "../../dist/system_wrappers/stdlib.h" 2 3
#pragma GCC visibility pop
# 16 "../../dist/include/mozilla/mozalloc.h" 2
# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 35 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const void *
memchr (__const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 165 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strchr (__const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strrchr (__const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strpbrk (char *__s, __const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strpbrk (__const char *__s, __const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strstr (char *__haystack, __const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
strstr (__const char *__haystack, __const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
index (__const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
rindex (__const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 646 "/usr/include/string.h" 3 4
}
# 4 "../../dist/system_wrappers/string.h" 2 3
#pragma GCC visibility pop
# 17 "../../dist/include/mozilla/mozalloc.h" 2

# 1 "../../dist/stl_wrappers/new" 1
# 18 "../../dist/stl_wrappers/new"
       
# 19 "../../dist/stl_wrappers/new" 3
# 33 "../../dist/stl_wrappers/new" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/new" 1 3
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/new" 3
       
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/new" 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++config.h" 1 3
# 171 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 414 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++config.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/os_defines.h" 1 3
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/os_defines.h" 3
# 1 "../../dist/system_wrappers/features.h" 1 3
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/os_defines.h" 2 3
# 415 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/cpu_defines.h" 1 3
# 418 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/new" 2 3
# 1 "../../dist/system_wrappers/exception" 1 3
       
# 2 "../../dist/system_wrappers/exception" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 1 3
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 3
       
# 36 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 3

#pragma GCC visibility push(default)


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/atomic_lockfree_defines.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/atomic_lockfree_defines.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/atomic_lockfree_defines.h" 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 2 3

extern "C++" {

namespace std
{
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char* what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char* what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  void unexpected() __attribute__ ((__noreturn__));
# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 144 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/exception_ptr.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/exception_defines.h" 1 3
# 38 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/exception_ptr.h" 2 3





extern "C++" {

namespace std
{




  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 109 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 136 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    {
      if (true)
 {



 }
      if (false)
 {
   return current_exception();
 }
    }




  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    { return std::copy_exception<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 155 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/nested_exception.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 45 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) = default;

    nested_exception& operator=(const nested_exception&) = default;

    virtual ~nested_exception() noexcept;

    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }

    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };

  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };

  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));




  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception*)
    { throw __ex; }

  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }

  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));



  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }


  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }


}

}



#pragma GCC visibility pop
# 156 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/exception" 2 3
# 4 "../../dist/system_wrappers/exception" 2 3
#pragma GCC visibility pop
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 93 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 4 "../../dist/system_wrappers/new" 2 3
#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/new" 2 3





# 1 "../../dist/include/mozilla/mozalloc.h" 1 3
# 40 "../../dist/stl_wrappers/new" 2 3
# 54 "../../dist/stl_wrappers/new" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/new" 2 3
#pragma GCC visibility pop
# 66 "../../dist/stl_wrappers/new" 3
# 1 "../../dist/include/mozilla/throw_gcc.h" 1 3
# 11 "../../dist/include/mozilla/throw_gcc.h" 3
# 1 "../../dist/include/mozilla/Attributes.h" 1 3
# 11 "../../dist/include/mozilla/Attributes.h" 3
# 1 "../../dist/include/mozilla/Compiler.h" 1 3
# 12 "../../dist/include/mozilla/Attributes.h" 2 3
# 12 "../../dist/include/mozilla/throw_gcc.h" 2 3
# 1 "../../dist/include/mozilla/Util.h" 1 3
# 14 "../../dist/include/mozilla/Util.h" 3
# 1 "../../dist/include/mozilla/Assertions.h" 1 3
# 14 "../../dist/include/mozilla/Assertions.h" 3
# 1 "../../dist/system_wrappers/stddef.h" 1 3
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 15 "../../dist/include/mozilla/Assertions.h" 2 3
# 1 "../../dist/system_wrappers/stdio.h" 1 3
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 35 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "../../dist/system_wrappers/wchar.h" 1 3 4
       
# 2 "../../dist/system_wrappers/wchar.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 4 "../../dist/system_wrappers/wchar.h" 2 3
#pragma GCC visibility pop
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "../../dist/system_wrappers/stdarg.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stdarg.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stdarg.h" 1 3 4
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 4 "../../dist/system_wrappers/stdarg.h" 2 3
#pragma GCC visibility pop
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 552 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 109 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 161 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 162 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 204 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 226 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 251 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 261 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 294 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 416 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 467 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 526 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 554 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 565 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 598 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 644 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 660 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 721 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 732 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 768 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 787 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 810 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 849 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 868 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 929 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 36 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 930 "/usr/include/stdio.h" 2 3 4
# 938 "/usr/include/stdio.h" 3 4
}
# 4 "../../dist/system_wrappers/stdio.h" 2 3
#pragma GCC visibility pop
# 16 "../../dist/include/mozilla/Assertions.h" 2 3
# 1 "../../dist/system_wrappers/stdlib.h" 1 3
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 17 "../../dist/include/mozilla/Assertions.h" 2 3
# 34 "../../dist/include/mozilla/Assertions.h" 3
# 1 "../../dist/system_wrappers/signal.h" 1 3
       
# 2 "../../dist/system_wrappers/signal.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/signal.h" 1 3 4
# 29 "/usr/include/signal.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 30 "/usr/include/signal.h" 2 3 4

extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 104 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 118 "/usr/include/bits/sigset.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int __sigismember (__const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
extern __inline __attribute__ ((__gnu_inline__)) int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
extern __inline __attribute__ ((__gnu_inline__)) int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 76 "/usr/include/signal.h" 3 4
# 1 "../../dist/system_wrappers/time.h" 1 3 4
       
# 2 "../../dist/system_wrappers/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 4 "../../dist/system_wrappers/time.h" 2 3
#pragma GCC visibility pop
# 77 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 80 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 113 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     throw ();






extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();




extern int raise (int __sig) throw ();




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, __const char *__s);




extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
# 168 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 177 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 196 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 211 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 253 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     throw ();
# 310 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 334 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) throw ();



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 26 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/sigcontext.h" 2 3 4

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 109 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  unsigned long r8;
  unsigned long r9;
  unsigned long r10;
  unsigned long r11;
  unsigned long r12;
  unsigned long r13;
  unsigned long r14;
  unsigned long r15;
  unsigned long rdi;
  unsigned long rsi;
  unsigned long rbp;
  unsigned long rbx;
  unsigned long rdx;
  unsigned long rax;
  unsigned long rcx;
  unsigned long rsp;
  unsigned long rip;
  unsigned long eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  unsigned long err;
  unsigned long trapno;
  unsigned long oldmask;
  unsigned long cr2;
  struct _fpstate * fpstate;
  unsigned long __reserved1 [8];
};
# 340 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();






# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 350 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 357 "/usr/include/signal.h" 2 3 4


# 1 "../../dist/system_wrappers/sys/ucontext.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/ucontext.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 22 "/usr/include/sys/ucontext.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/sys/ucontext.h" 2 3 4
# 1 "../../dist/system_wrappers/signal.h" 1 3 4
       
# 2 "../../dist/system_wrappers/signal.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/signal.h" 1 3 4
# 4 "../../dist/system_wrappers/signal.h" 2 3
#pragma GCC visibility pop
# 24 "/usr/include/sys/ucontext.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/sys/ucontext.h" 2 3 4
# 33 "/usr/include/sys/ucontext.h" 3 4
typedef long int greg_t;





typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    unsigned long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 4 "../../dist/system_wrappers/sys/ucontext.h" 2 3
#pragma GCC visibility pop
# 360 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) throw ();







extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();
# 396 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();



}
# 4 "../../dist/system_wrappers/signal.h" 2 3
#pragma GCC visibility pop
# 35 "../../dist/include/mozilla/Assertions.h" 2 3
# 131 "../../dist/include/mozilla/Assertions.h" 3
extern "C" {
# 199 "../../dist/include/mozilla/Assertions.h" 3
static __attribute__((always_inline)) inline void
MOZ_ReportAssertionFailure(const char* s, const char* file, int ln)
{




  fprintf(stderr, "Assertion failure: %s, at %s:%d\n", s, file, ln);
  fflush(stderr);

}


}
# 15 "../../dist/include/mozilla/Util.h" 2 3

# 1 "../../dist/include/mozilla/Types.h" 1 3
# 22 "../../dist/include/mozilla/Types.h" 3
# 1 "../../dist/include/mozilla/StandardInteger.h" 1 3
# 40 "../../dist/include/mozilla/StandardInteger.h" 3
# 1 "../../dist/system_wrappers/stdint.h" 1 3
       
# 2 "../../dist/system_wrappers/stdint.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stdint.h" 1 3 4


# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 66 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 91 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 104 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 120 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 135 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 4 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stdint.h" 2 3 4
# 4 "../../dist/system_wrappers/stdint.h" 2 3
#pragma GCC visibility pop
# 41 "../../dist/include/mozilla/StandardInteger.h" 2 3
# 23 "../../dist/include/mozilla/Types.h" 2 3


# 1 "../../dist/system_wrappers/stddef.h" 1 3
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 26 "../../dist/include/mozilla/Types.h" 2 3
# 17 "../../dist/include/mozilla/Util.h" 2 3



namespace mozilla {





template<class T>
class AlignmentFinder
{
    struct Aligner
    {
        char c;
        T t;
    };

  public:
    static const size_t alignment = sizeof(Aligner) - sizeof(T);
};
# 68 "../../dist/include/mozilla/Util.h" 3
template<size_t align>
struct AlignedElem;






template<>
struct AlignedElem<1>
{
    uint8_t elem __attribute__((aligned(1)));
};

template<>
struct AlignedElem<2>
{
    uint8_t elem __attribute__((aligned(2)));
};

template<>
struct AlignedElem<4>
{
    uint8_t elem __attribute__((aligned(4)));
};

template<>
struct AlignedElem<8>
{
    uint8_t elem __attribute__((aligned(8)));
};

template<>
struct AlignedElem<16>
{
    uint8_t elem __attribute__((aligned(16)));
};
# 116 "../../dist/include/mozilla/Util.h" 3
template<size_t nbytes>
struct AlignedStorage
{
    union U {
      char bytes[nbytes];
      uint64_t _;
    } u;

    const void* addr() const { return u.bytes; }
    void* addr() { return u.bytes; }
};

template<class T>
struct AlignedStorage2
{
    union U {
      char bytes[sizeof(T)];
      uint64_t _;
    } u;

    const T* addr() const { return reinterpret_cast<const T*>(u.bytes); }
    T* addr() { return static_cast<T*>(static_cast<void*>(u.bytes)); }
};
# 151 "../../dist/include/mozilla/Util.h" 3
template<class T>
class Maybe
{
    AlignedStorage2<T> storage;
    bool constructed;

    T& asT() { return *storage.addr(); }

  public:
    Maybe() { constructed = false; }
    ~Maybe() { if (constructed) asT().~T(); }

    bool empty() const { return !constructed; }

    void construct() {
      do { } while(0);
      ::new (storage.addr()) T();
      constructed = true;
    }

    template<class T1>
    void construct(const T1& t1) {
      do { } while(0);
      ::new (storage.addr()) T(t1);
      constructed = true;
    }

    template<class T1, class T2>
    void construct(const T1& t1, const T2& t2) {
      do { } while(0);
      ::new (storage.addr()) T(t1, t2);
      constructed = true;
    }

    template<class T1, class T2, class T3>
    void construct(const T1& t1, const T2& t2, const T3& t3) {
      do { } while(0);
      ::new (storage.addr()) T(t1, t2, t3);
      constructed = true;
    }

    template<class T1, class T2, class T3, class T4>
    void construct(const T1& t1, const T2& t2, const T3& t3, const T4& t4) {
      do { } while(0);
      ::new (storage.addr()) T(t1, t2, t3, t4);
      constructed = true;
    }

    T* addr() {
      do { } while(0);
      return &asT();
    }

    T& ref() {
      do { } while(0);
      return asT();
    }

    const T& ref() const {
      do { } while(0);
      return const_cast<Maybe*>(this)->asT();
    }

    void destroy() {
      ref().~T();
      constructed = false;
    }

    void destroyIfConstructed() {
      if (!empty())
        destroy();
    }

  private:
    Maybe(const Maybe& other) = delete;
    const Maybe& operator=(const Maybe& other) = delete;
};







template<class T>
__attribute__((always_inline)) inline size_t
PointerRangeSize(T* begin, T* end)
{
  do { } while(0);
  return (size_t(end) - size_t(begin)) / sizeof(T);
}







template<typename T, size_t N>
constexpr size_t
ArrayLength(T (&arr)[N])
{
  return N;
}






template<typename T, size_t N>
constexpr T*
ArrayEnd(T (&arr)[N])
{
  return arr + ArrayLength(arr);
}

}
# 13 "../../dist/include/mozilla/throw_gcc.h" 2 3

# 1 "../../dist/system_wrappers/stdio.h" 1 3
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 15 "../../dist/include/mozilla/throw_gcc.h" 2 3
# 1 "../../dist/system_wrappers/string.h" 1 3
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 16 "../../dist/include/mozilla/throw_gcc.h" 2 3





# 1 "../../dist/include/mozilla/mozalloc_abort.h" 1 3
# 33 "../../dist/include/mozilla/mozalloc_abort.h" 3
__attribute__ ((visibility ("default")))

  __attribute__((noreturn))

  void mozalloc_abort(const char* const msg);
# 22 "../../dist/include/mozilla/throw_gcc.h" 2 3

namespace std {





__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_bad_exception(void)
{
    mozalloc_abort("fatal: STL threw bad_exception");
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_bad_alloc(void)
{
    mozalloc_abort("fatal: STL threw bad_alloc");
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_bad_cast(void)
{
    mozalloc_abort("fatal: STL threw bad_cast");
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_bad_typeid(void)
{
    mozalloc_abort("fatal: STL threw bad_typeid");
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_logic_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_domain_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_invalid_argument(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_length_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_out_of_range(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_runtime_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_range_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_overflow_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_underflow_error(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_ios_failure(const char* msg)
{
    mozalloc_abort(msg);
}

__attribute__((noreturn)) __attribute__((always_inline)) inline void
__throw_system_error(int err)
{
    char error[128];
    snprintf(error, sizeof(error)-1,
             "fatal: STL threw system_error: %s (%d)", strerror(err), err);
    mozalloc_abort(error);
}

}
# 67 "../../dist/stl_wrappers/new" 2 3
# 19 "../../dist/include/mozilla/mozalloc.h" 2

# 1 "../../dist/include/xpcom-config.h" 1
# 21 "../../dist/include/mozilla/mozalloc.h" 2


# 1 "../../dist/include/mozilla/fallible.h" 1







namespace mozilla {

struct fallible_t { };

}
# 24 "../../dist/include/mozilla/mozalloc.h" 2
# 60 "../../dist/include/mozilla/mozalloc.h"
extern "C" {
# 77 "../../dist/include/mozilla/mozalloc.h"
__attribute__ ((visibility ("default")))
void moz_free(void* ptr);

__attribute__ ((visibility ("default"))) void* moz_xmalloc(size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default")))
void* moz_malloc(size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));


__attribute__ ((visibility ("default"))) void* moz_xcalloc(size_t nmemb, size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) void* moz_calloc(size_t nmemb, size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));


__attribute__ ((visibility ("default"))) void* moz_xrealloc(void* ptr, size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) void* moz_realloc(void* ptr, size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));


__attribute__ ((visibility ("default"))) char* moz_xstrdup(const char* str)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) char* moz_strdup(const char* str)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) size_t moz_malloc_usable_size(void *ptr);

__attribute__ ((visibility ("default"))) size_t moz_malloc_size_of(const void *ptr);


__attribute__ ((visibility ("default"))) char* moz_xstrndup(const char* str, size_t strsize)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) char* moz_strndup(const char* str, size_t strsize)
    __attribute__((malloc)) __attribute__((warn_unused_result));




__attribute__ ((visibility ("default"))) int moz_xposix_memalign(void **ptr, size_t alignment, size_t size)
    __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) int moz_posix_memalign(void **ptr, size_t alignment, size_t size)
    __attribute__((warn_unused_result));




__attribute__ ((visibility ("default"))) void* moz_xmemalign(size_t boundary, size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) void* moz_memalign(size_t boundary, size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));




__attribute__ ((visibility ("default"))) void* moz_xvalloc(size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));

__attribute__ ((visibility ("default"))) void* moz_valloc(size_t size)
    __attribute__((malloc)) __attribute__((warn_unused_result));




}
# 198 "../../dist/include/mozilla/mozalloc.h"
 __attribute__((always_inline)) inline
void* operator new(size_t size) throw(std::bad_alloc)
{
    return moz_xmalloc(size);
}

 __attribute__((always_inline)) inline
void* operator new(size_t size, const std::nothrow_t&) throw()
{
    return moz_malloc(size);
}

 __attribute__((always_inline)) inline
void* operator new[](size_t size) throw(std::bad_alloc)
{
    return moz_xmalloc(size);
}

 __attribute__((always_inline)) inline
void* operator new[](size_t size, const std::nothrow_t&) throw()
{
    return moz_malloc(size);
}

 __attribute__((always_inline)) inline
void operator delete(void* ptr) throw()
{
    return moz_free(ptr);
}

 __attribute__((always_inline)) inline
void operator delete(void* ptr, const std::nothrow_t&) throw()
{
    return moz_free(ptr);
}

 __attribute__((always_inline)) inline
void operator delete[](void* ptr) throw()
{
    return moz_free(ptr);
}

 __attribute__((always_inline)) inline
void operator delete[](void* ptr, const std::nothrow_t&) throw()
{
    return moz_free(ptr);
}
# 266 "../../dist/include/mozilla/mozalloc.h"
__attribute__((always_inline)) inline
void* operator new(size_t size, const mozilla::fallible_t&) throw()
{
    return moz_malloc(size);
}

__attribute__((always_inline)) inline
void* operator new[](size_t size, const mozilla::fallible_t&) throw()
{
    return moz_malloc(size);
}

__attribute__((always_inline)) inline
void operator delete(void* ptr, const mozilla::fallible_t&) throw()
{
    moz_free(ptr);
}

__attribute__((always_inline)) inline
void operator delete[](void* ptr, const mozilla::fallible_t&) throw()
{
    moz_free(ptr);
}
# 20 "../../dist/include/nscore.h" 2
# 1 "../../dist/include/mozilla/mozalloc_macro_wrappers.h" 1
# 21 "../../dist/include/nscore.h" 2





# 1 "../../dist/include/mozilla/StandardInteger.h" 1
# 27 "../../dist/include/nscore.h" 2
# 1 "../../dist/system_wrappers/stddef.h" 1
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 28 "../../dist/include/nscore.h" 2

# 1 "../../dist/include/mozilla/NullPtr.h" 1
# 30 "../../dist/include/nscore.h" 2





typedef size_t(*nsMallocSizeOfFun)(const void *p);
# 312 "../../dist/include/nscore.h"
# 1 "../../dist/include/nsError.h" 1
# 9 "../../dist/include/nsError.h"
# 1 "../../dist/include/mozilla/Likely.h" 1
# 10 "../../dist/include/nsError.h" 2

# 1 "../../dist/include/mozilla/TypedEnum.h" 1
# 12 "../../dist/include/nsError.h" 2
# 121 "../../dist/include/nsError.h"
  typedef enum class tag_nsresult : uint32_t
  {


# 1 "../../dist/include/ErrorList.h" 1


  NS_OK = 0,




  NS_ERROR_BASE = 0xC1F30000,

  NS_ERROR_NOT_INITIALIZED = NS_ERROR_BASE + 1,

  NS_ERROR_ALREADY_INITIALIZED = NS_ERROR_BASE + 2,

  NS_ERROR_NOT_IMPLEMENTED = 0x80004001,

  NS_NOINTERFACE = 0x80004002,
  NS_ERROR_NO_INTERFACE = NS_NOINTERFACE,
  NS_ERROR_INVALID_POINTER = 0x80004003,
  NS_ERROR_NULL_POINTER = NS_ERROR_INVALID_POINTER,

  NS_ERROR_ABORT = 0x80004004,

  NS_ERROR_FAILURE = 0x80004005,

  NS_ERROR_UNEXPECTED = 0x8000ffff,

  NS_ERROR_OUT_OF_MEMORY = 0x8007000e,

  NS_ERROR_ILLEGAL_VALUE = 0x80070057,
  NS_ERROR_INVALID_ARG = NS_ERROR_ILLEGAL_VALUE,

  NS_ERROR_NO_AGGREGATION = 0x80040110,

  NS_ERROR_NOT_AVAILABLE = 0x80040111,

  NS_ERROR_FACTORY_NOT_REGISTERED = 0x80040154,

  NS_ERROR_FACTORY_REGISTER_AGAIN = 0x80040155,

  NS_ERROR_FACTORY_NOT_LOADED = 0x800401f8,

  NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = NS_ERROR_BASE + 0x101,

  NS_ERROR_FACTORY_EXISTS = NS_ERROR_BASE + 0x100,







  NS_ERROR_CANNOT_CONVERT_DATA = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_OBJECT_IS_IMMUTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(3),

  NS_ERROR_NOT_SAME_THREAD = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(4),


  NS_ERROR_ILLEGAL_DURING_SHUTDOWN = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_SERVICE_NOT_AVAILABLE = ((uint32_t)(1) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(22),

  NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(1),

  NS_SUCCESS_INTERRUPTED_TRAVERSE = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(2),

  NS_ERROR_SERVICE_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(22),

  NS_ERROR_SERVICE_IN_USE = ((uint32_t)(0) << 31) | ((uint32_t)(1 + 0x45) << 16) | (uint32_t)(23),
# 79 "../../dist/include/ErrorList.h"
  NS_BASE_STREAM_CLOSED = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(2),

  NS_BASE_STREAM_OSERROR = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(3),

  NS_BASE_STREAM_ILLEGAL_ARGS = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(4),

  NS_BASE_STREAM_NO_CONVERTER = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(5),

  NS_BASE_STREAM_BAD_CONVERSION = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(6),
  NS_BASE_STREAM_WOULD_BLOCK = ((uint32_t)(1) << 31) | ((uint32_t)(2 + 0x45) << 16) | (uint32_t)(7),
# 97 "../../dist/include/ErrorList.h"
  NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(1),

  NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(2),

  NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(3),

  NS_ERROR_GFX_PRINTER_STARTDOC = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(4),

  NS_ERROR_GFX_PRINTER_ENDDOC = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(5),

  NS_ERROR_GFX_PRINTER_STARTPAGE = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(6),

  NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(7),

  NS_ERROR_GFX_PRINTER_NO_XUL = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(8),


  NS_ERROR_GFX_CMAP_MALFORMED = ((uint32_t)(1) << 31) | ((uint32_t)(3 + 0x45) << 16) | (uint32_t)(51),
# 131 "../../dist/include/ErrorList.h"
  NS_BINDING_SUCCEEDED = NS_OK,


  NS_BINDING_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(1),

  NS_BINDING_ABORTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(2),





  NS_BINDING_REDIRECTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(3),





  NS_BINDING_RETARGETED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(4),





  NS_ERROR_MALFORMED_URI = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(10),



  NS_ERROR_IN_PROGRESS = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(15),




  NS_ERROR_NO_CONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(17),

  NS_ERROR_UNKNOWN_PROTOCOL = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(18),


  NS_ERROR_INVALID_CONTENT_ENCODING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(27),



  NS_ERROR_CORRUPTED_CONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(29),



  NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(34),


  NS_ERROR_ALREADY_OPENED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(73),




  NS_ERROR_ALREADY_CONNECTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(11),

  NS_ERROR_NOT_CONNECTED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(12),


  NS_ERROR_CONNECTION_REFUSED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(13),

  NS_ERROR_NET_TIMEOUT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(14),


  NS_ERROR_OFFLINE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(16),



  NS_ERROR_PORT_ACCESS_NOT_ALLOWED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(19),

  NS_ERROR_NET_RESET = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(20),

  NS_ERROR_NET_INTERRUPT = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(71),

  NS_ERROR_PROXY_CONNECTION_REFUSED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(72),





  NS_ERROR_NOT_RESUMABLE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(25),

  NS_ERROR_REDIRECT_LOOP = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(31),


  NS_ERROR_ENTITY_CHANGED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(32),



  NS_ERROR_UNSAFE_CONTENT_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(74),


  NS_ERROR_REMOTE_XUL = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(75),




  NS_ERROR_FTP_LOGIN = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_FTP_CWD = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_FTP_PASV = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_FTP_PWD = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_FTP_LIST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(28),





  NS_ERROR_UNKNOWN_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(30),


  NS_ERROR_DNS_LOOKUP_QUEUE_FULL = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(33),



  NS_ERROR_UNKNOWN_PROXY_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(42),





  NS_ERROR_UNKNOWN_SOCKET_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(51),

  NS_ERROR_SOCKET_CREATE_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(52),



  NS_ERROR_CACHE_KEY_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(61),
  NS_ERROR_CACHE_DATA_IS_STREAM = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(62),
  NS_ERROR_CACHE_DATA_IS_NOT_STREAM = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(63),
  NS_ERROR_CACHE_WAIT_FOR_VALIDATION = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(64),
  NS_ERROR_CACHE_ENTRY_DOOMED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(65),
  NS_ERROR_CACHE_READ_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(66),
  NS_ERROR_CACHE_WRITE_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(67),
  NS_ERROR_CACHE_IN_USE = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(68),


  NS_ERROR_DOCUMENT_NOT_CACHED = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(70),





  NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(80),

  NS_ERROR_HOST_IS_IP_ADDRESS = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(81),







  NS_SUCCESS_ADOPTED_DATA = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(90),


  NS_NET_STATUS_BEGIN_FTP_TRANSACTION = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(27),
  NS_NET_STATUS_END_FTP_TRANSACTION = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(28),




  NS_SUCCESS_AUTH_FINISHED = ((uint32_t)(0) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(40),




  NS_NET_STATUS_READING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(8),
  NS_NET_STATUS_WRITING = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(9),


  NS_NET_STATUS_RESOLVING_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(3),
  NS_NET_STATUS_RESOLVED_HOST = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(11),
  NS_NET_STATUS_CONNECTING_TO = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(7),
  NS_NET_STATUS_CONNECTED_TO = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(4),
  NS_NET_STATUS_SENDING_TO = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(5),
  NS_NET_STATUS_WAITING_FOR = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(10),
  NS_NET_STATUS_RECEIVING_FROM = ((uint32_t)(1) << 31) | ((uint32_t)(6 + 0x45) << 16) | (uint32_t)(6),







  NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1000),
  NS_ERROR_PLUGIN_DISABLED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1001),
  NS_ERROR_PLUGIN_BLOCKLISTED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1002),
  NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1003),
  NS_ERROR_PLUGIN_CLICKTOPLAY = ((uint32_t)(1) << 31) | ((uint32_t)(7 + 0x45) << 16) | (uint32_t)(1004),
# 327 "../../dist/include/ErrorList.h"
  NS_TABLELAYOUT_CELL_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(8 + 0x45) << 16) | (uint32_t)(0),

  NS_POSITION_BEFORE_TABLE = ((uint32_t)(0) << 31) | ((uint32_t)(8 + 0x45) << 16) | (uint32_t)(3),


  NS_STATE_PROPERTY_EXISTS = NS_OK,

  NS_STATE_PROPERTY_NOT_THERE = ((uint32_t)(0) << 31) | ((uint32_t)(8 + 0x45) << 16) | (uint32_t)(5),







  NS_ERROR_HTMLPARSER_CONTINUE = NS_OK,

  NS_ERROR_HTMLPARSER_EOF = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1000),
  NS_ERROR_HTMLPARSER_UNKNOWN = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1001),
  NS_ERROR_HTMLPARSER_CANTPROPAGATE = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1002),
  NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1003),
  NS_ERROR_HTMLPARSER_BADFILENAME = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1004),
  NS_ERROR_HTMLPARSER_BADURL = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1005),
  NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1006),
  NS_ERROR_HTMLPARSER_INTERRUPTED = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1007),
  NS_ERROR_HTMLPARSER_BLOCK = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1008),
  NS_ERROR_HTMLPARSER_BADTOKENIZER = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1009),
  NS_ERROR_HTMLPARSER_BADATTRIBUTE = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1010),
  NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1011),
  NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1012),
  NS_ERROR_HTMLPARSER_BADDTD = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1013),
  NS_ERROR_HTMLPARSER_BADCONTEXT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1014),
  NS_ERROR_HTMLPARSER_STOPPARSING = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1015),
  NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1016),
  NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1017),
  NS_ERROR_HTMLPARSER_FAKE_ENDTAG = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1018),
  NS_ERROR_HTMLPARSER_INVALID_COMMENT = ((uint32_t)(1) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(1019),

  NS_HTMLTOKENS_NOT_AN_ENTITY = ((uint32_t)(0) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(2000),
  NS_HTMLPARSER_VALID_META_CHARSET = ((uint32_t)(0) << 31) | ((uint32_t)(9 + 0x45) << 16) | (uint32_t)(3000),
# 376 "../../dist/include/ErrorList.h"
  NS_RDF_ASSERTION_ACCEPTED = NS_OK,


  NS_RDF_CURSOR_EMPTY = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(1),


  NS_RDF_NO_VALUE = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(2),



  NS_RDF_ASSERTION_REJECTED = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(3),

  NS_RDF_STOP_VISIT = ((uint32_t)(0) << 31) | ((uint32_t)(10 + 0x45) << 16) | (uint32_t)(4),







  NS_ERROR_UCONV_NOCONV = ((uint32_t)(1) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_UDEC_ILLEGALINPUT = ((uint32_t)(1) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(14),

  NS_SUCCESS_USING_FALLBACK_LOCALE = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(2),
  NS_OK_UDEC_EXACTLENGTH = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(11),
  NS_OK_UDEC_MOREINPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(12),
  NS_OK_UDEC_MOREOUTPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(13),
  NS_OK_UDEC_NOBOMFOUND = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(14),
  NS_OK_UENC_EXACTLENGTH = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(33),
  NS_OK_UENC_MOREOUTPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(34),
  NS_ERROR_UENC_NOMAPPING = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(35),
  NS_OK_UENC_MOREINPUT = ((uint32_t)(0) << 31) | ((uint32_t)(11 + 0x45) << 16) | (uint32_t)(36),


  NS_EXACT_LENGTH = NS_OK_UDEC_EXACTLENGTH,
  NS_PARTIAL_MORE_INPUT = NS_OK_UDEC_MOREINPUT,
  NS_PARTIAL_MORE_OUTPUT = NS_OK_UDEC_MOREOUTPUT,
  NS_ERROR_ILLEGAL_INPUT = NS_ERROR_UDEC_ILLEGALINPUT,
# 422 "../../dist/include/ErrorList.h"
  NS_ERROR_FILE_UNRECOGNIZED_PATH = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_FILE_EXECUTION_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_FILE_UNKNOWN_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_FILE_DESTINATION_NOT_DIR = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_FILE_COPY_OR_MOVE_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_FILE_ALREADY_EXISTS = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_FILE_INVALID_PATH = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_FILE_DISK_FULL = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_FILE_CORRUPTED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_FILE_NOT_DIRECTORY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_FILE_IS_DIRECTORY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_FILE_IS_LOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_FILE_TOO_BIG = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_FILE_NO_DEVICE_SPACE = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(16),
  NS_ERROR_FILE_NAME_TOO_LONG = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_FILE_NOT_FOUND = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_FILE_READ_ONLY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_FILE_DIR_NOT_EMPTY = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_FILE_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(21),

  NS_SUCCESS_FILE_DIRECTORY_EMPTY = ((uint32_t)(0) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(1),

  NS_SUCCESS_AGGREGATE_RESULT = ((uint32_t)(0) << 31) | ((uint32_t)(13 + 0x45) << 16) | (uint32_t)(2),
# 458 "../../dist/include/ErrorList.h"
  NS_ERROR_DOM_INDEX_SIZE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_WRONG_DOCUMENT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_INVALID_CHARACTER_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_DOM_NOT_FOUND_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_DOM_NOT_SUPPORTED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_DOM_INVALID_STATE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_DOM_SYNTAX_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_DOM_INVALID_MODIFICATION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_DOM_NAMESPACE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_DOM_INVALID_ACCESS_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_DOM_TYPE_MISMATCH_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_DOM_SECURITY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_DOM_NETWORK_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_DOM_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_DOM_URL_MISMATCH_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_DOM_TIMEOUT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_DOM_DATA_CLONE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(25),

  NS_ERROR_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(26),
  NS_ERROR_RANGE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(27),

  NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(28),
  NS_ERROR_DOM_ENCODING_NOT_UTF_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(29),
  NS_ERROR_DOM_ENCODING_DECODE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(30),

  NS_ERROR_DOM_SECMAN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1001),
  NS_ERROR_DOM_WRONG_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1002),
  NS_ERROR_DOM_NOT_OBJECT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1003),
  NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1004),
  NS_ERROR_DOM_NOT_NUMBER_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1005),
  NS_ERROR_DOM_NOT_BOOLEAN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1006),
  NS_ERROR_DOM_NOT_FUNCTION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1007),
  NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1008),
  NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1009),
  NS_ERROR_DOM_PROP_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1010),
  NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1011),
  NS_ERROR_DOM_BAD_URI = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1012),
  NS_ERROR_DOM_RETVAL_UNDEFINED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1013),
  NS_ERROR_DOM_QUOTA_REACHED = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1014),
  NS_ERROR_DOM_JS_EXCEPTION = ((uint32_t)(1) << 31) | ((uint32_t)(14 + 0x45) << 16) | (uint32_t)(1015),







  NS_IMAGELIB_SUCCESS_LOAD_FINISHED = ((uint32_t)(0) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(0),
  NS_IMAGELIB_CHANGING_OWNER = ((uint32_t)(0) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(1),

  NS_IMAGELIB_ERROR_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(5),
  NS_IMAGELIB_ERROR_NO_DECODER = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(6),
  NS_IMAGELIB_ERROR_NOT_FINISHED = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(7),
  NS_IMAGELIB_ERROR_NO_ENCODER = ((uint32_t)(1) << 31) | ((uint32_t)(15 + 0x45) << 16) | (uint32_t)(9),







  NS_ERROR_EDITOR_NO_SELECTION = ((uint32_t)(1) << 31) | ((uint32_t)(17 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_EDITOR_NO_TEXTNODE = ((uint32_t)(1) << 31) | ((uint32_t)(17 + 0x45) << 16) | (uint32_t)(2),
  NS_FOUND_TARGET = ((uint32_t)(1) << 31) | ((uint32_t)(17 + 0x45) << 16) | (uint32_t)(3),

  NS_EDITOR_ELEMENT_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(17 + 0x45) << 16) | (uint32_t)(1),







  NS_ERROR_XPC_NOT_ENOUGH_ARGS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_XPC_NEED_OUT_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_XPC_CANT_SET_OUT_VAL = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_XPC_CANT_GET_METHOD_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_XPC_UNEXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_XPC_BAD_CONVERT_JS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_XPC_BAD_CONVERT_NATIVE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_XPC_CANT_WATCH_WN_STATIC = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(16),
  NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_XPC_CI_RETURNED_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_XPC_GS_RETURNED_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_XPC_BAD_CID = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_XPC_BAD_IID = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_XPC_CANT_CREATE_WN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(25),
  NS_ERROR_XPC_JS_THREW_EXCEPTION = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(26),
  NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(27),
  NS_ERROR_XPC_JS_THREW_JS_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(28),
  NS_ERROR_XPC_JS_THREW_NULL = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(29),
  NS_ERROR_XPC_JS_THREW_STRING = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_XPC_JS_THREW_NUMBER = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(31),
  NS_ERROR_XPC_JAVASCRIPT_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(32),
  NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(33),
  NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(34),
  NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(35),
  NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(36),
  NS_ERROR_XPC_CANT_GET_ARRAY_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(37),
  NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(38),
  NS_ERROR_XPC_SECURITY_MANAGER_VETO = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(39),
  NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(40),
  NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(41),
  NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(42),
  NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(43),
  NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(44),
  NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(45),
  NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(46),
  NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(47),
  NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(48),
  NS_ERROR_XPC_BAD_ID_STRING = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(49),
  NS_ERROR_XPC_BAD_INITIALIZER_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(50),
  NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(51),
  NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(52),
  NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = ((uint32_t)(1) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(53),


  NS_SUCCESS_I_DID_SOMETHING = ((uint32_t)(0) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(1),



  NS_SUCCESS_CHROME_ACCESS_ONLY = ((uint32_t)(0) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(2),






  NS_SUCCESS_ALLOW_SLIM_WRAPPERS = ((uint32_t)(0) << 31) | ((uint32_t)(18 + 0x45) << 16) | (uint32_t)(3),







  NS_ERROR_LAUNCHED_CHILD_PROCESS = ((uint32_t)(1) << 31) | ((uint32_t)(19 + 0x45) << 16) | (uint32_t)(200),
# 619 "../../dist/include/ErrorList.h"
  NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(99),



  NS_ERROR_CMS_VERIFY_NOT_SIGNED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1024),
  NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1025),
  NS_ERROR_CMS_VERIFY_BAD_DIGEST = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1026),
  NS_ERROR_CMS_VERIFY_NOCERT = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1028),
  NS_ERROR_CMS_VERIFY_UNTRUSTED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1029),
  NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1031),
  NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1032),
  NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1033),
  NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1034),
  NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1035),
  NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1036),
  NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1037),
  NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1038),
  NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1039),
  NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1040),
  NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1056),
  NS_ERROR_CMS_ENCRYPT_INCOMPLETE = ((uint32_t)(1) << 31) | ((uint32_t)(21 + 0x45) << 16) | (uint32_t)(1057),
# 648 "../../dist/include/ErrorList.h"
  NS_ERROR_DOM_INVALID_EXPRESSION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(22 + 0x45) << 16) | (uint32_t)(51),
  NS_ERROR_DOM_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(22 + 0x45) << 16) | (uint32_t)(52),







  NS_ERROR_WONT_HANDLE_CONTENT = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(1),


  NS_ERROR_MALWARE_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_PHISHING_URI = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(31),


  NS_ERROR_SAVE_LINK_AS_TIMEOUT = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(32),


  NS_ERROR_PARSED_DATA_CACHED = ((uint32_t)(1) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(33),



  NS_REFRESHURI_HEADER_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(24 + 0x45) << 16) | (uint32_t)(2),
# 680 "../../dist/include/ErrorList.h"
  NS_ERROR_IMAGE_SRC_CHANGED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_IMAGE_BLOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(5),

  NS_ERROR_CONTENT_BLOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(7),

  NS_PROPTABLE_PROP_NOT_THERE = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(10),

  NS_ERROR_XBL_BLOCKED = ((uint32_t)(1) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(15),


  NS_HTML_STYLE_PROPERTY_NOT_THERE = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(2),
  NS_CONTENT_BLOCKED = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(8),
  NS_CONTENT_BLOCKED_SHOW_ALT = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(9),
  NS_PROPTABLE_PROP_OVERWRITTEN = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(11),

  NS_FINDBROADCASTER_NOT_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(12),
  NS_FINDBROADCASTER_FOUND = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(13),
  NS_FINDBROADCASTER_AWAIT_OVERLAYS = ((uint32_t)(0) << 31) | ((uint32_t)(25 + 0x45) << 16) | (uint32_t)(14),







  NS_ERROR_XPATH_INVALID_ARG = NS_ERROR_INVALID_ARG,

  NS_ERROR_XSLT_PARSE_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_XPATH_PARSE_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_XSLT_ALREADY_SET = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_XSLT_EXECUTION_FAILURE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_XPATH_UNKNOWN_FUNCTION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_XSLT_BAD_RECURSION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_XSLT_BAD_VALUE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_XSLT_NODESET_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_XSLT_ABORTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_XSLT_NETWORK_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_XSLT_WRONG_MIME_TYPE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_XSLT_LOAD_RECURSION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(13),
  NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(14),
  NS_ERROR_XPATH_PAREN_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(15),
  NS_ERROR_XPATH_INVALID_AXIS = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(16),
  NS_ERROR_XPATH_NO_NODE_TYPE_TEST = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(17),
  NS_ERROR_XPATH_BRACKET_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(18),
  NS_ERROR_XPATH_INVALID_VAR_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(19),
  NS_ERROR_XPATH_UNEXPECTED_END = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(20),
  NS_ERROR_XPATH_OPERATOR_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(21),
  NS_ERROR_XPATH_UNCLOSED_LITERAL = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(22),
  NS_ERROR_XPATH_BAD_COLON = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(23),
  NS_ERROR_XPATH_BAD_BANG = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(24),
  NS_ERROR_XPATH_ILLEGAL_CHAR = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(25),
  NS_ERROR_XPATH_BINARY_EXPECTED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(26),
  NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(27),
  NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(28),
  NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(29),
  NS_ERROR_XSLT_BAD_NODE_NAME = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(30),
  NS_ERROR_XSLT_VAR_ALREADY_SET = ((uint32_t)(1) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(31),

  NS_XSLT_GET_NEW_HANDLER = ((uint32_t)(0) << 31) | ((uint32_t)(27 + 0x45) << 16) | (uint32_t)(1),
# 749 "../../dist/include/ErrorList.h"
  NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(29 + 0x45) << 16) | (uint32_t)(0),

  NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = ((uint32_t)(1) << 31) | ((uint32_t)(29 + 0x45) << 16) | (uint32_t)(2),
# 767 "../../dist/include/ErrorList.h"
  NS_ERROR_STORAGE_BUSY = ((uint32_t)(1) << 31) | ((uint32_t)(30 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_STORAGE_IOERR = ((uint32_t)(1) << 31) | ((uint32_t)(30 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_STORAGE_CONSTRAINT = ((uint32_t)(1) << 31) | ((uint32_t)(30 + 0x45) << 16) | (uint32_t)(3),







  NS_ERROR_DOM_FILE_NOT_FOUND_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(32 + 0x45) << 16) | (uint32_t)(0),
  NS_ERROR_DOM_FILE_NOT_READABLE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(32 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_FILE_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(32 + 0x45) << 16) | (uint32_t)(2),
# 788 "../../dist/include/ErrorList.h"
  NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_INDEXEDDB_DATA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(8),
  NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(9),
  NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(10),
  NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(11),
  NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(12),
  NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(33 + 0x45) << 16) | (uint32_t)(1001),







  NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_DOM_FILEHANDLE_LOCKEDFILE_INACTIVE_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = ((uint32_t)(1) << 31) | ((uint32_t)(34 + 0x45) << 16) | (uint32_t)(5),






  NS_ERROR_SIGNED_JAR_NOT_SIGNED = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(1),
  NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(3),
  NS_ERROR_SIGNED_JAR_ENTRY_MISSING = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(4),
  NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(5),
  NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(6),
  NS_ERROR_SIGNED_JAR_ENTRY_INVALID = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(7),
  NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = ((uint32_t)(1) << 31) | ((uint32_t)(35 + 0x45) << 16) | (uint32_t)(8),
# 834 "../../dist/include/ErrorList.h"
  NS_ERROR_DOWNLOAD_COMPLETE = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1),



  NS_ERROR_DOWNLOAD_NOT_PARTIAL = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(2),
  NS_ERROR_UNORM_MOREOUTPUT = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(33),

  NS_ERROR_DOCSHELL_REQUEST_REJECTED = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1001),




  NS_ERROR_DOCUMENT_IS_PRINTMODE = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(2001),

  NS_SUCCESS_DONT_FIXUP = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1),



  NS_SUCCESS_RESTART_APP = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(1),
  NS_SUCCESS_UNORM_NOTFOUND = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(17),




  NS_ERROR_NOT_IN_TREE = ((uint32_t)(1) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(38),


  NS_OK_NO_ARIA_VALUE = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(33),

  NS_OK_NO_NAME_CLAUSE_HANDLED = ((uint32_t)(0) << 31) | ((uint32_t)(51 + 0x45) << 16) | (uint32_t)(34)
# 126 "../../dist/include/nsError.h" 2

  } nsresult;





# 1 "../../dist/include/ErrorListCxxDefines.h" 1
# 134 "../../dist/include/nsError.h" 2
# 178 "../../dist/include/nsError.h"
inline uint32_t NS_FAILED_impl(nsresult _nsresult) {
  return static_cast<uint32_t>(_nsresult) & 0x80000000;
}
# 212 "../../dist/include/nsError.h"
extern nsresult
NS_ErrorAccordingToNSPR();







inline uint16_t NS_ERROR_GET_CODE(nsresult err) {
  return uint32_t(err) & 0xffff;
}
inline uint16_t NS_ERROR_GET_MODULE(nsresult err) {
  return ((uint32_t(err) >> 16) - 0x45) & 0x1fff;
}
inline bool NS_ERROR_GET_SEVERITY(nsresult err) {
  return uint32_t(err) >> 31;
}
# 313 "../../dist/include/nscore.h" 2
# 325 "../../dist/include/nscore.h"
typedef uint32_t nsrefcnt;
# 14 "../../dist/include/nsrootidl.h" 2
# 1 "../../dist/system_wrappers/prtime.h" 1
       
# 2 "../../dist/system_wrappers/prtime.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 1 3
# 19 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlong.h" 1 3
# 19 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlong.h" 3
extern "C" {
# 30 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlong.h" 3
extern __attribute__((visibility("default"))) PRInt64 LL_MaxInt(void);
extern __attribute__((visibility("default"))) PRInt64 LL_MinInt(void);
extern __attribute__((visibility("default"))) PRInt64 LL_Zero(void);
extern __attribute__((visibility("default"))) PRUint64 LL_MaxUint(void);
# 401 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlong.h" 3
}
# 20 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 2 3

extern "C" {
# 48 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
typedef PRInt64 PRTime;






typedef struct PRTimeParameters {
    PRInt32 tp_gmt_offset;
    PRInt32 tp_dst_offset;
} PRTimeParameters;
# 83 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
typedef struct PRExplodedTime {
    PRInt32 tm_usec;
    PRInt32 tm_sec;

    PRInt32 tm_min;
    PRInt32 tm_hour;
    PRInt32 tm_mday;

    PRInt32 tm_month;
    PRInt16 tm_year;


    PRInt8 tm_wday;

    PRInt16 tm_yday;


    PRTimeParameters tm_params;
} PRExplodedTime;
# 126 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
typedef PRTimeParameters ( *PRTimeParamFn)(const PRExplodedTime *gmt);
# 145 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
extern __attribute__((visibility("default"))) PRTime
PR_Now(void);
# 158 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
extern __attribute__((visibility("default"))) void PR_ExplodeTime(
    PRTime usecs, PRTimeParamFn params, PRExplodedTime *exploded);


extern __attribute__((visibility("default"))) PRTime
PR_ImplodeTime(const PRExplodedTime *exploded);
# 177 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
extern __attribute__((visibility("default"))) void PR_NormalizeTime(
    PRExplodedTime *exploded, PRTimeParamFn params);






extern __attribute__((visibility("default"))) PRTimeParameters PR_LocalTimeParameters(const PRExplodedTime *gmt);


extern __attribute__((visibility("default"))) PRTimeParameters PR_GMTParameters(const PRExplodedTime *gmt);





extern __attribute__((visibility("default"))) PRTimeParameters PR_USPacificTimeParameters(const PRExplodedTime *gmt);
# 231 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_ParseTimeStringToExplodedTime (
        const char *string,
        PRBool default_to_gmt,
        PRExplodedTime *result);
# 244 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_ParseTimeString (
 const char *string,
 PRBool default_to_gmt,
 PRTime *result);


extern __attribute__((visibility("default"))) PRUint32 PR_FormatTime(char *buf, int buflen, const char *fmt,
                                           const PRExplodedTime *tm);




extern __attribute__((visibility("default"))) PRUint32
PR_FormatTimeUSEnglish( char* buf, PRUint32 bufSize,
                        const char* format, const PRExplodedTime* tm );

}
# 4 "../../dist/system_wrappers/prtime.h" 2 3
#pragma GCC visibility pop
# 15 "../../dist/include/nsrootidl.h" 2



class nsAString_internal;
class nsACString_internal;
# 11 "../../dist/include/nsISupports.h" 2
# 122 "../../dist/include/nsISupports.h"
# 1 "../../dist/include/nsISupportsBase.h" 1
# 13 "../../dist/include/nsISupportsBase.h"
# 1 "../../dist/include/nsID.h" 1
# 9 "../../dist/include/nsID.h"
# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 10 "../../dist/include/nsID.h" 2
# 21 "../../dist/include/nsID.h"
struct nsID {





  uint32_t m0;
  uint16_t m1;
  uint16_t m2;
  uint8_t m3[8];
# 43 "../../dist/include/nsID.h"
  inline bool Equals(const nsID& other) const {

    return
      ((((uint32_t*) &m0)[0] == ((uint32_t*) &other.m0)[0]) &&
       (((uint32_t*) &m0)[1] == ((uint32_t*) &other.m0)[1]) &&
       (((uint32_t*) &m0)[2] == ((uint32_t*) &other.m0)[2]) &&
       (((uint32_t*) &m0)[3] == ((uint32_t*) &other.m0)[3]));
  }





  bool Parse(const char *aIDStr);







  char* ToString() const;






  void ToProvidedString(char (&dest)[39]) const;




};





typedef nsID nsCID;
# 98 "../../dist/include/nsID.h"
typedef nsID nsIID;
# 14 "../../dist/include/nsISupportsBase.h" 2
# 35 "../../dist/include/nsISupportsBase.h"
class nsISupports {
public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}
# 55 "../../dist/include/nsISupportsBase.h"
  virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr) = 0;







  virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void) = 0;
# 72 "../../dist/include/nsISupportsBase.h"
  virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void) = 0;


};

template <class Dummy> const nsIID nsISupports::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = { 0x00000000, 0x0000, 0x0000, {0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46} };
# 123 "../../dist/include/nsISupports.h" 2
# 1 "../../dist/include/nsISupportsUtils.h" 1
# 22 "../../dist/include/nsISupportsUtils.h"
# 1 "../../dist/include/nsDebug.h" 1
# 17 "../../dist/include/nsDebug.h"
# 1 "../../dist/include/nsXPCOM.h" 1
# 10 "../../dist/include/nsXPCOM.h"
# 1 "../../dist/include/nsXPCOMCID.h" 1
# 11 "../../dist/include/nsXPCOM.h" 2
# 20 "../../dist/include/nsXPCOM.h"
class nsAString_internal;
class nsACString_internal;

class nsISupports;
class nsIModule;
class nsIComponentManager;
class nsIComponentRegistrar;
class nsIServiceManager;
class nsIFile;
class nsILocalFile;
class nsIDirectoryServiceProvider;
class nsIMemory;
class nsIDebug;
class nsITraceRefcnt;
struct nsPurpleBufferEntry;


namespace mozilla {
struct Module;
}
# 74 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_InitXPCOM2(nsIServiceManager* *result,
              nsIFile* binDirectory,
              nsIDirectoryServiceProvider* appFileLocationProvider);
# 90 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_ShutdownXPCOM(nsIServiceManager* servMgr);
# 103 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_GetServiceManager(nsIServiceManager* *result);
# 115 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_GetComponentManager(nsIComponentManager* *result);
# 128 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_GetComponentRegistrar(nsIComponentRegistrar* *result);
# 140 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_GetMemoryManager(nsIMemory* *result);
# 166 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_NewLocalFile(const nsAString_internal &path,
                bool followLinks,
                nsIFile* *result);

extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_NewNativeLocalFile(const nsACString_internal &path,
                      bool followLinks,
                      nsIFile* *result);
# 186 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void*
NS_Alloc(size_t size);
# 204 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void*
NS_Realloc(void* ptr, size_t size);
# 215 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void
NS_Free(void* ptr);





enum {
    NS_DEBUG_WARNING = 0,
    NS_DEBUG_ASSERTION = 1,
    NS_DEBUG_BREAK = 2,
    NS_DEBUG_ABORT = 3
};
# 244 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void
NS_DebugBreak(uint32_t aSeverity,
              const char *aStr, const char *aExpr,
              const char *aFile, int32_t aLine);
# 265 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void
NS_LogInit();

extern "C" __attribute__ ((visibility ("default"))) void
NS_LogTerm();
# 281 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void
NS_LogCtor(void *aPtr, const char *aTypeName, uint32_t aInstanceSize);

extern "C" __attribute__ ((visibility ("default"))) void
NS_LogDtor(void *aPtr, const char *aTypeName, uint32_t aInstanceSize);
# 297 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void
NS_LogAddRef(void *aPtr, nsrefcnt aNewRefCnt,
             const char *aTypeName, uint32_t aInstanceSize);

extern "C" __attribute__ ((visibility ("default"))) void
NS_LogRelease(void *aPtr, nsrefcnt aNewRefCnt, const char *aTypeName);
# 314 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) void
NS_LogCOMPtrAddRef(void *aCOMPtr, nsISupports *aObject);

extern "C" __attribute__ ((visibility ("default"))) void
NS_LogCOMPtrRelease(void *aCOMPtr, nsISupports *aObject);
# 331 "../../dist/include/nsXPCOM.h"
class nsCycleCollectionParticipant;

extern "C" __attribute__ ((visibility ("default"))) nsPurpleBufferEntry*
NS_CycleCollectorSuspect2(void *n, nsCycleCollectionParticipant *p);

extern "C" __attribute__ ((visibility ("default"))) bool
NS_CycleCollectorForget2(nsPurpleBufferEntry *e);
# 416 "../../dist/include/nsXPCOM.h"
extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_GetDebug(nsIDebug* *result);

extern "C" __attribute__ ((visibility ("default"))) nsresult
NS_GetTraceRefcnt(nsITraceRefcnt* *result);
# 18 "../../dist/include/nsDebug.h" 2
# 1 "../../dist/include/mozilla/Assertions.h" 1
# 19 "../../dist/include/nsDebug.h" 2
# 361 "../../dist/include/nsDebug.h"
extern "C" {


 void
printf_stderr(const char *fmt, ...);


}
# 23 "../../dist/include/nsISupportsUtils.h" 2



# 1 "../../dist/include/nsISupportsImpl.h" 1
# 24 "../../dist/include/nsISupportsImpl.h"
# 1 "../../dist/system_wrappers/prthread.h" 1
       
# 2 "../../dist/system_wrappers/prthread.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 1 3
# 47 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 1 3
# 23 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 3
extern "C" {





typedef PRUint32 PRIntervalTime;
# 79 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 3
extern __attribute__((visibility("default"))) PRIntervalTime PR_IntervalNow(void);
# 97 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 3
extern __attribute__((visibility("default"))) PRUint32 PR_TicksPerSecond(void);
# 116 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 3
extern __attribute__((visibility("default"))) PRIntervalTime PR_SecondsToInterval(PRUint32 seconds);
extern __attribute__((visibility("default"))) PRIntervalTime PR_MillisecondsToInterval(PRUint32 milli);
extern __attribute__((visibility("default"))) PRIntervalTime PR_MicrosecondsToInterval(PRUint32 micro);
# 137 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 3
extern __attribute__((visibility("default"))) PRUint32 PR_IntervalToSeconds(PRIntervalTime ticks);
extern __attribute__((visibility("default"))) PRUint32 PR_IntervalToMilliseconds(PRIntervalTime ticks);
extern __attribute__((visibility("default"))) PRUint32 PR_IntervalToMicroseconds(PRIntervalTime ticks);

}
# 48 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 2 3

extern "C" {

typedef struct PRThread PRThread;
typedef struct PRThreadStack PRThreadStack;

typedef enum PRThreadType {
    PR_USER_THREAD,
    PR_SYSTEM_THREAD
} PRThreadType;

typedef enum PRThreadScope {
    PR_LOCAL_THREAD,
    PR_GLOBAL_THREAD,
    PR_GLOBAL_BOUND_THREAD
} PRThreadScope;

typedef enum PRThreadState {
    PR_JOINABLE_THREAD,
    PR_UNJOINABLE_THREAD
} PRThreadState;

typedef enum PRThreadPriority
{
    PR_PRIORITY_FIRST = 0,
    PR_PRIORITY_LOW = 0,
    PR_PRIORITY_NORMAL = 1,
    PR_PRIORITY_HIGH = 2,
    PR_PRIORITY_URGENT = 3,
    PR_PRIORITY_LAST = 3
} PRThreadPriority;
# 105 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
extern __attribute__((visibility("default"))) PRThread* PR_CreateThread(PRThreadType type,
                     void ( *start)(void *arg),
                     void *arg,
                     PRThreadPriority priority,
                     PRThreadScope scope,
                     PRThreadState state,
                     PRUint32 stackSize);
# 126 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_JoinThread(PRThread *thread);





extern __attribute__((visibility("default"))) PRThread* PR_GetCurrentThread(void);







extern __attribute__((visibility("default"))) PRThreadPriority PR_GetThreadPriority(const PRThread *thread);




extern __attribute__((visibility("default"))) void PR_SetThreadPriority(PRThread *thread, PRThreadPriority priority);





extern __attribute__((visibility("default"))) PRStatus PR_SetCurrentThreadName(const char *name);




extern __attribute__((visibility("default"))) const char * PR_GetThreadName(const PRThread *thread);
# 182 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
typedef void ( *PRThreadPrivateDTOR)(void *priv);

extern __attribute__((visibility("default"))) PRStatus PR_NewThreadPrivateIndex(
    PRUintn *newIndex, PRThreadPrivateDTOR destructor);
# 198 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_SetThreadPrivate(PRUintn tpdIndex, void *priv);
# 209 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
extern __attribute__((visibility("default"))) void* PR_GetThreadPrivate(PRUintn tpdIndex);
# 221 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Interrupt(PRThread *thread);





extern __attribute__((visibility("default"))) void PR_ClearInterrupt(void);




extern __attribute__((visibility("default"))) void PR_BlockInterrupt(void);




extern __attribute__((visibility("default"))) void PR_UnblockInterrupt(void);
# 246 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Sleep(PRIntervalTime ticks);




extern __attribute__((visibility("default"))) PRThreadScope PR_GetThreadScope(const PRThread *thread);




extern __attribute__((visibility("default"))) PRThreadType PR_GetThreadType(const PRThread *thread);




extern __attribute__((visibility("default"))) PRThreadState PR_GetThreadState(const PRThread *thread);

}
# 4 "../../dist/system_wrappers/prthread.h" 2 3
#pragma GCC visibility pop
# 25 "../../dist/include/nsISupportsImpl.h" 2
# 1 "../../dist/include/nsAtomicRefcnt.h" 1
# 9 "../../dist/include/nsAtomicRefcnt.h"
# 1 "../../dist/system_wrappers/pratom.h" 1
       
# 2 "../../dist/system_wrappers/pratom.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 1 3
# 15 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 1 3
# 21 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
extern "C" {
# 34 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
typedef struct PRLock PRLock;
# 51 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
extern __attribute__((visibility("default"))) PRLock* PR_NewLock(void);
# 62 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
extern __attribute__((visibility("default"))) void PR_DestroyLock(PRLock *lock);
# 73 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
extern __attribute__((visibility("default"))) void PR_Lock(PRLock *lock);
# 85 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Unlock(PRLock *lock);
# 105 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 3
extern __attribute__((visibility("default"))) void PR_AssertCurrentThreadOwnsLock(PRLock *lock);

}
# 16 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 2 3

extern "C" {
# 28 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_AtomicIncrement(PRInt32 *val);
# 39 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_AtomicDecrement(PRInt32 *val);
# 51 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_AtomicSet(PRInt32 *val, PRInt32 newval);
# 63 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_AtomicAdd(PRInt32 *ptr, PRInt32 val);
# 138 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
typedef struct PRStackElemStr PRStackElem;

struct PRStackElemStr {
    PRStackElem *prstk_elem_next;

};

typedef struct PRStackStr PRStack;
# 156 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRStack * PR_CreateStack(const char *stack_name);
# 168 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) void PR_StackPush(PRStack *stack, PRStackElem *stack_elem);
# 181 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRStackElem * PR_StackPop(PRStack *stack);
# 195 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_DestroyStack(PRStack *stack);

}
# 4 "../../dist/system_wrappers/pratom.h" 2 3
#pragma GCC visibility pop
# 10 "../../dist/include/nsAtomicRefcnt.h" 2

class nsAutoRefCnt;
# 26 "../../dist/include/nsAtomicRefcnt.h"
typedef int32_t nsAtomicRefcnt;



inline int32_t
NS_AtomicIncrementRefcnt(int32_t &refcnt)
{
  return __sync_add_and_fetch(&refcnt, 1);
}

inline nsrefcnt
NS_AtomicIncrementRefcnt(nsrefcnt &refcnt)
{
  return (nsrefcnt) __sync_add_and_fetch((nsAtomicRefcnt*)&refcnt, 1);
}

inline nsrefcnt
NS_AtomicIncrementRefcnt(nsAutoRefCnt &refcnt)
{

  return (nsrefcnt) __sync_add_and_fetch((nsAtomicRefcnt*)&refcnt, 1);
}

inline nsrefcnt
NS_AtomicDecrementRefcnt(nsrefcnt &refcnt)
{
  return (nsrefcnt) __sync_sub_and_fetch((nsAtomicRefcnt*)&refcnt, 1);
}

inline nsrefcnt
NS_AtomicDecrementRefcnt(nsAutoRefCnt &refcnt)
{
  return (nsrefcnt) __sync_sub_and_fetch((nsAtomicRefcnt*)&refcnt, 1);
}

inline int32_t
NS_AtomicDecrementRefcnt(int32_t &refcnt)
{
  return __sync_sub_and_fetch(&refcnt, 1);
}
# 26 "../../dist/include/nsISupportsImpl.h" 2



# 1 "../../dist/include/nsTraceRefcnt.h" 1
# 62 "../../dist/include/nsTraceRefcnt.h"
class nsTraceRefcnt {
public:
  inline static void LogAddRef(void* aPtr, nsrefcnt aNewRefCnt,
                               const char* aTypeName, uint32_t aInstanceSize) {
    NS_LogAddRef(aPtr, aNewRefCnt, aTypeName, aInstanceSize);
  }

  inline static void LogRelease(void* aPtr, nsrefcnt aNewRefCnt,
                                const char* aTypeName) {
    NS_LogRelease(aPtr, aNewRefCnt, aTypeName);
  }

  inline static void LogCtor(void* aPtr, const char* aTypeName,
                             uint32_t aInstanceSize) {
    NS_LogCtor(aPtr, aTypeName, aInstanceSize);
  }

  inline static void LogDtor(void* aPtr, const char* aTypeName,
                             uint32_t aInstanceSize) {
    NS_LogDtor(aPtr, aTypeName, aInstanceSize);
  }

  inline static void LogAddCOMPtr(void *aCOMPtr, nsISupports *aObject) {
    NS_LogCOMPtrAddRef(aCOMPtr, aObject);
  }

  inline static void LogReleaseCOMPtr(void *aCOMPtr, nsISupports *aObject) {
    NS_LogCOMPtrRelease(aCOMPtr, aObject);
  }
};
# 30 "../../dist/include/nsISupportsImpl.h" 2
# 1 "../../dist/include/nsCycleCollector.h" 1
# 9 "../../dist/include/nsCycleCollector.h"
class nsISupports;
class nsICycleCollectorListener;
class nsCycleCollectionParticipant;
class nsCycleCollectionTraversalCallback;


class nsCycleCollectorResults
{
public:
    nsCycleCollectorResults() :
        mForcedGC(false), mVisitedRefCounted(0), mVisitedGCed(0),
        mFreedRefCounted(0), mFreedGCed(0) {}
    bool mForcedGC;
    uint32_t mVisitedRefCounted;
    uint32_t mVisitedGCed;
    uint32_t mFreedRefCounted;
    uint32_t mFreedGCed;
};

bool nsCycleCollector_init();

enum CCThreadingModel {
    CCSingleThread,
    CCWithTraverseThread,
};

nsresult nsCycleCollector_startup(CCThreadingModel aThreadingModel);

typedef void (*CC_BeforeUnlinkCallback)(void);
void nsCycleCollector_setBeforeUnlinkCallback(CC_BeforeUnlinkCallback aCB);

typedef void (*CC_ForgetSkippableCallback)(void);
void nsCycleCollector_setForgetSkippableCallback(CC_ForgetSkippableCallback aCB);

void nsCycleCollector_forgetSkippable(bool aRemoveChildlessNodes = false);

void nsCycleCollector_collect(bool aMergeCompartments,
                              nsCycleCollectorResults *aResults,
                              nsICycleCollectorListener *aListener);
uint32_t nsCycleCollector_suspectedCount();
void nsCycleCollector_shutdownThreads();
void nsCycleCollector_shutdown();


struct nsCycleCollectionJSRuntime
{
    virtual nsresult BeginCycleCollection(nsCycleCollectionTraversalCallback &cb) = 0;







    virtual bool NotifyLeaveMainThread() = 0;
    virtual void NotifyEnterCycleCollectionThread() = 0;
    virtual void NotifyLeaveCycleCollectionThread() = 0;
    virtual void NotifyEnterMainThread() = 0;




    virtual void FixWeakMappingGrayBits() = 0;




    virtual bool NeedCollect() = 0;




    virtual void Collect(uint32_t reason) = 0;




    virtual nsCycleCollectionParticipant *GetParticipant() = 0;





};


void nsCycleCollector_registerJSRuntime(nsCycleCollectionJSRuntime *rt);
void nsCycleCollector_forgetJSRuntime();





extern nsresult
nsCycleCollectorLoggerConstructor(nsISupports* outer,
                                  const nsIID& aIID,
                                  void* *aInstancePtr);
# 31 "../../dist/include/nsISupportsImpl.h" 2
# 1 "../../dist/include/nsCycleCollectorUtils.h" 1
# 9 "../../dist/include/nsCycleCollectorUtils.h"
# 1 "../../dist/include/mozilla/threads/nsThreadIDs.h" 1







namespace mozilla {
namespace threads {

enum ID {
  Generic = 0,
  Main = 1,
  CycleCollector = 2
};

}
}
# 10 "../../dist/include/nsCycleCollectorUtils.h" 2






extern __thread mozilla::threads::ID gTLSThreadID;
inline bool NS_IsCycleCollectorThread()
{
  return gTLSThreadID == mozilla::threads::CycleCollector;
}
# 32 "../../dist/include/nsISupportsImpl.h" 2
# 1 "../../dist/include/mozilla/Attributes.h" 1
# 33 "../../dist/include/nsISupportsImpl.h" 2



inline nsISupports*
ToSupports(nsISupports* p)
{
    return p;
}

inline nsISupports*
ToCanonicalSupports(nsISupports* p)
{
    return __null;
}
# 97 "../../dist/include/nsISupportsImpl.h"
struct nsPurpleBufferEntry {



  union {
    void *mObject;
    nsPurpleBufferEntry *mNextInFreeList;
  };



  nsrefcnt mRefCnt : 31;




  nsrefcnt mNotPurple : 1;

  nsCycleCollectionParticipant *mParticipant;
};

class nsCycleCollectingAutoRefCnt {

public:
  nsCycleCollectingAutoRefCnt()
    : mTagged(((void *) (intptr_t) ((0 << 1) | 1)))
  {}

  nsCycleCollectingAutoRefCnt(nsrefcnt aValue)
    : mTagged(((void *) (intptr_t) ((aValue << 1) | 1)))
  {
  }

  __attribute__((always_inline)) inline nsrefcnt incr(void *owner)
  {
    if ((__builtin_expect(!!(mTagged == static_cast<void*>(0)), 0))) {






      return 2;
    }

    nsrefcnt refcount;
    if (HasPurpleBufferEntry()) {
      nsPurpleBufferEntry *e = static_cast<nsPurpleBufferEntry*>(mTagged);
      do { } while(0);
      do { } while(0);
      refcount = ++(e->mRefCnt);
      e->mNotPurple = true;
    } else {
      refcount = nsrefcnt(((int32_t) (intptr_t) (mTagged)) >> 1);
      do { } while(0);
      ++refcount;
      mTagged = ((void *) (intptr_t) ((refcount << 1) | 1));
    }

    return refcount;
  }

  __attribute__((always_inline)) inline void stabilizeForDeletion()
  {
    mTagged = static_cast<void*>(0);
  }

  __attribute__((always_inline)) inline nsrefcnt decr(nsISupports *owner)
  {
    return decr(owner, nullptr);
  }

  __attribute__((always_inline)) inline nsrefcnt decr(void *owner, nsCycleCollectionParticipant *p)
  {
    if ((__builtin_expect(!!(mTagged == static_cast<void*>(0)), 0)))
      return 1;

    nsrefcnt refcount;
    if (HasPurpleBufferEntry()) {
      nsPurpleBufferEntry *e = static_cast<nsPurpleBufferEntry*>(mTagged);
      do { } while(0);
      do { } while(0);
      refcount = --(e->mRefCnt);
      if ((__builtin_expect(!!(refcount == 0), 0))) {
        e->mObject = nullptr;
        mTagged = ((void *) (intptr_t) ((0 << 1) | 1));
      } else {
        e->mNotPurple = false;
      }
    } else {
      refcount = nsrefcnt(((int32_t) (intptr_t) (mTagged)) >> 1);
      do { } while(0);
      --refcount;

      nsPurpleBufferEntry *e;
      if ((__builtin_expect(!!(refcount > 0), 1)) &&
          ((e = NS_CycleCollectorSuspect2(owner, p)))) {
        e->mRefCnt = refcount;
        mTagged = static_cast<void*>(e);
      } else {
        mTagged = ((void *) (intptr_t) ((refcount << 1) | 1));
      }
    }

    return refcount;
  }

  __attribute__((always_inline)) inline void ReleasePurpleBufferEntry()
  {
    do { } while(0);
    nsrefcnt refcount = static_cast<nsPurpleBufferEntry*>(mTagged)->mRefCnt;
    mTagged = ((void *) (intptr_t) ((refcount << 1) | 1));
  }

  __attribute__((always_inline)) inline void RemovePurple()
  {
    do { } while(0);

    static_cast<nsPurpleBufferEntry*>(mTagged)->mObject = nullptr;
    ReleasePurpleBufferEntry();
  }

  __attribute__((always_inline)) inline bool HasPurpleBufferEntry() const
  {
    do { } while(0)
                                                             ;
    return !(((int32_t) (intptr_t) (mTagged)) & 1);
  }

  __attribute__((always_inline)) inline bool IsPurple() const
  {
    return HasPurpleBufferEntry() &&
      !(static_cast<nsPurpleBufferEntry*>(mTagged)->mNotPurple);
  }

  __attribute__((always_inline)) inline nsrefcnt get() const
  {
    if ((__builtin_expect(!!(mTagged == static_cast<void*>(0)), 0)))
      return 1;

    return (__builtin_expect(!!(HasPurpleBufferEntry()), 0))
             ? static_cast<nsPurpleBufferEntry*>(mTagged)->mRefCnt
             : nsrefcnt(((int32_t) (intptr_t) (mTagged)) >> 1);
  }

  __attribute__((always_inline)) inline operator nsrefcnt() const
  {
    return get();
  }

 private:
  void *mTagged;
};

class nsAutoRefCnt {

 public:
    nsAutoRefCnt() : mValue(0) {}
    nsAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}


    nsrefcnt operator++() { return ++mValue; }
    nsrefcnt operator--() { return --mValue; }

    nsrefcnt operator=(nsrefcnt aValue) { return (mValue = aValue); }
    operator nsrefcnt() const { return mValue; }
    nsrefcnt get() const { return mValue; }
 private:

    nsrefcnt operator++(int);
    nsrefcnt operator--(int);
    nsrefcnt mValue;
};
# 576 "../../dist/include/nsISupportsImpl.h"
struct QITableEntry
{
  const nsIID *iid;
  int32_t offset;
};

 nsresult
NS_TableDrivenQI(void* aThis, const QITableEntry* entries,
                 const nsIID& aIID, void **aInstancePtr);
# 27 "../../dist/include/nsISupportsUtils.h" 2
# 46 "../../dist/include/nsISupportsUtils.h"
extern "C++" {






template <class T>
inline
void
ns_if_addref( T expr )
{
    if (expr) {
        expr->AddRef();
    }
}

}
# 140 "../../dist/include/nsISupportsUtils.h"
template <class T, class DestinationType>
inline
nsresult
CallQueryInterface( T* aSource, DestinationType** aDestination )
{
    do { } while(0);
    do { } while(0);

    return aSource->QueryInterface((DestinationType::template COMTypeInfo<int>::kIID),
                                   reinterpret_cast<void**>(aDestination));
}
# 124 "../../dist/include/nsISupports.h" 2
# 24 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 2
# 1 "../../dist/include/nsIFile.h" 1
# 17 "../../dist/include/nsIFile.h"
# 1 "../../dist/system_wrappers/prio.h" 1
       
# 2 "../../dist/system_wrappers/prio.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 1 3
# 17 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtime.h" 1 3
# 18 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 2 3

# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 1 3
# 36 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 3
# 1 "../../dist/system_wrappers/sys/types.h" 1 3
       
# 2 "../../dist/system_wrappers/sys/types.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 37 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 2 3
# 1 "../../dist/system_wrappers/sys/socket.h" 1 3
       
# 2 "../../dist/system_wrappers/sys/socket.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/socket.h" 1 3 4
# 24 "/usr/include/sys/socket.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/sys/socket.h" 2 3 4

extern "C" {

# 1 "../../dist/system_wrappers/sys/uio.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/uio.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/uio.h" 1 3 4
# 22 "/usr/include/sys/uio.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/sys/uio.h" 2 3 4

# 1 "../../dist/system_wrappers/sys/types.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/types.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/sys/uio.h" 2 3 4

extern "C" {


# 1 "/usr/include/bits/uio.h" 1 3 4
# 26 "/usr/include/bits/uio.h" 3 4
# 1 "../../dist/system_wrappers/sys/types.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/types.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/bits/uio.h" 2 3 4
# 44 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count)
  ;
# 51 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count)
  ;
# 66 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, __const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 78 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, __const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 104 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, __const struct iovec *__iovec, int __count,
    __off64_t __offset) ;
# 116 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, __const struct iovec *__iovec, int __count,
     __off64_t __offset) ;



}
# 4 "../../dist/system_wrappers/sys/uio.h" 2 3
#pragma GCC visibility pop
# 29 "/usr/include/sys/socket.h" 2 3 4

# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 31 "/usr/include/sys/socket.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 34 "/usr/include/sys/socket.h" 2 3 4






# 1 "/usr/include/bits/socket.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 3 4
# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 30 "/usr/include/bits/socket.h" 2 3 4

# 1 "../../dist/system_wrappers/sys/types.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/types.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 32 "/usr/include/bits/socket.h" 2 3 4



typedef __socklen_t socklen_t;




enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 04000


};
# 171 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 29 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 172 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 187 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };



struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;
  };



struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 304 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) throw ();




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) throw ()
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
# 377 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/asm/socket.h" 2 3 4
# 378 "/usr/include/bits/socket.h" 2 3 4
# 411 "/usr/include/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };


extern "C" {






extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       __const struct timespec *__tmo);

}
# 41 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 105 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) throw ();





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) throw ();


extern int bind (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     throw ();


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();
# 129 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, __const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();






extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
         int __flags, __const struct sockaddr * __addr,
         socklen_t __addr_len);
# 166 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, __const struct msghdr *__message,
   int __flags);






extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);





extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) throw ();




extern int setsockopt (int __fd, int __level, int __optname,
         __const void *__optval, socklen_t __optlen) throw ();





extern int listen (int __fd, int __n) throw ();
# 214 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, struct sockaddr *__restrict __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 232 "/usr/include/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) throw ();




extern int sockatmark (int __fd) throw ();







extern int isfdtype (int __fd, int __fdtype) throw ();
# 254 "/usr/include/sys/socket.h" 3 4
}
# 4 "../../dist/system_wrappers/sys/socket.h" 2 3
#pragma GCC visibility pop
# 38 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 2 3
# 1 "../../dist/system_wrappers/netinet/in.h" 1 3
       
# 2 "../../dist/system_wrappers/netinet/in.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/netinet/in.h" 1 3 4
# 23 "/usr/include/netinet/in.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 24 "/usr/include/netinet/in.h" 2 3 4
# 1 "../../dist/system_wrappers/stdint.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stdint.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/netinet/in.h" 2 3 4
# 1 "../../dist/system_wrappers/sys/socket.h" 1 3 4
       
# 2 "../../dist/system_wrappers/sys/socket.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 26 "/usr/include/netinet/in.h" 2 3 4



extern "C" {


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_HOPOPTS = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MTP = 92,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
# 198 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 225 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 356 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/bits/in.h" 1 3 4
# 99 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 357 "/usr/include/netinet/in.h" 2 3 4
# 365 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) throw () __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     throw () __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     throw () __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     throw () __attribute__ ((__const__));

# 1 "../../dist/system_wrappers/endian.h" 1 3 4
       
# 2 "../../dist/system_wrappers/endian.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 374 "/usr/include/netinet/in.h" 2 3 4


# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 377 "/usr/include/netinet/in.h" 2 3 4
# 440 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) throw ();


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     throw ();
# 471 "/usr/include/netinet/in.h" 3 4
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) throw () __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    __const uint8_t *__typep, int __multx,
    int __plusy) throw () __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_next (__const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_find (__const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     throw () __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) throw ();
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) throw ();
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     throw ();
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();



extern socklen_t inet6_rth_space (int __type, int __segments) throw ();
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) throw ();
extern int inet6_rth_add (void *__bp, __const struct in6_addr *__addr) throw ();
extern int inet6_rth_reverse (__const void *__in, void *__out) throw ();
extern int inet6_rth_segments (__const void *__bp) throw ();
extern struct in6_addr *inet6_rth_getaddr (__const void *__bp, int __index)
     throw ();





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     throw ();


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    __const struct in_addr *__slist)
     throw ();



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       __const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) throw ();


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       __const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       __const struct sockaddr_storage *__slist) throw ();


}
# 4 "../../dist/system_wrappers/netinet/in.h" 2 3
#pragma GCC visibility pop
# 39 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 2 3
# 53 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 3
# 1 "../../dist/system_wrappers/arpa/inet.h" 1 3
       
# 2 "../../dist/system_wrappers/arpa/inet.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 22 "/usr/include/arpa/inet.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/arpa/inet.h" 2 3 4
# 1 "../../dist/system_wrappers/netinet/in.h" 1 3 4
       
# 2 "../../dist/system_wrappers/netinet/in.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 24 "/usr/include/arpa/inet.h" 2 3 4







extern "C" {



extern in_addr_t inet_addr (__const char *__cp) throw ();


extern in_addr_t inet_lnaof (struct in_addr __in) throw ();



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     throw ();


extern in_addr_t inet_netof (struct in_addr __in) throw ();



extern in_addr_t inet_network (__const char *__cp) throw ();



extern char *inet_ntoa (struct in_addr __in) throw ();




extern int inet_pton (int __af, __const char *__restrict __cp,
        void *__restrict __buf) throw ();




extern __const char *inet_ntop (int __af, __const void *__restrict __cp,
    char *__restrict __buf, socklen_t __len)
     throw ();






extern int inet_aton (__const char *__cp, struct in_addr *__inp) throw ();



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) throw ();




extern char *inet_net_ntop (int __af, __const void *__cp, int __bits,
       char *__buf, size_t __len) throw ();




extern int inet_net_pton (int __af, __const char *__cp,
     void *__buf, size_t __len) throw ();




extern unsigned int inet_nsap_addr (__const char *__cp,
        unsigned char *__buf, int __len) throw ();



extern char *inet_nsap_ntoa (int __len, __const unsigned char *__cp,
        char *__buf) throw ();


}
# 4 "../../dist/system_wrappers/arpa/inet.h" 2 3
#pragma GCC visibility pop
# 54 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 2 3

# 1 "../../dist/system_wrappers/netdb.h" 1 3
       
# 2 "../../dist/system_wrappers/netdb.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/netdb.h" 1 3 4
# 26 "/usr/include/netdb.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/netdb.h" 2 3 4

# 1 "../../dist/system_wrappers/netinet/in.h" 1 3 4
       
# 2 "../../dist/system_wrappers/netinet/in.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/netdb.h" 2 3 4
# 1 "../../dist/system_wrappers/stdint.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stdint.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 30 "/usr/include/netdb.h" 2 3 4



# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 39 "/usr/include/rpc/netdb.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 40 "/usr/include/rpc/netdb.h" 2 3 4


# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 43 "/usr/include/rpc/netdb.h" 2 3 4

extern "C" {

struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) throw ();
extern void endrpcent (void) throw ();
extern struct rpcent *getrpcbyname (__const char *__name) throw ();
extern struct rpcent *getrpcbynumber (int __number) throw ();
extern struct rpcent *getrpcent (void) throw ();


extern int getrpcbyname_r (__const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) throw ();

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) throw ();

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) throw ();


}
# 34 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 39 "/usr/include/netdb.h" 2 3 4

# 1 "../../dist/system_wrappers/time.h" 1 3 4
       
# 2 "../../dist/system_wrappers/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 4 "../../dist/system_wrappers/time.h" 2 3
#pragma GCC visibility pop
# 41 "/usr/include/netdb.h" 2 3 4


# 1 "/usr/include/bits/netdb.h" 1 3 4
# 27 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 44 "/usr/include/netdb.h" 2 3 4
# 54 "/usr/include/netdb.h" 3 4
extern "C" {







extern int *__h_errno_location (void) throw () __attribute__ ((__const__));
# 93 "/usr/include/netdb.h" 3 4
extern void herror (__const char *__str) throw ();


extern __const char *hstrerror (int __err_num) throw ();




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (__const char *__name);
# 156 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (__const char *__name, int __af);
# 168 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (__const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (__const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 199 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (__const char *__name);
# 238 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (__const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (__const char *__name,
          __const char *__proto);






extern struct servent *getservbyport (int __port, __const char *__proto);
# 310 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (__const char *__restrict __name,
       __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (__const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 376 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (__const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 397 "/usr/include/netdb.h" 3 4
extern int setnetgrent (__const char *__netgroup);







extern void endnetgrent (void);
# 414 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 425 "/usr/include/netdb.h" 3 4
extern int innetgr (__const char *__netgroup, __const char *__host,
      __const char *__user, __const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 453 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   __const char *__restrict __locuser,
   __const char *__restrict __remuser,
   __const char *__restrict __cmd, int *__restrict __fd2p);
# 465 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      __const char *__restrict __locuser,
      __const char *__restrict __remuser,
      __const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 481 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    __const char *__restrict __name,
    __const char *__restrict __pass,
    __const char *__restrict __cmd, int *__restrict __fd2p);
# 493 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       __const char *__restrict __name,
       __const char *__restrict __pass,
       __const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 507 "/usr/include/netdb.h" 3 4
extern int ruserok (__const char *__rhost, int __suser,
      __const char *__remuser, __const char *__locuser);
# 517 "/usr/include/netdb.h" 3 4
extern int ruserok_af (__const char *__rhost, int __suser,
         __const char *__remuser, __const char *__locuser,
         sa_family_t __af);
# 530 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       __const char *__remuser, __const char *__locuser);
# 541 "/usr/include/netdb.h" 3 4
extern int iruserok_af (__const void *__raddr, int __suser,
   __const char *__remuser, __const char *__locuser,
   sa_family_t __af);
# 553 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 562 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __unused[5];
};
# 664 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (__const char *__restrict __name,
   __const char *__restrict __service,
   __const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) throw ();


extern __const char *gai_strerror (int __ecode) throw ();





extern int getnameinfo (__const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, unsigned int __flags);
# 694 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[],
     int __ent, struct sigevent *__restrict __sig);
# 705 "/usr/include/netdb.h" 3 4
extern int gai_suspend (__const struct gaicb *__const __list[], int __ent,
   __const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) throw ();


extern int gai_cancel (struct gaicb *__gaicbp) throw ();


}
# 4 "../../dist/system_wrappers/netdb.h" 2 3
#pragma GCC visibility pop
# 56 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinet.h" 2 3
# 20 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 2 3

extern "C" {


typedef struct PRDir PRDir;
typedef struct PRDirEntry PRDirEntry;




typedef struct PRFileDesc PRFileDesc;
typedef struct PRFileInfo PRFileInfo;
typedef struct PRFileInfo64 PRFileInfo64;
typedef union PRNetAddr PRNetAddr;
typedef struct PRIOMethods PRIOMethods;
typedef struct PRPollDesc PRPollDesc;
typedef struct PRFilePrivate PRFilePrivate;
typedef struct PRSendFileData PRSendFileData;
# 50 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef PRIntn PRDescIdentity;

struct PRFileDesc {
    const PRIOMethods *methods;
    PRFilePrivate *secret;
    PRFileDesc *lower, *higher;
    void ( *dtor)(PRFileDesc *fd);

    PRDescIdentity identity;
};
# 70 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef enum PRTransmitFileFlags {
    PR_TRANSMITFILE_KEEP_OPEN = 0,

    PR_TRANSMITFILE_CLOSE_SOCKET = 1

} PRTransmitFileFlags;
# 130 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
struct PRIPv6Addr {
 union {
  PRUint8 _S6_u8[16];
  PRUint16 _S6_u16[8];
  PRUint32 _S6_u32[4];
  PRUint64 _S6_u64[2];
 } _S6_un;
};





typedef struct PRIPv6Addr PRIPv6Addr;

union PRNetAddr {
    struct {
        PRUint16 family;



        char data[14];

    } raw;
    struct {
        PRUint16 family;
        PRUint16 port;
        PRUint32 ip;



        char pad[8];

    } inet;
    struct {
        PRUint16 family;
        PRUint16 port;
        PRUint32 flowinfo;
        PRIPv6Addr ip;
        PRUint32 scope_id;
    } ipv6;

    struct {
        PRUint16 family;




        char path[104];

    } local;

};
# 193 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef enum PRSockOption
{
    PR_SockOpt_Nonblocking,
    PR_SockOpt_Linger,
    PR_SockOpt_Reuseaddr,
    PR_SockOpt_Keepalive,
    PR_SockOpt_RecvBufferSize,
    PR_SockOpt_SendBufferSize,

    PR_SockOpt_IpTimeToLive,
    PR_SockOpt_IpTypeOfService,

    PR_SockOpt_AddMember,
    PR_SockOpt_DropMember,
    PR_SockOpt_McastInterface,
    PR_SockOpt_McastTimeToLive,
    PR_SockOpt_McastLoopback,

    PR_SockOpt_NoDelay,
    PR_SockOpt_MaxSegment,
    PR_SockOpt_Broadcast,
    PR_SockOpt_Last
} PRSockOption;

typedef struct PRLinger {
 PRBool polarity;
 PRIntervalTime linger;
} PRLinger;

typedef struct PRMcastRequest {
 PRNetAddr mcaddr;
 PRNetAddr ifaddr;
} PRMcastRequest;

typedef struct PRSocketOptionData
{
    PRSockOption option;
    union
    {
        PRUintn ip_ttl;
        PRUintn mcast_ttl;
        PRUintn tos;
        PRBool non_blocking;
        PRBool reuse_addr;
        PRBool keep_alive;
        PRBool mcast_loopback;
        PRBool no_delay;
        PRBool broadcast;
        PRSize max_segment;
        PRSize recv_buffer_size;
        PRSize send_buffer_size;
        PRLinger linger;
        PRMcastRequest add_member;
        PRMcastRequest drop_member;
        PRNetAddr mcast_if;
    } value;
} PRSocketOptionData;
# 259 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef struct PRIOVec {
    char *iov_base;
    int iov_len;
} PRIOVec;






typedef enum PRDescType
{
    PR_DESC_FILE = 1,
    PR_DESC_SOCKET_TCP = 2,
    PR_DESC_SOCKET_UDP = 3,
    PR_DESC_LAYERED = 4,
    PR_DESC_PIPE = 5
} PRDescType;

typedef enum PRSeekWhence {
    PR_SEEK_SET = 0,
    PR_SEEK_CUR = 1,
    PR_SEEK_END = 2
} PRSeekWhence;

extern __attribute__((visibility("default"))) PRDescType PR_GetDescType(PRFileDesc *file);
# 302 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef PRStatus ( *PRCloseFN)(PRFileDesc *fd);
typedef PRInt32 ( *PRReadFN)(PRFileDesc *fd, void *buf, PRInt32 amount);
typedef PRInt32 ( *PRWriteFN)(PRFileDesc *fd, const void *buf, PRInt32 amount);
typedef PRInt32 ( *PRAvailableFN)(PRFileDesc *fd);
typedef PRInt64 ( *PRAvailable64FN)(PRFileDesc *fd);
typedef PRStatus ( *PRFsyncFN)(PRFileDesc *fd);
typedef PROffset32 ( *PRSeekFN)(PRFileDesc *fd, PROffset32 offset, PRSeekWhence how);
typedef PROffset64 ( *PRSeek64FN)(PRFileDesc *fd, PROffset64 offset, PRSeekWhence how);
typedef PRStatus ( *PRFileInfoFN)(PRFileDesc *fd, PRFileInfo *info);
typedef PRStatus ( *PRFileInfo64FN)(PRFileDesc *fd, PRFileInfo64 *info);
typedef PRInt32 ( *PRWritevFN)(
    PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_size,
    PRIntervalTime timeout);
typedef PRStatus ( *PRConnectFN)(
    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout);
typedef PRFileDesc* ( *PRAcceptFN) (
    PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout);
typedef PRStatus ( *PRBindFN)(PRFileDesc *fd, const PRNetAddr *addr);
typedef PRStatus ( *PRListenFN)(PRFileDesc *fd, PRIntn backlog);
typedef PRStatus ( *PRShutdownFN)(PRFileDesc *fd, PRIntn how);
typedef PRInt32 ( *PRRecvFN)(
    PRFileDesc *fd, void *buf, PRInt32 amount,
    PRIntn flags, PRIntervalTime timeout);
typedef PRInt32 ( *PRSendFN) (
    PRFileDesc *fd, const void *buf, PRInt32 amount,
    PRIntn flags, PRIntervalTime timeout);
typedef PRInt32 ( *PRRecvfromFN)(
    PRFileDesc *fd, void *buf, PRInt32 amount,
    PRIntn flags, PRNetAddr *addr, PRIntervalTime timeout);
typedef PRInt32 ( *PRSendtoFN)(
    PRFileDesc *fd, const void *buf, PRInt32 amount,
    PRIntn flags, const PRNetAddr *addr, PRIntervalTime timeout);
typedef PRInt16 ( *PRPollFN)(
    PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags);
typedef PRInt32 ( *PRAcceptreadFN)(
    PRFileDesc *sd, PRFileDesc **nd, PRNetAddr **raddr,
    void *buf, PRInt32 amount, PRIntervalTime t);
typedef PRInt32 ( *PRTransmitfileFN)(
     PRFileDesc *sd, PRFileDesc *fd, const void *headers,
     PRInt32 hlen, PRTransmitFileFlags flags, PRIntervalTime t);
typedef PRStatus ( *PRGetsocknameFN)(PRFileDesc *fd, PRNetAddr *addr);
typedef PRStatus ( *PRGetpeernameFN)(PRFileDesc *fd, PRNetAddr *addr);
typedef PRStatus ( *PRGetsocketoptionFN)(
    PRFileDesc *fd, PRSocketOptionData *data);
typedef PRStatus ( *PRSetsocketoptionFN)(
    PRFileDesc *fd, const PRSocketOptionData *data);
typedef PRInt32 ( *PRSendfileFN)(
 PRFileDesc *networkSocket, PRSendFileData *sendData,
 PRTransmitFileFlags flags, PRIntervalTime timeout);
typedef PRStatus ( *PRConnectcontinueFN)(
    PRFileDesc *fd, PRInt16 out_flags);
typedef PRIntn ( *PRReservedFN)(PRFileDesc *fd);

struct PRIOMethods {
    PRDescType file_type;
    PRCloseFN close;
    PRReadFN read;
    PRWriteFN write;
    PRAvailableFN available;
    PRAvailable64FN available64;
    PRFsyncFN fsync;
    PRSeekFN seek;
    PRSeek64FN seek64;
    PRFileInfoFN fileInfo;
    PRFileInfo64FN fileInfo64;
    PRWritevFN writev;
    PRConnectFN connect;
    PRAcceptFN accept;
    PRBindFN bind;
    PRListenFN listen;
    PRShutdownFN shutdown;
    PRRecvFN recv;
    PRSendFN send;
    PRRecvfromFN recvfrom;
    PRSendtoFN sendto;
    PRPollFN poll;
    PRAcceptreadFN acceptread;
    PRTransmitfileFN transmitfile;
    PRGetsocknameFN getsockname;
    PRGetpeernameFN getpeername;
    PRReservedFN reserved_fn_6;
    PRReservedFN reserved_fn_5;
    PRGetsocketoptionFN getsocketoption;

    PRSetsocketoptionFN setsocketoption;

    PRSendfileFN sendfile;
    PRConnectcontinueFN connectcontinue;

    PRReservedFN reserved_fn_3;
    PRReservedFN reserved_fn_2;
    PRReservedFN reserved_fn_1;
    PRReservedFN reserved_fn_0;
};
# 416 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef enum PRSpecialFD
{
    PR_StandardInput,
    PR_StandardOutput,
    PR_StandardError
} PRSpecialFD;

extern __attribute__((visibility("default"))) PRFileDesc* PR_GetSpecialFD(PRSpecialFD id);
# 463 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRDescIdentity PR_GetUniqueIdentity(const char *layer_name);
extern __attribute__((visibility("default"))) const char* PR_GetNameForIdentity(PRDescIdentity ident);
extern __attribute__((visibility("default"))) PRDescIdentity PR_GetLayersIdentity(PRFileDesc* fd);
extern __attribute__((visibility("default"))) PRFileDesc* PR_GetIdentitiesLayer(PRFileDesc* fd_stack, PRDescIdentity id);
# 476 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) const PRIOMethods * PR_GetDefaultIOMethods(void);
# 487 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_CreateIOLayerStub(
    PRDescIdentity ident, const PRIOMethods *methods);
# 504 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_CreateIOLayer(PRFileDesc* fd);
# 520 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_PushIOLayer(
    PRFileDesc *fd_stack, PRDescIdentity id, PRFileDesc *layer);
# 537 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_PopIOLayer(PRFileDesc *fd_stack, PRDescIdentity id);
# 611 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_Open(const char *name, PRIntn flags, PRIntn mode);
# 637 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_OpenFile(
    const char *name, PRIntn flags, PRIntn mode);
# 668 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Close(PRFileDesc *fd);
# 703 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Read(PRFileDesc *fd, void *buf, PRInt32 amount);
# 727 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Write(PRFileDesc *fd,const void *buf,PRInt32 amount);
# 761 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Writev(
    PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_size,
    PRIntervalTime timeout);
# 782 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Delete(const char *name);



typedef enum PRFileType
{
    PR_FILE_FILE = 1,
    PR_FILE_DIRECTORY = 2,
    PR_FILE_OTHER = 3
} PRFileType;

struct PRFileInfo {
    PRFileType type;
    PROffset32 size;
    PRTime creationTime;
    PRTime modifyTime;
};

struct PRFileInfo64 {
    PRFileType type;
    PROffset64 size;
    PRTime creationTime;
    PRTime modifyTime;
};
# 825 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetFileInfo(const char *fn, PRFileInfo *info);
extern __attribute__((visibility("default"))) PRStatus PR_GetFileInfo64(const char *fn, PRFileInfo64 *info);
# 852 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetOpenFileInfo(PRFileDesc *fd, PRFileInfo *info);
extern __attribute__((visibility("default"))) PRStatus PR_GetOpenFileInfo64(PRFileDesc *fd, PRFileInfo64 *info);
# 871 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Rename(const char *from, const char *to);
# 897 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef enum PRAccessHow {
    PR_ACCESS_EXISTS = 1,
    PR_ACCESS_WRITE_OK = 2,
    PR_ACCESS_READ_OK = 3
} PRAccessHow;

extern __attribute__((visibility("default"))) PRStatus PR_Access(const char *name, PRAccessHow how);
# 938 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PROffset32 PR_Seek(PRFileDesc *fd, PROffset32 offset, PRSeekWhence whence);
extern __attribute__((visibility("default"))) PROffset64 PR_Seek64(PRFileDesc *fd, PROffset64 offset, PRSeekWhence whence);
# 961 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Available(PRFileDesc *fd);
extern __attribute__((visibility("default"))) PRInt64 PR_Available64(PRFileDesc *fd);
# 981 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Sync(PRFileDesc *fd);



struct PRDirEntry {
    const char *name;
};
# 1020 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRDir* PR_OpenDir(const char *name);
# 1052 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef enum PRDirFlags {
    PR_SKIP_NONE = 0x0,
    PR_SKIP_DOT = 0x1,
    PR_SKIP_DOT_DOT = 0x2,
    PR_SKIP_BOTH = 0x3,
    PR_SKIP_HIDDEN = 0x4
} PRDirFlags;

extern __attribute__((visibility("default"))) PRDirEntry* PR_ReadDir(PRDir *dir, PRDirFlags flags);
# 1086 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_CloseDir(PRDir *dir);
# 1115 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_MkDir(const char *name, PRIntn mode);
# 1127 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_MakeDir(const char *name, PRIntn mode);
# 1147 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_RmDir(const char *name);
# 1166 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_NewUDPSocket(void);
# 1185 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_NewTCPSocket(void);
# 1205 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_OpenUDPSocket(PRIntn af);
# 1225 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_OpenTCPSocket(PRIntn af);
# 1253 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Connect(
    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout);
# 1288 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_ConnectContinue(PRFileDesc *fd, PRInt16 out_flags);
# 1318 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetConnectStatus(const PRPollDesc *pd);
# 1342 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc* PR_Accept(
    PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout);
# 1364 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Bind(PRFileDesc *fd, const PRNetAddr *addr);
# 1386 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Listen(PRFileDesc *fd, PRIntn backlog);
# 1410 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef enum PRShutdownHow
{
    PR_SHUTDOWN_RCV = 0,
    PR_SHUTDOWN_SEND = 1,
    PR_SHUTDOWN_BOTH = 2
} PRShutdownHow;

extern __attribute__((visibility("default"))) PRStatus PR_Shutdown(PRFileDesc *fd, PRShutdownHow how);
# 1450 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Recv(PRFileDesc *fd, void *buf, PRInt32 amount,
                PRIntn flags, PRIntervalTime timeout);
# 1481 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Send(PRFileDesc *fd, const void *buf, PRInt32 amount,
                                PRIntn flags, PRIntervalTime timeout);
# 1516 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_RecvFrom(
    PRFileDesc *fd, void *buf, PRInt32 amount, PRIntn flags,
    PRNetAddr *addr, PRIntervalTime timeout);
# 1549 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_SendTo(
    PRFileDesc *fd, const void *buf, PRInt32 amount, PRIntn flags,
    const PRNetAddr *addr, PRIntervalTime timeout);
# 1589 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_TransmitFile(
    PRFileDesc *networkSocket, PRFileDesc *sourceFile,
    const void *headers, PRInt32 hlen, PRTransmitFileFlags flags,
    PRIntervalTime timeout);
# 1628 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
struct PRSendFileData {
 PRFileDesc *fd;
 PRUint32 file_offset;
 PRSize file_nbytes;


 const void *header;
 PRInt32 hlen;
 const void *trailer;
 PRInt32 tlen;
};


extern __attribute__((visibility("default"))) PRInt32 PR_SendFile(
    PRFileDesc *networkSocket, PRSendFileData *sendData,
 PRTransmitFileFlags flags, PRIntervalTime timeout);
# 1695 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_AcceptRead(
    PRFileDesc *listenSock, PRFileDesc **acceptedSock,
    PRNetAddr **peerAddr, void *buf, PRInt32 amount, PRIntervalTime timeout);
# 1719 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_NewTCPSocketPair(PRFileDesc *fds[2]);
# 1739 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetSockName(PRFileDesc *fd, PRNetAddr *addr);
# 1761 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetPeerName(PRFileDesc *fd, PRNetAddr *addr);

extern __attribute__((visibility("default"))) PRStatus PR_GetSocketOption(
    PRFileDesc *fd, PRSocketOptionData *data);

extern __attribute__((visibility("default"))) PRStatus PR_SetSocketOption(
    PRFileDesc *fd, const PRSocketOptionData *data);
# 1796 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_SetFDInheritable(
    PRFileDesc *fd,
    PRBool inheritable);
# 1816 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc * PR_GetInheritedFD(const char *name);
# 1826 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
typedef struct PRFileMap PRFileMap;




typedef enum PRFileMapProtect {
    PR_PROT_READONLY,
    PR_PROT_READWRITE,
    PR_PROT_WRITECOPY
} PRFileMapProtect;

extern __attribute__((visibility("default"))) PRFileMap * PR_CreateFileMap(
    PRFileDesc *fd,
    PRInt64 size,
    PRFileMapProtect prot);




extern __attribute__((visibility("default"))) PRInt32 PR_GetMemMapAlignment(void);

extern __attribute__((visibility("default"))) void * PR_MemMap(
    PRFileMap *fmap,
    PROffset64 offset,

    PRUint32 len);

extern __attribute__((visibility("default"))) PRStatus PR_MemUnmap(void *addr, PRUint32 len);

extern __attribute__((visibility("default"))) PRStatus PR_CloseFileMap(PRFileMap *fmap);
# 1870 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_CreatePipe(
    PRFileDesc **readPipe,
    PRFileDesc **writePipe
);





struct PRPollDesc {
    PRFileDesc* fd;
    PRInt16 in_flags;
    PRInt16 out_flags;
};
# 1951 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_Poll(
    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout);
# 1995 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 3
extern __attribute__((visibility("default"))) PRFileDesc * PR_NewPollableEvent(void);

extern __attribute__((visibility("default"))) PRStatus PR_DestroyPollableEvent(PRFileDesc *event);

extern __attribute__((visibility("default"))) PRStatus PR_SetPollableEvent(PRFileDesc *event);

extern __attribute__((visibility("default"))) PRStatus PR_WaitForPollableEvent(PRFileDesc *event);

}
# 4 "../../dist/system_wrappers/prio.h" 2 3
#pragma GCC visibility pop
# 18 "../../dist/include/nsIFile.h" 2
# 1 "../../dist/system_wrappers/prlink.h" 1
       
# 2 "../../dist/system_wrappers/prlink.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 1 3
# 14 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern "C" {

typedef struct PRLibrary PRLibrary;

typedef struct PRStaticLinkTable {
    const char *name;
    void (*fp)(void);
} PRStaticLinkTable;
# 30 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_SetLibraryPath(const char *path);
# 40 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) char* PR_GetLibraryPath(void);
# 53 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) char* PR_GetLibraryName(const char *dir, const char *lib);





extern __attribute__((visibility("default"))) void PR_FreeLibraryName(char *mem);
# 73 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) PRLibrary* PR_LoadLibrary(const char *name);
# 94 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
typedef enum PRLibSpecType {
    PR_LibSpec_Pathname,
    PR_LibSpec_MacNamedFragment,
    PR_LibSpec_MacIndexedFragment,
    PR_LibSpec_PathnameU
} PRLibSpecType;

struct FSSpec;

typedef struct PRLibSpec {
    PRLibSpecType type;
    union {

        const char *pathname;


        struct {
            const struct FSSpec *fsspec;
            const char *name;
        } mac_named_fragment;


        struct {
            const struct FSSpec *fsspec;
            PRUint32 index;
        } mac_indexed_fragment;


        const PRUnichar *pathname_u;
    } value;
} PRLibSpec;
# 144 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) PRLibrary *
PR_LoadLibraryWithFlags(
    PRLibSpec libSpec,
    PRIntn flags
);
# 159 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_UnloadLibrary(PRLibrary *lib);
# 169 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) void* PR_FindSymbol(PRLibrary *lib, const char *name);
# 179 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
typedef void (*PRFuncPtr)(void);
extern __attribute__((visibility("default"))) PRFuncPtr PR_FindFunctionSymbol(PRLibrary *lib, const char *name);
# 192 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) void* PR_FindSymbolAndLibrary(const char *name,
            PRLibrary* *lib);
# 203 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) PRFuncPtr PR_FindFunctionSymbolAndLibrary(const char *name,
            PRLibrary* *lib);
# 217 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 3
extern __attribute__((visibility("default"))) PRLibrary* PR_LoadStaticLibrary(
    const char *name, const PRStaticLinkTable *table);







extern __attribute__((visibility("default"))) char * PR_GetLibraryFilePathname(const char *name, PRFuncPtr addr);

}
# 4 "../../dist/system_wrappers/prlink.h" 2 3
#pragma GCC visibility pop
# 19 "../../dist/include/nsIFile.h" 2
# 1 "../../dist/system_wrappers/stdio.h" 1
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 20 "../../dist/include/nsIFile.h" 2
class nsISimpleEnumerator;
# 30 "../../dist/include/nsIFile.h"
class nsIFile : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}

  enum {
    NORMAL_FILE_TYPE = 0U,
    DIRECTORY_TYPE = 1U
  };


  virtual __attribute__ ((visibility ("hidden"))) nsresult Append(const nsAString_internal & node) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult AppendNative(const nsACString_internal & node) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Normalize(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Create(uint32_t type, uint32_t permissions) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetLeafName(nsAString_internal & aLeafName) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetLeafName(const nsAString_internal & aLeafName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetNativeLeafName(nsACString_internal & aNativeLeafName) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetNativeLeafName(const nsACString_internal & aNativeLeafName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult CopyTo(nsIFile *newParentDir, const nsAString_internal & newName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult CopyToNative(nsIFile *newParentDir, const nsACString_internal & newName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult CopyToFollowingLinks(nsIFile *newParentDir, const nsAString_internal & newName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult CopyToFollowingLinksNative(nsIFile *newParentDir, const nsACString_internal & newName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult MoveTo(nsIFile *newParentDir, const nsAString_internal & newName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult MoveToNative(nsIFile *newParentDir, const nsACString_internal & newName) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Remove(bool recursive) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetPermissions(uint32_t *aPermissions) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetPermissions(uint32_t aPermissions) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetPermissionsOfLink(uint32_t *aPermissionsOfLink) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetPermissionsOfLink(uint32_t aPermissionsOfLink) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastModifiedTime(PRTime *aLastModifiedTime) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetLastModifiedTime(PRTime aLastModifiedTime) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastModifiedTimeOfLink(PRTime *aLastModifiedTimeOfLink) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetLastModifiedTimeOfLink(PRTime aLastModifiedTimeOfLink) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetFileSize(int64_t *aFileSize) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetFileSize(int64_t aFileSize) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetFileSizeOfLink(int64_t *aFileSizeOfLink) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetTarget(nsAString_internal & aTarget) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetNativeTarget(nsACString_internal & aNativeTarget) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetPath(nsAString_internal & aPath) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetNativePath(nsACString_internal & aNativePath) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Exists(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsWritable(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsReadable(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsExecutable(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsHidden(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsDirectory(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsFile(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsSymlink(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsSpecial(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult CreateUnique(uint32_t type, uint32_t permissions) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Clone(nsIFile * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Equals(nsIFile *inFile, bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Contains(nsIFile *inFile, bool recur, bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetParent(nsIFile * *aParent) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDirectoryEntries(nsISimpleEnumerator * *aDirectoryEntries) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult InitWithPath(const nsAString_internal & filePath) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult InitWithNativePath(const nsACString_internal & filePath) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult InitWithFile(nsIFile *aFile) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetFollowLinks(bool *aFollowLinks) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetFollowLinks(bool aFollowLinks) = 0;

  enum {
    OS_READAHEAD = 1073741824U,
    DELETE_ON_CLOSE = 2147483648U
  };


  virtual __attribute__ ((visibility ("hidden"))) nsresult OpenNSPRFileDesc(int32_t flags, int32_t mode, PRFileDesc **_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult OpenANSIFileDesc(const char * mode, FILE **_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Load(PRLibrary **_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDiskSpaceAvailable(int64_t *aDiskSpaceAvailable) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult AppendRelativePath(const nsAString_internal & relativeFilePath) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult AppendRelativeNativePath(const nsACString_internal & relativeFilePath) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetPersistentDescriptor(nsACString_internal & aPersistentDescriptor) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetPersistentDescriptor(const nsACString_internal & aPersistentDescriptor) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Reveal(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Launch(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetRelativeDescriptor(nsIFile *fromFile, nsACString_internal & _retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult SetRelativeDescriptor(nsIFile *fromFile, const nsACString_internal & relativeDesc) = 0;

};

  template <class Dummy> const nsIID nsIFile::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x272a5020, 0x64f5, 0x485c, { 0xa8, 0xc4, 0x44, 0xb2, 0x88, 0x2a, 0xe0, 0xa2 }};
# 802 "../../dist/include/nsIFile.h"
# 1 "../../dist/include/nsDirectoryServiceUtils.h" 1
# 9 "../../dist/include/nsDirectoryServiceUtils.h"
# 1 "../../dist/include/nsIServiceManager.h" 1
# 25 "../../dist/include/nsIServiceManager.h"
class nsIServiceManager : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetService(const nsCID & aClass, const nsIID & aIID, void **result) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetServiceByContractID(const char * aContractID, const nsIID & aIID, void **result) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsServiceInstantiated(const nsCID & aClass, const nsIID & aIID, bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsServiceInstantiatedByContractID(const char * aContractID, const nsIID & aIID, bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsIServiceManager::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x8bb35ed9, 0xe332, 0x462d, { 0x91, 0x55, 0x4a, 0x00, 0x2a, 0xb5, 0xc9, 0x58 }};
# 130 "../../dist/include/nsIServiceManager.h"
# 1 "../../dist/include/nsComponentManagerUtils.h" 1
# 14 "../../dist/include/nsComponentManagerUtils.h"
# 1 "../../dist/include/nsCOMPtr.h" 1
# 40 "../../dist/include/nsCOMPtr.h"
# 1 "../../dist/include/nsCycleCollectionNoteChild.h" 1
# 12 "../../dist/include/nsCycleCollectionNoteChild.h"
# 1 "../../dist/include/nsCycleCollectionTraversalCallback.h" 1
# 9 "../../dist/include/nsCycleCollectionTraversalCallback.h"
# 1 "../../dist/include/nsISupports.h" 1
# 10 "../../dist/include/nsCycleCollectionTraversalCallback.h" 2

class nsCycleCollectionParticipant;

class nsCycleCollectionTraversalCallback
{
public:




  virtual __attribute__ ((visibility ("hidden"))) void DescribeRefCountedNode(nsrefcnt refcount,
                                           const char* objname) = 0;
  virtual __attribute__ ((visibility ("hidden"))) void DescribeGCedNode(bool ismarked,
                                     const char* objname) = 0;

  virtual __attribute__ ((visibility ("hidden"))) void NoteXPCOMRoot(nsISupports *root) = 0;
  virtual __attribute__ ((visibility ("hidden"))) void NoteJSRoot(void *root) = 0;
  virtual __attribute__ ((visibility ("hidden"))) void NoteNativeRoot(void *root, nsCycleCollectionParticipant *participant) = 0;

  virtual __attribute__ ((visibility ("hidden"))) void NoteXPCOMChild(nsISupports *child) = 0;
  virtual __attribute__ ((visibility ("hidden"))) void NoteJSChild(void *child) = 0;
  virtual __attribute__ ((visibility ("hidden"))) void NoteNativeChild(void *child,
                                    nsCycleCollectionParticipant *helper) = 0;





  virtual __attribute__ ((visibility ("hidden"))) void NoteNextEdgeName(const char* name) = 0;

  virtual __attribute__ ((visibility ("hidden"))) void NoteWeakMapping(void *map, void *key, void *kdelegate, void *val) = 0;

  enum {




    WANT_DEBUG_INFO = (1<<0),



    WANT_ALL_TRACES = (1<<1)
  };
  uint32_t Flags() const { return mFlags; }
  bool WantDebugInfo() const { return (mFlags & WANT_DEBUG_INFO) != 0; }
  bool WantAllTraces() const { return (mFlags & WANT_ALL_TRACES) != 0; }
protected:
  nsCycleCollectionTraversalCallback() : mFlags(0) {}

  uint32_t mFlags;
};
# 13 "../../dist/include/nsCycleCollectionNoteChild.h" 2

# 1 "../../dist/include/mozilla/TypeTraits.h" 1
# 16 "../../dist/include/mozilla/TypeTraits.h"
# 1 "../../dist/system_wrappers/wchar.h" 1
       
# 2 "../../dist/system_wrappers/wchar.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/wchar.h" 1 3 4
# 28 "/usr/include/wchar.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/wchar.h" 2 3 4
# 37 "/usr/include/wchar.h" 3 4
# 1 "../../dist/system_wrappers/stdio.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 38 "/usr/include/wchar.h" 2 3 4


# 1 "../../dist/system_wrappers/stdarg.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stdarg.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stdarg.h" 1 3 4
# 4 "../../dist/system_wrappers/stdarg.h" 2 3
#pragma GCC visibility pop
# 41 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 354 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 53 "/usr/include/wchar.h" 2 3 4
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 129 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
           __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 303 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
           size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 528 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();




extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();
# 578 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 678 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 734 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 799 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 889 "/usr/include/wchar.h" 3 4
}
# 4 "../../dist/system_wrappers/wchar.h" 2 3
#pragma GCC visibility pop
# 17 "../../dist/include/mozilla/TypeTraits.h" 2

namespace mozilla {







template<typename T, T Value>
struct IntegralConstant
{
    static const T value = Value;
    typedef T ValueType;
    typedef IntegralConstant<T, Value> Type;
};


typedef IntegralConstant<bool, true> TrueType;
typedef IntegralConstant<bool, false> FalseType;
# 52 "../../dist/include/mozilla/TypeTraits.h"
template<typename T>
struct IsPointer : FalseType {};

template<typename T>
struct IsPointer<T*> : TrueType {};
# 70 "../../dist/include/mozilla/TypeTraits.h"
template<typename T>
struct IsPod : public FalseType {};

template<> struct IsPod<char> : TrueType {};
template<> struct IsPod<signed char> : TrueType {};
template<> struct IsPod<unsigned char> : TrueType {};
template<> struct IsPod<short> : TrueType {};
template<> struct IsPod<unsigned short> : TrueType {};
template<> struct IsPod<int> : TrueType {};
template<> struct IsPod<unsigned int> : TrueType {};
template<> struct IsPod<long> : TrueType {};
template<> struct IsPod<unsigned long> : TrueType {};
template<> struct IsPod<long long> : TrueType {};
template<> struct IsPod<unsigned long long> : TrueType {};
template<> struct IsPod<bool> : TrueType {};
template<> struct IsPod<float> : TrueType {};
template<> struct IsPod<double> : TrueType {};
template<> struct IsPod<wchar_t> : TrueType {};
template<typename T> struct IsPod<T*> : TrueType {};
# 104 "../../dist/include/mozilla/TypeTraits.h"
template<typename T, typename U>
struct IsSame : FalseType {};

template<typename T>
struct IsSame<T, T> : TrueType {};

namespace detail {






template<class Base, class Derived>
struct BaseOfHelper
{
  public:
    operator Base*() const;
    operator Derived*();
};

template<class Base, class Derived>
struct BaseOfTester
{
  private:
    template<class T>
    static char test(Derived*, T);
    static int test(Base*, int);

  public:
    static const bool value =
      sizeof(test(BaseOfHelper<Base, Derived>(), int())) == sizeof(char);
};

template<class Base, class Derived>
struct BaseOfTester<Base, const Derived>
{
  private:
    template<class T>
    static char test(Derived*, T);
    static int test(Base*, int);

  public:
    static const bool value =
      sizeof(test(BaseOfHelper<Base, Derived>(), int())) == sizeof(char);
};

template<class Base, class Derived>
struct BaseOfTester<Base&, Derived&> : FalseType {};

template<class Type>
struct BaseOfTester<Type, Type> : TrueType {};

template<class Type>
struct BaseOfTester<Type, const Type> : TrueType {};

}
# 174 "../../dist/include/mozilla/TypeTraits.h"
template<class Base, class Derived>
struct IsBaseOf
  : IntegralConstant<bool, detail::BaseOfTester<Base, Derived>::value>
{};

namespace detail {

template<typename From, typename To>
struct ConvertibleTester
{
  private:
    static From create();

    template<typename From1, typename To1>
    static char test(To to);

    template<typename From1, typename To1>
    static int test(...);

  public:
    static const bool value =
      sizeof(test<From, To>(create())) == sizeof(char);
};

}
# 221 "../../dist/include/mozilla/TypeTraits.h"
template<typename From, typename To>
struct IsConvertible
  : IntegralConstant<bool, detail::ConvertibleTester<From, To>::value>
{};
# 258 "../../dist/include/mozilla/TypeTraits.h"
template<bool B, typename T = void>
struct EnableIf
{};

template<typename T>
struct EnableIf<true, T>
{
    typedef T Type;
};







template<bool Condition, typename A, typename B>
struct Conditional
{
    typedef A Type;
};

template<class A, class B>
struct Conditional<false, A, B>
{
    typedef B Type;
};

}
# 15 "../../dist/include/nsCycleCollectionNoteChild.h" 2

enum {
  CycleCollectionEdgeNameArrayFlag = 1
};


void
CycleCollectionNoteEdgeNameImpl(nsCycleCollectionTraversalCallback& aCallback,
                                const char* aName,
                                uint32_t aFlags = 0);


__attribute__((always_inline)) inline void
CycleCollectionNoteEdgeName(nsCycleCollectionTraversalCallback& aCallback,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  if ((__builtin_expect(!!(aCallback.WantDebugInfo()), 0))) {
    CycleCollectionNoteEdgeNameImpl(aCallback, aName, aFlags);
  }
}
# 46 "../../dist/include/nsCycleCollectionNoteChild.h"
template <typename T>
nsISupports* ToSupports(T* p, typename T::cycleCollection* dummy = 0)
{
  return T::cycleCollection::Upcast(p);
}



template <typename T,
          bool IsXPCOM = mozilla::IsBaseOf<nsISupports, T>::value>
struct CycleCollectionNoteChildImpl
{
};

template <typename T>
struct CycleCollectionNoteChildImpl<T, true>
{
  static void Run(nsCycleCollectionTraversalCallback& aCallback, T* aChild)
  {
    aCallback.NoteXPCOMChild(ToSupports(aChild));
  }
};

template <typename T>
struct CycleCollectionNoteChildImpl<T, false>
{
  static void Run(nsCycleCollectionTraversalCallback& aCallback, T* aChild)
  {
    aCallback.NoteNativeChild(aChild, T::cycleCollection::GetParticipant());
  }
};

template <typename T>
inline void CycleCollectionNoteChild(nsCycleCollectionTraversalCallback& aCallback,
                                     T* aChild,
                                     const char* aName,
                                     uint32_t aFlags = 0)
{
  CycleCollectionNoteEdgeName(aCallback, aName, aFlags);
  CycleCollectionNoteChildImpl<T>::Run(aCallback, aChild);
}
# 41 "../../dist/include/nsCOMPtr.h" 2
# 128 "../../dist/include/nsCOMPtr.h"
template <class T>
struct already_AddRefed
# 145 "../../dist/include/nsCOMPtr.h"
  {
    already_AddRefed( T* aRawPtr )
        : mRawPtr(aRawPtr)
      {

      }

    T* get() const { return mRawPtr; }
# 169 "../../dist/include/nsCOMPtr.h"
    template<class U>
    operator already_AddRefed<U>()
    {
      U* tmp = mRawPtr;
      mRawPtr = __null;
      return tmp;
    }

    T* mRawPtr;
  };

template <class T>
inline
const already_AddRefed<T>
getter_AddRefs( T* aRawPtr )




  {
    return already_AddRefed<T>(aRawPtr);
  }

template <class T>
inline
const already_AddRefed<T>
getter_AddRefs( const already_AddRefed<T> aAlreadyAddRefedPtr )
  {
    return aAlreadyAddRefedPtr;
  }

template <class T>
inline
const already_AddRefed<T>
dont_AddRef( T* aRawPtr )
  {
    return already_AddRefed<T>(aRawPtr);
  }

template <class T>
inline
const already_AddRefed<T>
dont_AddRef( const already_AddRefed<T> aAlreadyAddRefedPtr )
  {
    return aAlreadyAddRefedPtr;
  }



class nsCOMPtr_helper
# 234 "../../dist/include/nsCOMPtr.h"
  {
    public:
      virtual nsresult operator()( const nsIID&, void** ) const = 0;
  };
# 246 "../../dist/include/nsCOMPtr.h"
class
 
 
nsQueryInterface final
  {
    public:
      explicit
      nsQueryInterface( nsISupports* aRawPtr )
          : mRawPtr(aRawPtr)
        {

        }

      nsresult operator()( const nsIID& aIID, void** ) const;

    private:
      nsISupports* mRawPtr;
  };

class nsQueryInterfaceWithError
  {
    public:
      nsQueryInterfaceWithError( nsISupports* aRawPtr, nsresult* error )
          : mRawPtr(aRawPtr),
            mErrorPtr(error)
        {

        }

      nsresult operator()( const nsIID& aIID, void** ) const;

    private:
      nsISupports* mRawPtr;
      nsresult* mErrorPtr;
  };

inline
nsQueryInterface
do_QueryInterface( nsISupports* aRawPtr )
  {
    return nsQueryInterface(aRawPtr);
  }

inline
nsQueryInterfaceWithError
do_QueryInterface( nsISupports* aRawPtr, nsresult* error )
  {
    return nsQueryInterfaceWithError(aRawPtr, error);
  }

template <class T>
inline
void
do_QueryInterface( already_AddRefed<T>& )
  {



  }

template <class T>
inline
void
do_QueryInterface( already_AddRefed<T>&, nsresult* )
  {



  }




class nsGetServiceByCID
{
 public:
    explicit nsGetServiceByCID(const nsCID& aCID)
        : mCID(aCID)
        {

        }

    nsresult operator()( const nsIID&, void** ) const;

 private:
    const nsCID& mCID;
};

class nsGetServiceByCIDWithError
{
 public:
    nsGetServiceByCIDWithError( const nsCID& aCID, nsresult* aErrorPtr )
        : mCID(aCID),
          mErrorPtr(aErrorPtr)
        {

        }

    nsresult operator()( const nsIID&, void** ) const;

 private:
    const nsCID& mCID;
    nsresult* mErrorPtr;
};

class nsGetServiceByContractID
{
 public:
    explicit nsGetServiceByContractID(const char* aContractID)
        : mContractID(aContractID)
        {

        }

    nsresult operator()( const nsIID&, void** ) const;

 private:
    const char* mContractID;
};

class nsGetServiceByContractIDWithError
{
 public:
    nsGetServiceByContractIDWithError(const char* aContractID, nsresult* aErrorPtr)
        : mContractID(aContractID),
          mErrorPtr(aErrorPtr)
        {

        }

    nsresult operator()( const nsIID&, void** ) const;

 private:
    const char* mContractID;
    nsresult* mErrorPtr;
};

class
nsCOMPtr_base
# 397 "../../dist/include/nsCOMPtr.h"
  {
    public:

      nsCOMPtr_base( nsISupports* rawPtr = 0 )
          : mRawPtr(rawPtr)
        {

        }

      ~nsCOMPtr_base()
        {
          ;
            if ( mRawPtr )
              (mRawPtr)->Release();
        }

      void assign_with_AddRef( nsISupports* );
      void assign_from_qi( const nsQueryInterface, const nsIID& );
      void assign_from_qi_with_error( const nsQueryInterfaceWithError&, const nsIID& );
      void assign_from_gs_cid( const nsGetServiceByCID, const nsIID& );
      void assign_from_gs_cid_with_error( const nsGetServiceByCIDWithError&, const nsIID& );
      void assign_from_gs_contractid( const nsGetServiceByContractID, const nsIID& );
      void assign_from_gs_contractid_with_error( const nsGetServiceByContractIDWithError&, const nsIID& );
      void assign_from_helper( const nsCOMPtr_helper&, const nsIID& );
      void** begin_assignment();

    protected:
      nsISupports* __attribute__((__may_alias__)) mRawPtr;

      void
      assign_assuming_AddRef( nsISupports* newPtr )
        {
# 437 "../../dist/include/nsCOMPtr.h"
          nsISupports* oldPtr = mRawPtr;
          mRawPtr = newPtr;
          ;
          ;
          if ( oldPtr )
            (oldPtr)->Release();
        }
  };



template <class T>
class nsCOMPtr final

    : private nsCOMPtr_base

  {
# 486 "../../dist/include/nsCOMPtr.h"
    public:
      typedef T element_type;
# 517 "../../dist/include/nsCOMPtr.h"
      nsCOMPtr()
            : nsCOMPtr_base(0)

        {
          ;
        }

      nsCOMPtr( const nsCOMPtr<T>& aSmartPtr )
            : nsCOMPtr_base(aSmartPtr.mRawPtr)

        {
          if ( mRawPtr )
            (mRawPtr)->AddRef();
          ;
        }

      nsCOMPtr( T* aRawPtr )
            : nsCOMPtr_base(aRawPtr)

        {
          if ( mRawPtr )
            (mRawPtr)->AddRef();
          ;
          ;
        }

      nsCOMPtr( const already_AddRefed<T>& aSmartPtr )
            : nsCOMPtr_base(aSmartPtr.mRawPtr)

        {
          ;
          ;
        }

      nsCOMPtr( const nsQueryInterface qi )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_qi(qi, (T::template COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsQueryInterfaceWithError& qi )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_qi_with_error(qi, (T::template COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByCID gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_cid(gs, (T::template COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByCIDWithError& gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_cid_with_error(gs, (T::template COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByContractID gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_contractid(gs, (T::template COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByContractIDWithError& gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_contractid_with_error(gs, (T::template COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsCOMPtr_helper& helper )
            : nsCOMPtr_base(0)


        {
          ;
          assign_from_helper(helper, (T::template COMTypeInfo<int>::kIID));
          ;
        }




      nsCOMPtr<T>&
      operator=( const nsCOMPtr<T>& rhs )

        {
          assign_with_AddRef(rhs.mRawPtr);
          return *this;
        }

      nsCOMPtr<T>&
      operator=( T* rhs )

        {
          assign_with_AddRef(rhs);
          ;
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const already_AddRefed<T>& rhs )

        {
          assign_assuming_AddRef(rhs.mRawPtr);
          ;
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsQueryInterface rhs )

        {
          assign_from_qi(rhs, (T::template COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsQueryInterfaceWithError& rhs )

        {
          assign_from_qi_with_error(rhs, (T::template COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsGetServiceByCID rhs )

        {
          assign_from_gs_cid(rhs, (T::template COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsGetServiceByCIDWithError& rhs )

        {
          assign_from_gs_cid_with_error(rhs, (T::template COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsGetServiceByContractID rhs )

        {
          assign_from_gs_contractid(rhs, (T::template COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsGetServiceByContractIDWithError& rhs )

        {
          assign_from_gs_contractid_with_error(rhs, (T::template COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<T>&
      operator=( const nsCOMPtr_helper& rhs )


        {
          assign_from_helper(rhs, (T::template COMTypeInfo<int>::kIID));
          ;
          return *this;
        }

      void
      swap( nsCOMPtr<T>& rhs )

        {

          nsISupports* temp = rhs.mRawPtr;



          ;
          ;
          ;
          ;
          rhs.mRawPtr = mRawPtr;
          mRawPtr = temp;

        }

      void
      swap( T*& rhs )

        {

          nsISupports* temp = rhs;



          ;
          ;
          rhs = reinterpret_cast<T*>(mRawPtr);
          mRawPtr = temp;
          ;
        }




      already_AddRefed<T>
      forget()


        {
          T* temp = 0;
          swap(temp);
          return temp;
        }

      template <typename I>
      void
      forget( I** rhs )




        {
          do { } while(0);
          ;
          *rhs = get();
          mRawPtr = 0;
        }

      T*
      get() const




        {
          return reinterpret_cast<T*>(mRawPtr);
        }

      operator T*() const
# 776 "../../dist/include/nsCOMPtr.h"
        {
          return get();
        }

      T*
      operator->() const
        {
          do { } while(0);
          return get();
        }

      nsCOMPtr<T>*
      get_address()


        {
          return this;
        }

      const nsCOMPtr<T>*
      get_address() const


        {
          return this;
        }

    public:
      T&
      operator*() const
        {
          do { } while(0);
          return *get();
        }

      T**
      StartAssignment()
        {

          return reinterpret_cast<T**>(begin_assignment());




        }
  };
# 834 "../../dist/include/nsCOMPtr.h"
template <>
class nsCOMPtr<nsISupports>
    : private nsCOMPtr_base
  {
    public:
      typedef nsISupports element_type;



      nsCOMPtr()
            : nsCOMPtr_base(0)

        {
          ;
        }

      nsCOMPtr( const nsCOMPtr<nsISupports>& aSmartPtr )
            : nsCOMPtr_base(aSmartPtr.mRawPtr)

        {
          if ( mRawPtr )
            (mRawPtr)->AddRef();
          ;
        }

      nsCOMPtr( nsISupports* aRawPtr )
            : nsCOMPtr_base(aRawPtr)

        {
          if ( mRawPtr )
            (mRawPtr)->AddRef();
          ;
        }

      nsCOMPtr( const already_AddRefed<nsISupports>& aSmartPtr )
            : nsCOMPtr_base(aSmartPtr.mRawPtr)

        {
          ;
        }

      nsCOMPtr( const nsQueryInterface qi )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_qi(qi, (::nsISupports::COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsQueryInterfaceWithError& qi )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_qi_with_error(qi, (::nsISupports::COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByCID gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_cid(gs, (::nsISupports::COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByCIDWithError& gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_cid_with_error(gs, (::nsISupports::COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByContractID gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_contractid(gs, (::nsISupports::COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsGetServiceByContractIDWithError& gs )
            : nsCOMPtr_base(0)

        {
          ;
          assign_from_gs_contractid_with_error(gs, (::nsISupports::COMTypeInfo<int>::kIID));
        }

      nsCOMPtr( const nsCOMPtr_helper& helper )
            : nsCOMPtr_base(0)


        {
          ;
          assign_from_helper(helper, (::nsISupports::COMTypeInfo<int>::kIID));
        }




      nsCOMPtr<nsISupports>&
      operator=( const nsCOMPtr<nsISupports>& rhs )

        {
          assign_with_AddRef(rhs.mRawPtr);
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( nsISupports* rhs )

        {
          assign_with_AddRef(rhs);
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const already_AddRefed<nsISupports>& rhs )

        {
          assign_assuming_AddRef(rhs.mRawPtr);
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsQueryInterface rhs )

        {
          assign_from_qi(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsQueryInterfaceWithError& rhs )

        {
          assign_from_qi_with_error(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsGetServiceByCID rhs )

        {
          assign_from_gs_cid(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsGetServiceByCIDWithError& rhs )

        {
          assign_from_gs_cid_with_error(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsGetServiceByContractID rhs )

        {
          assign_from_gs_contractid(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsGetServiceByContractIDWithError& rhs )

        {
          assign_from_gs_contractid_with_error(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      nsCOMPtr<nsISupports>&
      operator=( const nsCOMPtr_helper& rhs )


        {
          assign_from_helper(rhs, (::nsISupports::COMTypeInfo<int>::kIID));
          return *this;
        }

      void
      swap( nsCOMPtr<nsISupports>& rhs )

        {
          nsISupports* temp = rhs.mRawPtr;
          ;
          ;
          ;
          ;
          rhs.mRawPtr = mRawPtr;
          mRawPtr = temp;
        }

      void
      swap( nsISupports*& rhs )

        {
          nsISupports* temp = rhs;
          ;
          ;
          rhs = mRawPtr;
          mRawPtr = temp;
        }

      already_AddRefed<nsISupports>
      forget()


        {
          nsISupports* temp = 0;
          swap(temp);
          return temp;
        }

      void
      forget( nsISupports** rhs )



        {
          do { } while(0);
          *rhs = 0;
          swap(*rhs);
        }



      nsISupports*
      get() const





        {
          return reinterpret_cast<nsISupports*>(mRawPtr);
        }

      operator nsISupports*() const
# 1083 "../../dist/include/nsCOMPtr.h"
        {
          return get();
        }

      nsISupports*
      operator->() const
        {
          do { } while(0);
          return get();
        }

      nsCOMPtr<nsISupports>*
      get_address()


        {
          return this;
        }

      const nsCOMPtr<nsISupports>*
      get_address() const


        {
          return this;
        }

    public:

      nsISupports&
      operator*() const
        {
          do { } while(0);
          return *get();
        }

      nsISupports**
      StartAssignment()
        {

          return reinterpret_cast<nsISupports**>(begin_assignment());




        }
  };

template <typename T>
inline void
ImplCycleCollectionUnlink(nsCOMPtr<T>& aField)
{
  aField = nullptr;
}

template <typename T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsCOMPtr<T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  CycleCollectionNoteChild(aCallback, aField.get(), aName, aFlags);
}
# 1239 "../../dist/include/nsCOMPtr.h"
template <class T>
inline
nsCOMPtr<T>*
address_of( nsCOMPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
inline
const nsCOMPtr<T>*
address_of( const nsCOMPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
class nsGetterAddRefs
# 1274 "../../dist/include/nsCOMPtr.h"
  {
    public:
      explicit
      nsGetterAddRefs( nsCOMPtr<T>& aSmartPtr )
          : mTargetSmartPtr(aSmartPtr)
        {

        }
# 1296 "../../dist/include/nsCOMPtr.h"
      operator void**()
        {
          return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
        }

      operator nsISupports**()
        {
          return reinterpret_cast<nsISupports**>(mTargetSmartPtr.StartAssignment());
        }

      operator T**()
        {
          return mTargetSmartPtr.StartAssignment();
        }

      T*&
      operator*()
        {
          return *(mTargetSmartPtr.StartAssignment());
        }

    private:
      nsCOMPtr<T>& mTargetSmartPtr;
  };


template <>
class nsGetterAddRefs<nsISupports>
  {
    public:
      explicit
      nsGetterAddRefs( nsCOMPtr<nsISupports>& aSmartPtr )
          : mTargetSmartPtr(aSmartPtr)
        {

        }
# 1340 "../../dist/include/nsCOMPtr.h"
      operator void**()
        {
          return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
        }

      operator nsISupports**()
        {
          return mTargetSmartPtr.StartAssignment();
        }

      nsISupports*&
      operator*()
        {
          return *(mTargetSmartPtr.StartAssignment());
        }

    private:
      nsCOMPtr<nsISupports>& mTargetSmartPtr;
  };


template <class T>
inline
nsGetterAddRefs<T>
getter_AddRefs( nsCOMPtr<T>& aSmartPtr )




  {
    return nsGetterAddRefs<T>(aSmartPtr);
  }

template <class T, class DestinationType>
inline
nsresult
CallQueryInterface( T* aSource, nsGetterAddRefs<DestinationType> aDestination )
{
    return CallQueryInterface(aSource,
                              static_cast<DestinationType**>(aDestination));
}




template <class T, class U>
inline
bool
operator==( const nsCOMPtr<T>& lhs, const nsCOMPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
  }


template <class T, class U>
inline
bool
operator!=( const nsCOMPtr<T>& lhs, const nsCOMPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
  }




template <class T, class U>
inline
bool
operator==( const nsCOMPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == rhs;
  }

template <class T, class U>
inline
bool
operator==( const U* lhs, const nsCOMPtr<T>& rhs )
  {
    return lhs == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsCOMPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != rhs;
  }

template <class T, class U>
inline
bool
operator!=( const U* lhs, const nsCOMPtr<T>& rhs )
  {
    return lhs != static_cast<const T*>(rhs.get());
  }
# 1445 "../../dist/include/nsCOMPtr.h"
template <class T, class U>
inline
bool
operator==( const nsCOMPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( U* lhs, const nsCOMPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsCOMPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( U* lhs, const nsCOMPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }






class NSCAP_Zero;

template <class T>
inline
bool
operator==( const nsCOMPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator==( NSCAP_Zero* lhs, const nsCOMPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
  }

template <class T>
inline
bool
operator!=( const nsCOMPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator!=( NSCAP_Zero* lhs, const nsCOMPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
  }
# 1548 "../../dist/include/nsCOMPtr.h"
inline
bool
SameCOMIdentity( nsISupports* lhs, nsISupports* rhs )
  {
    return nsCOMPtr<nsISupports>( do_QueryInterface(lhs) ) == nsCOMPtr<nsISupports>( do_QueryInterface(rhs) );
  }



template <class SourceType, class DestinationType>
inline
nsresult
CallQueryInterface( nsCOMPtr<SourceType>& aSourcePtr, DestinationType** aDestPtr )
  {
    return CallQueryInterface(aSourcePtr.get(), aDestPtr);
  }
# 15 "../../dist/include/nsComponentManagerUtils.h" 2


# 1 "../../dist/include/nsIFactory.h" 1
# 25 "../../dist/include/nsIFactory.h"
class nsIFactory : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult CreateInstance(nsISupports *aOuter, const nsIID & iid, void **result) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult LockFactory(bool lock) = 0;

};

  template <class Dummy> const nsIID nsIFactory::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x00000001, 0x0000, 0x0000, { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }};
# 18 "../../dist/include/nsComponentManagerUtils.h" 2


 nsresult
CallCreateInstance
  (const nsCID &aClass, nsISupports *aDelegate, const nsIID &aIID,
   void **aResult);

 nsresult
CallCreateInstance
  (const char *aContractID, nsISupports *aDelegate, const nsIID &aIID,
   void **aResult);

 nsresult
CallGetClassObject
  (const nsCID &aClass, const nsIID &aIID, void **aResult);

 nsresult
CallGetClassObject
  (const char *aContractID, const nsIID &aIID, void **aResult);


class nsCreateInstanceByCID : public nsCOMPtr_helper
{
public:
    nsCreateInstanceByCID( const nsCID& aCID, nsISupports* aOuter, nsresult* aErrorPtr )
        : mCID(aCID),
          mOuter(aOuter),
          mErrorPtr(aErrorPtr)
    {

    }

    virtual nsresult operator()( const nsIID&, void** ) const;

private:
    const nsCID& mCID;
    nsISupports* mOuter;
    nsresult* mErrorPtr;
};

class nsCreateInstanceByContractID : public nsCOMPtr_helper
{
public:
    nsCreateInstanceByContractID( const char* aContractID, nsISupports* aOuter, nsresult* aErrorPtr )
        : mContractID(aContractID),
          mOuter(aOuter),
          mErrorPtr(aErrorPtr)
    {

    }

    virtual nsresult operator()( const nsIID&, void** ) const;

private:
    const char* mContractID;
    nsISupports* mOuter;
    nsresult* mErrorPtr;
};

class nsCreateInstanceFromFactory : public nsCOMPtr_helper
{
public:
    nsCreateInstanceFromFactory( nsIFactory* aFactory, nsISupports* aOuter, nsresult* aErrorPtr )
        : mFactory(aFactory),
          mOuter(aOuter),
          mErrorPtr(aErrorPtr)
    {

    }

    virtual nsresult operator()( const nsIID&, void** ) const;

private:
    nsIFactory* mFactory;
    nsISupports* mOuter;
    nsresult* mErrorPtr;
};


inline
const nsCreateInstanceByCID
do_CreateInstance( const nsCID& aCID, nsresult* error = 0 )
{
    return nsCreateInstanceByCID(aCID, 0, error);
}

inline
const nsCreateInstanceByCID
do_CreateInstance( const nsCID& aCID, nsISupports* aOuter, nsresult* error = 0 )
{
    return nsCreateInstanceByCID(aCID, aOuter, error);
}

inline
const nsCreateInstanceByContractID
do_CreateInstance( const char* aContractID, nsresult* error = 0 )
{
    return nsCreateInstanceByContractID(aContractID, 0, error);
}

inline
const nsCreateInstanceByContractID
do_CreateInstance( const char* aContractID, nsISupports* aOuter, nsresult* error = 0 )
{
    return nsCreateInstanceByContractID(aContractID, aOuter, error);
}

inline
const nsCreateInstanceFromFactory
do_CreateInstance( nsIFactory* aFactory, nsresult* error = 0 )
{
    return nsCreateInstanceFromFactory(aFactory, 0, error);
}

inline
const nsCreateInstanceFromFactory
do_CreateInstance( nsIFactory* aFactory, nsISupports* aOuter, nsresult* error = 0 )
{
    return nsCreateInstanceFromFactory(aFactory, aOuter, error);
}


class nsGetClassObjectByCID : public nsCOMPtr_helper
{
public:
    nsGetClassObjectByCID( const nsCID& aCID, nsresult* aErrorPtr )
        : mCID(aCID),
          mErrorPtr(aErrorPtr)
    {

    }

    virtual nsresult operator()( const nsIID&, void** ) const;

private:
    const nsCID& mCID;
    nsresult* mErrorPtr;
};

class nsGetClassObjectByContractID : public nsCOMPtr_helper
{
public:
    nsGetClassObjectByContractID( const char* aContractID, nsresult* aErrorPtr )
        : mContractID(aContractID),
          mErrorPtr(aErrorPtr)
    {

    }

    virtual nsresult operator()( const nsIID&, void** ) const;

private:
    const char* mContractID;
    nsresult* mErrorPtr;
};
# 181 "../../dist/include/nsComponentManagerUtils.h"
inline const nsGetClassObjectByCID
do_GetClassObject( const nsCID& aCID, nsresult* error = 0 )
{
    return nsGetClassObjectByCID(aCID, error);
}

inline const nsGetClassObjectByContractID
do_GetClassObject( const char* aContractID, nsresult* error = 0 )
{
    return nsGetClassObjectByContractID(aContractID, error);
}


template <class DestinationType>
inline
nsresult
CallCreateInstance( const nsCID &aClass,
                    nsISupports *aDelegate,
                    DestinationType** aDestination )
{
    do { } while(0);

    return CallCreateInstance(aClass, aDelegate,
                              (DestinationType::template COMTypeInfo<int>::kIID),
                              reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallCreateInstance( const nsCID &aClass,
                    DestinationType** aDestination )
{
    do { } while(0);

    return CallCreateInstance(aClass, nullptr,
                              (DestinationType::template COMTypeInfo<int>::kIID),
                              reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallCreateInstance( const char *aContractID,
                    nsISupports *aDelegate,
                    DestinationType** aDestination )
{
    do { } while(0);
    do { } while(0);

    return CallCreateInstance(aContractID,
                              aDelegate,
                              (DestinationType::template COMTypeInfo<int>::kIID),
                              reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallCreateInstance( const char *aContractID,
                    DestinationType** aDestination )
{
    do { } while(0);
    do { } while(0);

    return CallCreateInstance(aContractID, nullptr,
                              (DestinationType::template COMTypeInfo<int>::kIID),
                              reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallCreateInstance( nsIFactory *aFactory,
                    nsISupports *aDelegate,
                    DestinationType** aDestination )
{
    do { } while(0);
    do { } while(0);

    return aFactory->CreateInstance(aDelegate,
                                    (DestinationType::template COMTypeInfo<int>::kIID),
                                    reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallCreateInstance( nsIFactory *aFactory,
                    DestinationType** aDestination )
{
    do { } while(0);
    do { } while(0);

    return aFactory->CreateInstance(nullptr,
                                    (DestinationType::template COMTypeInfo<int>::kIID),
                                    reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallGetClassObject( const nsCID &aClass,
                    DestinationType** aDestination )
{
    do { } while(0);

    return CallGetClassObject(aClass,
        (DestinationType::template COMTypeInfo<int>::kIID), reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallGetClassObject( const char* aContractID,
                    DestinationType** aDestination )
{
    do { } while(0);

    return CallGetClassObject(aContractID,
        (DestinationType::template COMTypeInfo<int>::kIID), reinterpret_cast<void**>(aDestination));
}
# 131 "../../dist/include/nsIServiceManager.h" 2
# 1 "../../dist/include/nsServiceManagerUtils.h" 1
# 9 "../../dist/include/nsServiceManagerUtils.h"
# 1 "../../dist/include/nsIServiceManager.h" 1
# 10 "../../dist/include/nsServiceManagerUtils.h" 2


inline
const nsGetServiceByCID
do_GetService(const nsCID& aCID)
{
    return nsGetServiceByCID(aCID);
}

inline
const nsGetServiceByCIDWithError
do_GetService(const nsCID& aCID, nsresult* error)
{
    return nsGetServiceByCIDWithError(aCID, error);
}

inline
const nsGetServiceByContractID
do_GetService(const char* aContractID)
{
    return nsGetServiceByContractID(aContractID);
}

inline
const nsGetServiceByContractIDWithError
do_GetService( const char* aContractID, nsresult* error)
{
    return nsGetServiceByContractIDWithError(aContractID, error);
}

class nsGetServiceFromCategory : public nsCOMPtr_helper
{
 public:
    nsGetServiceFromCategory(const char* aCategory, const char* aEntry,
                             nsresult* aErrorPtr)
        : mCategory(aCategory),
        mEntry(aEntry),
        mErrorPtr(aErrorPtr)
        {

        }

    virtual nsresult operator()( const nsIID&, void** ) const;
 protected:
    const char* mCategory;
    const char* mEntry;
    nsresult* mErrorPtr;
};

inline
const nsGetServiceFromCategory
do_GetServiceFromCategory( const char* category, const char* entry,
                           nsresult* error = 0)
{
    return nsGetServiceFromCategory(category, entry, error);
}

 nsresult
CallGetService(const nsCID &aClass, const nsIID &aIID, void **aResult);

 nsresult
CallGetService(const char *aContractID, const nsIID &aIID, void **aResult);


template <class DestinationType>
inline
nsresult
CallGetService( const nsCID &aClass,
                DestinationType** aDestination)
{
    do { } while(0);

    return CallGetService(aClass,
                          (DestinationType::template COMTypeInfo<int>::kIID),
                          reinterpret_cast<void**>(aDestination));
}

template <class DestinationType>
inline
nsresult
CallGetService( const char *aContractID,
                DestinationType** aDestination)
{
    do { } while(0);
    do { } while(0);

    return CallGetService(aContractID,
                          (DestinationType::template COMTypeInfo<int>::kIID),
                          reinterpret_cast<void**>(aDestination));
}
# 132 "../../dist/include/nsIServiceManager.h" 2
# 10 "../../dist/include/nsDirectoryServiceUtils.h" 2
# 1 "../../dist/include/nsIProperties.h" 1
# 25 "../../dist/include/nsIProperties.h"
class nsIProperties : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Get(const char * prop, const nsIID & iid, void **result) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Set(const char * prop, nsISupports *value) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Has(const char * prop, bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Undefine(const char * prop) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetKeys(uint32_t *count, char * **keys) = 0;

};

  template <class Dummy> const nsIID nsIProperties::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x78650582, 0x4e93, 0x4b60, { 0x8e, 0x85, 0x26, 0xeb, 0xd3, 0xeb, 0x14, 0xca }};
# 11 "../../dist/include/nsDirectoryServiceUtils.h" 2



# 1 "../../dist/include/nsIFile.h" 1
# 15 "../../dist/include/nsDirectoryServiceUtils.h" 2

inline nsresult
NS_GetSpecialDirectory(const char* specialDirName, nsIFile* *result)
{
    nsresult rv;
    nsCOMPtr<nsIProperties> serv(do_GetService("@mozilla.org/file/directory_service;1", &rv));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0))))
        return rv;

    return serv->Get(specialDirName, (::nsIFile::COMTypeInfo<int>::kIID),
                     reinterpret_cast<void**>(result));
}
# 803 "../../dist/include/nsIFile.h" 2
# 25 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 2
# 1 "../../dist/include/nsAString.h" 1
# 11 "../../dist/include/nsAString.h"
# 1 "../../dist/include/nsStringFwd.h" 1
# 23 "../../dist/include/nsStringFwd.h"
class nsAString_internal;
class nsSubstringTuple;
class nsString;
class nsAutoString;
class nsDependentString;
class nsDependentSubstring;
class nsPromiseFlatString;
class nsStringComparator;
class nsDefaultStringComparator;
class nsXPIDLString;






class nsACString_internal;
class nsCSubstringTuple;
class nsCString;
class nsAutoCString;
class nsDependentCString;
class nsDependentCSubstring;
class nsPromiseFlatCString;
class nsCStringComparator;
class nsDefaultCStringComparator;
class nsXPIDLCString;






typedef nsAString_internal nsSubstring;
typedef nsACString_internal nsCSubstring;

typedef nsString nsAFlatString;
typedef nsSubstring nsASingleFragmentString;

typedef nsCString nsAFlatCString;
typedef nsCSubstring nsASingleFragmentCString;
# 12 "../../dist/include/nsAString.h" 2



# 1 "../../dist/include/nsStringIterator.h" 1
# 10 "../../dist/include/nsStringIterator.h"
# 1 "../../dist/include/nsCharTraits.h" 1
# 9 "../../dist/include/nsCharTraits.h"
# 1 "../../dist/system_wrappers/ctype.h" 1
       
# 2 "../../dist/system_wrappers/ctype.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/ctype.h" 1 3 4
# 27 "/usr/include/ctype.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/usr/include/ctype.h" 2 3 4


extern "C" {
# 41 "/usr/include/ctype.h" 3 4
# 1 "../../dist/system_wrappers/endian.h" 1 3 4
       
# 2 "../../dist/system_wrappers/endian.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 42 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 4 "../../dist/system_wrappers/ctype.h" 2 3
#pragma GCC visibility pop
# 10 "../../dist/include/nsCharTraits.h" 2


# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 13 "../../dist/include/nsCharTraits.h" 2
# 94 "../../dist/include/nsCharTraits.h"
template <class CharT> struct nsCharTraits {};

template <>
struct nsCharTraits<PRUnichar>
  {
    typedef PRUnichar char_type;
    typedef uint16_t unsigned_char_type;
    typedef char incompatible_char_type;

    static char_type *sEmptyBuffer;

    static
    void
    assign( char_type& lhs, char_type rhs )
      {
        lhs = rhs;
      }



    typedef int int_type;

    static
    char_type
    to_char_type( int_type c )
      {
        return char_type(c);
      }

    static
    int_type
    to_int_type( char_type c )
      {
        return int_type( static_cast<unsigned_char_type>(c) );
      }

    static
    bool
    eq_int_type( int_type lhs, int_type rhs )
      {
        return lhs == rhs;
      }




    static
    bool
    eq( char_type lhs, char_type rhs )
      {
        return lhs == rhs;
      }

    static
    bool
    lt( char_type lhs, char_type rhs )
      {
        return lhs < rhs;
      }




    static
    char_type*
    move( char_type* s1, const char_type* s2, size_t n )
      {
        return static_cast<char_type*>(memmove(s1, s2, n * sizeof(char_type)));
      }

    static
    char_type*
    copy( char_type* s1, const char_type* s2, size_t n )
      {
        return static_cast<char_type*>(memcpy(s1, s2, n * sizeof(char_type)));
      }

    static
    char_type*
    copyASCII( char_type* s1, const char* s2, size_t n )
      {
        for (char_type* s = s1; n--; ++s, ++s2) {
          do { } while(0);
          *s = *s2;
        }
        return s1;
      }

    static
    char_type*
    assign( char_type* s, size_t n, char_type c )
      {
        char_type* result = s;
        while ( n-- )
          assign(*s++, c);
        return result;
      }

    static
    int
    compare( const char_type* s1, const char_type* s2, size_t n )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            if ( !eq(*s1, *s2) )
              return to_int_type(*s1) - to_int_type(*s2);
          }

        return 0;
      }

    static
    int
    compareASCII( const char_type* s1, const char* s2, size_t n )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            do { } while(0);
            if ( !eq_int_type(to_int_type(*s1), to_int_type(*s2)) )
              return to_int_type(*s1) - to_int_type(*s2);
          }

        return 0;
      }




    static
    int
    compareASCIINullTerminated( const char_type* s1, size_t n, const char* s2 )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            if ( !*s2 )
              return 1;
            do { } while(0);
            if ( !eq_int_type(to_int_type(*s1), to_int_type(*s2)) )
              return to_int_type(*s1) - to_int_type(*s2);
          }

        if ( *s2 )
          return -1;

        return 0;
      }





    static
    char_type
    ASCIIToLower( char_type c )
      {
        if (c >= 'A' && c <= 'Z')
          return char_type(c + ('a' - 'A'));

        return c;
      }

    static
    int
    compareLowerCaseToASCII( const char_type* s1, const char* s2, size_t n )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            do { } while(0);
            do { } while(0)
                                                          ;
            char_type lower_s1 = ASCIIToLower(*s1);
            if ( lower_s1 != to_char_type(*s2) )
              return to_int_type(lower_s1) - to_int_type(*s2);
          }

        return 0;
      }




    static
    int
    compareLowerCaseToASCIINullTerminated( const char_type* s1, size_t n, const char* s2 )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            if ( !*s2 )
              return 1;
            do { } while(0);
            do { } while(0)
                                                          ;
            char_type lower_s1 = ASCIIToLower(*s1);
            if ( lower_s1 != to_char_type(*s2) )
              return to_int_type(lower_s1) - to_int_type(*s2);
          }

        if ( *s2 )
          return -1;

        return 0;
      }

    static
    size_t
    length( const char_type* s )
      {
        size_t result = 0;
        while ( !eq(*s++, char_type(0)) )
          ++result;
        return result;
      }

    static
    const char_type*
    find( const char_type* s, size_t n, char_type c )
      {
        while ( n-- )
          {
            if ( eq(*s, c) )
              return s;
            ++s;
          }

        return 0;
      }
  };

template <>
struct nsCharTraits<char>
  {
    typedef char char_type;
    typedef unsigned char unsigned_char_type;
    typedef PRUnichar incompatible_char_type;

    static char_type *sEmptyBuffer;

    static
    void
    assign( char_type& lhs, char_type rhs )
      {
        lhs = rhs;
      }




    typedef int int_type;

    static
    char_type
    to_char_type( int_type c )
      {
        return char_type(c);
      }

    static
    int_type
    to_int_type( char_type c )
      {
        return int_type( static_cast<unsigned_char_type>(c) );
      }

    static
    bool
    eq_int_type( int_type lhs, int_type rhs )
      {
        return lhs == rhs;
      }




    static
    bool
    eq( char_type lhs, char_type rhs )
      {
        return lhs == rhs;
      }

    static
    bool
    lt( char_type lhs, char_type rhs )
      {
        return lhs < rhs;
      }




    static
    char_type*
    move( char_type* s1, const char_type* s2, size_t n )
      {
        return static_cast<char_type*>(memmove(s1, s2, n * sizeof(char_type)));
      }

    static
    char_type*
    copy( char_type* s1, const char_type* s2, size_t n )
      {
        return static_cast<char_type*>(memcpy(s1, s2, n * sizeof(char_type)));
      }

    static
    char_type*
    copyASCII( char_type* s1, const char* s2, size_t n )
      {
        return copy(s1, s2, n);
      }

    static
    char_type*
    assign( char_type* s, size_t n, char_type c )
      {
        return static_cast<char_type*>(memset(s, to_int_type(c), n));
      }

    static
    int
    compare( const char_type* s1, const char_type* s2, size_t n )
      {
        return memcmp(s1, s2, n);
      }

    static
    int
    compareASCII( const char_type* s1, const char* s2, size_t n )
      {






        return compare(s1, s2, n);
      }




    static
    int
    compareASCIINullTerminated( const char_type* s1, size_t n, const char* s2 )
      {


        for ( ; n--; ++s1, ++s2 )
          {
            if ( !*s2 )
              return 1;
            do { } while(0);
            if ( *s1 != *s2 )
              return to_int_type(*s1) - to_int_type(*s2);
          }

        if ( *s2 )
          return -1;

        return 0;
      }




    static
    char_type
    ASCIIToLower( char_type c )
      {
        if (c >= 'A' && c <= 'Z')
          return char_type(c + ('a' - 'A'));

        return c;
      }

    static
    int
    compareLowerCaseToASCII( const char_type* s1, const char* s2, size_t n )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            do { } while(0);
            do { } while(0)
                                                          ;
            char_type lower_s1 = ASCIIToLower(*s1);
            if ( lower_s1 != *s2 )
              return to_int_type(lower_s1) - to_int_type(*s2);
          }
        return 0;
      }




    static
    int
    compareLowerCaseToASCIINullTerminated( const char_type* s1, size_t n, const char* s2 )
      {
        for ( ; n--; ++s1, ++s2 )
          {
            if ( !*s2 )
              return 1;
            do { } while(0);
            do { } while(0)
                                                          ;
            char_type lower_s1 = ASCIIToLower(*s1);
            if ( lower_s1 != *s2 )
              return to_int_type(lower_s1) - to_int_type(*s2);
          }

        if ( *s2 )
          return -1;

        return 0;
      }

    static
    size_t
    length( const char_type* s )
      {
        return strlen(s);
      }

    static
    const char_type*
    find( const char_type* s, size_t n, char_type c )
      {
        return reinterpret_cast<const char_type*>(memchr(s, to_int_type(c), n));
      }
  };

template <class InputIterator>
struct nsCharSourceTraits
  {
    typedef typename InputIterator::difference_type difference_type;

    static
    uint32_t
    readable_distance( const InputIterator& first, const InputIterator& last )
      {

        return uint32_t(last.get() - first.get());
      }

    static
    const typename InputIterator::value_type*
    read( const InputIterator& iter )
      {
        return iter.get();
      }

    static
    void
    advance( InputIterator& s, difference_type n )
      {
        s.advance(n);
      }
  };



template <class CharT>
struct nsCharSourceTraits<CharT*>
  {
    typedef ptrdiff_t difference_type;

    static
    uint32_t
    readable_distance( CharT* s )
      {
        return uint32_t(nsCharTraits<CharT>::length(s));

      }

    static
    uint32_t
    readable_distance( CharT* first, CharT* last )
      {
        return uint32_t(last-first);
      }

    static
    const CharT*
    read( CharT* s )
      {
        return s;
      }

    static
    void
    advance( CharT*& s, difference_type n )
      {
        s += n;
      }
  };
# 666 "../../dist/include/nsCharTraits.h"
template <class OutputIterator>
struct nsCharSinkTraits
  {
    static
    void
    write( OutputIterator& iter, const typename OutputIterator::value_type* s, uint32_t n )
      {
        iter.write(s, n);
      }
  };



template <class CharT>
struct nsCharSinkTraits<CharT*>
  {
    static
    void
    write( CharT*& iter, const CharT* s, uint32_t n )
      {
        nsCharTraits<CharT>::move(iter, s, n);
        iter += n;
      }
  };
# 11 "../../dist/include/nsStringIterator.h" 2



# 1 "../../dist/include/nsAlgorithm.h" 1
# 20 "../../dist/include/nsAlgorithm.h"
template <class T>
inline
T
NS_ROUNDUP( const T& a, const T& b )
  {
    return ((a + (b - 1)) / b) * b;
  }




template <class T>
inline
const T&
XPCOM_MIN( const T& a, const T& b )
  {
    return b < a ? b : a;
  }


template <class T>
inline
const T&
XPCOM_MAX( const T& a, const T& b )
  {
    return a > b ? a : b;
  }
# 59 "../../dist/include/nsAlgorithm.h"
namespace mozilla {

template <class T>
inline
const T&
clamped( const T& a, const T& min, const T& max )
  {
    do { } while(0);
    return XPCOM_MIN(XPCOM_MAX(a, min), max);
  }

}

template <class InputIterator, class T>
inline
uint32_t
NS_COUNT( InputIterator& first, const InputIterator& last, const T& value )
  {
    uint32_t result = 0;
    for ( ; first != last; ++first )
      if ( *first == value )
        ++result;
    return result;
  }

template <class InputIterator, class OutputIterator>
inline
OutputIterator&
copy_string( const InputIterator& first, const InputIterator& last, OutputIterator& result )
  {
    typedef nsCharSourceTraits<InputIterator> source_traits;
    typedef nsCharSinkTraits<OutputIterator> sink_traits;

    sink_traits::write(result, source_traits::read(first), source_traits::readable_distance(first, last));
    return result;
  }
# 15 "../../dist/include/nsStringIterator.h" 2
# 25 "../../dist/include/nsStringIterator.h"
template <class CharT>
class nsReadingIterator
  {
    public:
      typedef nsReadingIterator<CharT> self_type;
      typedef ptrdiff_t difference_type;
      typedef CharT value_type;
      typedef const CharT* pointer;
      typedef const CharT& reference;

    private:
      friend class nsAString_internal;
      friend class nsACString_internal;






      const CharT* mStart;
      const CharT* mEnd;
      const CharT* mPosition;

    public:
      nsReadingIterator() { }



      inline void normalize_forward() {}
      inline void normalize_backward() {}

      pointer
      start() const
        {
          return mStart;
        }

      pointer
      end() const
        {
          return mEnd;
        }

      pointer
      get() const
        {
          return mPosition;
        }

      CharT
      operator*() const
        {
          return *get();
        }
# 90 "../../dist/include/nsStringIterator.h"
      self_type&
      operator++()
        {
          ++mPosition;
          return *this;
        }

      self_type
      operator++( int )
        {
          self_type result(*this);
          ++mPosition;
          return result;
        }

      self_type&
      operator--()
        {
          --mPosition;
          return *this;
        }

      self_type
      operator--( int )
        {
          self_type result(*this);
          --mPosition;
          return result;
        }

      difference_type
      size_forward() const
        {
          return mEnd - mPosition;
        }

      difference_type
      size_backward() const
        {
          return mPosition - mStart;
        }

      self_type&
      advance( difference_type n )
        {
          if (n > 0)
            {
              difference_type step = XPCOM_MIN(n, size_forward());

              do { } while(0);

              mPosition += step;
            }
          else if (n < 0)
            {
              difference_type step = XPCOM_MAX(n, -size_backward());

              do { } while(0);

              mPosition += step;
            }
          return *this;
        }
  };





template <class CharT>
class nsWritingIterator
  {
    public:
      typedef nsWritingIterator<CharT> self_type;
      typedef ptrdiff_t difference_type;
      typedef CharT value_type;
      typedef CharT* pointer;
      typedef CharT& reference;

    private:
      friend class nsAString_internal;
      friend class nsACString_internal;






      CharT* mStart;
      CharT* mEnd;
      CharT* mPosition;

    public:
      nsWritingIterator() { }



      inline void normalize_forward() {}
      inline void normalize_backward() {}

      pointer
      start() const
        {
          return mStart;
        }

      pointer
      end() const
        {
          return mEnd;
        }

      pointer
      get() const
        {
          return mPosition;
        }

      reference
      operator*() const
        {
          return *get();
        }
# 224 "../../dist/include/nsStringIterator.h"
      self_type&
      operator++()
        {
          ++mPosition;
          return *this;
        }

      self_type
      operator++( int )
        {
          self_type result(*this);
          ++mPosition;
          return result;
        }

      self_type&
      operator--()
        {
          --mPosition;
          return *this;
        }

      self_type
      operator--( int )
        {
          self_type result(*this);
          --mPosition;
          return result;
        }

      difference_type
      size_forward() const
        {
          return mEnd - mPosition;
        }

      difference_type
      size_backward() const
        {
          return mPosition - mStart;
        }

      self_type&
      advance( difference_type n )
        {
          if (n > 0)
            {
              difference_type step = XPCOM_MIN(n, size_forward());

              do { } while(0);

              mPosition += step;
            }
          else if (n < 0)
            {
              difference_type step = XPCOM_MAX(n, -size_backward());

              do { } while(0);

              mPosition += step;
            }
          return *this;
        }

      void
      write( const value_type* s, uint32_t n )
        {
          do { } while(0);

          nsCharTraits<value_type>::move(mPosition, s, n);
          advance( difference_type(n) );
        }
  };

template <class CharT>
inline
bool
operator==( const nsReadingIterator<CharT>& lhs, const nsReadingIterator<CharT>& rhs )
  {
    return lhs.get() == rhs.get();
  }

template <class CharT>
inline
bool
operator!=( const nsReadingIterator<CharT>& lhs, const nsReadingIterator<CharT>& rhs )
  {
    return lhs.get() != rhs.get();
  }






template <class CharT>
inline
bool
operator==( const nsWritingIterator<CharT>& lhs, const nsWritingIterator<CharT>& rhs )
  {
    return lhs.get() == rhs.get();
  }

template <class CharT>
inline
bool
operator!=( const nsWritingIterator<CharT>& lhs, const nsWritingIterator<CharT>& rhs )
  {
    return lhs.get() != rhs.get();
  }
# 16 "../../dist/include/nsAString.h" 2
# 26 "../../dist/include/nsAString.h"
# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "../../dist/include/nsAString.h" 2
# 1 "../../dist/system_wrappers/stdarg.h" 1
       
# 2 "../../dist/system_wrappers/stdarg.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stdarg.h" 1 3 4
# 4 "../../dist/system_wrappers/stdarg.h" 2 3
#pragma GCC visibility pop
# 28 "../../dist/include/nsAString.h" 2

# 1 "../../dist/include/mozilla/fallible.h" 1
# 30 "../../dist/include/nsAString.h" 2




# 1 "../../dist/include/string-template-def-unichar.h" 1
# 35 "../../dist/include/nsAString.h" 2
# 1 "../../dist/include/nsTSubstring.h" 1
# 16 "../../dist/include/nsTSubstring.h"
class nsStringComparator
  {
    public:
      typedef PRUnichar char_type;

      nsStringComparator() {}

      virtual int operator()( const char_type*, const char_type*, uint32_t, uint32_t ) const = 0;
  };





class nsDefaultStringComparator
    : public nsStringComparator
  {
    public:
      typedef PRUnichar char_type;

      nsDefaultStringComparator() {}

      virtual int operator()( const char_type*, const char_type*, uint32_t, uint32_t ) const;
  };
# 53 "../../dist/include/nsTSubstring.h"
class nsAString_internal
  {
    public:
      typedef mozilla::fallible_t fallible_t;

      typedef PRUnichar char_type;

      typedef nsCharTraits<char_type> char_traits;
      typedef char_traits::incompatible_char_type incompatible_char_type;

      typedef nsAString_internal self_type;
      typedef self_type abstract_string_type;
      typedef self_type base_string_type;

      typedef self_type substring_type;
      typedef nsSubstringTuple substring_tuple_type;
      typedef nsString string_type;

      typedef nsReadingIterator<char_type> const_iterator;
      typedef nsWritingIterator<char_type> iterator;

      typedef nsStringComparator comparator_type;

      typedef char_type* char_iterator;
      typedef const char_type* const_char_iterator;

      typedef uint32_t size_type;
      typedef uint32_t index_type;

    public:


      ~nsAString_internal() { Finalize(); }





      const_char_iterator BeginReading() const { return mData; }
      const_char_iterator EndReading() const { return mData + mLength; }





      const_iterator& BeginReading( const_iterator& iter ) const
        {
          iter.mStart = mData;
          iter.mEnd = mData + mLength;
          iter.mPosition = iter.mStart;
          return iter;
        }

      const_iterator& EndReading( const_iterator& iter ) const
        {
          iter.mStart = mData;
          iter.mEnd = mData + mLength;
          iter.mPosition = iter.mEnd;
          return iter;
        }

      const_char_iterator& BeginReading( const_char_iterator& iter ) const
        {
          return iter = mData;
        }

      const_char_iterator& EndReading( const_char_iterator& iter ) const
        {
          return iter = mData + mLength;
        }






      char_iterator BeginWriting()
        {
          if (!EnsureMutable())
            NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTSubstring.h", 132);

          return mData;
        }

      char_iterator BeginWriting( const fallible_t& )
        {
          return EnsureMutable() ? mData : char_iterator(0);
        }

      char_iterator EndWriting()
        {
          if (!EnsureMutable())
            NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTSubstring.h", 145);

          return mData + mLength;
        }

      char_iterator EndWriting( const fallible_t& )
        {
          return EnsureMutable() ? (mData + mLength) : char_iterator(0);
        }

      char_iterator& BeginWriting( char_iterator& iter )
        {
          return iter = BeginWriting();
        }

      char_iterator& BeginWriting( char_iterator& iter, const fallible_t& )
        {
          return iter = BeginWriting(fallible_t());
        }

      char_iterator& EndWriting( char_iterator& iter )
        {
          return iter = EndWriting();
        }

      char_iterator& EndWriting( char_iterator& iter, const fallible_t& )
        {
          return iter = EndWriting(fallible_t());
        }





      iterator& BeginWriting( iterator& iter )
        {
          char_type *data = BeginWriting();
          iter.mStart = data;
          iter.mEnd = data + mLength;
          iter.mPosition = iter.mStart;
          return iter;
        }

      iterator& EndWriting( iterator& iter )
        {
          char_type *data = BeginWriting();
          iter.mStart = data;
          iter.mEnd = data + mLength;
          iter.mPosition = iter.mEnd;
          return iter;
        }






      const char_type *Data() const
        {
          return mData;
        }

      size_type Length() const
        {
          return mLength;
        }

      bool IsEmpty() const
        {
          return mLength == 0;
        }

      bool IsVoid() const
        {
          return (mFlags & F_VOIDED) != 0;
        }

      bool IsTerminated() const
        {
          return (mFlags & F_TERMINATED) != 0;
        }

      char_type CharAt( index_type i ) const
        {
          do { } while(0);
          return mData[i];
        }

      char_type operator[]( index_type i ) const
        {
          return CharAt(i);
        }

      char_type First() const
        {
          do { } while(0);
          return mData[0];
        }

      inline
      char_type Last() const
        {
          do { } while(0);
          return mData[mLength - 1];
        }

      size_type CountChar( char_type ) const;
      int32_t FindChar( char_type, index_type offset = 0 ) const;






      bool Equals( const self_type& ) const;
      bool Equals( const self_type&, const comparator_type& ) const;

      bool Equals( const char_type* data ) const;
      bool Equals( const char_type* data, const comparator_type& comp ) const;






      bool EqualsASCII( const char* data, size_type len ) const;





      bool EqualsASCII( const char* data ) const;
# 290 "../../dist/include/nsTSubstring.h"
      template<int N>
      inline bool EqualsLiteral( const char (&str)[N] ) const
        {
          return EqualsASCII(str, N-1);
        }
      template<int N>
      inline bool EqualsLiteral( char (&str)[N] ) const
        {
          const char* s = str;
          return EqualsASCII(s, N-1);
        }
# 309 "../../dist/include/nsTSubstring.h"
      bool LowerCaseEqualsASCII( const char* data, size_type len ) const;
      bool LowerCaseEqualsASCII( const char* data ) const;
# 323 "../../dist/include/nsTSubstring.h"
      template<int N>
      inline bool LowerCaseEqualsLiteral( const char (&str)[N] ) const
        {
          return LowerCaseEqualsASCII(str, N-1);
        }
      template<int N>
      inline bool LowerCaseEqualsLiteral( char (&str)[N] ) const
        {
          const char* s = str;
          return LowerCaseEqualsASCII(s, N-1);
        }






      void Assign( char_type c );
      bool Assign( char_type c, const fallible_t& ) __attribute__((warn_unused_result));

      void
        Assign( const char_type* data, size_type length = size_type(-1) );
      bool Assign( const char_type* data, size_type length, const fallible_t& ) __attribute__((warn_unused_result));

      void Assign( const self_type& );
      bool Assign( const self_type&, const fallible_t& ) __attribute__((warn_unused_result));

      void Assign( const substring_tuple_type& );
      bool Assign( const substring_tuple_type&, const fallible_t& ) __attribute__((warn_unused_result));

      void AssignASCII( const char* data, size_type length );
      bool AssignASCII( const char* data, size_type length, const fallible_t& ) __attribute__((warn_unused_result));

      void AssignASCII( const char* data )
        {
          AssignASCII(data, strlen(data));
        }
      bool AssignASCII( const char* data, const fallible_t& ) __attribute__((warn_unused_result))
        {
          return AssignASCII(data, strlen(data), fallible_t());
        }
# 375 "../../dist/include/nsTSubstring.h"
      template<int N>
      void AssignLiteral( const char (&str)[N] )
                  { AssignASCII(str, N-1); }
      template<int N>
      void AssignLiteral( char (&str)[N] )
                  { AssignASCII(str, N-1); }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }

      void Adopt( char_type* data, size_type length = size_type(-1) );






      void Replace( index_type cutStart, size_type cutLength, char_type c );
      void Replace( index_type cutStart, size_type cutLength, const char_type* data, size_type length = size_type(-1) );
      void Replace( index_type cutStart, size_type cutLength, const self_type& str ) { Replace(cutStart, cutLength, str.Data(), str.Length()); }
      void Replace( index_type cutStart, size_type cutLength, const substring_tuple_type& tuple );

      void ReplaceASCII( index_type cutStart, size_type cutLength, const char* data, size_type length = size_type(-1) );

      void Append( char_type c ) { Replace(mLength, 0, c); }
      void Append( const char_type* data, size_type length = size_type(-1) ) { Replace(mLength, 0, data, length); }
      void Append( const self_type& str ) { Replace(mLength, 0, str); }
      void Append( const substring_tuple_type& tuple ) { Replace(mLength, 0, tuple); }

      void AppendASCII( const char* data, size_type length = size_type(-1) ) { ReplaceASCII(mLength, 0, data, length); }





      void AppendPrintf( const char* format, ... );
      void AppendPrintf( const char* format, va_list ap );
      void AppendInt( int32_t aInteger )
                 { AppendPrintf( "%d", aInteger ); }
      void AppendInt( int32_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%d" : aRadix == 8 ? "%o" : "%x";
          AppendPrintf( fmt, aInteger );
        }
      void AppendInt( uint32_t aInteger )
                 { AppendPrintf( "%u", aInteger ); }
      void AppendInt( uint32_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%u" : aRadix == 8 ? "%o" : "%x";
          AppendPrintf( fmt, aInteger );
        }
      void AppendInt( int64_t aInteger )
                 { AppendPrintf( "%lld", aInteger ); }
      void AppendInt( int64_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%lld" : aRadix == 8 ? "%llo" : "%llx";
          AppendPrintf( fmt, aInteger );
        }
      void AppendInt( uint64_t aInteger )
                 { AppendPrintf( "%llu", aInteger ); }
      void AppendInt( uint64_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%llu" : aRadix == 8 ? "%llo" : "%llx";
          AppendPrintf( fmt, aInteger );
        }




      void AppendFloat( float aFloat )
                      { DoAppendFloat(aFloat, 6); }
      void AppendFloat( double aFloat )
                      { DoAppendFloat(aFloat, 15); }
  private:
      void DoAppendFloat( double aFloat, int digits );
  public:
# 462 "../../dist/include/nsTSubstring.h"
      template<int N>
      void AppendLiteral( const char (&str)[N] )
                  { AppendASCII(str, N-1); }
      template<int N>
      void AppendLiteral( char (&str)[N] )
                  { AppendASCII(str, N-1); }


      self_type& operator+=( char_type c ) { Append(c); return *this; }
      self_type& operator+=( const char_type* data ) { Append(data); return *this; }
      self_type& operator+=( const self_type& str ) { Append(str); return *this; }
      self_type& operator+=( const substring_tuple_type& tuple ) { Append(tuple); return *this; }

      void Insert( char_type c, index_type pos ) { Replace(pos, 0, c); }
      void Insert( const char_type* data, index_type pos, size_type length = size_type(-1) ) { Replace(pos, 0, data, length); }
      void Insert( const self_type& str, index_type pos ) { Replace(pos, 0, str); }
      void Insert( const substring_tuple_type& tuple, index_type pos ) { Replace(pos, 0, tuple); }

      void Cut( index_type cutStart, size_type cutLength ) { Replace(cutStart, cutLength, char_traits::sEmptyBuffer, 0); }
# 494 "../../dist/include/nsTSubstring.h"
      void SetCapacity( size_type newCapacity );
      bool SetCapacity( size_type newCapacity, const fallible_t& ) __attribute__((warn_unused_result));

      void SetLength( size_type newLength );
      bool SetLength( size_type newLength, const fallible_t& ) __attribute__((warn_unused_result));

      void Truncate( size_type newLength = 0 )
        {
          do { } while(0);
          SetLength(newLength);
        }
# 518 "../../dist/include/nsTSubstring.h"
      inline size_type GetData( const char_type** data ) const
        {
          *data = mData;
          return mLength;
        }
# 534 "../../dist/include/nsTSubstring.h"
      size_type GetMutableData( char_type** data, size_type newLen = size_type(-1) )
        {
          if (!EnsureMutable(newLen))
            NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTSubstring.h", 537);

          *data = mData;
          return mLength;
        }

      size_type GetMutableData( char_type** data, size_type newLen, const fallible_t& )
        {
          if (!EnsureMutable(newLen))
            {
              *data = nullptr;
              return 0;
            }

          *data = mData;
          return mLength;
        }







      void SetIsVoid( bool );
# 571 "../../dist/include/nsTSubstring.h"
      void StripChar( char_type aChar, int32_t aOffset=0 );
# 581 "../../dist/include/nsTSubstring.h"
      void StripChars( const char_type* aChars, uint32_t aOffset=0 );





      void ForgetSharedBuffer()
      {
        if (mFlags & nsSubstring::F_SHARED)
          {
            mData = char_traits::sEmptyBuffer;
            mLength = 0;
            mFlags = F_TERMINATED;
          }
      }

    public:





      nsAString_internal(const substring_tuple_type& tuple)
        : mData(nullptr),
          mLength(0),
          mFlags(F_NONE)
        {
          Assign(tuple);
        }
# 623 "../../dist/include/nsTSubstring.h"
      nsAString_internal( char_type *data, size_type length, uint32_t flags )
        : mData(data),
          mLength(length),
          mFlags(flags) {}


      size_t SizeOfExcludingThisMustBeUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;
      size_t SizeOfIncludingThisMustBeUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;

      size_t SizeOfExcludingThisIfUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;
      size_t SizeOfIncludingThisIfUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;







      size_t SizeOfExcludingThisEvenIfShared(nsMallocSizeOfFun mallocSizeOf)
        const;
      size_t SizeOfIncludingThisEvenIfShared(nsMallocSizeOfFun mallocSizeOf)
        const;

    protected:

      friend class nsTObsoleteAStringThunk_CharT;
      friend class nsSubstringTuple;


      friend class nsPromiseFlatString;

      char_type* mData;
      size_type mLength;
      uint32_t mFlags;


      nsAString_internal()
        : mData(char_traits::sEmptyBuffer),
          mLength(0),
          mFlags(F_TERMINATED) {}


      explicit
      nsAString_internal( uint32_t flags )
        : mFlags(flags) {}



      nsAString_internal( const self_type& str )
        : mData(str.mData),
          mLength(str.mLength),
          mFlags(str.mFlags & (F_TERMINATED | F_VOIDED)) {}






      void Finalize();
# 705 "../../dist/include/nsTSubstring.h"
      bool MutatePrep( size_type capacity, char_type** old_data, uint32_t* old_flags );
# 727 "../../dist/include/nsTSubstring.h"
      bool ReplacePrep(index_type cutStart, size_type cutLength,
                       size_type newLength) __attribute__((warn_unused_result))
      {
        cutLength = XPCOM_MIN(cutLength, mLength - cutStart);
        uint32_t newTotalLen = mLength - cutLength + newLength;
        if (cutStart == mLength && Capacity() > newTotalLen) {
          mFlags &= ~F_VOIDED;
          mData[newTotalLen] = char_type(0);
          mLength = newTotalLen;
          return true;
        }
        return ReplacePrepInternal(cutStart, cutLength, newLength, newTotalLen);
      }

      bool ReplacePrepInternal(index_type cutStart,
                                           size_type cutLength,
                                           size_type newFragLength,
                                           size_type newTotalLength)
        __attribute__((warn_unused_result));
# 754 "../../dist/include/nsTSubstring.h"
      size_type Capacity() const;





      bool EnsureMutable( size_type newLen = size_type(-1) ) __attribute__((warn_unused_result));




      bool IsDependentOn( const char_type *start, const char_type *end ) const
        {
# 775 "../../dist/include/nsTSubstring.h"
          return ( start < (mData + mLength) && end > mData );
        }




      void SetDataFlags(uint32_t dataFlags)
        {
          do { } while(0);
          mFlags = dataFlags | (mFlags & 0xFFFF0000);
        }

      static int AppendFunc( void* arg, const char* s, uint32_t len);

    public:







      enum
        {
          F_NONE = 0,


          F_TERMINATED = 1 << 0,
          F_VOIDED = 1 << 1,
          F_SHARED = 1 << 2,
          F_OWNED = 1 << 3,
          F_FIXED = 1 << 4,


          F_CLASS_FIXED = 1 << 16
        };
# 845 "../../dist/include/nsTSubstring.h"
  };

int Compare( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs, const nsStringComparator& = nsDefaultStringComparator() );


inline
bool operator!=( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs )
  {
    return !lhs.Equals(rhs);
  }

inline
bool operator< ( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)< 0;
  }

inline
bool operator<=( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)<=0;
  }

inline
bool operator==( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs )
  {
    return lhs.Equals(rhs);
  }

inline
bool operator==( const nsAString_internal::base_string_type& lhs, const nsAString_internal::char_type* rhs )
  {
    return lhs.Equals(rhs);
  }


inline
bool operator>=( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)>=0;
  }

inline
bool operator> ( const nsAString_internal::base_string_type& lhs, const nsAString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)> 0;
  }
# 36 "../../dist/include/nsAString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 37 "../../dist/include/nsAString.h" 2


# 1 "../../dist/include/string-template-def-char.h" 1
# 40 "../../dist/include/nsAString.h" 2
# 1 "../../dist/include/nsTSubstring.h" 1
# 16 "../../dist/include/nsTSubstring.h"
class nsCStringComparator
  {
    public:
      typedef char char_type;

      nsCStringComparator() {}

      virtual int operator()( const char_type*, const char_type*, uint32_t, uint32_t ) const = 0;
  };





class nsDefaultCStringComparator
    : public nsCStringComparator
  {
    public:
      typedef char char_type;

      nsDefaultCStringComparator() {}

      virtual int operator()( const char_type*, const char_type*, uint32_t, uint32_t ) const;
  };
# 53 "../../dist/include/nsTSubstring.h"
class nsACString_internal
  {
    public:
      typedef mozilla::fallible_t fallible_t;

      typedef char char_type;

      typedef nsCharTraits<char_type> char_traits;
      typedef char_traits::incompatible_char_type incompatible_char_type;

      typedef nsACString_internal self_type;
      typedef self_type abstract_string_type;
      typedef self_type base_string_type;

      typedef self_type substring_type;
      typedef nsCSubstringTuple substring_tuple_type;
      typedef nsCString string_type;

      typedef nsReadingIterator<char_type> const_iterator;
      typedef nsWritingIterator<char_type> iterator;

      typedef nsCStringComparator comparator_type;

      typedef char_type* char_iterator;
      typedef const char_type* const_char_iterator;

      typedef uint32_t size_type;
      typedef uint32_t index_type;

    public:


      ~nsACString_internal() { Finalize(); }





      const_char_iterator BeginReading() const { return mData; }
      const_char_iterator EndReading() const { return mData + mLength; }





      const_iterator& BeginReading( const_iterator& iter ) const
        {
          iter.mStart = mData;
          iter.mEnd = mData + mLength;
          iter.mPosition = iter.mStart;
          return iter;
        }

      const_iterator& EndReading( const_iterator& iter ) const
        {
          iter.mStart = mData;
          iter.mEnd = mData + mLength;
          iter.mPosition = iter.mEnd;
          return iter;
        }

      const_char_iterator& BeginReading( const_char_iterator& iter ) const
        {
          return iter = mData;
        }

      const_char_iterator& EndReading( const_char_iterator& iter ) const
        {
          return iter = mData + mLength;
        }






      char_iterator BeginWriting()
        {
          if (!EnsureMutable())
            NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTSubstring.h", 132);

          return mData;
        }

      char_iterator BeginWriting( const fallible_t& )
        {
          return EnsureMutable() ? mData : char_iterator(0);
        }

      char_iterator EndWriting()
        {
          if (!EnsureMutable())
            NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTSubstring.h", 145);

          return mData + mLength;
        }

      char_iterator EndWriting( const fallible_t& )
        {
          return EnsureMutable() ? (mData + mLength) : char_iterator(0);
        }

      char_iterator& BeginWriting( char_iterator& iter )
        {
          return iter = BeginWriting();
        }

      char_iterator& BeginWriting( char_iterator& iter, const fallible_t& )
        {
          return iter = BeginWriting(fallible_t());
        }

      char_iterator& EndWriting( char_iterator& iter )
        {
          return iter = EndWriting();
        }

      char_iterator& EndWriting( char_iterator& iter, const fallible_t& )
        {
          return iter = EndWriting(fallible_t());
        }





      iterator& BeginWriting( iterator& iter )
        {
          char_type *data = BeginWriting();
          iter.mStart = data;
          iter.mEnd = data + mLength;
          iter.mPosition = iter.mStart;
          return iter;
        }

      iterator& EndWriting( iterator& iter )
        {
          char_type *data = BeginWriting();
          iter.mStart = data;
          iter.mEnd = data + mLength;
          iter.mPosition = iter.mEnd;
          return iter;
        }






      const char_type *Data() const
        {
          return mData;
        }

      size_type Length() const
        {
          return mLength;
        }

      bool IsEmpty() const
        {
          return mLength == 0;
        }

      bool IsVoid() const
        {
          return (mFlags & F_VOIDED) != 0;
        }

      bool IsTerminated() const
        {
          return (mFlags & F_TERMINATED) != 0;
        }

      char_type CharAt( index_type i ) const
        {
          do { } while(0);
          return mData[i];
        }

      char_type operator[]( index_type i ) const
        {
          return CharAt(i);
        }

      char_type First() const
        {
          do { } while(0);
          return mData[0];
        }

      inline
      char_type Last() const
        {
          do { } while(0);
          return mData[mLength - 1];
        }

      size_type CountChar( char_type ) const;
      int32_t FindChar( char_type, index_type offset = 0 ) const;






      bool Equals( const self_type& ) const;
      bool Equals( const self_type&, const comparator_type& ) const;

      bool Equals( const char_type* data ) const;
      bool Equals( const char_type* data, const comparator_type& comp ) const;






      bool EqualsASCII( const char* data, size_type len ) const;





      bool EqualsASCII( const char* data ) const;
# 290 "../../dist/include/nsTSubstring.h"
      template<int N>
      inline bool EqualsLiteral( const char (&str)[N] ) const
        {
          return EqualsASCII(str, N-1);
        }
      template<int N>
      inline bool EqualsLiteral( char (&str)[N] ) const
        {
          const char* s = str;
          return EqualsASCII(s, N-1);
        }
# 309 "../../dist/include/nsTSubstring.h"
      bool LowerCaseEqualsASCII( const char* data, size_type len ) const;
      bool LowerCaseEqualsASCII( const char* data ) const;
# 323 "../../dist/include/nsTSubstring.h"
      template<int N>
      inline bool LowerCaseEqualsLiteral( const char (&str)[N] ) const
        {
          return LowerCaseEqualsASCII(str, N-1);
        }
      template<int N>
      inline bool LowerCaseEqualsLiteral( char (&str)[N] ) const
        {
          const char* s = str;
          return LowerCaseEqualsASCII(s, N-1);
        }






      void Assign( char_type c );
      bool Assign( char_type c, const fallible_t& ) __attribute__((warn_unused_result));

      void
        Assign( const char_type* data, size_type length = size_type(-1) );
      bool Assign( const char_type* data, size_type length, const fallible_t& ) __attribute__((warn_unused_result));

      void Assign( const self_type& );
      bool Assign( const self_type&, const fallible_t& ) __attribute__((warn_unused_result));

      void Assign( const substring_tuple_type& );
      bool Assign( const substring_tuple_type&, const fallible_t& ) __attribute__((warn_unused_result));

      void AssignASCII( const char* data, size_type length );
      bool AssignASCII( const char* data, size_type length, const fallible_t& ) __attribute__((warn_unused_result));

      void AssignASCII( const char* data )
        {
          AssignASCII(data, strlen(data));
        }
      bool AssignASCII( const char* data, const fallible_t& ) __attribute__((warn_unused_result))
        {
          return AssignASCII(data, strlen(data), fallible_t());
        }
# 375 "../../dist/include/nsTSubstring.h"
      template<int N>
      void AssignLiteral( const char (&str)[N] )
                  { AssignASCII(str, N-1); }
      template<int N>
      void AssignLiteral( char (&str)[N] )
                  { AssignASCII(str, N-1); }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }

      void Adopt( char_type* data, size_type length = size_type(-1) );






      void Replace( index_type cutStart, size_type cutLength, char_type c );
      void Replace( index_type cutStart, size_type cutLength, const char_type* data, size_type length = size_type(-1) );
      void Replace( index_type cutStart, size_type cutLength, const self_type& str ) { Replace(cutStart, cutLength, str.Data(), str.Length()); }
      void Replace( index_type cutStart, size_type cutLength, const substring_tuple_type& tuple );

      void ReplaceASCII( index_type cutStart, size_type cutLength, const char* data, size_type length = size_type(-1) );

      void Append( char_type c ) { Replace(mLength, 0, c); }
      void Append( const char_type* data, size_type length = size_type(-1) ) { Replace(mLength, 0, data, length); }
      void Append( const self_type& str ) { Replace(mLength, 0, str); }
      void Append( const substring_tuple_type& tuple ) { Replace(mLength, 0, tuple); }

      void AppendASCII( const char* data, size_type length = size_type(-1) ) { ReplaceASCII(mLength, 0, data, length); }





      void AppendPrintf( const char* format, ... );
      void AppendPrintf( const char* format, va_list ap );
      void AppendInt( int32_t aInteger )
                 { AppendPrintf( "%d", aInteger ); }
      void AppendInt( int32_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%d" : aRadix == 8 ? "%o" : "%x";
          AppendPrintf( fmt, aInteger );
        }
      void AppendInt( uint32_t aInteger )
                 { AppendPrintf( "%u", aInteger ); }
      void AppendInt( uint32_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%u" : aRadix == 8 ? "%o" : "%x";
          AppendPrintf( fmt, aInteger );
        }
      void AppendInt( int64_t aInteger )
                 { AppendPrintf( "%lld", aInteger ); }
      void AppendInt( int64_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%lld" : aRadix == 8 ? "%llo" : "%llx";
          AppendPrintf( fmt, aInteger );
        }
      void AppendInt( uint64_t aInteger )
                 { AppendPrintf( "%llu", aInteger ); }
      void AppendInt( uint64_t aInteger, int aRadix )
        {
          const char *fmt = aRadix == 10 ? "%llu" : aRadix == 8 ? "%llo" : "%llx";
          AppendPrintf( fmt, aInteger );
        }




      void AppendFloat( float aFloat )
                      { DoAppendFloat(aFloat, 6); }
      void AppendFloat( double aFloat )
                      { DoAppendFloat(aFloat, 15); }
  private:
      void DoAppendFloat( double aFloat, int digits );
  public:
# 462 "../../dist/include/nsTSubstring.h"
      template<int N>
      void AppendLiteral( const char (&str)[N] )
                  { AppendASCII(str, N-1); }
      template<int N>
      void AppendLiteral( char (&str)[N] )
                  { AppendASCII(str, N-1); }


      self_type& operator+=( char_type c ) { Append(c); return *this; }
      self_type& operator+=( const char_type* data ) { Append(data); return *this; }
      self_type& operator+=( const self_type& str ) { Append(str); return *this; }
      self_type& operator+=( const substring_tuple_type& tuple ) { Append(tuple); return *this; }

      void Insert( char_type c, index_type pos ) { Replace(pos, 0, c); }
      void Insert( const char_type* data, index_type pos, size_type length = size_type(-1) ) { Replace(pos, 0, data, length); }
      void Insert( const self_type& str, index_type pos ) { Replace(pos, 0, str); }
      void Insert( const substring_tuple_type& tuple, index_type pos ) { Replace(pos, 0, tuple); }

      void Cut( index_type cutStart, size_type cutLength ) { Replace(cutStart, cutLength, char_traits::sEmptyBuffer, 0); }
# 494 "../../dist/include/nsTSubstring.h"
      void SetCapacity( size_type newCapacity );
      bool SetCapacity( size_type newCapacity, const fallible_t& ) __attribute__((warn_unused_result));

      void SetLength( size_type newLength );
      bool SetLength( size_type newLength, const fallible_t& ) __attribute__((warn_unused_result));

      void Truncate( size_type newLength = 0 )
        {
          do { } while(0);
          SetLength(newLength);
        }
# 518 "../../dist/include/nsTSubstring.h"
      inline size_type GetData( const char_type** data ) const
        {
          *data = mData;
          return mLength;
        }
# 534 "../../dist/include/nsTSubstring.h"
      size_type GetMutableData( char_type** data, size_type newLen = size_type(-1) )
        {
          if (!EnsureMutable(newLen))
            NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTSubstring.h", 537);

          *data = mData;
          return mLength;
        }

      size_type GetMutableData( char_type** data, size_type newLen, const fallible_t& )
        {
          if (!EnsureMutable(newLen))
            {
              *data = nullptr;
              return 0;
            }

          *data = mData;
          return mLength;
        }







      void SetIsVoid( bool );
# 571 "../../dist/include/nsTSubstring.h"
      void StripChar( char_type aChar, int32_t aOffset=0 );
# 581 "../../dist/include/nsTSubstring.h"
      void StripChars( const char_type* aChars, uint32_t aOffset=0 );





      void ForgetSharedBuffer()
      {
        if (mFlags & nsSubstring::F_SHARED)
          {
            mData = char_traits::sEmptyBuffer;
            mLength = 0;
            mFlags = F_TERMINATED;
          }
      }

    public:





      nsACString_internal(const substring_tuple_type& tuple)
        : mData(nullptr),
          mLength(0),
          mFlags(F_NONE)
        {
          Assign(tuple);
        }
# 623 "../../dist/include/nsTSubstring.h"
      nsACString_internal( char_type *data, size_type length, uint32_t flags )
        : mData(data),
          mLength(length),
          mFlags(flags) {}


      size_t SizeOfExcludingThisMustBeUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;
      size_t SizeOfIncludingThisMustBeUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;

      size_t SizeOfExcludingThisIfUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;
      size_t SizeOfIncludingThisIfUnshared(nsMallocSizeOfFun mallocSizeOf)
        const;







      size_t SizeOfExcludingThisEvenIfShared(nsMallocSizeOfFun mallocSizeOf)
        const;
      size_t SizeOfIncludingThisEvenIfShared(nsMallocSizeOfFun mallocSizeOf)
        const;

    protected:

      friend class nsTObsoleteAStringThunk_CharT;
      friend class nsCSubstringTuple;


      friend class nsPromiseFlatCString;

      char_type* mData;
      size_type mLength;
      uint32_t mFlags;


      nsACString_internal()
        : mData(char_traits::sEmptyBuffer),
          mLength(0),
          mFlags(F_TERMINATED) {}


      explicit
      nsACString_internal( uint32_t flags )
        : mFlags(flags) {}



      nsACString_internal( const self_type& str )
        : mData(str.mData),
          mLength(str.mLength),
          mFlags(str.mFlags & (F_TERMINATED | F_VOIDED)) {}






      void Finalize();
# 705 "../../dist/include/nsTSubstring.h"
      bool MutatePrep( size_type capacity, char_type** old_data, uint32_t* old_flags );
# 727 "../../dist/include/nsTSubstring.h"
      bool ReplacePrep(index_type cutStart, size_type cutLength,
                       size_type newLength) __attribute__((warn_unused_result))
      {
        cutLength = XPCOM_MIN(cutLength, mLength - cutStart);
        uint32_t newTotalLen = mLength - cutLength + newLength;
        if (cutStart == mLength && Capacity() > newTotalLen) {
          mFlags &= ~F_VOIDED;
          mData[newTotalLen] = char_type(0);
          mLength = newTotalLen;
          return true;
        }
        return ReplacePrepInternal(cutStart, cutLength, newLength, newTotalLen);
      }

      bool ReplacePrepInternal(index_type cutStart,
                                           size_type cutLength,
                                           size_type newFragLength,
                                           size_type newTotalLength)
        __attribute__((warn_unused_result));
# 754 "../../dist/include/nsTSubstring.h"
      size_type Capacity() const;





      bool EnsureMutable( size_type newLen = size_type(-1) ) __attribute__((warn_unused_result));




      bool IsDependentOn( const char_type *start, const char_type *end ) const
        {
# 775 "../../dist/include/nsTSubstring.h"
          return ( start < (mData + mLength) && end > mData );
        }




      void SetDataFlags(uint32_t dataFlags)
        {
          do { } while(0);
          mFlags = dataFlags | (mFlags & 0xFFFF0000);
        }

      static int AppendFunc( void* arg, const char* s, uint32_t len);

    public:







      enum
        {
          F_NONE = 0,


          F_TERMINATED = 1 << 0,
          F_VOIDED = 1 << 1,
          F_SHARED = 1 << 2,
          F_OWNED = 1 << 3,
          F_FIXED = 1 << 4,


          F_CLASS_FIXED = 1 << 16
        };
# 845 "../../dist/include/nsTSubstring.h"
  };

int Compare( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs, const nsCStringComparator& = nsDefaultCStringComparator() );


inline
bool operator!=( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs )
  {
    return !lhs.Equals(rhs);
  }

inline
bool operator< ( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)< 0;
  }

inline
bool operator<=( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)<=0;
  }

inline
bool operator==( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs )
  {
    return lhs.Equals(rhs);
  }

inline
bool operator==( const nsACString_internal::base_string_type& lhs, const nsACString_internal::char_type* rhs )
  {
    return lhs.Equals(rhs);
  }


inline
bool operator>=( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)>=0;
  }

inline
bool operator> ( const nsACString_internal::base_string_type& lhs, const nsACString_internal::base_string_type& rhs )
  {
    return Compare(lhs, rhs)> 0;
  }
# 41 "../../dist/include/nsAString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 42 "../../dist/include/nsAString.h" 2






class nsCaseInsensitiveCStringComparator
    : public nsCStringComparator
  {
    public:
      nsCaseInsensitiveCStringComparator() {}
      typedef char char_type;

      virtual int operator()( const char_type*, const char_type*, uint32_t, uint32_t ) const;
  };

class nsCaseInsensitiveCStringArrayComparator
  {
    public:
      template<class A, class B>
      bool Equals(const A& a, const B& b) const {
        return a.Equals(b, nsCaseInsensitiveCStringComparator());
      }
  };



# 1 "../../dist/include/nsSubstringTuple.h" 1
# 11 "../../dist/include/nsSubstringTuple.h"
# 1 "../../dist/include/nsSubstring.h" 1
# 12 "../../dist/include/nsSubstringTuple.h" 2



# 1 "../../dist/include/string-template-def-unichar.h" 1
# 16 "../../dist/include/nsSubstringTuple.h" 2
# 1 "../../dist/include/nsTSubstringTuple.h" 1
# 18 "../../dist/include/nsTSubstringTuple.h"
class nsSubstringTuple
  {
    public:

      typedef PRUnichar char_type;
      typedef nsCharTraits<char_type> char_traits;

      typedef nsSubstringTuple self_type;
      typedef nsAString_internal substring_type;
      typedef nsAString_internal base_string_type;
      typedef uint32_t size_type;

    public:

      nsSubstringTuple(const base_string_type* a, const base_string_type* b)
        : mHead(nullptr)
        , mFragA(a)
        , mFragB(b) {}

      nsSubstringTuple(const self_type& head, const base_string_type* b)
        : mHead(&head)
        , mFragA(nullptr)
        , mFragB(b) {}




      size_type Length() const;






      void WriteTo(char_type *buf, uint32_t bufLen) const;





      bool IsDependentOn(const char_type *start, const char_type *end) const;

    private:

      const self_type* mHead;
      const base_string_type* mFragA;
      const base_string_type* mFragB;
  };

inline
const nsSubstringTuple
operator+(const nsSubstringTuple::base_string_type& a, const nsSubstringTuple::base_string_type& b)
  {
    return nsSubstringTuple(&a, &b);
  }

inline
const nsSubstringTuple
operator+(const nsSubstringTuple& head, const nsSubstringTuple::base_string_type& b)
  {
    return nsSubstringTuple(head, &b);
  }
# 17 "../../dist/include/nsSubstringTuple.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 18 "../../dist/include/nsSubstringTuple.h" 2


# 1 "../../dist/include/string-template-def-char.h" 1
# 21 "../../dist/include/nsSubstringTuple.h" 2
# 1 "../../dist/include/nsTSubstringTuple.h" 1
# 18 "../../dist/include/nsTSubstringTuple.h"
class nsCSubstringTuple
  {
    public:

      typedef char char_type;
      typedef nsCharTraits<char_type> char_traits;

      typedef nsCSubstringTuple self_type;
      typedef nsACString_internal substring_type;
      typedef nsACString_internal base_string_type;
      typedef uint32_t size_type;

    public:

      nsCSubstringTuple(const base_string_type* a, const base_string_type* b)
        : mHead(nullptr)
        , mFragA(a)
        , mFragB(b) {}

      nsCSubstringTuple(const self_type& head, const base_string_type* b)
        : mHead(&head)
        , mFragA(nullptr)
        , mFragB(b) {}




      size_type Length() const;






      void WriteTo(char_type *buf, uint32_t bufLen) const;





      bool IsDependentOn(const char_type *start, const char_type *end) const;

    private:

      const self_type* mHead;
      const base_string_type* mFragA;
      const base_string_type* mFragB;
  };

inline
const nsCSubstringTuple
operator+(const nsCSubstringTuple::base_string_type& a, const nsCSubstringTuple::base_string_type& b)
  {
    return nsCSubstringTuple(&a, &b);
  }

inline
const nsCSubstringTuple
operator+(const nsCSubstringTuple& head, const nsCSubstringTuple::base_string_type& b)
  {
    return nsCSubstringTuple(head, &b);
  }
# 22 "../../dist/include/nsSubstringTuple.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 23 "../../dist/include/nsSubstringTuple.h" 2
# 70 "../../dist/include/nsAString.h" 2
# 26 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 2
# 1 "../../dist/system_wrappers/prtime.h" 1
       
# 2 "../../dist/system_wrappers/prtime.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 2
# 1 "../../dist/include/nsError.h" 1
# 28 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h" 2



extern PRLogModuleInfo * gCacheLog;
void CacheLogInit();
void CacheLogPrintPath(PRLogModuleLevel level,
                         const char * format,
                         nsIFile * item);
# 53 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCache.h"
extern uint32_t SecondsFromPRTime(PRTime prTime);
extern PRTime PRTimeFromSeconds(uint32_t seconds);


extern nsresult ClientIDFromCacheKey(const nsACString_internal& key, char ** result);
extern nsresult ClientKeyFromCacheKey(const nsCString& key, nsACString_internal &result);
# 8 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h"
# 1 "../../dist/system_wrappers/limits.h" 1
       
# 2 "../../dist/system_wrappers/limits.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/limits.h" 1 3 4
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/limits.h" 3 4
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/syslimits.h" 1 3 4






# 1 "../../dist/system_wrappers/limits.h" 1 3 4
       
# 2 "../../dist/system_wrappers/limits.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/limits.h" 1 3 4
# 169 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 27 "/usr/include/limits.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/usr/include/limits.h" 2 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "../../dist/system_wrappers/linux/limits.h" 1 3 4
       
# 2 "../../dist/system_wrappers/linux/limits.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/linux/limits.h" 1 3 4
# 4 "../../dist/system_wrappers/linux/limits.h" 2 3
#pragma GCC visibility pop
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 170 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/limits.h" 2 3 4
# 4 "../../dist/system_wrappers/limits.h" 2 3
#pragma GCC visibility pop
# 8 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/syslimits.h" 2 3 4
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/limits.h" 2 3 4
# 4 "../../dist/system_wrappers/limits.h" 2 3
#pragma GCC visibility pop
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2

# 1 "../../dist/system_wrappers/prtypes.h" 1
       
# 2 "../../dist/system_wrappers/prtypes.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtypes.h" 1 3
# 4 "../../dist/system_wrappers/prtypes.h" 2 3
#pragma GCC visibility pop
# 13 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2
# 1 "../../dist/system_wrappers/prnetdb.h" 1
       
# 2 "../../dist/system_wrappers/prnetdb.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 1 3
# 10 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prio.h" 1 3
# 11 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 2 3

extern "C" {







extern __attribute__((visibility("default"))) PRStatus PR_StringToNetAddr(
    const char *string, PRNetAddr *addr);

extern __attribute__((visibility("default"))) PRStatus PR_NetAddrToString(
    const PRNetAddr *addr, char *string, PRUint32 size);
# 36 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
typedef struct PRHostEnt {
    char *h_name;
    char **h_aliases;




    PRInt32 h_addrtype;
    PRInt32 h_length;

    char **h_addr_list;
} PRHostEnt;
# 77 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetHostByName(
    const char *hostname, char *buf, PRIntn bufsize, PRHostEnt *hostentry);
# 114 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetIPNodeByName(
    const char *hostname,
    PRUint16 af,
    PRIntn flags,
    char *buf,
    PRIntn bufsize,
    PRHostEnt *hostentry);
# 143 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetHostByAddr(
    const PRNetAddr *hostaddr, char *buf, PRIntn bufsize, PRHostEnt *hostentry);
# 177 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRIntn PR_EnumerateHostEnt(
    PRIntn enumIndex, const PRHostEnt *hostEnt, PRUint16 port, PRNetAddr *address);
# 202 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
typedef enum PRNetAddrValue
{
    PR_IpAddrNull,
    PR_IpAddrAny,
    PR_IpAddrLoopback,
    PR_IpAddrV4Mapped
} PRNetAddrValue;

extern __attribute__((visibility("default"))) PRStatus PR_InitializeNetAddr(
    PRNetAddrValue val, PRUint16 port, PRNetAddr *addr);
# 238 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_SetNetAddr(
    PRNetAddrValue val, PRUint16 af, PRUint16 port, PRNetAddr *addr);
# 254 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRBool PR_IsNetAddrType(const PRNetAddr *addr, PRNetAddrValue val);
# 271 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) void PR_ConvertIPv4AddrToIPv6(PRUint32 v4addr, PRIPv6Addr *v6addr);
# 322 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
typedef struct PRProtoEnt {
    char *p_name;
    char **p_aliases;



    PRInt32 p_num;

} PRProtoEnt;

extern __attribute__((visibility("default"))) PRStatus PR_GetProtoByName(
    const char* protocolname, char* buffer, PRInt32 bufsize, PRProtoEnt* result);
# 357 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetProtoByNumber(
    PRInt32 protocolnumber, char* buffer, PRInt32 bufsize, PRProtoEnt* result);
# 381 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
typedef struct PRAddrInfo PRAddrInfo;

extern __attribute__((visibility("default"))) PRAddrInfo* PR_GetAddrInfoByName(
    const char *hostname, PRUint16 af, PRIntn flags);
# 398 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) void PR_FreeAddrInfo(PRAddrInfo *addrInfo);
# 423 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) void * PR_EnumerateAddrInfo(
    void *enumPtr, const PRAddrInfo *addrInfo, PRUint16 port, PRNetAddr *result);
# 442 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) const char * PR_GetCanonNameFromAddrInfo(
    const PRAddrInfo *addrInfo);
# 458 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 3
extern __attribute__((visibility("default"))) PRUint16 PR_ntohs(PRUint16);
extern __attribute__((visibility("default"))) PRUint32 PR_ntohl(PRUint32);
extern __attribute__((visibility("default"))) PRUint64 PR_ntohll(PRUint64);
extern __attribute__((visibility("default"))) PRUint16 PR_htons(PRUint16);
extern __attribute__((visibility("default"))) PRUint32 PR_htonl(PRUint32);
extern __attribute__((visibility("default"))) PRUint64 PR_htonll(PRUint64);

}
# 4 "../../dist/system_wrappers/prnetdb.h" 2 3
#pragma GCC visibility pop
# 14 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2
# 1 "../../dist/include/nsDebug.h" 1
# 15 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2


# 1 "../../dist/include/nsITimer.h" 1
# 17 "../../dist/include/nsITimer.h"
class nsIObserver;

class nsIEventTarget;
# 34 "../../dist/include/nsITimer.h"
class nsITimer;
typedef void (*nsTimerCallbackFunc) (nsITimer *aTimer, void *aClosure);
class nsITimer;
# 46 "../../dist/include/nsITimer.h"
class nsITimerCallback : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Notify(nsITimer *timer) = 0;

};

  template <class Dummy> const nsIID nsITimerCallback::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xa796816d, 0x7d47, 0x4348, { 0x9a, 0xb8, 0xc7, 0xae, 0xb3, 0x21, 0x6a, 0x7d }};
# 121 "../../dist/include/nsITimer.h"
class nsITimer : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}

  enum {
    TYPE_ONE_SHOT = 0,
    TYPE_REPEATING_SLACK = 1,
    TYPE_REPEATING_PRECISE = 2,
    TYPE_REPEATING_PRECISE_CAN_SKIP = 3
  };


  virtual __attribute__ ((visibility ("hidden"))) nsresult Init(nsIObserver *aObserver, uint32_t aDelay, uint32_t aType) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult InitWithFuncCallback(nsTimerCallbackFunc aCallback, void *aClosure, uint32_t aDelay, uint32_t aType) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult InitWithCallback(nsITimerCallback *aCallback, uint32_t aDelay, uint32_t aType) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Cancel(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDelay(uint32_t *aDelay) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetDelay(uint32_t aDelay) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetType(uint32_t *aType) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetType(uint32_t aType) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetClosure(void **aClosure) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetCallback(nsITimerCallback * *aCallback) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetTarget(nsIEventTarget * *aTarget) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetTarget(nsIEventTarget *aTarget) = 0;

};

  template <class Dummy> const nsIID nsITimer::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x193fc37a, 0x8aa4, 0x4d29, { 0xaa, 0x57, 0x1a, 0xcd, 0x87, 0xc2, 0x6b, 0x66 }};
# 18 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2

# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCache.h" 1
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCache.h"
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h"
# 1 "../../dist/include/nsICache.h" 1
# 17 "../../dist/include/nsICache.h"
typedef int32_t nsCacheStoragePolicy;

typedef int32_t nsCacheAccessMode;
# 29 "../../dist/include/nsICache.h"
class nsICache {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}

  enum {
    ACCESS_NONE = 0,
    ACCESS_READ = 1,
    ACCESS_WRITE = 2,
    ACCESS_READ_WRITE = 3,
    STORE_ANYWHERE = 0,
    STORE_IN_MEMORY = 1,
    STORE_ON_DISK = 2,
    STORE_OFFLINE = 4,
    NOT_STREAM_BASED = 0,
    STREAM_BASED = 1,
    NON_BLOCKING = 0,
    BLOCKING = 1,
    NO_EXPIRATION_TIME = 4294967295U
  };

};

  template <class Dummy> const nsIID nsICache::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xd6c67f38, 0xb39a, 0x4582, { 0x8a, 0x48, 0x4c, 0x4f, 0x8a, 0x56, 0xdf, 0xd0 }};
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2
# 1 "../../dist/include/nsICacheEntryDescriptor.h" 1
# 10 "../../dist/include/nsICacheEntryDescriptor.h"
# 1 "../../dist/include/nsICacheVisitor.h" 1
# 17 "../../dist/include/nsICacheVisitor.h"
class nsICacheDeviceInfo;

class nsICacheEntryInfo;
# 29 "../../dist/include/nsICacheVisitor.h"
class nsICacheVisitor : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult VisitDevice(const char * deviceID, nsICacheDeviceInfo *deviceInfo, bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult VisitEntry(const char * deviceID, nsICacheEntryInfo *entryInfo, bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsICacheVisitor::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xf8c08c4b, 0xd778, 0x49d1, { 0xa5, 0x9b, 0x86, 0x6f, 0xdc, 0x50, 0x0d, 0x95 }};
# 114 "../../dist/include/nsICacheVisitor.h"
class nsICacheDeviceInfo : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDescription(char * *aDescription) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetUsageReport(char * *aUsageReport) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetEntryCount(uint32_t *aEntryCount) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetTotalSize(uint32_t *aTotalSize) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetMaximumSize(uint32_t *aMaximumSize) = 0;

};

  template <class Dummy> const nsIID nsICacheDeviceInfo::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x31d1c294, 0x1dd2, 0x11b2, { 0xbe, 0x3a, 0xc7, 0x92, 0x30, 0xdc, 0xa2, 0x97 }};
# 235 "../../dist/include/nsICacheVisitor.h"
class nsICacheEntryInfo : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetClientID(char * *aClientID) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDeviceID(char * *aDeviceID) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetKey(nsACString_internal & aKey) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetFetchCount(int32_t *aFetchCount) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastFetched(uint32_t *aLastFetched) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastModified(uint32_t *aLastModified) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetExpirationTime(uint32_t *aExpirationTime) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDataSize(uint32_t *aDataSize) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsStreamBased(bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsICacheEntryInfo::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xfab51c92, 0x95c3, 0x4468, { 0xb3, 0x17, 0x7d, 0xe4, 0xd7, 0x58, 0x82, 0x54 }};
# 11 "../../dist/include/nsICacheEntryDescriptor.h" 2
# 21 "../../dist/include/nsICacheEntryDescriptor.h"
class nsISimpleEnumerator;

class nsICacheListener;

class nsIInputStream;

class nsIOutputStream;

class nsIFile;

class nsICacheMetaDataVisitor;
# 41 "../../dist/include/nsICacheEntryDescriptor.h"
class nsICacheEntryDescriptor : public nsICacheEntryInfo {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult SetExpirationTime(uint32_t expirationTime) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult SetDataSize(uint32_t size) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult OpenInputStream(uint32_t offset, nsIInputStream * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult OpenOutputStream(uint32_t offset, nsIOutputStream * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetCacheElement(nsISupports * *aCacheElement) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetCacheElement(nsISupports *aCacheElement) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetPredictedDataSize(int64_t *aPredictedDataSize) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetPredictedDataSize(int64_t aPredictedDataSize) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetAccessGranted(nsCacheAccessMode *aAccessGranted) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetStoragePolicy(nsCacheStoragePolicy *aStoragePolicy) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetStoragePolicy(nsCacheStoragePolicy aStoragePolicy) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetFile(nsIFile * *aFile) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetSecurityInfo(nsISupports * *aSecurityInfo) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetSecurityInfo(nsISupports *aSecurityInfo) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetStorageDataSize(uint32_t *aStorageDataSize) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Doom(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult DoomAndFailPendingRequests(nsresult status) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult AsyncDoom(nsICacheListener *listener) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult MarkValid(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Close(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetMetaDataElement(const char * key, char * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult SetMetaDataElement(const char * key, const char * value) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult VisitMetaData(nsICacheMetaDataVisitor *visitor) = 0;

};

  template <class Dummy> const nsIID nsICacheEntryDescriptor::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x90b17d31, 0x46aa, 0x4fb1, { 0xa2, 0x06, 0x47, 0x3c, 0x96, 0x6c, 0xbc, 0x18 }};
# 362 "../../dist/include/nsICacheEntryDescriptor.h"
class nsICacheMetaDataVisitor : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult VisitMetaDataElement(const char * key, const char * value, bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsICacheMetaDataVisitor::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x22f9a49c, 0x3cf8, 0x4c23, { 0x80, 0x06, 0x54, 0xef, 0xb1, 0x1a, 0xc5, 0x62 }};
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2
# 1 "../../dist/include/nsIThread.h" 1
# 10 "../../dist/include/nsIThread.h"
# 1 "../../dist/include/nsIEventTarget.h" 1
# 17 "../../dist/include/nsIEventTarget.h"
class nsIRunnable;
# 27 "../../dist/include/nsIEventTarget.h"
class nsIEventTarget : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Dispatch(nsIRunnable *event, uint32_t flags) = 0;

  enum {
    DISPATCH_NORMAL = 0U,
    DISPATCH_SYNC = 1U
  };


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsOnCurrentThread(bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsIEventTarget::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x4e8febe4, 0x6631, 0x49dc, { 0x8a, 0xc9, 0x30, 0x8c, 0x1c, 0xb9, 0xb0, 0x9c }};
# 11 "../../dist/include/nsIThread.h" 2
# 25 "../../dist/include/nsIThread.h"
class nsIThread : public nsIEventTarget {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetPRThread(PRThread **aPRThread) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Shutdown(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult HasPendingEvents(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult ProcessNextEvent(bool mayWait, bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsIThread::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x9c889946, 0xa73a, 0x4af3, { 0xae, 0x9a, 0xea, 0x64, 0xf7, 0xd4, 0xe3, 0xca }};
# 13 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheMetaData.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheMetaData.h"
# 1 "../../dist/system_wrappers/nspr.h" 1
       
# 2 "../../dist/system_wrappers/nspr.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 1 3
# 9 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pratom.h" 1 3
# 10 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prbit.h" 1 3
# 10 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prbit.h" 3
extern "C" {
# 42 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prbit.h" 3
typedef unsigned long prbitmap_t;
# 54 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prbit.h" 3
extern __attribute__((visibility("default"))) PRIntn PR_CeilingLog2(PRUint32 i);




extern __attribute__((visibility("default"))) PRIntn PR_FloorLog2(PRUint32 i);
# 146 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prbit.h" 3
}
# 11 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prclist.h" 1 3
# 11 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prclist.h" 3
typedef struct PRCListStr PRCList;




struct PRCListStr {
    PRCList *next;
    PRCList *prev;
};
# 12 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcmon.h" 1 3
# 19 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcmon.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmon.h" 1 3
# 12 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmon.h" 3
extern "C" {

typedef struct PRMonitor PRMonitor;
# 23 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmon.h" 3
extern __attribute__((visibility("default"))) PRMonitor* PR_NewMonitor(void);







extern __attribute__((visibility("default"))) void PR_DestroyMonitor(PRMonitor *mon);






extern __attribute__((visibility("default"))) void PR_EnterMonitor(PRMonitor *mon);






extern __attribute__((visibility("default"))) PRStatus PR_ExitMonitor(PRMonitor *mon);
# 63 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmon.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Wait(PRMonitor *mon, PRIntervalTime ticks);






extern __attribute__((visibility("default"))) PRStatus PR_Notify(PRMonitor *mon);






extern __attribute__((visibility("default"))) PRStatus PR_NotifyAll(PRMonitor *mon);
# 92 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmon.h" 3
extern __attribute__((visibility("default"))) void PR_AssertCurrentThreadInMonitor(PRMonitor *mon);

}
# 20 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcmon.h" 2 3


extern "C" {
# 32 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcmon.h" 3
extern __attribute__((visibility("default"))) PRMonitor* PR_CEnterMonitor(void *address);





extern __attribute__((visibility("default"))) PRStatus PR_CExitMonitor(void *address);





extern __attribute__((visibility("default"))) PRStatus PR_CWait(void *address, PRIntervalTime timeout);





extern __attribute__((visibility("default"))) PRStatus PR_CNotify(void *address);





extern __attribute__((visibility("default"))) PRStatus PR_CNotifyAll(void *address);





extern __attribute__((visibility("default"))) void PR_CSetOnMonitorRecycle(void ( *callback)(void *address));

}
# 13 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 1 3
# 12 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 3
extern "C" {

typedef struct PRCondVar PRCondVar;
# 27 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 3
extern __attribute__((visibility("default"))) PRCondVar* PR_NewCondVar(PRLock *lock);







extern __attribute__((visibility("default"))) void PR_DestroyCondVar(PRCondVar *cvar);
# 65 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_WaitCondVar(PRCondVar *cvar, PRIntervalTime timeout);
# 80 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_NotifyCondVar(PRCondVar *cvar);
# 90 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_NotifyAllCondVar(PRCondVar *cvar);

}
# 14 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prdtoa.h" 1 3
# 11 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prdtoa.h" 3
extern "C" {
# 24 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prdtoa.h" 3
extern __attribute__((visibility("default"))) PRFloat64
PR_strtod(const char *s00, char **se);







extern __attribute__((visibility("default"))) void PR_cnvtf(char *buf, PRIntn bufsz, PRIntn prcsn, PRFloat64 fval);
# 46 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prdtoa.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_dtoa(PRFloat64 d, PRIntn mode, PRIntn ndigits,
 PRIntn *decpt, PRIntn *sign, char **rve, char *buf, PRSize bufsize);

}
# 15 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prenv.h" 1 3
# 17 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prenv.h" 3
extern "C" {
# 91 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prenv.h" 3
extern __attribute__((visibility("default"))) char* PR_GetEnv(const char *var);
# 114 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prenv.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_SetEnv(const char *string);

}
# 16 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 1 3
# 11 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern "C" {

typedef PRInt32 PRErrorCode;



# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerr.h" 1 3
# 246 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerr.h" 3
extern void nspr_InitializePRErrorTable(void);
# 18 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 2 3







extern __attribute__((visibility("default"))) void PR_SetError(PRErrorCode errorCode, PRInt32 oserr);
# 36 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern __attribute__((visibility("default"))) void PR_SetErrorText(
    PRIntn textLength, const char *text);




extern __attribute__((visibility("default"))) PRErrorCode PR_GetError(void);





extern __attribute__((visibility("default"))) PRInt32 PR_GetOSError(void);






extern __attribute__((visibility("default"))) PRInt32 PR_GetErrorTextLength(void);






extern __attribute__((visibility("default"))) PRInt32 PR_GetErrorText(char *text);
# 145 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
typedef PRUint32 PRLanguageCode;
# 154 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
struct PRErrorMessage {
    const char * name;
    const char * en_text;
};






struct PRErrorTable {
    const struct PRErrorMessage * msgs;
    const char *name;
    PRErrorCode base;
    int n_msgs;
};






struct PRErrorCallbackPrivate;







struct PRErrorCallbackTablePrivate;
# 196 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
typedef const char *
PRErrorCallbackLookupFn(PRErrorCode code, PRLanguageCode language,
     const struct PRErrorTable *table,
     struct PRErrorCallbackPrivate *cb_private,
     struct PRErrorCallbackTablePrivate *table_private);
# 212 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
typedef struct PRErrorCallbackTablePrivate *
PRErrorCallbackNewTableFn(const struct PRErrorTable *table,
   struct PRErrorCallbackPrivate *cb_private);
# 230 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern __attribute__((visibility("default"))) const char * PR_ErrorToString(PRErrorCode code,
    PRLanguageCode language);
# 244 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern __attribute__((visibility("default"))) const char * PR_ErrorToName(PRErrorCode code);
# 258 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern __attribute__((visibility("default"))) const char * const * PR_ErrorLanguages(void);
# 271 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern __attribute__((visibility("default"))) PRErrorCode PR_ErrorInstallTable(const struct PRErrorTable *table);
# 287 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prerror.h" 3
extern __attribute__((visibility("default"))) void PR_ErrorInstallCallback(const char * const * languages,
         PRErrorCallbackLookupFn *lookup,
         PRErrorCallbackNewTableFn *newtable,
         struct PRErrorCallbackPrivate *cb_private);

}
# 17 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3

# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 1 3
# 9 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prthread.h" 1 3
# 10 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 2 3

# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prwin16.h" 1 3
# 12 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 2 3
# 1 "../../dist/system_wrappers/stdio.h" 1 3
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 13 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 2 3

extern "C" {
# 56 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
typedef PRBool (*PRVersionCheck)(const char*);
# 66 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
extern __attribute__((visibility("default"))) PRBool PR_VersionCheck(const char *importedVersion);




extern __attribute__((visibility("default"))) const char* PR_GetVersion(void);
# 84 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
extern __attribute__((visibility("default"))) void PR_Init(
    PRThreadType type, PRThreadPriority priority, PRUintn maxPTDs);
# 105 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
typedef PRIntn ( *PRPrimordialFn)(PRIntn argc, char **argv);

extern __attribute__((visibility("default"))) PRIntn PR_Initialize(
    PRPrimordialFn prmain, PRIntn argc, char **argv, PRUintn maxPTDs);




extern __attribute__((visibility("default"))) PRBool PR_Initialized(void);
# 131 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_Cleanup(void);





extern __attribute__((visibility("default"))) void PR_DisableClockInterrupts(void);





extern __attribute__((visibility("default"))) void PR_EnableClockInterrupts(void);





extern __attribute__((visibility("default"))) void PR_BlockClockInterrupts(void);





extern __attribute__((visibility("default"))) void PR_UnblockClockInterrupts(void);




extern __attribute__((visibility("default"))) void PR_SetConcurrency(PRUintn numCPUs);






extern __attribute__((visibility("default"))) PRStatus PR_SetFDCacheSize(PRIntn low, PRIntn high);






extern __attribute__((visibility("default"))) void PR_ProcessExit(PRIntn status);






extern __attribute__((visibility("default"))) void PR_Abort(void);
# 191 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinit.h" 3
typedef struct PRCallOnceType {
    PRIntn initialized;
    PRInt32 inProgress;
    PRStatus status;
} PRCallOnceType;

typedef PRStatus ( *PRCallOnceFN)(void);

typedef PRStatus ( *PRCallOnceWithArgFN)(void *arg);

extern __attribute__((visibility("default"))) PRStatus PR_CallOnce(
    PRCallOnceType *once,
    PRCallOnceFN func
);

extern __attribute__((visibility("default"))) PRStatus PR_CallOnceWithArg(
    PRCallOnceType *once,
    PRCallOnceWithArgFN func,
    void *arg
);


}
# 19 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3


# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pripcsem.h" 1 3
# 30 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pripcsem.h" 3
extern "C" {





typedef struct PRSem PRSem;
# 60 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pripcsem.h" 3
extern __attribute__((visibility("default"))) PRSem * PR_OpenSemaphore(
    const char *name, PRIntn flags, PRIntn mode, PRUintn value);
# 73 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/pripcsem.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_WaitSemaphore(PRSem *sem);







extern __attribute__((visibility("default"))) PRStatus PR_PostSemaphore(PRSem *sem);







extern __attribute__((visibility("default"))) PRStatus PR_CloseSemaphore(PRSem *sem);







extern __attribute__((visibility("default"))) PRStatus PR_DeleteSemaphore(const char *name);

}
# 22 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlink.h" 1 3
# 23 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3

# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlog.h" 1 3
# 25 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3

# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmem.h" 1 3
# 15 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmem.h" 3
# 1 "../../dist/system_wrappers/stdlib.h" 1 3
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 16 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmem.h" 2 3

extern "C" {
# 34 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmem.h" 3
extern __attribute__((visibility("default"))) void * PR_Malloc(PRUint32 size);

extern __attribute__((visibility("default"))) void * PR_Calloc(PRUint32 nelem, PRUint32 elsize);

extern __attribute__((visibility("default"))) void * PR_Realloc(void *ptr, PRUint32 size);

extern __attribute__((visibility("default"))) void PR_Free(void *ptr);
# 124 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmem.h" 3
}
# 27 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3

# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 1 3
# 14 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern "C" {
# 37 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
typedef struct PRWaitGroup PRWaitGroup;
# 61 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
typedef enum PRMWStatus
{
    PR_MW_PENDING = 1,
    PR_MW_SUCCESS = 0,
    PR_MW_FAILURE = -1,
    PR_MW_TIMEOUT = -2,
    PR_MW_INTERRUPT = -3
} PRMWStatus;
# 77 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
typedef struct PRMemoryDescriptor
{
    void *start;
    PRSize length;
} PRMemoryDescriptor;
# 90 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
typedef struct PRMWaitClientData PRMWaitClientData;
# 108 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
typedef struct PRRecvWait
{
    PRCList internal;

    PRFileDesc *fd;
    PRMWStatus outcome;
    PRIntervalTime timeout;

    PRInt32 bytesRecv;
    PRMemoryDescriptor buffer;
    PRMWaitClientData *client;
} PRRecvWait;
# 130 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
typedef struct PRMWaitEnumerator PRMWaitEnumerator;
# 164 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_AddWaitFileDesc(PRWaitGroup *group, PRRecvWait *desc);
# 198 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRRecvWait* PR_WaitRecvReady(PRWaitGroup *group);
# 233 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_CancelWaitFileDesc(PRWaitGroup *group, PRRecvWait *desc);
# 260 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRRecvWait* PR_CancelWaitGroup(PRWaitGroup *group);
# 287 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRWaitGroup* PR_CreateWaitGroup(PRInt32 size);
# 310 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_DestroyWaitGroup(PRWaitGroup *group);
# 332 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRMWaitEnumerator* PR_CreateMWaitEnumerator(PRWaitGroup *group);
# 350 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_DestroyMWaitEnumerator(PRMWaitEnumerator* enumerator);
# 373 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prmwait.h" 3
extern __attribute__((visibility("default"))) PRRecvWait* PR_EnumerateWaitGroup(
    PRMWaitEnumerator *enumerator, const PRRecvWait *previous);

}
# 29 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prnetdb.h" 1 3
# 30 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 1 3
# 27 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 3
# 1 "../../dist/system_wrappers/stdio.h" 1 3
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 2 3
# 1 "../../dist/system_wrappers/stdarg.h" 1 3
       
# 2 "../../dist/system_wrappers/stdarg.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 2 3

extern "C" {






extern __attribute__((visibility("default"))) PRUint32 PR_snprintf(char *out, PRUint32 outlen, const char *fmt, ...);






extern __attribute__((visibility("default"))) char* PR_smprintf(const char *fmt, ...);




extern __attribute__((visibility("default"))) void PR_smprintf_free(char *mem);
# 58 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 3
extern __attribute__((visibility("default"))) char* PR_sprintf_append(char *last, const char *fmt, ...);
# 67 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 3
typedef PRIntn (*PRStuffFunc)(void *arg, const char *s, PRUint32 slen);

extern __attribute__((visibility("default"))) PRUint32 PR_sxprintf(PRStuffFunc f, void *arg, const char *fmt, ...);




extern __attribute__((visibility("default"))) PRUint32 PR_fprintf(struct PRFileDesc* fd, const char *fmt, ...);




extern __attribute__((visibility("default"))) PRUint32 PR_vsnprintf(char *out, PRUint32 outlen, const char *fmt, va_list ap);
extern __attribute__((visibility("default"))) char* PR_vsmprintf(const char *fmt, va_list ap);
extern __attribute__((visibility("default"))) char* PR_vsprintf_append(char *last, const char *fmt, va_list ap);
extern __attribute__((visibility("default"))) PRUint32 PR_vsxprintf(PRStuffFunc f, void *arg, const char *fmt, va_list ap);
extern __attribute__((visibility("default"))) PRUint32 PR_vfprintf(struct PRFileDesc* fd, const char *fmt, va_list ap);
# 118 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prprf.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_sscanf(const char *buf, const char *fmt, ...);

}
# 31 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prproces.h" 1 3
# 12 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prproces.h" 3
extern "C" {





typedef struct PRProcess PRProcess;
typedef struct PRProcessAttr PRProcessAttr;

extern __attribute__((visibility("default"))) PRProcessAttr * PR_NewProcessAttr(void);

extern __attribute__((visibility("default"))) void PR_ResetProcessAttr(PRProcessAttr *attr);

extern __attribute__((visibility("default"))) void PR_DestroyProcessAttr(PRProcessAttr *attr);

extern __attribute__((visibility("default"))) void PR_ProcessAttrSetStdioRedirect(
    PRProcessAttr *attr,
    PRSpecialFD stdioFd,
    PRFileDesc *redirectFd
);




extern __attribute__((visibility("default"))) void PR_SetStdioRedirect(
    PRProcessAttr *attr,
    PRSpecialFD stdioFd,
    PRFileDesc *redirectFd
);

extern __attribute__((visibility("default"))) PRStatus PR_ProcessAttrSetCurrentDirectory(
    PRProcessAttr *attr,
    const char *dir
);

extern __attribute__((visibility("default"))) PRStatus PR_ProcessAttrSetInheritableFD(
    PRProcessAttr *attr,
    PRFileDesc *fd,
    const char *name
);
# 66 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prproces.h" 3
extern __attribute__((visibility("default"))) PRProcess* PR_CreateProcess(
    const char *path,
    char *const *argv,
    char *const *envp,
    const PRProcessAttr *attr);

extern __attribute__((visibility("default"))) PRStatus PR_CreateProcessDetached(
    const char *path,
    char *const *argv,
    char *const *envp,
    const PRProcessAttr *attr);

extern __attribute__((visibility("default"))) PRStatus PR_DetachProcess(PRProcess *process);

extern __attribute__((visibility("default"))) PRStatus PR_WaitProcess(PRProcess *process, PRInt32 *exitCode);

extern __attribute__((visibility("default"))) PRStatus PR_KillProcess(PRProcess *process);

}
# 32 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrng.h" 1 3
# 19 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrng.h" 3
extern "C" {
# 67 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrng.h" 3
extern __attribute__((visibility("default"))) PRSize PR_GetRandomNoise(
    void *buf,
    PRSize size
);

}
# 33 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 1 3
# 17 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
extern "C" {
# 27 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
typedef struct PRRWLock PRRWLock;
# 44 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
extern __attribute__((visibility("default"))) PRRWLock* PR_NewRWLock(PRUint32 lock_rank, const char *lock_name);
# 54 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
extern __attribute__((visibility("default"))) void PR_DestroyRWLock(PRRWLock *lock);
# 64 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
extern __attribute__((visibility("default"))) void PR_RWLock_Rlock(PRRWLock *lock);
# 74 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
extern __attribute__((visibility("default"))) void PR_RWLock_Wlock(PRRWLock *lock);
# 84 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prrwlock.h" 3
extern __attribute__((visibility("default"))) void PR_RWLock_Unlock(PRRWLock *lock);

}
# 34 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 1 3
# 105 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 3
extern "C" {




typedef struct PRSharedMemory PRSharedMemory;
# 147 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 3
extern __attribute__((visibility("default"))) PRSharedMemory *
    PR_OpenSharedMemory(
        const char *name,
        PRSize size,
        PRIntn flags,
        PRIntn mode
);
# 181 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 3
extern __attribute__((visibility("default"))) void *
    PR_AttachSharedMemory(
        PRSharedMemory *shm,
        PRIntn flags
);
# 207 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 3
extern __attribute__((visibility("default"))) PRStatus
    PR_DetachSharedMemory(
        PRSharedMemory *shm,
        void *addr
);
# 229 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 3
extern __attribute__((visibility("default"))) PRStatus
    PR_CloseSharedMemory(
        PRSharedMemory *shm
);
# 250 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshm.h" 3
extern __attribute__((visibility("default"))) PRStatus
    PR_DeleteSharedMemory(
        const char *name
);

}
# 35 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 1 3
# 106 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 3
extern "C" {
# 134 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 3
extern __attribute__((visibility("default"))) PRFileMap *
PR_OpenAnonFileMap(
    const char *dirName,
    PRSize size,
    PRFileMapProtect prot
);
# 162 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 3
extern __attribute__((visibility("default"))) PRStatus
PR_ProcessAttrSetInheritableFileMap(
    PRProcessAttr *attr,
    PRFileMap *fm,
    const char *shmname
);
# 187 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 3
extern __attribute__((visibility("default"))) PRFileMap *
PR_GetInheritedFileMap(
    const char *shmname
);
# 211 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 3
extern __attribute__((visibility("default"))) PRStatus
PR_ExportFileMapAsString(
    PRFileMap *fm,
    PRSize bufsize,
    char *buf
);
# 233 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prshma.h" 3
extern __attribute__((visibility("default"))) PRFileMap *
PR_ImportFileMapFromString(
    const char *fmstring
);

}
# 36 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prsystem.h" 1 3
# 14 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prsystem.h" 3
extern "C" {







extern __attribute__((visibility("default"))) char PR_GetDirectorySeparator(void);






extern __attribute__((visibility("default"))) char PR_GetDirectorySepartor(void);







extern __attribute__((visibility("default"))) char PR_GetPathSeparator(void);


typedef enum {
    PR_SI_HOSTNAME,

    PR_SI_SYSNAME,
    PR_SI_RELEASE,
    PR_SI_ARCHITECTURE,
    PR_SI_HOSTNAME_UNTRUNCATED

} PRSysInfo;
# 62 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prsystem.h" 3
extern __attribute__((visibility("default"))) PRStatus PR_GetSystemInfo(PRSysInfo cmd, char *buf, PRUint32 buflen);




extern __attribute__((visibility("default"))) PRInt32 PR_GetPageSize(void);




extern __attribute__((visibility("default"))) PRInt32 PR_GetPageShift(void);
# 88 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prsystem.h" 3
extern __attribute__((visibility("default"))) PRInt32 PR_GetNumberOfProcessors( void );
# 104 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prsystem.h" 3
extern __attribute__((visibility("default"))) PRUint64 PR_GetPhysicalMemorySize(void);

}
# 37 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3


# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtpool.h" 1 3
# 20 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtpool.h" 3
extern "C" {

typedef struct PRJobIoDesc {
    PRFileDesc *socket;
    PRErrorCode error;
    PRIntervalTime timeout;
} PRJobIoDesc;

typedef struct PRThreadPool PRThreadPool;
typedef struct PRJob PRJob;
typedef void ( *PRJobFn) (void *arg);


extern __attribute__((visibility("default"))) PRThreadPool *
PR_CreateThreadPool(PRInt32 initial_threads, PRInt32 max_threads,
                          PRUint32 stacksize);


extern __attribute__((visibility("default"))) PRJob *
PR_QueueJob(PRThreadPool *tpool, PRJobFn fn, void *arg, PRBool joinable);


extern __attribute__((visibility("default"))) PRJob *
PR_QueueJob_Read(PRThreadPool *tpool, PRJobIoDesc *iod,
       PRJobFn fn, void * arg, PRBool joinable);


extern __attribute__((visibility("default"))) PRJob *
PR_QueueJob_Write(PRThreadPool *tpool, PRJobIoDesc *iod,
        PRJobFn fn, void * arg, PRBool joinable);


extern __attribute__((visibility("default"))) PRJob *
PR_QueueJob_Accept(PRThreadPool *tpool, PRJobIoDesc *iod,
         PRJobFn fn, void * arg, PRBool joinable);


extern __attribute__((visibility("default"))) PRJob *
PR_QueueJob_Connect(PRThreadPool *tpool, PRJobIoDesc *iod,
   const PRNetAddr *addr, PRJobFn fn, void * arg, PRBool joinable);


extern __attribute__((visibility("default"))) PRJob *
PR_QueueJob_Timer(PRThreadPool *tpool, PRIntervalTime timeout,
        PRJobFn fn, void * arg, PRBool joinable);

extern __attribute__((visibility("default"))) PRStatus
PR_CancelJob(PRJob *job);


extern __attribute__((visibility("default"))) PRStatus
PR_JoinJob(PRJob *job);


extern __attribute__((visibility("default"))) PRStatus
PR_ShutdownThreadPool(PRThreadPool *tpool);


extern __attribute__((visibility("default"))) PRStatus
PR_JoinThreadPool(PRThreadPool *tpool);

}
# 40 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 1 3
# 68 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern "C" {






typedef void * PRTraceHandle;






typedef struct PRTraceEntry
{
    PRThread *thread;
    PRTraceHandle handle;
    PRTime time;
    PRUint32 userData[8];
} PRTraceEntry;






typedef enum PRTraceOption
{
    PRTraceBufSize,
    PRTraceEnable,
    PRTraceDisable,
    PRTraceSuspend,
    PRTraceResume,
    PRTraceSuspendRecording,
    PRTraceResumeRecording,
    PRTraceLockHandles,
    PRTraceUnLockHandles,
    PRTraceStopRecording
} PRTraceOption;
# 176 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) PRTraceHandle
 PR_CreateTrace(
     const char *qName,
     const char *rName,
     const char *description
);
# 210 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) void
 PR_DestroyTrace(
  PRTraceHandle handle
);
# 251 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) void
 PR_Trace(
     PRTraceHandle handle,
     PRUint32 userData0,
     PRUint32 userData1,
     PRUint32 userData2,
     PRUint32 userData3,
     PRUint32 userData4,
     PRUint32 userData5,
     PRUint32 userData6,
     PRUint32 userData7
);
# 338 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) void
 PR_SetTraceOption(
     PRTraceOption command,
     void *value
);
# 376 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) void
 PR_GetTraceOption(
     PRTraceOption command,
     void *value
);
# 412 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) PRTraceHandle
 PR_GetTraceHandleFromName(
     const char *qName,
        const char *rName
);
# 444 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) void
 PR_GetTraceNameFromHandle(
     PRTraceHandle handle,
     const char **qName,
     const char **rName,
     const char **description
);
# 486 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) PRTraceHandle
 PR_FindNextTraceQname(
        PRTraceHandle handle
);
# 528 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) PRTraceHandle
 PR_FindNextTraceRname(
        PRTraceHandle rhandle,
        PRTraceHandle qhandle
);
# 584 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) void
 PR_RecordTraceEntries(
        void
);
# 636 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prtrace.h" 3
extern __attribute__((visibility("default"))) PRIntn
    PR_GetTraceEntries(
        PRTraceEntry *buffer,
        PRInt32 count,
        PRInt32 *found
);

}
# 41 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/nspr.h" 2 3
# 4 "../../dist/system_wrappers/nspr.h" 2 3
#pragma GCC visibility pop
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheMetaData.h" 2
# 1 "../../dist/include/nscore.h" 1
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheMetaData.h" 2

class nsICacheMetaDataVisitor;

class nsCacheMetaData {
public:
    nsCacheMetaData() : mBuffer(nullptr), mBufferSize(0), mMetaSize(0) { }

    ~nsCacheMetaData() {
        mBufferSize = mMetaSize = 0;
        moz_free(mBuffer);
        mBuffer = nullptr;
    }

    const char * GetElement(const char * key);

    nsresult SetElement(const char * key, const char * value);

    uint32_t Size(void) { return mMetaSize; }

    nsresult FlattenMetaData(char * buffer, uint32_t bufSize);

    nsresult UnflattenMetaData(const char * buffer, uint32_t bufSize);

    nsresult VisitElements(nsICacheMetaDataVisitor * visitor);

private:
    nsresult EnsureBuffer(uint32_t size);

    char * mBuffer;
    uint32_t mBufferSize;
    uint32_t mMetaSize;
};
# 14 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2

# 1 "../../dist/system_wrappers/nspr.h" 1
       
# 2 "../../dist/system_wrappers/nspr.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 16 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2
# 1 "../../dist/include/pldhash.h" 1
# 13 "../../dist/include/pldhash.h"
# 1 "../../dist/include/mozilla/Types.h" 1
# 14 "../../dist/include/pldhash.h" 2



extern "C" {
# 51 "../../dist/include/pldhash.h"
typedef uint32_t PLDHashNumber;
typedef struct PLDHashEntryHdr PLDHashEntryHdr;
typedef struct PLDHashEntryStub PLDHashEntryStub;
typedef struct PLDHashTable PLDHashTable;
typedef struct PLDHashTableOps PLDHashTableOps;
# 86 "../../dist/include/pldhash.h"
struct PLDHashEntryHdr {
    PLDHashNumber keyHash;
};
# 166 "../../dist/include/pldhash.h"
struct PLDHashTable {
    const PLDHashTableOps *ops;
    void *data;
    int16_t hashShift;
    uint8_t maxAlphaFrac;
    uint8_t minAlphaFrac;
    uint32_t entrySize;
    uint32_t entryCount;
    uint32_t removedCount;
    uint32_t generation;
    char *entryStore;
# 198 "../../dist/include/pldhash.h"
};
# 213 "../../dist/include/pldhash.h"
typedef void *
(* PLDHashAllocTable)(PLDHashTable *table, uint32_t nbytes);

typedef void
(* PLDHashFreeTable) (PLDHashTable *table, void *ptr);





typedef PLDHashNumber
(* PLDHashHashKey) (PLDHashTable *table, const void *key);





typedef bool
(* PLDHashMatchEntry)(PLDHashTable *table, const PLDHashEntryHdr *entry,
                      const void *key);







typedef void
(* PLDHashMoveEntry)(PLDHashTable *table, const PLDHashEntryHdr *from,
                     PLDHashEntryHdr *to);






typedef void
(* PLDHashClearEntry)(PLDHashTable *table, PLDHashEntryHdr *entry);






typedef void
(* PLDHashFinalize) (PLDHashTable *table);
# 267 "../../dist/include/pldhash.h"
typedef bool
(* PLDHashInitEntry)(PLDHashTable *table, PLDHashEntryHdr *entry,
                     const void *key);
# 298 "../../dist/include/pldhash.h"
struct PLDHashTableOps {

    PLDHashAllocTable allocTable;
    PLDHashFreeTable freeTable;
    PLDHashHashKey hashKey;
    PLDHashMatchEntry matchEntry;
    PLDHashMoveEntry moveEntry;
    PLDHashClearEntry clearEntry;
    PLDHashFinalize finalize;


    PLDHashInitEntry initEntry;
};




 void *
PL_DHashAllocTable(PLDHashTable *table, uint32_t nbytes);

 void
PL_DHashFreeTable(PLDHashTable *table, void *ptr);

 PLDHashNumber
PL_DHashStringKey(PLDHashTable *table, const void *key);


struct PLDHashEntryStub {
    PLDHashEntryHdr hdr;
    const void *key;
};

 PLDHashNumber
PL_DHashVoidPtrKeyStub(PLDHashTable *table, const void *key);

 bool
PL_DHashMatchEntryStub(PLDHashTable *table,
                       const PLDHashEntryHdr *entry,
                       const void *key);

 bool
PL_DHashMatchStringKey(PLDHashTable *table,
                       const PLDHashEntryHdr *entry,
                       const void *key);

 void
PL_DHashMoveEntryStub(PLDHashTable *table,
                      const PLDHashEntryHdr *from,
                      PLDHashEntryHdr *to);

 void
PL_DHashClearEntryStub(PLDHashTable *table, PLDHashEntryHdr *entry);

 void
PL_DHashFreeStringKey(PLDHashTable *table, PLDHashEntryHdr *entry);

 void
PL_DHashFinalizeStub(PLDHashTable *table);






 const PLDHashTableOps *
PL_DHashGetStubOps(void);







 PLDHashTable *
PL_NewDHashTable(const PLDHashTableOps *ops, void *data, uint32_t entrySize,
                 uint32_t capacity);





 void
PL_DHashTableDestroy(PLDHashTable *table);







 bool
PL_DHashTableInit(PLDHashTable *table, const PLDHashTableOps *ops, void *data,
                  uint32_t entrySize, uint32_t capacity);
# 400 "../../dist/include/pldhash.h"
 void
PL_DHashTableSetAlphaBounds(PLDHashTable *table,
                            float maxAlpha,
                            float minAlpha);
# 444 "../../dist/include/pldhash.h"
 void
PL_DHashTableFinish(PLDHashTable *table);







typedef enum PLDHashOperator {
    PL_DHASH_LOOKUP = 0,
    PL_DHASH_ADD = 1,
    PL_DHASH_REMOVE = 2,
    PL_DHASH_NEXT = 0,
    PL_DHASH_STOP = 1
} PLDHashOperator;
# 491 "../../dist/include/pldhash.h"
 PLDHashEntryHdr *
PL_DHashTableOperate(PLDHashTable *table, const void *key, PLDHashOperator op);
# 503 "../../dist/include/pldhash.h"
 void
PL_DHashTableRawRemove(PLDHashTable *table, PLDHashEntryHdr *entry);
# 545 "../../dist/include/pldhash.h"
typedef PLDHashOperator
(* PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr, uint32_t number,
                      void *arg);

 uint32_t
PL_DHashTableEnumerate(PLDHashTable *table, PLDHashEnumerator etor, void *arg);

typedef size_t
(* PLDHashSizeOfEntryExcludingThisFun)(PLDHashEntryHdr *hdr,
                                       nsMallocSizeOfFun mallocSizeOf,
                                       void *arg);







 size_t
PL_DHashTableSizeOfExcludingThis(const PLDHashTable *table,
                                 PLDHashSizeOfEntryExcludingThisFun sizeOfEntryExcludingThis,
                                 nsMallocSizeOfFun mallocSizeOf,
                                 void *arg = __null);




 size_t
PL_DHashTableSizeOfIncludingThis(const PLDHashTable *table,
                                 PLDHashSizeOfEntryExcludingThisFun sizeOfEntryExcludingThis,
                                 nsMallocSizeOfFun mallocSizeOf,
                                 void *arg = __null);
# 605 "../../dist/include/pldhash.h"
}
# 17 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2
# 1 "../../dist/include/nsAutoPtr.h" 1
# 23 "../../dist/include/nsAutoPtr.h"
template <class T>
class nsAutoPtr
  {
    private:
      void**
      begin_assignment()
        {
          assign(0);
          return reinterpret_cast<void**>(&mRawPtr);
        }

      void
      assign( T* newPtr )
        {
          T* oldPtr = mRawPtr;

          if (newPtr != nullptr && newPtr == oldPtr) {
            NS_DebugBreak(NS_DEBUG_ABORT, "Logic flaw in the caller", nullptr, "../../dist/include/nsAutoPtr.h", 40);
          }

          mRawPtr = newPtr;
          delete oldPtr;
        }






      class Ptr
        {
          public:
            Ptr( T* aPtr )
                  : mPtr(aPtr)
              {
              }

            operator T*() const
              {
                return mPtr;
              }

          private:
            T* mPtr;
        };

    private:
      T* mRawPtr;

    public:
      typedef T element_type;

     ~nsAutoPtr()
        {
          delete mRawPtr;
        }



      nsAutoPtr()
            : mRawPtr(0)

        {
        }

      nsAutoPtr( Ptr aRawPtr )
            : mRawPtr(aRawPtr)

        {
        }

      nsAutoPtr( nsAutoPtr<T>& aSmartPtr )
            : mRawPtr( aSmartPtr.forget() )

        {
        }




      nsAutoPtr<T>&
      operator=( T* rhs )

        {
          assign(rhs);
          return *this;
        }

      nsAutoPtr<T>& operator=( nsAutoPtr<T>& rhs )

        {
          assign(rhs.forget());
          return *this;
        }



      T*
      get() const





        {
          return mRawPtr;
        }

      operator T*() const
# 141 "../../dist/include/nsAutoPtr.h"
        {
          return get();
        }

      T*
      forget()
        {
          T* temp = mRawPtr;
          mRawPtr = 0;
          return temp;
        }

      T*
      operator->() const
        {
          do { } while(0);
          return get();
        }





      template <class U, class V>
      U&
      operator->*(U V::* aMember)
        {
          do { } while(0);
          return get()->*aMember;
        }


      nsAutoPtr<T>*
      get_address()


        {
          return this;
        }

      const nsAutoPtr<T>*
      get_address() const


        {
          return this;
        }

    public:
      T&
      operator*() const
        {
          do { } while(0);
          return *get();
        }

      T**
      StartAssignment()
        {

          return reinterpret_cast<T**>(begin_assignment());




        }
  };

template <class T>
inline
nsAutoPtr<T>*
address_of( nsAutoPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
inline
const nsAutoPtr<T>*
address_of( const nsAutoPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
class nsAutoPtrGetterTransfers
# 244 "../../dist/include/nsAutoPtr.h"
  {
    public:
      explicit
      nsAutoPtrGetterTransfers( nsAutoPtr<T>& aSmartPtr )
          : mTargetSmartPtr(aSmartPtr)
        {

        }

      operator void**()
        {
          return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
        }

      operator T**()
        {
          return mTargetSmartPtr.StartAssignment();
        }

      T*&
      operator*()
        {
          return *(mTargetSmartPtr.StartAssignment());
        }

    private:
      nsAutoPtr<T>& mTargetSmartPtr;
  };

template <class T>
inline
nsAutoPtrGetterTransfers<T>
getter_Transfers( nsAutoPtr<T>& aSmartPtr )




  {
    return nsAutoPtrGetterTransfers<T>(aSmartPtr);
  }





template <class T, class U>
inline
bool
operator==( const nsAutoPtr<T>& lhs, const nsAutoPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
  }


template <class T, class U>
inline
bool
operator!=( const nsAutoPtr<T>& lhs, const nsAutoPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
  }




template <class T, class U>
inline
bool
operator==( const nsAutoPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( const U* lhs, const nsAutoPtr<T>& rhs )
  {
    return static_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsAutoPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( const U* lhs, const nsAutoPtr<T>& rhs )
  {
    return static_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }
# 349 "../../dist/include/nsAutoPtr.h"
template <class T, class U>
inline
bool
operator==( const nsAutoPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( U* lhs, const nsAutoPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsAutoPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( U* lhs, const nsAutoPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }






template <class T>
inline
bool
operator==( const nsAutoPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator==( NSCAP_Zero* lhs, const nsAutoPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
  }

template <class T>
inline
bool
operator!=( const nsAutoPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator!=( NSCAP_Zero* lhs, const nsAutoPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
  }
# 452 "../../dist/include/nsAutoPtr.h"
template <class T>
class nsAutoArrayPtr
  {
    private:
      void**
      begin_assignment()
        {
          assign(0);
          return reinterpret_cast<void**>(&mRawPtr);
        }

      void
      assign( T* newPtr )
        {
          T* oldPtr = mRawPtr;
          mRawPtr = newPtr;
          delete [] oldPtr;
        }

    private:
      T* mRawPtr;

    public:
      typedef T element_type;

     ~nsAutoArrayPtr()
        {
          delete [] mRawPtr;
        }



      nsAutoArrayPtr()
            : mRawPtr(0)

        {
        }

      nsAutoArrayPtr( T* aRawPtr )
            : mRawPtr(aRawPtr)

        {
        }

      nsAutoArrayPtr( nsAutoArrayPtr<T>& aSmartPtr )
            : mRawPtr( aSmartPtr.forget() )

        {
        }




      nsAutoArrayPtr<T>&
      operator=( T* rhs )

        {
          assign(rhs);
          return *this;
        }

      nsAutoArrayPtr<T>& operator=( nsAutoArrayPtr<T>& rhs )

        {
          assign(rhs.forget());
          return *this;
        }



      T*
      get() const





        {
          return mRawPtr;
        }

      operator T*() const
# 543 "../../dist/include/nsAutoPtr.h"
        {
          return get();
        }

      T*
      forget()
        {
          T* temp = mRawPtr;
          mRawPtr = 0;
          return temp;
        }

      T*
      operator->() const
        {
          do { } while(0);
          return get();
        }

      nsAutoArrayPtr<T>*
      get_address()


        {
          return this;
        }

      const nsAutoArrayPtr<T>*
      get_address() const


        {
          return this;
        }

    public:
      T&
      operator*() const
        {
          do { } while(0);
          return *get();
        }

      T**
      StartAssignment()
        {

          return reinterpret_cast<T**>(begin_assignment());




        }
  };

template <class T>
inline
nsAutoArrayPtr<T>*
address_of( nsAutoArrayPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
inline
const nsAutoArrayPtr<T>*
address_of( const nsAutoArrayPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
class nsAutoArrayPtrGetterTransfers
# 633 "../../dist/include/nsAutoPtr.h"
  {
    public:
      explicit
      nsAutoArrayPtrGetterTransfers( nsAutoArrayPtr<T>& aSmartPtr )
          : mTargetSmartPtr(aSmartPtr)
        {

        }

      operator void**()
        {
          return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
        }

      operator T**()
        {
          return mTargetSmartPtr.StartAssignment();
        }

      T*&
      operator*()
        {
          return *(mTargetSmartPtr.StartAssignment());
        }

    private:
      nsAutoArrayPtr<T>& mTargetSmartPtr;
  };

template <class T>
inline
nsAutoArrayPtrGetterTransfers<T>
getter_Transfers( nsAutoArrayPtr<T>& aSmartPtr )




  {
    return nsAutoArrayPtrGetterTransfers<T>(aSmartPtr);
  }





template <class T, class U>
inline
bool
operator==( const nsAutoArrayPtr<T>& lhs, const nsAutoArrayPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
  }


template <class T, class U>
inline
bool
operator!=( const nsAutoArrayPtr<T>& lhs, const nsAutoArrayPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
  }




template <class T, class U>
inline
bool
operator==( const nsAutoArrayPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( const U* lhs, const nsAutoArrayPtr<T>& rhs )
  {
    return static_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsAutoArrayPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( const U* lhs, const nsAutoArrayPtr<T>& rhs )
  {
    return static_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }
# 738 "../../dist/include/nsAutoPtr.h"
template <class T, class U>
inline
bool
operator==( const nsAutoArrayPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( U* lhs, const nsAutoArrayPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsAutoArrayPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( U* lhs, const nsAutoArrayPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }






template <class T>
inline
bool
operator==( const nsAutoArrayPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator==( NSCAP_Zero* lhs, const nsAutoArrayPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
  }

template <class T>
inline
bool
operator!=( const nsAutoArrayPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator!=( NSCAP_Zero* lhs, const nsAutoArrayPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
  }
# 842 "../../dist/include/nsAutoPtr.h"
template <class T>
class nsRefPtr
  {
    private:

      void
      assign_with_AddRef( T* rawPtr )
        {
          if ( rawPtr )
            rawPtr->AddRef();
          assign_assuming_AddRef(rawPtr);
        }

      void**
      begin_assignment()
        {
          assign_assuming_AddRef(0);
          return reinterpret_cast<void**>(&mRawPtr);
        }

      void
      assign_assuming_AddRef( T* newPtr )
        {
          T* oldPtr = mRawPtr;
          mRawPtr = newPtr;
          if ( oldPtr )
            oldPtr->Release();
        }

    private:
      T* mRawPtr;

    public:
      typedef T element_type;

     ~nsRefPtr()
        {
          if ( mRawPtr )
            mRawPtr->Release();
        }



      nsRefPtr()
            : mRawPtr(0)

        {
        }

      nsRefPtr( const nsRefPtr<T>& aSmartPtr )
            : mRawPtr(aSmartPtr.mRawPtr)

        {
          if ( mRawPtr )
            mRawPtr->AddRef();
        }

      nsRefPtr( T* aRawPtr )
            : mRawPtr(aRawPtr)

        {
          if ( mRawPtr )
            mRawPtr->AddRef();
        }

      template <typename I>
      nsRefPtr( const already_AddRefed<I>& aSmartPtr )
            : mRawPtr(aSmartPtr.mRawPtr)

        {
        }

      nsRefPtr( const nsCOMPtr_helper& helper )
        {
          void* newRawPtr;
          if (((bool)(__builtin_expect(!!(NS_FAILED_impl(helper((T::template COMTypeInfo<int>::kIID), &newRawPtr))), 0))))
            newRawPtr = 0;
          mRawPtr = static_cast<T*>(newRawPtr);
        }



      nsRefPtr<T>&
      operator=( const nsRefPtr<T>& rhs )

        {
          assign_with_AddRef(rhs.mRawPtr);
          return *this;
        }

      nsRefPtr<T>&
      operator=( T* rhs )

        {
          assign_with_AddRef(rhs);
          return *this;
        }

      template <typename I>
      nsRefPtr<T>&
      operator=( const already_AddRefed<I>& rhs )

        {
          assign_assuming_AddRef(rhs.mRawPtr);
          return *this;
        }

      nsRefPtr<T>&
      operator=( const nsCOMPtr_helper& helper )
        {
          void* newRawPtr;
          if (((bool)(__builtin_expect(!!(NS_FAILED_impl(helper((T::template COMTypeInfo<int>::kIID), &newRawPtr))), 0))))
            newRawPtr = 0;
          assign_assuming_AddRef(static_cast<T*>(newRawPtr));
          return *this;
        }



      void
      swap( nsRefPtr<T>& rhs )

        {
          T* temp = rhs.mRawPtr;
          rhs.mRawPtr = mRawPtr;
          mRawPtr = temp;
        }

      void
      swap( T*& rhs )

        {
          T* temp = rhs;
          rhs = mRawPtr;
          mRawPtr = temp;
        }

      already_AddRefed<T>
      forget()


        {
          T* temp = 0;
          swap(temp);
          return temp;
        }

      template <typename I>
      void
      forget( I** rhs)




        {
          do { } while(0);
          *rhs = mRawPtr;
          mRawPtr = 0;
        }

      T*
      get() const




        {
          return const_cast<T*>(mRawPtr);
        }

      operator T*() const
# 1021 "../../dist/include/nsAutoPtr.h"
        {
          return get();
        }

      T*
      operator->() const
        {
          do { } while(0);
          return get();
        }





      template <class U, class V>
      U&
      operator->*(U V::* aMember)
        {
          do { } while(0);
          return get()->*aMember;
        }


      nsRefPtr<T>*
      get_address()


        {
          return this;
        }

      const nsRefPtr<T>*
      get_address() const


        {
          return this;
        }

    public:
      T&
      operator*() const
        {
          do { } while(0);
          return *get();
        }

      T**
      StartAssignment()
        {

          return reinterpret_cast<T**>(begin_assignment());




        }
  };

template <typename T>
inline void
ImplCycleCollectionUnlink(nsRefPtr<T>& aField)
{
  aField = nullptr;
}

template <typename T>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsRefPtr<T>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  CycleCollectionNoteChild(aCallback, aField.get(), aName, aFlags);
}

template <class T>
inline
nsRefPtr<T>*
address_of( nsRefPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
inline
const nsRefPtr<T>*
address_of( const nsRefPtr<T>& aPtr )
  {
    return aPtr.get_address();
  }

template <class T>
class nsRefPtrGetterAddRefs
# 1133 "../../dist/include/nsAutoPtr.h"
  {
    public:
      explicit
      nsRefPtrGetterAddRefs( nsRefPtr<T>& aSmartPtr )
          : mTargetSmartPtr(aSmartPtr)
        {

        }

      operator void**()
        {
          return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
        }

      operator T**()
        {
          return mTargetSmartPtr.StartAssignment();
        }

      T*&
      operator*()
        {
          return *(mTargetSmartPtr.StartAssignment());
        }

    private:
      nsRefPtr<T>& mTargetSmartPtr;
  };

template <class T>
inline
nsRefPtrGetterAddRefs<T>
getter_AddRefs( nsRefPtr<T>& aSmartPtr )




  {
    return nsRefPtrGetterAddRefs<T>(aSmartPtr);
  }





template <class T, class U>
inline
bool
operator==( const nsRefPtr<T>& lhs, const nsRefPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
  }


template <class T, class U>
inline
bool
operator!=( const nsRefPtr<T>& lhs, const nsRefPtr<U>& rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
  }




template <class T, class U>
inline
bool
operator==( const nsRefPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( const U* lhs, const nsRefPtr<T>& rhs )
  {
    return static_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsRefPtr<T>& lhs, const U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( const U* lhs, const nsRefPtr<T>& rhs )
  {
    return static_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }
# 1238 "../../dist/include/nsAutoPtr.h"
template <class T, class U>
inline
bool
operator==( const nsRefPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator==( U* lhs, const nsRefPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
  }

template <class T, class U>
inline
bool
operator!=( const nsRefPtr<T>& lhs, U* rhs )
  {
    return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
  }

template <class T, class U>
inline
bool
operator!=( U* lhs, const nsRefPtr<T>& rhs )
  {
    return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
  }






template <class T>
inline
bool
operator==( const nsRefPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator==( NSCAP_Zero* lhs, const nsRefPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
  }

template <class T>
inline
bool
operator!=( const nsRefPtr<T>& lhs, NSCAP_Zero* rhs )

  {
    return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
  }

template <class T>
inline
bool
operator!=( NSCAP_Zero* lhs, const nsRefPtr<T>& rhs )

  {
    return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
  }
# 1337 "../../dist/include/nsAutoPtr.h"
template <class SourceType, class DestinationType>
inline
nsresult
CallQueryInterface( nsRefPtr<SourceType>& aSourcePtr, DestinationType** aDestPtr )
  {
    return CallQueryInterface(aSourcePtr.get(), aDestPtr);
  }



template<class T>
class nsQueryObject : public nsCOMPtr_helper
{
public:
  nsQueryObject(T* aRawPtr)
    : mRawPtr(aRawPtr) {}

  virtual nsresult operator()( const nsIID& aIID, void** aResult ) const {
    nsresult status = mRawPtr ? mRawPtr->QueryInterface(aIID, aResult)
                              : nsresult::NS_ERROR_NULL_POINTER;
    return status;
  }
private:
  T* mRawPtr;
};

template<class T>
class nsQueryObjectWithError : public nsCOMPtr_helper
{
public:
  nsQueryObjectWithError(T* aRawPtr, nsresult* aErrorPtr)
    : mRawPtr(aRawPtr), mErrorPtr(aErrorPtr) {}

  virtual nsresult operator()( const nsIID& aIID, void** aResult ) const {
    nsresult status = mRawPtr ? mRawPtr->QueryInterface(aIID, aResult)
                              : nsresult::NS_ERROR_NULL_POINTER;
    if (mErrorPtr)
      *mErrorPtr = status;
    return status;
  }
private:
  T* mRawPtr;
  nsresult* mErrorPtr;
};

template<class T>
inline
nsQueryObject<T>
do_QueryObject(T* aRawPtr)
{
  return nsQueryObject<T>(aRawPtr);
}

template<class T>
inline
nsQueryObject<T>
do_QueryObject(nsCOMPtr<T>& aRawPtr)
{
  return nsQueryObject<T>(aRawPtr);
}

template<class T>
inline
nsQueryObject<T>
do_QueryObject(nsRefPtr<T>& aRawPtr)
{
  return nsQueryObject<T>(aRawPtr);
}

template<class T>
inline
nsQueryObjectWithError<T>
do_QueryObject(T* aRawPtr, nsresult* aErrorPtr)
{
  return nsQueryObjectWithError<T>(aRawPtr, aErrorPtr);
}

template<class T>
inline
nsQueryObjectWithError<T>
do_QueryObject(nsCOMPtr<T>& aRawPtr, nsresult* aErrorPtr)
{
  return nsQueryObjectWithError<T>(aRawPtr, aErrorPtr);
}

template<class T>
inline
nsQueryObjectWithError<T>
do_QueryObject(nsRefPtr<T>& aRawPtr, nsresult* aErrorPtr)
{
  return nsQueryObjectWithError<T>(aRawPtr, aErrorPtr);
}
# 18 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2

# 1 "../../dist/include/nsCOMPtr.h" 1
# 20 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2
# 1 "../../dist/include/nsString.h" 1
# 17 "../../dist/include/nsString.h"
# 1 "../../dist/include/nsDependentSubstring.h" 1
# 15 "../../dist/include/nsDependentSubstring.h"
# 1 "../../dist/include/string-template-def-unichar.h" 1
# 16 "../../dist/include/nsDependentSubstring.h" 2
# 1 "../../dist/include/nsTDependentSubstring.h" 1
# 20 "../../dist/include/nsTDependentSubstring.h"
class nsDependentSubstring : public nsAString_internal
  {
    public:

      typedef nsDependentSubstring self_type;

    public:

      void Rebind( const substring_type&, uint32_t startPos, uint32_t length = size_type(-1) );

      void Rebind( const char_type* data, size_type length );

      void Rebind( const char_type* start, const char_type* end )
        {
          Rebind(start, size_type(end - start));
        }

      nsDependentSubstring( const substring_type& str, uint32_t startPos, uint32_t length = size_type(-1) )
        : substring_type()
        {
          Rebind(str, startPos, length);
        }

      nsDependentSubstring( const char_type* data, size_type length )
        : substring_type(const_cast<char_type*>(data), length, F_NONE) {}

      nsDependentSubstring( const char_type* start, const char_type* end )
        : substring_type(const_cast<char_type*>(start), uint32_t(end - start), F_NONE) {}

      nsDependentSubstring( const const_iterator& start, const const_iterator& end )
        : substring_type(const_cast<char_type*>(start.get()), uint32_t(end.get() - start.get()), F_NONE) {}


      nsDependentSubstring()
        : substring_type() {}



    private:

      void operator=( const self_type& );
  };

inline
const nsDependentSubstring
Substring( const nsAString_internal& str, uint32_t startPos, uint32_t length = uint32_t(-1) )
  {
    return nsDependentSubstring(str, startPos, length);
  }

inline
const nsDependentSubstring
Substring( const nsReadingIterator<PRUnichar>& start, const nsReadingIterator<PRUnichar>& end )
  {
    return nsDependentSubstring(start.get(), end.get());
  }

inline
const nsDependentSubstring
Substring( const PRUnichar* data, uint32_t length )
  {
    return nsDependentSubstring(data, length);
  }

inline
const nsDependentSubstring
Substring( const PRUnichar* start, const PRUnichar* end )
  {
    return nsDependentSubstring(start, end);
  }

inline
const nsDependentSubstring
StringHead( const nsAString_internal& str, uint32_t count )
  {
    return nsDependentSubstring(str, 0, count);
  }

inline
const nsDependentSubstring
StringTail( const nsAString_internal& str, uint32_t count )
  {
    return nsDependentSubstring(str, str.Length() - count, count);
  }
# 17 "../../dist/include/nsDependentSubstring.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 18 "../../dist/include/nsDependentSubstring.h" 2


# 1 "../../dist/include/string-template-def-char.h" 1
# 21 "../../dist/include/nsDependentSubstring.h" 2
# 1 "../../dist/include/nsTDependentSubstring.h" 1
# 20 "../../dist/include/nsTDependentSubstring.h"
class nsDependentCSubstring : public nsACString_internal
  {
    public:

      typedef nsDependentCSubstring self_type;

    public:

      void Rebind( const substring_type&, uint32_t startPos, uint32_t length = size_type(-1) );

      void Rebind( const char_type* data, size_type length );

      void Rebind( const char_type* start, const char_type* end )
        {
          Rebind(start, size_type(end - start));
        }

      nsDependentCSubstring( const substring_type& str, uint32_t startPos, uint32_t length = size_type(-1) )
        : substring_type()
        {
          Rebind(str, startPos, length);
        }

      nsDependentCSubstring( const char_type* data, size_type length )
        : substring_type(const_cast<char_type*>(data), length, F_NONE) {}

      nsDependentCSubstring( const char_type* start, const char_type* end )
        : substring_type(const_cast<char_type*>(start), uint32_t(end - start), F_NONE) {}

      nsDependentCSubstring( const const_iterator& start, const const_iterator& end )
        : substring_type(const_cast<char_type*>(start.get()), uint32_t(end.get() - start.get()), F_NONE) {}


      nsDependentCSubstring()
        : substring_type() {}



    private:

      void operator=( const self_type& );
  };

inline
const nsDependentCSubstring
Substring( const nsACString_internal& str, uint32_t startPos, uint32_t length = uint32_t(-1) )
  {
    return nsDependentCSubstring(str, startPos, length);
  }

inline
const nsDependentCSubstring
Substring( const nsReadingIterator<char>& start, const nsReadingIterator<char>& end )
  {
    return nsDependentCSubstring(start.get(), end.get());
  }

inline
const nsDependentCSubstring
Substring( const char* data, uint32_t length )
  {
    return nsDependentCSubstring(data, length);
  }

inline
const nsDependentCSubstring
Substring( const char* start, const char* end )
  {
    return nsDependentCSubstring(start, end);
  }

inline
const nsDependentCSubstring
StringHead( const nsACString_internal& str, uint32_t count )
  {
    return nsDependentCSubstring(str, 0, count);
  }

inline
const nsDependentCSubstring
StringTail( const nsACString_internal& str, uint32_t count )
  {
    return nsDependentCSubstring(str, str.Length() - count, count);
  }
# 22 "../../dist/include/nsDependentSubstring.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 23 "../../dist/include/nsDependentSubstring.h" 2
# 18 "../../dist/include/nsString.h" 2



# 1 "../../dist/include/nsReadableUtils.h" 1
# 18 "../../dist/include/nsReadableUtils.h"
template<class E> class nsTArray;

inline size_t Distance( const nsReadingIterator<PRUnichar>& start, const nsReadingIterator<PRUnichar>& end )
  {
    return end.get() - start.get();
  }
inline size_t Distance( const nsReadingIterator<char>& start, const nsReadingIterator<char>& end )
  {
    return end.get() - start.get();
  }

void LossyCopyUTF16toASCII( const nsAString_internal& aSource, nsACString_internal& aDest );
void CopyASCIItoUTF16( const nsACString_internal& aSource, nsAString_internal& aDest );

void LossyCopyUTF16toASCII( const PRUnichar* aSource, nsACString_internal& aDest );
void CopyASCIItoUTF16( const char* aSource, nsAString_internal& aDest );

void CopyUTF16toUTF8( const nsAString_internal& aSource, nsACString_internal& aDest );
void CopyUTF8toUTF16( const nsACString_internal& aSource, nsAString_internal& aDest );

void CopyUTF16toUTF8( const PRUnichar* aSource, nsACString_internal& aDest );
void CopyUTF8toUTF16( const char* aSource, nsAString_internal& aDest );

void LossyAppendUTF16toASCII( const nsAString_internal& aSource, nsACString_internal& aDest );
void AppendASCIItoUTF16( const nsACString_internal& aSource, nsAString_internal& aDest );

void LossyAppendUTF16toASCII( const PRUnichar* aSource, nsACString_internal& aDest );
void AppendASCIItoUTF16( const char* aSource, nsAString_internal& aDest );

void AppendUTF16toUTF8( const nsAString_internal& aSource, nsACString_internal& aDest );
void AppendUTF8toUTF16( const nsACString_internal& aSource, nsAString_internal& aDest );
bool AppendUTF8toUTF16( const nsACString_internal& aSource, nsAString_internal& aDest,
                        const mozilla::fallible_t& ) __attribute__((warn_unused_result));

void AppendUTF16toUTF8( const PRUnichar* aSource, nsACString_internal& aDest );
void AppendUTF8toUTF16( const char* aSource, nsAString_internal& aDest );
# 66 "../../dist/include/nsReadableUtils.h"
char* ToNewCString( const nsAString_internal& aSource );
# 78 "../../dist/include/nsReadableUtils.h"
char* ToNewCString( const nsACString_internal& aSource );
# 95 "../../dist/include/nsReadableUtils.h"
char* ToNewUTF8String( const nsAString_internal& aSource, uint32_t *aUTF8Count = nullptr );
# 110 "../../dist/include/nsReadableUtils.h"
PRUnichar* ToNewUnicode( const nsAString_internal& aSource );
# 124 "../../dist/include/nsReadableUtils.h"
PRUnichar* ToNewUnicode( const nsACString_internal& aSource );
# 134 "../../dist/include/nsReadableUtils.h"
uint32_t CalcUTF8ToUnicodeLength( const nsACString_internal& aSource );
# 154 "../../dist/include/nsReadableUtils.h"
PRUnichar* UTF8ToUnicodeBuffer( const nsACString_internal& aSource,
                                PRUnichar *aBuffer,
                                uint32_t *aUTF16Count = nullptr );
# 173 "../../dist/include/nsReadableUtils.h"
PRUnichar* UTF8ToNewUnicode( const nsACString_internal& aSource, uint32_t *aUTF16Count = nullptr );
# 187 "../../dist/include/nsReadableUtils.h"
PRUnichar* CopyUnicodeTo( const nsAString_internal& aSource,
                                 uint32_t aSrcOffset,
                                 PRUnichar* aDest,
                                 uint32_t aLength );
# 204 "../../dist/include/nsReadableUtils.h"
void CopyUnicodeTo( const nsAString_internal::const_iterator& aSrcStart,
                           const nsAString_internal::const_iterator& aSrcEnd,
                           nsAString_internal& aDest );
# 218 "../../dist/include/nsReadableUtils.h"
void AppendUnicodeTo( const nsAString_internal::const_iterator& aSrcStart,
                             const nsAString_internal::const_iterator& aSrcEnd,
                             nsAString_internal& aDest );






bool IsASCII( const nsAString_internal& aString );






bool IsASCII( const nsACString_internal& aString );
# 267 "../../dist/include/nsReadableUtils.h"
bool IsUTF8( const nsACString_internal& aString, bool aRejectNonChar = true );

bool ParseString(const nsACString_internal& aAstring, char aDelimiter,
                          nsTArray<nsCString>& aArray);




void ToUpperCase( nsACString_internal& );

void ToLowerCase( nsACString_internal& );

void ToUpperCase( nsCSubstring& );

void ToLowerCase( nsCSubstring& );




void ToUpperCase( const nsACString_internal& aSource, nsACString_internal& aDest );

void ToLowerCase( const nsACString_internal& aSource, nsACString_internal& aDest );
# 300 "../../dist/include/nsReadableUtils.h"
bool FindInReadable( const nsAString_internal& aPattern, nsAString_internal::const_iterator&, nsAString_internal::const_iterator&, const nsStringComparator& = nsDefaultStringComparator() );
bool FindInReadable( const nsACString_internal& aPattern, nsACString_internal::const_iterator&, nsACString_internal::const_iterator&, const nsCStringComparator& = nsDefaultCStringComparator() );



inline bool FindInReadable( const nsAString_internal& aPattern, const nsAString_internal& aSource, const nsStringComparator& compare = nsDefaultStringComparator() )
{
  nsAString_internal::const_iterator start, end;
  aSource.BeginReading(start);
  aSource.EndReading(end);
  return FindInReadable(aPattern, start, end, compare);
}

inline bool FindInReadable( const nsACString_internal& aPattern, const nsACString_internal& aSource, const nsCStringComparator& compare = nsDefaultCStringComparator() )
{
  nsACString_internal::const_iterator start, end;
  aSource.BeginReading(start);
  aSource.EndReading(end);
  return FindInReadable(aPattern, start, end, compare);
}


bool CaseInsensitiveFindInReadable( const nsACString_internal& aPattern, nsACString_internal::const_iterator&, nsACString_internal::const_iterator& );







bool RFindInReadable( const nsAString_internal& aPattern, nsAString_internal::const_iterator&, nsAString_internal::const_iterator&, const nsStringComparator& = nsDefaultStringComparator() );
bool RFindInReadable( const nsACString_internal& aPattern, nsACString_internal::const_iterator&, nsACString_internal::const_iterator&, const nsCStringComparator& = nsDefaultCStringComparator() );
# 341 "../../dist/include/nsReadableUtils.h"
bool FindCharInReadable( PRUnichar aChar, nsAString_internal::const_iterator& aSearchStart, const nsAString_internal::const_iterator& aSearchEnd );
bool FindCharInReadable( char aChar, nsACString_internal::const_iterator& aSearchStart, const nsACString_internal::const_iterator& aSearchEnd );




uint32_t CountCharInReadable( const nsAString_internal& aStr,
                                     PRUnichar aChar );
uint32_t CountCharInReadable( const nsACString_internal& aStr,
                                     char aChar );

bool
StringBeginsWith( const nsAString_internal& aSource, const nsAString_internal& aSubstring,
                  const nsStringComparator& aComparator =
                                              nsDefaultStringComparator() );
bool
StringBeginsWith( const nsACString_internal& aSource, const nsACString_internal& aSubstring,
                  const nsCStringComparator& aComparator =
                                               nsDefaultCStringComparator() );
bool
StringEndsWith( const nsAString_internal& aSource, const nsAString_internal& aSubstring,
                const nsStringComparator& aComparator =
                                            nsDefaultStringComparator() );
bool
StringEndsWith( const nsACString_internal& aSource, const nsACString_internal& aSubstring,
                const nsCStringComparator& aComparator =
                                             nsDefaultCStringComparator() );

const nsAFlatString& EmptyString();
const nsAFlatCString& EmptyCString();

const nsAFlatString& NullString();
const nsAFlatCString& NullCString();
# 383 "../../dist/include/nsReadableUtils.h"
int32_t
CompareUTF8toUTF16(const nsASingleFragmentCString& aUTF8String,
                   const nsASingleFragmentString& aUTF16String);

void
AppendUCS4ToUTF16(const uint32_t aSource, nsAString_internal& aDest);

template<class T>
inline bool EnsureStringLength(T& aStr, uint32_t aLen)
{
    aStr.SetLength(aLen);
    return (aStr.Length() == aLen);
}
# 22 "../../dist/include/nsString.h" 2



# 1 "../../dist/system_wrappers/prtypes.h" 1
       
# 2 "../../dist/system_wrappers/prtypes.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 26 "../../dist/include/nsString.h" 2
# 45 "../../dist/include/nsString.h"
# 1 "../../dist/include/string-template-def-unichar.h" 1
# 46 "../../dist/include/nsString.h" 2
# 1 "../../dist/include/nsTString.h" 1
# 21 "../../dist/include/nsTString.h"
class nsString : public nsAString_internal
  {
    public:

      typedef nsString self_type;

    public:





      nsString()
        : substring_type() {}

      explicit
      nsString( const char_type* data, size_type length = size_type(-1) )
        : substring_type()
        {
          Assign(data, length);
        }

      nsString( const self_type& str )
        : substring_type()
        {
          Assign(str);
        }

      nsString( const substring_tuple_type& tuple )
        : substring_type()
        {
          Assign(tuple);
        }

      explicit
      nsString( const substring_type& readable )
        : substring_type()
        {
          Assign(readable);
        }



      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }





      const char_type* get() const
        {
          return mData;
        }
# 87 "../../dist/include/nsTString.h"
      char_type CharAt( index_type i ) const
        {
          do { } while(0);
          return mData[i];
        }

      char_type operator[]( index_type i ) const
        {
          return CharAt(i);
        }
# 113 "../../dist/include/nsTString.h"
      int32_t Find( const nsCString& aString, bool aIgnoreCase=false, int32_t aOffset=0, int32_t aCount=-1 ) const;
      int32_t Find( const char* aString, bool aIgnoreCase=false, int32_t aOffset=0, int32_t aCount=-1 ) const;


      int32_t Find( const nsAFlatString& aString, int32_t aOffset=0, int32_t aCount=-1 ) const;
      int32_t Find( const PRUnichar* aString, int32_t aOffset=0, int32_t aCount=-1 ) const;
# 134 "../../dist/include/nsTString.h"
      int32_t RFind( const nsCString& aString, bool aIgnoreCase=false, int32_t aOffset=-1, int32_t aCount=-1 ) const;
      int32_t RFind( const char* aCString, bool aIgnoreCase=false, int32_t aOffset=-1, int32_t aCount=-1 ) const;


      int32_t RFind( const nsAFlatString& aString, int32_t aOffset=-1, int32_t aCount=-1 ) const;
      int32_t RFind( const PRUnichar* aString, int32_t aOffset=-1, int32_t aCount=-1 ) const;
# 154 "../../dist/include/nsTString.h"
      int32_t RFindChar( PRUnichar aChar, int32_t aOffset=-1, int32_t aCount=-1 ) const;
# 167 "../../dist/include/nsTString.h"
      int32_t FindCharInSet( const char* aString, int32_t aOffset=0 ) const;
      int32_t FindCharInSet( const self_type& aString, int32_t aOffset=0 ) const
        {
          return FindCharInSet(aString.get(), aOffset);
        }


      int32_t FindCharInSet( const PRUnichar* aString, int32_t aOffset=0 ) const;
# 188 "../../dist/include/nsTString.h"
      int32_t RFindCharInSet( const char_type* aString, int32_t aOffset=-1 ) const;
      int32_t RFindCharInSet( const self_type& aString, int32_t aOffset=-1 ) const
        {
          return RFindCharInSet(aString.get(), aOffset);
        }
# 222 "../../dist/include/nsTString.h"
      bool EqualsIgnoreCase( const char* aString, int32_t aCount=-1 ) const;
# 233 "../../dist/include/nsTString.h"
      double ToDouble( nsresult* aErrorCode ) const;







      float ToFloat( nsresult* aErrorCode ) const {
        return (float)ToDouble(aErrorCode);
      }
# 252 "../../dist/include/nsTString.h"
      int32_t ToInteger( nsresult* aErrorCode, uint32_t aRadix=(10) ) const;







      int64_t ToInteger64( nsresult* aErrorCode, uint32_t aRadix=(10) ) const;
# 280 "../../dist/include/nsTString.h"
      size_type Mid( self_type& aResult, uint32_t aStartPos, uint32_t aCount ) const;

      size_type Left( self_type& aResult, size_type aCount ) const
        {
          return Mid(aResult, 0, aCount);
        }

      size_type Right( self_type& aResult, size_type aCount ) const
        {
          aCount = XPCOM_MIN(mLength, aCount);
          return Mid(aResult, mLength - aCount, aCount);
        }
# 302 "../../dist/include/nsTString.h"
      bool SetCharAt( PRUnichar aChar, uint32_t aIndex );
# 311 "../../dist/include/nsTString.h"
      void StripChars( const char* aSet );





      void StripWhitespace();






      void ReplaceChar( char_type aOldChar, char_type aNewChar );
      void ReplaceChar( const char* aSet, char_type aNewChar );
      void ReplaceSubstring( const self_type& aTarget, const self_type& aNewValue);
      void ReplaceSubstring( const char_type* aTarget, const char_type* aNewValue);
# 340 "../../dist/include/nsTString.h"
      void Trim( const char* aSet, bool aEliminateLeading=true, bool aEliminateTrailing=true, bool aIgnoreQuotes=false );
# 350 "../../dist/include/nsTString.h"
      void CompressWhitespace( bool aEliminateLeading=true, bool aEliminateTrailing=true );






      void AssignWithConversion( const nsACString_internal& aString );
      void AssignWithConversion( const incompatible_char_type* aData, int32_t aLength=-1 );




    protected:

      explicit
      nsString( uint32_t flags )
        : substring_type(flags) {}


      nsString( char_type* data, size_type length, uint32_t flags )
        : substring_type(data, length, flags) {}
  };


class nsFixedString : public nsString
  {
    public:

      typedef nsFixedString self_type;
      typedef nsFixedString fixed_string_type;

    public:
# 394 "../../dist/include/nsTString.h"
      nsFixedString( char_type* data, size_type storageSize )
        : string_type(data, uint32_t(char_traits::length(data)), F_TERMINATED | F_FIXED | F_CLASS_FIXED)
        , mFixedCapacity(storageSize - 1)
        , mFixedBuf(data)
        {}

      nsFixedString( char_type* data, size_type storageSize, size_type length )
        : string_type(data, length, F_TERMINATED | F_FIXED | F_CLASS_FIXED)
        , mFixedCapacity(storageSize - 1)
        , mFixedBuf(data)
        {

          mFixedBuf[length] = char_type(0);
        }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }

    protected:

      friend class nsAString_internal;

      size_type mFixedCapacity;
      char_type *mFixedBuf;
  };
# 436 "../../dist/include/nsTString.h"
class nsAutoString : public nsFixedString
  {
    public:

      typedef nsAutoString self_type;

    public:





      nsAutoString()
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {}

      explicit
      nsAutoString( char_type c )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(c);
        }

      explicit
      nsAutoString( const char_type* data, size_type length = size_type(-1) )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(data, length);
        }

      nsAutoString( const self_type& str )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(str);
        }

      explicit
      nsAutoString( const substring_type& str )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(str);
        }

      nsAutoString( const substring_tuple_type& tuple )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(tuple);
        }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }

      enum { kDefaultStorageSize = 64 };

    private:

      char_type mStorage[kDefaultStorageSize];
  };







  template<class E> class nsTArrayElementTraits;
  template<>
  class nsTArrayElementTraits<nsAutoString> {
    public:
      template<class A> struct Dont_Instantiate_nsTArray_of;
      template<class A> struct Instead_Use_nsTArray_of;

      static Dont_Instantiate_nsTArray_of<nsAutoString> *
      Construct(Instead_Use_nsTArray_of<nsString> *e) {
        return 0;
      }
      template<class A>
      static Dont_Instantiate_nsTArray_of<nsAutoString> *
      Construct(Instead_Use_nsTArray_of<nsString> *e,
                const A &arg) {
        return 0;
      }
      static Dont_Instantiate_nsTArray_of<nsAutoString> *
      Destruct(Instead_Use_nsTArray_of<nsString> *e) {
        return 0;
      }
  };
# 540 "../../dist/include/nsTString.h"
class nsXPIDLString : public nsString
  {
    public:

      typedef nsXPIDLString self_type;

    public:

      nsXPIDLString()
        : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED) {}


      nsXPIDLString( const self_type& str )
        : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED)
        {
          Assign(str);
        }


      const char_type* get() const
        {
          return (mFlags & F_VOIDED) ? nullptr : mData;
        }



      operator const char_type*() const
        {
          return get();
        }


      char_type operator[]( int32_t i ) const
        {
          return CharAt(index_type(i));
        }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }
  };
# 598 "../../dist/include/nsTString.h"
class nsGetterCopies
  {
    public:
      typedef PRUnichar char_type;

      nsGetterCopies(nsAString_internal& str)
        : mString(str), mData(nullptr) {}

      ~nsGetterCopies()
        {
          mString.Adopt(mData);
        }

      operator char_type**()
        {
          return &mData;
        }

    private:
      nsAString_internal& mString;
      char_type* mData;
  };

inline
nsGetterCopies
getter_Copies( nsAString_internal& aString )
  {
    return nsGetterCopies(aString);
  }
# 637 "../../dist/include/nsTString.h"
class nsAdoptingString : public nsXPIDLString
  {
    public:

      typedef nsAdoptingString self_type;

    public:

      explicit nsAdoptingString() {}
      explicit nsAdoptingString(char_type* str, size_type length = size_type(-1))
        {
          Adopt(str, length);
        }





      nsAdoptingString( const self_type& str )
        {
          *this = str;
        }


      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }




      self_type& operator=( const self_type& str );

    private:
      self_type& operator=( const char_type* data ) = delete;
      self_type& operator=( char_type* data ) = delete;
  };
# 47 "../../dist/include/nsString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 48 "../../dist/include/nsString.h" 2


# 1 "../../dist/include/string-template-def-char.h" 1
# 51 "../../dist/include/nsString.h" 2
# 1 "../../dist/include/nsTString.h" 1
# 21 "../../dist/include/nsTString.h"
class nsCString : public nsACString_internal
  {
    public:

      typedef nsCString self_type;

    public:





      nsCString()
        : substring_type() {}

      explicit
      nsCString( const char_type* data, size_type length = size_type(-1) )
        : substring_type()
        {
          Assign(data, length);
        }

      nsCString( const self_type& str )
        : substring_type()
        {
          Assign(str);
        }

      nsCString( const substring_tuple_type& tuple )
        : substring_type()
        {
          Assign(tuple);
        }

      explicit
      nsCString( const substring_type& readable )
        : substring_type()
        {
          Assign(readable);
        }



      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }





      const char_type* get() const
        {
          return mData;
        }
# 87 "../../dist/include/nsTString.h"
      char_type CharAt( index_type i ) const
        {
          do { } while(0);
          return mData[i];
        }

      char_type operator[]( index_type i ) const
        {
          return CharAt(i);
        }
# 113 "../../dist/include/nsTString.h"
      int32_t Find( const nsCString& aString, bool aIgnoreCase=false, int32_t aOffset=0, int32_t aCount=-1 ) const;
      int32_t Find( const char* aString, bool aIgnoreCase=false, int32_t aOffset=0, int32_t aCount=-1 ) const;
# 134 "../../dist/include/nsTString.h"
      int32_t RFind( const nsCString& aString, bool aIgnoreCase=false, int32_t aOffset=-1, int32_t aCount=-1 ) const;
      int32_t RFind( const char* aCString, bool aIgnoreCase=false, int32_t aOffset=-1, int32_t aCount=-1 ) const;
# 154 "../../dist/include/nsTString.h"
      int32_t RFindChar( PRUnichar aChar, int32_t aOffset=-1, int32_t aCount=-1 ) const;
# 167 "../../dist/include/nsTString.h"
      int32_t FindCharInSet( const char* aString, int32_t aOffset=0 ) const;
      int32_t FindCharInSet( const self_type& aString, int32_t aOffset=0 ) const
        {
          return FindCharInSet(aString.get(), aOffset);
        }
# 188 "../../dist/include/nsTString.h"
      int32_t RFindCharInSet( const char_type* aString, int32_t aOffset=-1 ) const;
      int32_t RFindCharInSet( const self_type& aString, int32_t aOffset=-1 ) const
        {
          return RFindCharInSet(aString.get(), aOffset);
        }
# 205 "../../dist/include/nsTString.h"
      int32_t Compare( const char* aString, bool aIgnoreCase=false, int32_t aCount=-1 ) const;
# 218 "../../dist/include/nsTString.h"
      bool EqualsIgnoreCase( const char* aString, int32_t aCount=-1 ) const {
        return Compare(aString, true, aCount) == 0;
      }
# 233 "../../dist/include/nsTString.h"
      double ToDouble( nsresult* aErrorCode ) const;







      float ToFloat( nsresult* aErrorCode ) const {
        return (float)ToDouble(aErrorCode);
      }
# 252 "../../dist/include/nsTString.h"
      int32_t ToInteger( nsresult* aErrorCode, uint32_t aRadix=(10) ) const;







      int64_t ToInteger64( nsresult* aErrorCode, uint32_t aRadix=(10) ) const;
# 280 "../../dist/include/nsTString.h"
      size_type Mid( self_type& aResult, uint32_t aStartPos, uint32_t aCount ) const;

      size_type Left( self_type& aResult, size_type aCount ) const
        {
          return Mid(aResult, 0, aCount);
        }

      size_type Right( self_type& aResult, size_type aCount ) const
        {
          aCount = XPCOM_MIN(mLength, aCount);
          return Mid(aResult, mLength - aCount, aCount);
        }
# 302 "../../dist/include/nsTString.h"
      bool SetCharAt( PRUnichar aChar, uint32_t aIndex );
# 311 "../../dist/include/nsTString.h"
      void StripChars( const char* aSet );





      void StripWhitespace();






      void ReplaceChar( char_type aOldChar, char_type aNewChar );
      void ReplaceChar( const char* aSet, char_type aNewChar );
      void ReplaceSubstring( const self_type& aTarget, const self_type& aNewValue);
      void ReplaceSubstring( const char_type* aTarget, const char_type* aNewValue);
# 340 "../../dist/include/nsTString.h"
      void Trim( const char* aSet, bool aEliminateLeading=true, bool aEliminateTrailing=true, bool aIgnoreQuotes=false );
# 350 "../../dist/include/nsTString.h"
      void CompressWhitespace( bool aEliminateLeading=true, bool aEliminateTrailing=true );






      void AssignWithConversion( const nsAString_internal& aString );
      void AssignWithConversion( const incompatible_char_type* aData, int32_t aLength=-1 );




    protected:

      explicit
      nsCString( uint32_t flags )
        : substring_type(flags) {}


      nsCString( char_type* data, size_type length, uint32_t flags )
        : substring_type(data, length, flags) {}
  };


class nsFixedCString : public nsCString
  {
    public:

      typedef nsFixedCString self_type;
      typedef nsFixedCString fixed_string_type;

    public:
# 394 "../../dist/include/nsTString.h"
      nsFixedCString( char_type* data, size_type storageSize )
        : string_type(data, uint32_t(char_traits::length(data)), F_TERMINATED | F_FIXED | F_CLASS_FIXED)
        , mFixedCapacity(storageSize - 1)
        , mFixedBuf(data)
        {}

      nsFixedCString( char_type* data, size_type storageSize, size_type length )
        : string_type(data, length, F_TERMINATED | F_FIXED | F_CLASS_FIXED)
        , mFixedCapacity(storageSize - 1)
        , mFixedBuf(data)
        {

          mFixedBuf[length] = char_type(0);
        }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }

    protected:

      friend class nsACString_internal;

      size_type mFixedCapacity;
      char_type *mFixedBuf;
  };
# 436 "../../dist/include/nsTString.h"
class nsAutoCString : public nsFixedCString
  {
    public:

      typedef nsAutoCString self_type;

    public:





      nsAutoCString()
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {}

      explicit
      nsAutoCString( char_type c )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(c);
        }

      explicit
      nsAutoCString( const char_type* data, size_type length = size_type(-1) )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(data, length);
        }

      nsAutoCString( const self_type& str )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(str);
        }

      explicit
      nsAutoCString( const substring_type& str )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(str);
        }

      nsAutoCString( const substring_tuple_type& tuple )
        : fixed_string_type(mStorage, kDefaultStorageSize, 0)
        {
          Assign(tuple);
        }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }

      enum { kDefaultStorageSize = 64 };

    private:

      char_type mStorage[kDefaultStorageSize];
  };







  template<class E> class nsTArrayElementTraits;
  template<>
  class nsTArrayElementTraits<nsAutoCString> {
    public:
      template<class A> struct Dont_Instantiate_nsTArray_of;
      template<class A> struct Instead_Use_nsTArray_of;

      static Dont_Instantiate_nsTArray_of<nsAutoCString> *
      Construct(Instead_Use_nsTArray_of<nsCString> *e) {
        return 0;
      }
      template<class A>
      static Dont_Instantiate_nsTArray_of<nsAutoCString> *
      Construct(Instead_Use_nsTArray_of<nsCString> *e,
                const A &arg) {
        return 0;
      }
      static Dont_Instantiate_nsTArray_of<nsAutoCString> *
      Destruct(Instead_Use_nsTArray_of<nsCString> *e) {
        return 0;
      }
  };
# 540 "../../dist/include/nsTString.h"
class nsXPIDLCString : public nsCString
  {
    public:

      typedef nsXPIDLCString self_type;

    public:

      nsXPIDLCString()
        : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED) {}


      nsXPIDLCString( const self_type& str )
        : string_type(char_traits::sEmptyBuffer, 0, F_TERMINATED | F_VOIDED)
        {
          Assign(str);
        }


      const char_type* get() const
        {
          return (mFlags & F_VOIDED) ? nullptr : mData;
        }



      operator const char_type*() const
        {
          return get();
        }


      char_type operator[]( int32_t i ) const
        {
          return CharAt(index_type(i));
        }


      self_type& operator=( char_type c ) { Assign(c); return *this; }
      self_type& operator=( const char_type* data ) { Assign(data); return *this; }
      self_type& operator=( const self_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }
  };
# 598 "../../dist/include/nsTString.h"
class nsCGetterCopies
  {
    public:
      typedef char char_type;

      nsCGetterCopies(nsACString_internal& str)
        : mString(str), mData(nullptr) {}

      ~nsCGetterCopies()
        {
          mString.Adopt(mData);
        }

      operator char_type**()
        {
          return &mData;
        }

    private:
      nsACString_internal& mString;
      char_type* mData;
  };

inline
nsCGetterCopies
getter_Copies( nsACString_internal& aString )
  {
    return nsCGetterCopies(aString);
  }
# 637 "../../dist/include/nsTString.h"
class nsAdoptingCString : public nsXPIDLCString
  {
    public:

      typedef nsAdoptingCString self_type;

    public:

      explicit nsAdoptingCString() {}
      explicit nsAdoptingCString(char_type* str, size_type length = size_type(-1))
        {
          Adopt(str, length);
        }





      nsAdoptingCString( const self_type& str )
        {
          *this = str;
        }


      self_type& operator=( const substring_type& str ) { Assign(str); return *this; }
      self_type& operator=( const substring_tuple_type& tuple ) { Assign(tuple); return *this; }




      self_type& operator=( const self_type& str );

    private:
      self_type& operator=( const char_type* data ) = delete;
      self_type& operator=( char_type* data ) = delete;
  };
# 52 "../../dist/include/nsString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 53 "../../dist/include/nsString.h" 2

extern void pr_static_assert(int arg[(sizeof(PRUnichar) == 2) ? 1 : -1]);
extern void pr_static_assert(int arg[(sizeof(nsString::char_type) == 2) ? 1 : -1]);
extern void pr_static_assert(int arg[(sizeof(nsCString::char_type) == 1) ? 1 : -1]);




class NS_LossyConvertUTF16toASCII : public nsAutoCString
  {
    public:
      explicit
      NS_LossyConvertUTF16toASCII( const PRUnichar* aString )
        {
          LossyAppendUTF16toASCII(aString, *this);
        }

      NS_LossyConvertUTF16toASCII( const PRUnichar* aString, uint32_t aLength )
        {
          LossyAppendUTF16toASCII(Substring(aString, aLength), *this);
        }

      explicit
      NS_LossyConvertUTF16toASCII( const nsAString_internal& aString )
        {
          LossyAppendUTF16toASCII(aString, *this);
        }

    private:

      NS_LossyConvertUTF16toASCII( char );
  };


class NS_ConvertASCIItoUTF16 : public nsAutoString
  {
    public:
      explicit
      NS_ConvertASCIItoUTF16( const char* aCString )
        {
          AppendASCIItoUTF16(aCString, *this);
        }

      NS_ConvertASCIItoUTF16( const char* aCString, uint32_t aLength )
        {
          AppendASCIItoUTF16(Substring(aCString, aLength), *this);
        }

      explicit
      NS_ConvertASCIItoUTF16( const nsACString_internal& aCString )
        {
          AppendASCIItoUTF16(aCString, *this);
        }

    private:

      NS_ConvertASCIItoUTF16( PRUnichar );
  };





class NS_ConvertUTF16toUTF8 : public nsAutoCString
  {
    public:
      explicit
      NS_ConvertUTF16toUTF8( const PRUnichar* aString )
        {
          AppendUTF16toUTF8(aString, *this);
        }

      NS_ConvertUTF16toUTF8( const PRUnichar* aString, uint32_t aLength )
        {
          AppendUTF16toUTF8(Substring(aString, aLength), *this);
        }

      explicit
      NS_ConvertUTF16toUTF8( const nsAString_internal& aString )
        {
          AppendUTF16toUTF8(aString, *this);
        }

    private:

      NS_ConvertUTF16toUTF8( char );
  };


class NS_ConvertUTF8toUTF16 : public nsAutoString
  {
    public:
      explicit
      NS_ConvertUTF8toUTF16( const char* aCString )
        {
          AppendUTF8toUTF16(aCString, *this);
        }

      NS_ConvertUTF8toUTF16( const char* aCString, uint32_t aLength )
        {
          AppendUTF8toUTF16(Substring(aCString, aLength), *this);
        }

      explicit
      NS_ConvertUTF8toUTF16( const nsACString_internal& aCString )
        {
          AppendUTF8toUTF16(aCString, *this);
        }

    private:

      NS_ConvertUTF8toUTF16( PRUnichar );
  };



typedef nsAutoString nsVoidableString;


# 1 "../../dist/include/nsDependentString.h" 1
# 19 "../../dist/include/nsDependentString.h"
# 1 "../../dist/include/string-template-def-unichar.h" 1
# 20 "../../dist/include/nsDependentString.h" 2
# 1 "../../dist/include/nsTDependentString.h" 1
# 19 "../../dist/include/nsTDependentString.h"
class nsDependentString : public nsString
  {
    public:

      typedef nsDependentString self_type;

    public:




      void AssertValid()
        {
          do { } while(0);
          do { } while(0);
          do { } while(0);
        }






      nsDependentString( const char_type* start, const char_type* end )
        : string_type(const_cast<char_type*>(start), uint32_t(end - start), F_TERMINATED)
        {
          AssertValid();
        }

      nsDependentString( const char_type* data, uint32_t length )
        : string_type(const_cast<char_type*>(data), length, F_TERMINATED)
        {
          AssertValid();
        }

      explicit
      nsDependentString( const char_type* data )
        : string_type(const_cast<char_type*>(data), uint32_t(char_traits::length(data)), F_TERMINATED)
        {
          AssertValid();
        }

      nsDependentString( const string_type& str, uint32_t startPos )
        : string_type()
        {
          Rebind(str, startPos);
        }


      nsDependentString()
        : string_type() {}
# 81 "../../dist/include/nsTDependentString.h"
      void Rebind( const char_type* data )
        {
          Rebind(data, uint32_t(char_traits::length(data)));
        }

      void Rebind( const char_type* data, size_type length );

      void Rebind( const char_type* start, const char_type* end )
        {
          Rebind(start, uint32_t(end - start));
        }

      void Rebind( const string_type&, uint32_t startPos );

    private:


      nsDependentString( const substring_tuple_type& );
  };
# 21 "../../dist/include/nsDependentString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 22 "../../dist/include/nsDependentString.h" 2


# 1 "../../dist/include/string-template-def-char.h" 1
# 25 "../../dist/include/nsDependentString.h" 2
# 1 "../../dist/include/nsTDependentString.h" 1
# 19 "../../dist/include/nsTDependentString.h"
class nsDependentCString : public nsCString
  {
    public:

      typedef nsDependentCString self_type;

    public:




      void AssertValid()
        {
          do { } while(0);
          do { } while(0);
          do { } while(0);
        }






      nsDependentCString( const char_type* start, const char_type* end )
        : string_type(const_cast<char_type*>(start), uint32_t(end - start), F_TERMINATED)
        {
          AssertValid();
        }

      nsDependentCString( const char_type* data, uint32_t length )
        : string_type(const_cast<char_type*>(data), length, F_TERMINATED)
        {
          AssertValid();
        }

      explicit
      nsDependentCString( const char_type* data )
        : string_type(const_cast<char_type*>(data), uint32_t(char_traits::length(data)), F_TERMINATED)
        {
          AssertValid();
        }

      nsDependentCString( const string_type& str, uint32_t startPos )
        : string_type()
        {
          Rebind(str, startPos);
        }


      nsDependentCString()
        : string_type() {}
# 81 "../../dist/include/nsTDependentString.h"
      void Rebind( const char_type* data )
        {
          Rebind(data, uint32_t(char_traits::length(data)));
        }

      void Rebind( const char_type* data, size_type length );

      void Rebind( const char_type* start, const char_type* end )
        {
          Rebind(start, uint32_t(end - start));
        }

      void Rebind( const string_type&, uint32_t startPos );

    private:


      nsDependentCString( const substring_tuple_type& );
  };
# 26 "../../dist/include/nsDependentString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 27 "../../dist/include/nsDependentString.h" 2
# 173 "../../dist/include/nsString.h" 2



# 1 "../../dist/include/nsLiteralString.h" 1
# 17 "../../dist/include/nsLiteralString.h"
namespace mozilla {
namespace internal {




template<int n>
inline uint32_t LiteralStringLength(const char (&c)[n])
{
  return n - 1;
}


template<int n>
inline uint32_t LiteralWStringLength(const char16_t (&c)[n])
{
  return n - 1;
}
# 43 "../../dist/include/nsLiteralString.h"
}
}
# 57 "../../dist/include/nsLiteralString.h"
  typedef nsDependentString nsLiteralString;
# 85 "../../dist/include/nsLiteralString.h"
typedef nsDependentCString nsLiteralCString;
# 177 "../../dist/include/nsString.h" 2



# 1 "../../dist/include/nsPromiseFlatString.h" 1
# 15 "../../dist/include/nsPromiseFlatString.h"
# 1 "../../dist/include/string-template-def-unichar.h" 1
# 16 "../../dist/include/nsPromiseFlatString.h" 2
# 1 "../../dist/include/nsTPromiseFlatString.h" 1
# 61 "../../dist/include/nsTPromiseFlatString.h"
class nsPromiseFlatString : public nsString
  {
    public:

      typedef nsPromiseFlatString self_type;

    private:

      void Init( const substring_type& );


      void operator=( const self_type& ) = delete;


      nsPromiseFlatString() = delete;


      nsPromiseFlatString( const string_type& str ) = delete;

    public:

      explicit
      nsPromiseFlatString( const substring_type& str )
        : string_type()
        {
          Init(str);
        }

      explicit
      nsPromiseFlatString( const substring_tuple_type& tuple )
        : string_type()
        {


          Assign(tuple);
        }
  };



template<class T>
const nsPromiseFlatString
PromiseFlatString( const T& string )
  {
    return nsPromiseFlatString(string);
  }
# 17 "../../dist/include/nsPromiseFlatString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 18 "../../dist/include/nsPromiseFlatString.h" 2


# 1 "../../dist/include/string-template-def-char.h" 1
# 21 "../../dist/include/nsPromiseFlatString.h" 2
# 1 "../../dist/include/nsTPromiseFlatString.h" 1
# 61 "../../dist/include/nsTPromiseFlatString.h"
class nsPromiseFlatCString : public nsCString
  {
    public:

      typedef nsPromiseFlatCString self_type;

    private:

      void Init( const substring_type& );


      void operator=( const self_type& ) = delete;


      nsPromiseFlatCString() = delete;


      nsPromiseFlatCString( const string_type& str ) = delete;

    public:

      explicit
      nsPromiseFlatCString( const substring_type& str )
        : string_type()
        {
          Init(str);
        }

      explicit
      nsPromiseFlatCString( const substring_tuple_type& tuple )
        : string_type()
        {


          Assign(tuple);
        }
  };



template<class T>
const nsPromiseFlatCString
PromiseFlatCString( const T& string )
  {
    return nsPromiseFlatCString(string);
  }
# 22 "../../dist/include/nsPromiseFlatString.h" 2
# 1 "../../dist/include/string-template-undef.h" 1
# 23 "../../dist/include/nsPromiseFlatString.h" 2
# 181 "../../dist/include/nsString.h" 2



# 1 "../../dist/include/nsMemory.h" 1
# 10 "../../dist/include/nsMemory.h"
# 1 "../../dist/include/nsIMemory.h" 1
# 25 "../../dist/include/nsIMemory.h"
class nsIMemory : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) void * Alloc(size_t size) = 0;


  virtual __attribute__ ((visibility ("hidden"))) void * Realloc(void *ptr, size_t newSize) = 0;


  virtual __attribute__ ((visibility ("hidden"))) void Free(void *ptr) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult HeapMinimize(bool immediate) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsLowMemory(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsLowMemoryPlatform(bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsIMemory::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x6aef11c4, 0x8615, 0x44a6, { 0x97, 0x11, 0x98, 0xf4, 0x38, 0x05, 0x69, 0x3d }};
# 11 "../../dist/include/nsMemory.h" 2
# 31 "../../dist/include/nsMemory.h"
class nsMemory
{
public:
    static __attribute__ ((visibility ("hidden"))) void* Alloc(size_t size)
        { return NS_Alloc(size); }

    static __attribute__ ((visibility ("hidden"))) void* Realloc(void* ptr, size_t size)
        { return NS_Realloc(ptr, size); }

    static __attribute__ ((visibility ("hidden"))) void Free(void* ptr)
        { NS_Free(ptr); }

    static nsresult HeapMinimize(bool aImmediate);
    static void* Clone(const void* ptr, size_t size);
    static nsIMemory* GetGlobalMemoryService();
};
# 130 "../../dist/include/nsMemory.h"
namespace mozilla {
  template <class T>
  struct AlignmentTestStruct
  {
    char c;
    T t;
  };
}







enum nsAssignmentType {
    NS_ASSIGNMENT_COPY,
    NS_ASSIGNMENT_DEPEND,
    NS_ASSIGNMENT_ADOPT
};
# 185 "../../dist/include/nsString.h" 2
# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 186 "../../dist/include/nsString.h" 2
# 1 "../../dist/system_wrappers/stdio.h" 1
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 187 "../../dist/include/nsString.h" 2
# 1 "../../dist/system_wrappers/plhash.h" 1
       
# 2 "../../dist/system_wrappers/plhash.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/plhash.h" 1 3
# 11 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/plhash.h" 3
# 1 "../../dist/system_wrappers/stdio.h" 1 3
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 12 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/plhash.h" 2 3


extern "C" {

typedef struct PLHashEntry PLHashEntry;
typedef struct PLHashTable PLHashTable;
typedef PRUint32 PLHashNumber;

typedef PLHashNumber ( *PLHashFunction)(const void *key);
typedef PRIntn ( *PLHashComparator)(const void *v1, const void *v2);

typedef PRIntn ( *PLHashEnumerator)(PLHashEntry *he, PRIntn i, void *arg);







typedef struct PLHashAllocOps {
    void * ( *allocTable)(void *pool, PRSize size);
    void ( *freeTable)(void *pool, void *item);
    PLHashEntry * ( *allocEntry)(void *pool, const void *key);
    void ( *freeEntry)(void *pool, PLHashEntry *he, PRUintn flag);
} PLHashAllocOps;




struct PLHashEntry {
    PLHashEntry *next;
    PLHashNumber keyHash;
    const void *key;
    void *value;
};

struct PLHashTable {
    PLHashEntry **buckets;
    PRUint32 nentries;
    PRUint32 shift;
    PLHashFunction keyHash;
    PLHashComparator keyCompare;
    PLHashComparator valueCompare;
    const PLHashAllocOps *allocOps;
    void *allocPriv;






};





extern __attribute__((visibility("default"))) PLHashTable *
PL_NewHashTable(PRUint32 numBuckets, PLHashFunction keyHash,
                PLHashComparator keyCompare, PLHashComparator valueCompare,
                const PLHashAllocOps *allocOps, void *allocPriv);

extern __attribute__((visibility("default"))) void
PL_HashTableDestroy(PLHashTable *ht);


extern __attribute__((visibility("default"))) PLHashEntry *
PL_HashTableAdd(PLHashTable *ht, const void *key, void *value);

extern __attribute__((visibility("default"))) PRBool
PL_HashTableRemove(PLHashTable *ht, const void *key);

extern __attribute__((visibility("default"))) void *
PL_HashTableLookup(PLHashTable *ht, const void *key);

extern __attribute__((visibility("default"))) void *
PL_HashTableLookupConst(PLHashTable *ht, const void *key);

extern __attribute__((visibility("default"))) PRIntn
PL_HashTableEnumerateEntries(PLHashTable *ht, PLHashEnumerator f, void *arg);


extern __attribute__((visibility("default"))) PLHashNumber
PL_HashString(const void *key);


extern __attribute__((visibility("default"))) PRIntn
PL_CompareStrings(const void *v1, const void *v2);


extern __attribute__((visibility("default"))) PRIntn
PL_CompareValues(const void *v1, const void *v2);


extern __attribute__((visibility("default"))) PLHashEntry **
PL_HashTableRawLookup(PLHashTable *ht, PLHashNumber keyHash, const void *key);

extern __attribute__((visibility("default"))) PLHashEntry **
PL_HashTableRawLookupConst(PLHashTable *ht, PLHashNumber keyHash,
                           const void *key);

extern __attribute__((visibility("default"))) PLHashEntry *
PL_HashTableRawAdd(PLHashTable *ht, PLHashEntry **hep, PLHashNumber keyHash,
                   const void *key, void *value);

extern __attribute__((visibility("default"))) void
PL_HashTableRawRemove(PLHashTable *ht, PLHashEntry **hep, PLHashEntry *he);


extern __attribute__((visibility("default"))) PRIntn
PL_HashTableDump(PLHashTable *ht, PLHashEnumerator dump, FILE *fp);

}
# 4 "../../dist/system_wrappers/plhash.h" 2 3
#pragma GCC visibility pop
# 188 "../../dist/include/nsString.h" 2

inline int32_t MinInt(int32_t x, int32_t y)
  {
    return XPCOM_MIN(x, y);
  }

inline int32_t MaxInt(int32_t x, int32_t y)
  {
    return XPCOM_MAX(x, y);
  }






inline void Recycle( char* aBuffer) { nsMemory::Free(aBuffer); }
inline void Recycle( PRUnichar* aBuffer) { nsMemory::Free(aBuffer); }
# 21 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheEntry.h" 2


class nsCacheDevice;
class nsCacheMetaData;
class nsCacheRequest;
class nsCacheEntryDescriptor;




class nsCacheEntry : public PRCList
{
public:

    nsCacheEntry(const nsACString_internal & key,
                 bool streamBased,
                 nsCacheStoragePolicy storagePolicy);
    ~nsCacheEntry();


    static nsresult Create( const char * key,
                             bool streamBased,
                             nsCacheStoragePolicy storagePolicy,
                             nsCacheDevice * device,
                             nsCacheEntry ** result);

    nsCString * Key() { return &mKey; }

    int32_t FetchCount() { return mFetchCount; }
    void SetFetchCount( int32_t count) { mFetchCount = count; }
    void Fetched();

    uint32_t LastFetched() { return mLastFetched; }
    void SetLastFetched( uint32_t lastFetched) { mLastFetched = lastFetched; }

    uint32_t LastModified() { return mLastModified; }
    void SetLastModified( uint32_t lastModified) { mLastModified = lastModified; }

    uint32_t ExpirationTime() { return mExpirationTime; }
    void SetExpirationTime( uint32_t expires) { mExpirationTime = expires; }

    uint32_t Size()
        { return mDataSize + mMetaData.Size() + mKey.Length() ; }

    nsCacheDevice * CacheDevice() { return mCacheDevice; }
    void SetCacheDevice( nsCacheDevice * device) { mCacheDevice = device; }
    void SetCustomCacheDevice( nsCacheDevice * device )
                                                             { mCustomDevice = device; }
    nsCacheDevice * CustomCacheDevice() { return mCustomDevice; }
    const char * GetDeviceID();




    nsISupports *Data() { return mData; }
    void SetData( nsISupports * data);

    int64_t PredictedDataSize() { return mPredictedDataSize; }
    void SetPredictedDataSize(int64_t size) { mPredictedDataSize = size; }

    uint32_t DataSize() { return mDataSize; }
    void SetDataSize( uint32_t size) { mDataSize = size; }

    void TouchData();




    const char * GetMetaDataElement( const char * key) { return mMetaData.GetElement(key); }
    nsresult SetMetaDataElement( const char * key,
                                     const char * value) { return mMetaData.SetElement(key, value); }
    nsresult VisitMetaDataElements( nsICacheMetaDataVisitor * visitor) { return mMetaData.VisitElements(visitor); }
    nsresult FlattenMetaData(char * buffer, uint32_t bufSize) { return mMetaData.FlattenMetaData(buffer, bufSize); }
    nsresult UnflattenMetaData(const char * buffer, uint32_t bufSize) { return mMetaData.UnflattenMetaData(buffer, bufSize); }
    uint32_t MetaDataSize() { return mMetaData.Size(); }

    void TouchMetaData();





    nsISupports* SecurityInfo() { return mSecurityInfo; }
    void SetSecurityInfo( nsISupports * info) { mSecurityInfo = info; }





    enum CacheEntryFlags {
        eStoragePolicyMask = 0x000000FF,
        eDoomedMask = 0x00000100,
        eEntryDirtyMask = 0x00000200,
        eDataDirtyMask = 0x00000400,
        eMetaDataDirtyMask = 0x00000800,
        eStreamDataMask = 0x00001000,
        eActiveMask = 0x00002000,
        eInitializedMask = 0x00004000,
        eValidMask = 0x00008000,
        eBindingMask = 0x00010000,
        ePrivateMask = 0x00020000
    };

    void MarkBinding() { mFlags |= eBindingMask; }
    void ClearBinding() { mFlags &= ~eBindingMask; }
    bool IsBinding() { return (mFlags & eBindingMask) != 0; }

    void MarkEntryDirty() { mFlags |= eEntryDirtyMask; }
    void MarkEntryClean() { mFlags &= ~eEntryDirtyMask; }
    void MarkDataDirty() { mFlags |= eDataDirtyMask; }
    void MarkDataClean() { mFlags &= ~eDataDirtyMask; }
    void MarkMetaDataDirty() { mFlags |= eMetaDataDirtyMask; }
    void MarkMetaDataClean() { mFlags &= ~eMetaDataDirtyMask; }
    void MarkStreamData() { mFlags |= eStreamDataMask; }
    void MarkValid() { mFlags |= eValidMask; }
    void MarkInvalid() { mFlags &= ~eValidMask; }
    void MarkPrivate() { mFlags |= ePrivateMask; }
    void MarkPublic() { mFlags &= ~ePrivateMask; }



    bool IsDoomed() { return (mFlags & eDoomedMask) != 0; }
    bool IsEntryDirty() { return (mFlags & eEntryDirtyMask) != 0; }
    bool IsDataDirty() { return (mFlags & eDataDirtyMask) != 0; }
    bool IsMetaDataDirty() { return (mFlags & eMetaDataDirtyMask) != 0; }
    bool IsStreamData() { return (mFlags & eStreamDataMask) != 0; }
    bool IsActive() { return (mFlags & eActiveMask) != 0; }
    bool IsInitialized() { return (mFlags & eInitializedMask) != 0; }
    bool IsValid() { return (mFlags & eValidMask) != 0; }
    bool IsInvalid() { return (mFlags & eValidMask) == 0; }
    bool IsInUse() { return IsBinding() ||
                                        !(((&mRequestQ)->next == (&mRequestQ)) &&
                                          ((&mDescriptorQ)->next == (&mDescriptorQ))); }
    bool IsNotInUse() { return !IsInUse(); }
    bool IsPrivate() { return (mFlags & ePrivateMask) != 0; }


    bool IsAllowedInMemory()
    {
        return (StoragePolicy() == nsICache::STORE_ANYWHERE) ||
            (StoragePolicy() == nsICache::STORE_IN_MEMORY);
    }

    bool IsAllowedOnDisk()
    {
        return !IsPrivate() && ((StoragePolicy() == nsICache::STORE_ANYWHERE) ||
            (StoragePolicy() == nsICache::STORE_ON_DISK));
    }

    bool IsAllowedOffline()
    {
        return (StoragePolicy() == nsICache::STORE_OFFLINE);
    }

    nsCacheStoragePolicy StoragePolicy()
    {
        return (nsCacheStoragePolicy)(mFlags & eStoragePolicyMask);
    }

    void SetStoragePolicy(nsCacheStoragePolicy policy)
    {
        do { } while(0);
        mFlags &= ~eStoragePolicyMask;
        mFlags |= policy;
    }



    nsresult RequestAccess( nsCacheRequest * request, nsCacheAccessMode *accessGranted);
    nsresult CreateDescriptor( nsCacheRequest * request,
                               nsCacheAccessMode accessGranted,
                               nsICacheEntryDescriptor ** result);

    bool RemoveRequest( nsCacheRequest * request);
    bool RemoveDescriptor( nsCacheEntryDescriptor * descriptor,
                               bool * doomEntry);

    void GetDescriptors(nsTArray<nsRefPtr<nsCacheEntryDescriptor> > &outDescriptors);

private:
    friend class nsCacheEntryHashTable;
    friend class nsCacheService;

    void DetachDescriptors();


    void MarkDoomed() { mFlags |= eDoomedMask; }
    void MarkStreamBased() { mFlags |= eStreamDataMask; }
    void MarkInitialized() { mFlags |= eInitializedMask; }
    void MarkActive() { mFlags |= eActiveMask; }
    void MarkInactive() { mFlags &= ~eActiveMask; }

    nsCString mKey;
    uint32_t mFetchCount;
    uint32_t mLastFetched;
    uint32_t mLastModified;
    uint32_t mLastValidated;
    uint32_t mExpirationTime;
    uint32_t mFlags;
    int64_t mPredictedDataSize;
    uint32_t mDataSize;
    nsCacheDevice * mCacheDevice;
    nsCacheDevice * mCustomDevice;
    nsCOMPtr<nsISupports> mSecurityInfo;
    nsISupports * mData;
    nsCOMPtr<nsIThread> mThread;
    nsCacheMetaData mMetaData;
    PRCList mRequestQ;
    PRCList mDescriptorQ;
};





class nsCacheEntryInfo : public nsICacheEntryInfo {
public:
    public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
    virtual __attribute__ ((visibility ("hidden"))) nsresult GetClientID(char * *aClientID); virtual __attribute__ ((visibility ("hidden"))) nsresult GetDeviceID(char * *aDeviceID); virtual __attribute__ ((visibility ("hidden"))) nsresult GetKey(nsACString_internal & aKey); virtual __attribute__ ((visibility ("hidden"))) nsresult GetFetchCount(int32_t *aFetchCount); virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastFetched(uint32_t *aLastFetched); virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastModified(uint32_t *aLastModified); virtual __attribute__ ((visibility ("hidden"))) nsresult GetExpirationTime(uint32_t *aExpirationTime); virtual __attribute__ ((visibility ("hidden"))) nsresult GetDataSize(uint32_t *aDataSize); virtual __attribute__ ((visibility ("hidden"))) nsresult IsStreamBased(bool *_retval);

    nsCacheEntryInfo(nsCacheEntry* entry)
        : mCacheEntry(entry)
    {
    }

    virtual ~nsCacheEntryInfo() {}
    void DetachEntry() { mCacheEntry = nullptr; }

private:
    nsCacheEntry * mCacheEntry;
};





typedef struct {
    PLDHashNumber keyHash;
    nsCacheEntry *cacheEntry;
} nsCacheEntryHashTableEntry;


class nsCacheEntryHashTable
{
public:
    nsCacheEntryHashTable();
    ~nsCacheEntryHashTable();

    nsresult Init();
    void Shutdown();

    nsCacheEntry *GetEntry( const nsCString * key);
    nsresult AddEntry( nsCacheEntry *entry);
    void RemoveEntry( nsCacheEntry *entry);

    void VisitEntries( PLDHashEnumerator etor, void *arg);

private:

    static PLDHashNumber HashKey( PLDHashTable *table, const void *key);

    static bool MatchEntry( PLDHashTable * table,
                                      const PLDHashEntryHdr * entry,
                                      const void * key);

    static void MoveEntry( PLDHashTable *table,
                                     const PLDHashEntryHdr *from,
                                     PLDHashEntryHdr *to);

    static void ClearEntry( PLDHashTable *table, PLDHashEntryHdr *entry);

    static void Finalize( PLDHashTable *table);

    static
    PLDHashOperator FreeCacheEntries(PLDHashTable * table,
                                           PLDHashEntryHdr * hdr,
                                           uint32_t number,
                                           void * arg);
    static
    PLDHashOperator VisitEntry(PLDHashTable * table,
                                     PLDHashEntryHdr * hdr,
                                     uint32_t number,
                                     void * arg);


    static PLDHashTableOps ops;
    PLDHashTable table;
    bool initialized;
};
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCache.h" 2






class nsDiskCache {
public:
    enum {
            kCurrentVersion = 0x00010013
    };

    enum { kData, kMetaData };




    enum CorruptCacheInfo {
      kNotCorrupt = 0,
      kInvalidArgPointer = 1,
      kUnexpectedError = 2,
      kOpenCacheMapError = 3,
      kBlockFilesShouldNotExist = 4,
      kOutOfMemory = 5,
      kCreateCacheSubdirectories = 6,
      kBlockFilesShouldExist = 7,
      kHeaderSizeNotRead = 8,
      kHeaderIsDirty = 9,
      kVersionMismatch = 10,
      kRecordsIncomplete = 11,
      kHeaderIncomplete = 12,
      kNotEnoughToRead = 13,
      kEntryCountIncorrect = 14,
      kCouldNotGetBlockFileForIndex = 15,
      kCouldNotCreateBlockFile = 16,
      kBlockFileSizeError = 17,
      kBlockFileBitMapWriteError = 18,
      kBlockFileSizeLessThanBitMap = 19,
      kBlockFileBitMapReadError = 20,
      kBlockFileEstimatedSizeError = 21,
      kFlushHeaderError = 22,
      kCacheCleanFilePathError = 23,
      kCacheCleanOpenFileError = 24,
      kCacheCleanTimerError = 25
    };
# 68 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCache.h"
    static PLDHashNumber Hash(const char* key, PLDHashNumber initval=0);
    static nsresult Truncate(PRFileDesc * fd, uint32_t newEOF);
};
# 20 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBlockFile.h" 1
# 21 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBlockFile.h"
class nsDiskCacheBlockFile {
public:
    nsDiskCacheBlockFile()
           : mFD(nullptr)
           , mBitMap(nullptr)
           , mBlockSize(0)
           , mBitMapWords(0)
           , mFileSize(0)
           , mBitMapDirty(false)
            {}
    ~nsDiskCacheBlockFile() { (void) Close(true); }

    nsresult Open( nsIFile * blockFile, uint32_t blockSize,
                    uint32_t bitMapSize, nsDiskCache::CorruptCacheInfo * corruptInfo);
    nsresult Close(bool flush);





    nsresult Trim() { return nsDiskCache::Truncate(mFD, CalcBlockFileSize()); }
    nsresult DeallocateBlocks( int32_t startBlock, int32_t numBlocks);
    nsresult WriteBlocks( void * buffer, uint32_t size, int32_t numBlocks,
                           int32_t * startBlock);
    nsresult ReadBlocks( void * buffer, int32_t startBlock, int32_t numBlocks,
                          int32_t * bytesRead);

    size_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf);

private:
    nsresult FlushBitMap();
    int32_t AllocateBlocks( int32_t numBlocks);
    nsresult VerifyAllocation( int32_t startBlock, int32_t numBLocks);
    uint32_t CalcBlockFileSize();
    bool Write(int32_t offset, const void *buf, int32_t amount);




    PRFileDesc * mFD;
    uint32_t * mBitMap;
    uint32_t mBlockSize;
    uint32_t mBitMapWords;
    int32_t mFileSize;
    bool mBitMapDirty;
};
# 21 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h" 2


class nsDiskCacheBinding;
struct nsDiskCacheEntry;
# 88 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h"
class nsDiskCacheRecord {

private:
    uint32_t mHashNumber;
    uint32_t mEvictionRank;
    uint32_t mDataLocation;
    uint32_t mMetaLocation;

    enum {
        eLocationInitializedMask = 0x80000000,

        eLocationSelectorMask = 0x30000000,
        eLocationSelectorOffset = 28,

        eExtraBlocksMask = 0x03000000,
        eExtraBlocksOffset = 24,

        eReservedMask = 0x4C000000,

        eBlockNumberMask = 0x00FFFFFF,

        eFileSizeMask = 0x00FFFF00,
        eFileSizeOffset = 8,
        eFileGenerationMask = 0x000000FF,
        eFileReservedMask = 0x4F000000

    };

public:
    nsDiskCacheRecord()
        : mHashNumber(0), mEvictionRank(0), mDataLocation(0), mMetaLocation(0)
    {
    }

    bool ValidRecord()
    {
        if ((mDataLocation & eReservedMask) || (mMetaLocation & eReservedMask))
            return false;
        return true;
    }


    uint32_t HashNumber() const { return mHashNumber; }
    void SetHashNumber( uint32_t hashNumber) { mHashNumber = hashNumber; }


    uint32_t EvictionRank() const { return mEvictionRank; }
    void SetEvictionRank( uint32_t rank) { mEvictionRank = rank ? rank : 1; }


    bool DataLocationInitialized() const { return 0 != (mDataLocation & eLocationInitializedMask); }
    void ClearDataLocation() { mDataLocation = 0; }

    uint32_t DataFile() const
    {
        return (uint32_t)(mDataLocation & eLocationSelectorMask) >> eLocationSelectorOffset;
    }

    void SetDataBlocks( uint32_t index, uint32_t startBlock, uint32_t blockCount)
    {

        mDataLocation = 0;


        do { } while(0);
        do { } while(0);
        mDataLocation |= (index << eLocationSelectorOffset) & eLocationSelectorMask;


        do { } while(0);
        mDataLocation |= startBlock & eBlockNumberMask;


        do { } while(0);
        --blockCount;
        mDataLocation |= (blockCount << eExtraBlocksOffset) & eExtraBlocksMask;

        mDataLocation |= eLocationInitializedMask;
    }

    uint32_t DataBlockCount() const
    {
        return (uint32_t)((mDataLocation & eExtraBlocksMask) >> eExtraBlocksOffset) + 1;
    }

    uint32_t DataStartBlock() const
    {
        return (mDataLocation & eBlockNumberMask);
    }

    uint32_t DataBlockSize() const
    {
        return ((DataFile()) ? (256 << (2 * ((DataFile()) - 1))) : 0);
    }

    uint32_t DataFileSize() const { return (mDataLocation & eFileSizeMask) >> eFileSizeOffset; }
    void SetDataFileSize(uint32_t size)
    {
        do { } while(0);
        mDataLocation &= ~eFileSizeMask;
        mDataLocation |= (size << eFileSizeOffset) & eFileSizeMask;
    }

    uint8_t DataFileGeneration() const
    {
        return (mDataLocation & eFileGenerationMask);
    }

    void SetDataFileGeneration( uint8_t generation)
    {

        mDataLocation = 0;
        mDataLocation |= generation & eFileGenerationMask;
        mDataLocation |= eLocationInitializedMask;
    }


    bool MetaLocationInitialized() const { return 0 != (mMetaLocation & eLocationInitializedMask); }
    void ClearMetaLocation() { mMetaLocation = 0; }
    uint32_t MetaLocation() const { return mMetaLocation; }

    uint32_t MetaFile() const
    {
        return (uint32_t)(mMetaLocation & eLocationSelectorMask) >> eLocationSelectorOffset;
    }

    void SetMetaBlocks( uint32_t index, uint32_t startBlock, uint32_t blockCount)
    {

        mMetaLocation = 0;


        do { } while(0);
        do { } while(0);
        mMetaLocation |= (index << eLocationSelectorOffset) & eLocationSelectorMask;


        do { } while(0);
        mMetaLocation |= startBlock & eBlockNumberMask;


        do { } while(0);
        --blockCount;
        mMetaLocation |= (blockCount << eExtraBlocksOffset) & eExtraBlocksMask;

        mMetaLocation |= eLocationInitializedMask;
    }

    uint32_t MetaBlockCount() const
    {
        return (uint32_t)((mMetaLocation & eExtraBlocksMask) >> eExtraBlocksOffset) + 1;
    }

    uint32_t MetaStartBlock() const
    {
        return (mMetaLocation & eBlockNumberMask);
    }

    uint32_t MetaBlockSize() const
    {
        return ((MetaFile()) ? (256 << (2 * ((MetaFile()) - 1))) : 0);
    }

    uint32_t MetaFileSize() const { return (mMetaLocation & eFileSizeMask) >> eFileSizeOffset; }
    void SetMetaFileSize(uint32_t size)
    {
        mMetaLocation &= ~eFileSizeMask;
        mMetaLocation |= (size << eFileSizeOffset) & eFileSizeMask;
    }

    uint8_t MetaFileGeneration() const
    {
        return (mMetaLocation & eFileGenerationMask);
    }

    void SetMetaFileGeneration( uint8_t generation)
    {

        mMetaLocation = 0;
        mMetaLocation |= generation & eFileGenerationMask;
        mMetaLocation |= eLocationInitializedMask;
    }

    uint8_t Generation() const
    {
        if ((mDataLocation & eLocationInitializedMask) &&
            (DataFile() == 0))
            return DataFileGeneration();

        if ((mMetaLocation & eLocationInitializedMask) &&
            (MetaFile() == 0))
            return MetaFileGeneration();

        return 0;
    }


    void Swap()
    {
        mHashNumber = (__extension__ ({ register unsigned int __v, __x = (mHashNumber); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mEvictionRank = (__extension__ ({ register unsigned int __v, __x = (mEvictionRank); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mDataLocation = (__extension__ ({ register unsigned int __v, __x = (mDataLocation); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mMetaLocation = (__extension__ ({ register unsigned int __v, __x = (mMetaLocation); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
    }



    void Unswap()
    {
        mHashNumber = (__extension__ ({ register unsigned int __v, __x = (mHashNumber); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mEvictionRank = (__extension__ ({ register unsigned int __v, __x = (mEvictionRank); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mDataLocation = (__extension__ ({ register unsigned int __v, __x = (mDataLocation); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mMetaLocation = (__extension__ ({ register unsigned int __v, __x = (mMetaLocation); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
    }


};






enum { kDeleteRecordAndContinue = -1,
        kStopVisitingRecords = 0,
        kVisitNextRecord = 1
};

class nsDiskCacheRecordVisitor {
    public:

    virtual int32_t VisitRecord( nsDiskCacheRecord * mapRecord) = 0;
};






struct nsDiskCacheHeader {
    uint32_t mVersion;
    uint32_t mDataSize;
    int32_t mEntryCount;
    uint32_t mIsDirty;
    int32_t mRecordCount;
    uint32_t mEvictionRank[(1 << 5)];
    uint32_t mBucketUsage[(1 << 5)];

    nsDiskCacheHeader()
        : mVersion(nsDiskCache::kCurrentVersion)
        , mDataSize(0)
        , mEntryCount(0)
        , mIsDirty(true)
        , mRecordCount(0)
    {}

    void Swap()
    {

        mVersion = (__extension__ ({ register unsigned int __v, __x = (mVersion); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mDataSize = (__extension__ ({ register unsigned int __v, __x = (mDataSize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mEntryCount = (__extension__ ({ register unsigned int __v, __x = (mEntryCount); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mIsDirty = (__extension__ ({ register unsigned int __v, __x = (mIsDirty); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mRecordCount = (__extension__ ({ register unsigned int __v, __x = (mRecordCount); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));

        for (uint32_t i = 0; i < (1 << 5) ; i++) {
            mEvictionRank[i] = (__extension__ ({ register unsigned int __v, __x = (mEvictionRank[i]); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
            mBucketUsage[i] = (__extension__ ({ register unsigned int __v, __x = (mBucketUsage[i]); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        }

    }

    void Unswap()
    {

        mVersion = (__extension__ ({ register unsigned int __v, __x = (mVersion); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mDataSize = (__extension__ ({ register unsigned int __v, __x = (mDataSize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mEntryCount = (__extension__ ({ register unsigned int __v, __x = (mEntryCount); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mIsDirty = (__extension__ ({ register unsigned int __v, __x = (mIsDirty); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mRecordCount = (__extension__ ({ register unsigned int __v, __x = (mRecordCount); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));

        for (uint32_t i = 0; i < (1 << 5) ; i++) {
            mEvictionRank[i] = (__extension__ ({ register unsigned int __v, __x = (mEvictionRank[i]); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
            mBucketUsage[i] = (__extension__ ({ register unsigned int __v, __x = (mBucketUsage[i]); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        }

    }
};






class nsDiskCacheMap {
public:

     nsDiskCacheMap() :
        mCacheDirectory(nullptr),
        mMapFD(nullptr),
        mCleanFD(nullptr),
        mRecordArray(nullptr),
        mBufferSize(0),
        mBuffer(nullptr),
        mMaxRecordCount(16384),
        mIsDirtyCacheFlushed(false),
        mLastInvalidateTime(0)
    { }

    ~nsDiskCacheMap()
    {
        (void) Close(true);
    }
# 410 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.h"
    nsresult Open( nsIFile * cacheDirectory,
                    nsDiskCache::CorruptCacheInfo * corruptInfo,
                    bool reportCacheCleanTelemetryData);
    nsresult Close(bool flush);
    nsresult Trim();

    nsresult FlushHeader();
    nsresult FlushRecords( bool unswap);

    void NotifyCapacityChange(uint32_t capacity);




    nsresult AddRecord( nsDiskCacheRecord * mapRecord, nsDiskCacheRecord * oldRecord);
    nsresult UpdateRecord( nsDiskCacheRecord * mapRecord);
    nsresult FindRecord( uint32_t hashNumber, nsDiskCacheRecord * mapRecord);
    nsresult DeleteRecord( nsDiskCacheRecord * mapRecord);
    nsresult VisitRecords( nsDiskCacheRecordVisitor * visitor);
    nsresult EvictRecords( nsDiskCacheRecordVisitor * visitor);




    nsresult DeleteStorage( nsDiskCacheRecord * record);

    nsresult GetFileForDiskCacheRecord( nsDiskCacheRecord * record,
                                           bool meta,
                                           bool createPath,
                                           nsIFile ** result);

    nsresult GetLocalFileForDiskCacheRecord( nsDiskCacheRecord * record,
                                                bool meta,
                                                bool createPath,
                                                nsIFile ** result);



    nsDiskCacheEntry * ReadDiskCacheEntry( nsDiskCacheRecord * record);

    nsresult WriteDiskCacheEntry( nsDiskCacheBinding * binding);

    nsresult ReadDataCacheBlocks(nsDiskCacheBinding * binding, char * buffer, uint32_t size);
    nsresult WriteDataCacheBlocks(nsDiskCacheBinding * binding, char * buffer, uint32_t size);
    nsresult DeleteStorage( nsDiskCacheRecord * record, bool metaData);




    void IncrementTotalSize( uint32_t delta)
             {
                mHeader.mDataSize += delta;
                mHeader.mIsDirty = true;
             }

    void DecrementTotalSize( uint32_t delta)
             {
                do { } while(0);
                mHeader.mDataSize = mHeader.mDataSize > delta ? mHeader.mDataSize - delta : 0;
                mHeader.mIsDirty = true;
             }

    inline void IncrementTotalSize( uint32_t blocks, uint32_t blockSize)
             {

                IncrementTotalSize(((blocks*blockSize) + 0x03FF) >> 10);
             }

    inline void DecrementTotalSize( uint32_t blocks, uint32_t blockSize)
             {

                DecrementTotalSize(((blocks*blockSize) + 0x03FF) >> 10);
             }

    uint32_t TotalSize() { return mHeader.mDataSize; }

    int32_t EntryCount() { return mHeader.mEntryCount; }

    size_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf);


private:




    nsresult OpenBlockFiles(nsDiskCache::CorruptCacheInfo * corruptInfo);
    nsresult CloseBlockFiles(bool flush);
    bool CacheFilesExist();

    nsresult CreateCacheSubDirectories();

    uint32_t CalculateFileIndex(uint32_t size);

    nsresult GetBlockFileForIndex( uint32_t index, nsIFile ** result);
    uint32_t GetBlockSizeForIndex( uint32_t index) const {
        return ((index) ? (256 << (2 * ((index) - 1))) : 0);
    }
    uint32_t GetBitMapSizeForIndex( uint32_t index) const {
        return ((index) ? (131072 >> (2 * ((index) - 1))) : 0);
    }


    uint32_t GetBucketIndex( uint32_t hashNumber) const {
        return (hashNumber & ((1 << 5) - 1));
    }


    uint32_t GetRecordsPerBucket() const {
        return mHeader.mRecordCount / (1 << 5);
    }


    nsDiskCacheRecord *GetFirstRecordInBucket(uint32_t bucket) const {
        return mRecordArray + bucket * GetRecordsPerBucket();
    }

    uint32_t GetBucketRank(uint32_t bucketIndex, uint32_t targetRank);

    int32_t VisitEachRecord(uint32_t bucketIndex,
                             nsDiskCacheRecordVisitor * visitor,
                             uint32_t evictionRank);

    nsresult GrowRecords();
    nsresult ShrinkRecords();

    nsresult EnsureBuffer(uint32_t bufSize);



    nsDiskCacheEntry * CreateDiskCacheEntry(nsDiskCacheBinding * binding,
                                             uint32_t * size);


    nsresult InitCacheClean(nsIFile * cacheDirectory,
                            nsDiskCache::CorruptCacheInfo * corruptInfo,
                            bool reportCacheCleanTelemetryData);

    nsresult WriteCacheClean(bool clean);

    nsresult ResetCacheTimer(int32_t timeout = 3000);

    nsresult InvalidateCache();

    bool IsCacheInSafeState();


    nsresult RevalidateCache();

    static void RevalidateTimerCallback(nsITimer *aTimer, void *arg);




private:
    nsCOMPtr<nsITimer> mCleanCacheTimer;
    nsCOMPtr<nsIFile> mCacheDirectory;
    PRFileDesc * mMapFD;
    PRFileDesc * mCleanFD;
    nsDiskCacheRecord * mRecordArray;
    nsDiskCacheBlockFile mBlockFile[3];
    uint32_t mBufferSize;
    char * mBuffer;
    nsDiskCacheHeader mHeader;
    int32_t mMaxRecordCount;
    bool mIsDirtyCacheFlushed;
    PRIntervalTime mLastInvalidateTime;
};
# 9 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h" 1
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h"
# 1 "../../dist/system_wrappers/nspr.h" 1
       
# 2 "../../dist/system_wrappers/nspr.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h" 2






# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheStreams.h" 1
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheStreams.h"
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h" 1
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheStreams.h" 2



# 1 "../../dist/include/nsIInputStream.h" 1
# 17 "../../dist/include/nsIInputStream.h"
class nsIInputStream;
# 43 "../../dist/include/nsIInputStream.h"
typedef nsresult (* nsWriteSegmentFun)(nsIInputStream *aInStream,
                                       void *aClosure,
                                       const char *aFromSegment,
                                       uint32_t aToOffset,
                                       uint32_t aCount,
                                       uint32_t *aWriteCount);
# 57 "../../dist/include/nsIInputStream.h"
class nsIInputStream : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Close(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Available(uint64_t *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Read(char *aBuf, uint32_t aCount, uint32_t *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult ReadSegments(nsWriteSegmentFun aWriter, void *aClosure, uint32_t aCount, uint32_t *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsNonBlocking(bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsIInputStream::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x53cdbc97, 0xc2d7, 0x4e30, { 0xb2, 0xc3, 0x45, 0xb2, 0xee, 0x79, 0xdb, 0x18 }};
# 16 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheStreams.h" 2
# 1 "../../dist/include/nsIOutputStream.h" 1
# 17 "../../dist/include/nsIOutputStream.h"
class nsIOutputStream;

class nsIInputStream;
# 40 "../../dist/include/nsIOutputStream.h"
typedef nsresult (* nsReadSegmentFun)(nsIOutputStream *aOutStream,
                                      void *aClosure,
                                      char *aToSegment,
                                      uint32_t aFromOffset,
                                      uint32_t aCount,
                                      uint32_t *aReadCount);
# 54 "../../dist/include/nsIOutputStream.h"
class nsIOutputStream : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Close(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Flush(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Write(const char * aBuf, uint32_t aCount, uint32_t *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult WriteFrom(nsIInputStream *aFromStream, uint32_t aCount, uint32_t *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult WriteSegments(nsReadSegmentFun aReader, void *aClosure, uint32_t aCount, uint32_t *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsNonBlocking(bool *_retval) = 0;

};

  template <class Dummy> const nsIID nsIOutputStream::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x0d0acd2a, 0x61b4, 0x11d4, { 0x98, 0x77, 0x00, 0xc0, 0x4f, 0xa0, 0xcf, 0x4a }};
# 17 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheStreams.h" 2

# 1 "../../dist/system_wrappers/pratom.h" 1
       
# 2 "../../dist/system_wrappers/pratom.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 19 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheStreams.h" 2

class nsDiskCacheInputStream;
class nsDiskCacheDevice;

class nsDiskCacheStreamIO : public nsIOutputStream {
public:
             nsDiskCacheStreamIO(nsDiskCacheBinding * binding);
    virtual ~nsDiskCacheStreamIO();

    public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
    virtual __attribute__ ((visibility ("hidden"))) nsresult Close(void); virtual __attribute__ ((visibility ("hidden"))) nsresult Flush(void); virtual __attribute__ ((visibility ("hidden"))) nsresult Write(const char * aBuf, uint32_t aCount, uint32_t *_retval); virtual __attribute__ ((visibility ("hidden"))) nsresult WriteFrom(nsIInputStream *aFromStream, uint32_t aCount, uint32_t *_retval); virtual __attribute__ ((visibility ("hidden"))) nsresult WriteSegments(nsReadSegmentFun aReader, void *aClosure, uint32_t aCount, uint32_t *_retval); virtual __attribute__ ((visibility ("hidden"))) nsresult IsNonBlocking(bool *_retval);

    nsresult GetInputStream(uint32_t offset, nsIInputStream ** inputStream);
    nsresult GetOutputStream(uint32_t offset, nsIOutputStream ** outputStream);

    nsresult ClearBinding();

    void IncrementInputStreamCount() { __sync_add_and_fetch(&mInStreamCount, 1); }
    void DecrementInputStreamCount()
                {
                    __sync_sub_and_fetch(&mInStreamCount, 1);
                    do { } while(0);
                }

    size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf);



    nsDiskCacheStreamIO() { do { } while(0); }

private:
    nsresult OpenCacheFile(int flags, PRFileDesc ** fd);
    nsresult ReadCacheBlocks(uint32_t bufferSize);
    nsresult FlushBufferToFile();
    void UpdateFileSize();
    void DeleteBuffer();
    nsresult CloseOutputStream();
    nsresult SeekAndTruncate(uint32_t offset);

    nsDiskCacheBinding * mBinding;
    nsDiskCacheDevice * mDevice;
    int32_t mInStreamCount;
    PRFileDesc * mFD;

    uint32_t mStreamEnd;
    uint32_t mBufSize;
    char * mBuffer;
    bool mOutputStreamIsOpen;
};
# 19 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h" 2
# 30 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h"
class nsDiskCacheDeviceDeactivateEntryEvent;

class nsDiskCacheBinding : public nsISupports, public PRCList {
public:
    public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:

    nsDiskCacheBinding(nsCacheEntry* entry, nsDiskCacheRecord * record);
    virtual ~nsDiskCacheBinding();

    nsresult EnsureStreamIO();
    bool IsActive() { return mCacheEntry != nullptr;}


public:
    nsCacheEntry* mCacheEntry;
    nsDiskCacheRecord mRecord;
    nsDiskCacheStreamIO* mStreamIO;
    bool mDoomed;
    uint8_t mGeneration;





    nsDiskCacheDeviceDeactivateEntryEvent *mDeactivateEvent;
};






nsDiskCacheBinding * GetCacheEntryBinding(nsCacheEntry * entry);
# 93 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheBinding.h"
class nsDiskCacheBindery {
public:
    nsDiskCacheBindery();
    ~nsDiskCacheBindery();

    nsresult Init();
    void Reset();

    nsDiskCacheBinding * CreateBinding(nsCacheEntry * entry,
                                          nsDiskCacheRecord * record);

    nsDiskCacheBinding * FindActiveBinding(uint32_t hashNumber);
    void RemoveBinding(nsDiskCacheBinding * binding);
    bool ActiveBindings();

    size_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf);

private:
    nsresult AddBinding(nsDiskCacheBinding * binding);


    static PLDHashTableOps ops;
    PLDHashTable table;
    bool initialized;
};
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheEntry.h" 1
# 18 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheEntry.h"
struct nsDiskCacheEntry {
    uint32_t mHeaderVersion;
    uint32_t mMetaLocation;
    int32_t mFetchCount;
    uint32_t mLastFetched;
    uint32_t mLastModified;
    uint32_t mExpirationTime;
    uint32_t mDataSize;
    uint32_t mKeySize;
    uint32_t mMetaDataSize;



    uint32_t Size() { return sizeof(nsDiskCacheEntry) +
                                    mKeySize + mMetaDataSize;
                              }

    char* Key() { return reinterpret_cast<char*const>(this) +
                                    sizeof(nsDiskCacheEntry);
                              }

    char* MetaData()
                              { return Key() + mKeySize; }

    nsCacheEntry * CreateCacheEntry(nsCacheDevice * device);

    void Swap()
    {

        mHeaderVersion = (__extension__ ({ register unsigned int __v, __x = (mHeaderVersion); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mMetaLocation = (__extension__ ({ register unsigned int __v, __x = (mMetaLocation); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mFetchCount = (__extension__ ({ register unsigned int __v, __x = (mFetchCount); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mLastFetched = (__extension__ ({ register unsigned int __v, __x = (mLastFetched); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mLastModified = (__extension__ ({ register unsigned int __v, __x = (mLastModified); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mExpirationTime = (__extension__ ({ register unsigned int __v, __x = (mExpirationTime); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mDataSize = (__extension__ ({ register unsigned int __v, __x = (mDataSize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mKeySize = (__extension__ ({ register unsigned int __v, __x = (mKeySize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mMetaDataSize = (__extension__ ({ register unsigned int __v, __x = (mMetaDataSize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));

    }

    void Unswap()
    {

        mHeaderVersion = (__extension__ ({ register unsigned int __v, __x = (mHeaderVersion); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mMetaLocation = (__extension__ ({ register unsigned int __v, __x = (mMetaLocation); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mFetchCount = (__extension__ ({ register unsigned int __v, __x = (mFetchCount); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mLastFetched = (__extension__ ({ register unsigned int __v, __x = (mLastFetched); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mLastModified = (__extension__ ({ register unsigned int __v, __x = (mLastModified); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mExpirationTime = (__extension__ ({ register unsigned int __v, __x = (mExpirationTime); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mDataSize = (__extension__ ({ register unsigned int __v, __x = (mDataSize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mKeySize = (__extension__ ({ register unsigned int __v, __x = (mKeySize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));
        mMetaDataSize = (__extension__ ({ register unsigned int __v, __x = (mMetaDataSize); if (__builtin_constant_p (__x)) __v = ((((__x) & 0xff000000) >> 24) | (((__x) & 0x00ff0000) >> 8) | (((__x) & 0x0000ff00) << 8) | (((__x) & 0x000000ff) << 24)); else __asm__ ("bswap %0" : "=r" (__v) : "0" (__x)); __v; }));

    }
};





class nsDiskCacheEntryInfo : public nsICacheEntryInfo {
public:
    public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
    virtual __attribute__ ((visibility ("hidden"))) nsresult GetClientID(char * *aClientID); virtual __attribute__ ((visibility ("hidden"))) nsresult GetDeviceID(char * *aDeviceID); virtual __attribute__ ((visibility ("hidden"))) nsresult GetKey(nsACString_internal & aKey); virtual __attribute__ ((visibility ("hidden"))) nsresult GetFetchCount(int32_t *aFetchCount); virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastFetched(uint32_t *aLastFetched); virtual __attribute__ ((visibility ("hidden"))) nsresult GetLastModified(uint32_t *aLastModified); virtual __attribute__ ((visibility ("hidden"))) nsresult GetExpirationTime(uint32_t *aExpirationTime); virtual __attribute__ ((visibility ("hidden"))) nsresult GetDataSize(uint32_t *aDataSize); virtual __attribute__ ((visibility ("hidden"))) nsresult IsStreamBased(bool *_retval);

    nsDiskCacheEntryInfo(const char * deviceID, nsDiskCacheEntry * diskEntry)
        : mDeviceID(deviceID)
        , mDiskEntry(diskEntry)
    {
    }

    virtual ~nsDiskCacheEntryInfo() {}

    const char* Key() { return mDiskEntry->Key(); }

private:
    const char * mDeviceID;
    nsDiskCacheEntry * mDiskEntry;
};
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheDevice.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheDevice.h"
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheDevice.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheDevice.h"
# 1 "../../dist/system_wrappers/nspr.h" 1
       
# 2 "../../dist/system_wrappers/nspr.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheDevice.h" 2



class nsIFile;
class nsCString;
class nsCacheEntry;
class nsICacheVisitor;
class nsIInputStream;
class nsIOutputStream;




class nsCacheDevice {
public:
    nsCacheDevice() { ; }
    virtual ~nsCacheDevice() { ; }

    virtual nsresult Init() = 0;
    virtual nsresult Shutdown() = 0;

    virtual const char * GetDeviceID(void) = 0;
    virtual nsCacheEntry * FindEntry( nsCString * key, bool *collision ) = 0;

    virtual nsresult DeactivateEntry( nsCacheEntry * entry ) = 0;
    virtual nsresult BindEntry( nsCacheEntry * entry ) = 0;
    virtual void DoomEntry( nsCacheEntry * entry ) = 0;

    virtual nsresult OpenInputStreamForEntry(nsCacheEntry * entry,
                                             nsCacheAccessMode mode,
                                             uint32_t offset,
                                             nsIInputStream ** result) = 0;

    virtual nsresult OpenOutputStreamForEntry(nsCacheEntry * entry,
                                              nsCacheAccessMode mode,
                                              uint32_t offset,
                                              nsIOutputStream ** result) = 0;

    virtual nsresult GetFileForEntry( nsCacheEntry * entry,
                                      nsIFile ** result ) = 0;

    virtual nsresult OnDataSizeChange( nsCacheEntry * entry, int32_t deltaSize ) = 0;

    virtual nsresult Visit(nsICacheVisitor * visitor) = 0;





    virtual nsresult EvictEntries(const char * clientID) = 0;
};
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheDevice.h" 2





# 1 "../../dist/include/nsIObserver.h" 1
# 25 "../../dist/include/nsIObserver.h"
class nsIObserver : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Observe(nsISupports *aSubject, const char * aTopic, const PRUnichar * aData) = 0;

};

  template <class Dummy> const nsIID nsIObserver::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xdb242e01, 0xe4d9, 0x11d2, { 0x9d, 0xde, 0x00, 0x00, 0x64, 0x65, 0x73, 0x74 }};
# 17 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheDevice.h" 2
# 1 "../../dist/include/nsCOMArray.h" 1
# 12 "../../dist/include/nsCOMArray.h"
# 1 "../../dist/include/nsTArray.h" 1
# 10 "../../dist/include/nsTArray.h"
# 1 "../../dist/include/nsTArrayForwardDeclare.h" 1
# 24 "../../dist/include/nsTArrayForwardDeclare.h"
template<class E>
class nsTArray;

template<class E>
class FallibleTArray;

template<class E, uint32_t N>
class nsAutoTArray;

template<class E, uint32_t N>
class AutoFallibleTArray;
# 11 "../../dist/include/nsTArray.h" 2


# 1 "../../dist/include/mozilla/Util.h" 1
# 14 "../../dist/include/nsTArray.h" 2

# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 16 "../../dist/include/nsTArray.h" 2




# 1 "../../dist/include/nsQuickSort.h" 1
# 17 "../../dist/include/nsQuickSort.h"
extern "C" {
# 32 "../../dist/include/nsQuickSort.h"
 void NS_QuickSort(void *, unsigned int, unsigned int,
                              int (*)(const void *, const void *, void *),
                              void *);


}
# 21 "../../dist/include/nsTArray.h" 2
# 90 "../../dist/include/nsTArray.h"
struct nsTArrayFallibleResult
{

  nsTArrayFallibleResult(bool result)
    : mResult(result)
  {}

  operator bool() {
    return mResult;
  }

private:
  bool mResult;
};

struct nsTArrayInfallibleResult
{
};






struct nsTArrayFallibleAllocatorBase
{
  typedef bool ResultType;
  typedef nsTArrayFallibleResult ResultTypeProxy;

  static ResultType Result(ResultTypeProxy result) {
    return result;
  }

  static bool Successful(ResultTypeProxy result) {
    return result;
  }

  static ResultTypeProxy SuccessResult() {
    return true;
  }

  static ResultTypeProxy FailureResult() {
    return false;
  }
};

struct nsTArrayInfallibleAllocatorBase
{
  typedef void ResultType;
  typedef nsTArrayInfallibleResult ResultTypeProxy;

  static ResultType Result(ResultTypeProxy result) {
  }

  static bool Successful(ResultTypeProxy) {
    return true;
  }

  static ResultTypeProxy SuccessResult() {
    return ResultTypeProxy();
  }

  static ResultTypeProxy FailureResult() {
    NS_DebugBreak(NS_DEBUG_ABORT, "Infallible nsTArray should never fail", nullptr, "../../dist/include/nsTArray.h", 153);
    return ResultTypeProxy();
  }
};


# 1 "../../dist/include/mozilla/mozalloc_abort.h" 1
# 160 "../../dist/include/nsTArray.h" 2

struct nsTArrayFallibleAllocator : nsTArrayFallibleAllocatorBase
{
  static void* Malloc(size_t size) {
    return moz_malloc(size);
  }

  static void* Realloc(void* ptr, size_t size) {
    return moz_realloc(ptr, size);
  }

  static void Free(void* ptr) {
    moz_free(ptr);
  }

  static void SizeTooBig() {
  }
};

struct nsTArrayInfallibleAllocator : nsTArrayInfallibleAllocatorBase
{
  static void* Malloc(size_t size) {
    return moz_xmalloc(size);
  }

  static void* Realloc(void* ptr, size_t size) {
    return moz_xrealloc(ptr, size);
  }

  static void Free(void* ptr) {
    moz_free(ptr);
  }

  static void SizeTooBig() {
    mozalloc_abort("Trying to allocate an infallible array that's too big");
  }
};
# 258 "../../dist/include/nsTArray.h"
struct nsTArrayHeader
{
  static nsTArrayHeader sEmptyHdr;

  uint32_t mLength;
  uint32_t mCapacity : 31;
  uint32_t mIsAutoArray : 1;
};



template <class E, class Derived>
struct nsTArray_SafeElementAtHelper
{
  typedef E* elem_type;
  typedef uint32_t index_type;




  elem_type& SafeElementAt(index_type i);
  const elem_type& SafeElementAt(index_type i) const;
};

template <class E, class Derived>
struct nsTArray_SafeElementAtHelper<E*, Derived>
{
  typedef E* elem_type;
  typedef uint32_t index_type;

  elem_type SafeElementAt(index_type i) {
    return static_cast<Derived*> (this)->SafeElementAt(i, nullptr);
  }

  const elem_type SafeElementAt(index_type i) const {
    return static_cast<const Derived*> (this)->SafeElementAt(i, nullptr);
  }
};



template <class E, class Derived>
struct nsTArray_SafeElementAtSmartPtrHelper
{
  typedef E* elem_type;
  typedef uint32_t index_type;

  elem_type SafeElementAt(index_type i) {
    return static_cast<Derived*> (this)->SafeElementAt(i, nullptr);
  }

  const elem_type SafeElementAt(index_type i) const {
    return static_cast<const Derived*> (this)->SafeElementAt(i, nullptr);
  }
};

template <class T> class nsCOMPtr;

template <class E, class Derived>
struct nsTArray_SafeElementAtHelper<nsCOMPtr<E>, Derived> :
  public nsTArray_SafeElementAtSmartPtrHelper<E, Derived>
{
};

template <class T> class nsRefPtr;

template <class E, class Derived>
struct nsTArray_SafeElementAtHelper<nsRefPtr<E>, Derived> :
  public nsTArray_SafeElementAtSmartPtrHelper<E, Derived>
{
};






template<class Alloc>
class nsTArray_base
{



  template<class Allocator>
  friend class nsTArray_base;

protected:
  typedef nsTArrayHeader Header;

public:
  typedef uint32_t size_type;
  typedef uint32_t index_type;


  size_type Length() const {
    return mHdr->mLength;
  }


  bool IsEmpty() const {
    return Length() == 0;
  }




  size_type Capacity() const {
    return mHdr->mCapacity;
  }







protected:
  nsTArray_base();

  ~nsTArray_base();





  typename Alloc::ResultTypeProxy EnsureCapacity(size_type capacity, size_type elemSize);




  void ShrinkCapacity(size_type elemSize, size_t elemAlign);
# 398 "../../dist/include/nsTArray.h"
  void ShiftData(index_type start, size_type oldLen, size_type newLen,
                 size_type elemSize, size_t elemAlign);





  void IncrementLength(uint32_t n) {
    if (mHdr == EmptyHdr()) {
      if ((__builtin_expect(!!(n != 0), 0))) {

        do { *((volatile int*) __null) = 123; ::abort(); } while (0);
      }
    } else {
      mHdr->mLength += n;
    }
  }







  bool InsertSlotsAt(index_type index, size_type count,
                       size_type elementSize, size_t elemAlign);

protected:
  template<class Allocator>
  bool SwapArrayElements(nsTArray_base<Allocator>& other,
                           size_type elemSize,
                           size_t elemAlign);


  class IsAutoArrayRestorer {
    public:
      IsAutoArrayRestorer(nsTArray_base<Alloc> &array, size_t elemAlign);
      ~IsAutoArrayRestorer();

    private:
      nsTArray_base<Alloc> &mArray;
      size_t mElemAlign;
      bool mIsAuto;
  };



  bool EnsureNotUsingAutoArrayBuffer(size_type elemSize);


  bool IsAutoArray() const {
    return mHdr->mIsAutoArray;
  }


  Header* GetAutoArrayBuffer(size_t elemAlign) {
    do { } while(0);
    return GetAutoArrayBufferUnsafe(elemAlign);
  }
  const Header* GetAutoArrayBuffer(size_t elemAlign) const {
    do { } while(0);
    return GetAutoArrayBufferUnsafe(elemAlign);
  }



  Header* GetAutoArrayBufferUnsafe(size_t elemAlign) {
    return const_cast<Header*>(static_cast<const nsTArray_base<Alloc>*>(this)->
                               GetAutoArrayBufferUnsafe(elemAlign));
  }
  const Header* GetAutoArrayBufferUnsafe(size_t elemAlign) const;



  bool UsesAutoArrayBuffer() const;



  Header *mHdr;

  Header* Hdr() const {
    return mHdr;
  }

  Header** PtrToHdr() {
    return &mHdr;
  }

  static Header* EmptyHdr() {
    return &Header::sEmptyHdr;
  }
};





template<class E>
class nsTArrayElementTraits
{
public:

  static inline void Construct(E *e) {





    new (static_cast<void *>(e)) E;
  }

  template<class A>
  static inline void Construct(E *e, const A &arg) {
    new (static_cast<void *>(e)) E(arg);
  }

  static inline void Destruct(E *e) {
    e->~E();
  }
};


template<class A, class B>
class nsDefaultComparator
{
public:
  bool Equals(const A& a, const B& b) const {
    return a == b;
  }
  bool LessThan(const A& a, const B& b) const {
    return a < b;
  }
};

template <class E> class nsTArray;
template <class E> class FallibleTArray;

template<bool IsPod, bool IsSameType>
struct AssignRangeAlgorithm {
  template<class Item, class ElemType, class IndexType, class SizeType>
  static void implementation(ElemType* elements, IndexType start,
                             SizeType count, const Item *values) {
    ElemType *iter = elements + start, *end = iter + count;
    for (; iter != end; ++iter, ++values)
      nsTArrayElementTraits<ElemType>::Construct(iter, *values);
  }
};

template<>
struct AssignRangeAlgorithm<true, true> {
  template<class Item, class ElemType, class IndexType, class SizeType>
  static void implementation(ElemType* elements, IndexType start,
                             SizeType count, const Item *values) {
    memcpy(elements + start, values, count * sizeof(ElemType));
  }
};
# 567 "../../dist/include/nsTArray.h"
template<class E, class Alloc>
class nsTArray_Impl : public nsTArray_base<Alloc>,
                      public nsTArray_SafeElementAtHelper<E, nsTArray_Impl<E, Alloc> >
{
public:
  typedef nsTArray_base<Alloc> base_type;
  typedef typename base_type::size_type size_type;
  typedef typename base_type::index_type index_type;
  typedef E elem_type;
  typedef nsTArray_Impl<E, Alloc> self_type;
  typedef nsTArrayElementTraits<E> elem_traits;
  typedef nsTArray_SafeElementAtHelper<E, self_type> safeelementat_helper_type;

  using safeelementat_helper_type::SafeElementAt;
  using base_type::EmptyHdr;



  enum {
    NoIndex = index_type(-1)
  };

  using base_type::Length;





  ~nsTArray_Impl() { Clear(); }





  nsTArray_Impl() {}


  explicit nsTArray_Impl(size_type capacity) {
    SetCapacity(capacity);
  }
# 623 "../../dist/include/nsTArray.h"
  explicit nsTArray_Impl(const self_type& other) {
    AppendElements(other);
  }



  template<typename Allocator>
  operator const nsTArray_Impl<E, Allocator>&() const {
    return *reinterpret_cast<const nsTArray_Impl<E, Allocator>*>(this);
  }

  operator const nsTArray<E>&() const {
    return *reinterpret_cast<const nsTArray<E>*>(this);
  }
  operator const FallibleTArray<E>&() const {
    return *reinterpret_cast<const FallibleTArray<E>*>(this);
  }




  self_type& operator=(const self_type& other) {
    ReplaceElementsAt(0, Length(), other.Elements(), other.Length());
    return *this;
  }



  template<typename Allocator>
  bool operator==(const nsTArray_Impl<E, Allocator>& other) const {
    size_type len = Length();
    if (len != other.Length())
      return false;


    for (index_type i = 0; i < len; ++i)
      if (!(operator[](i) == other[i]))
        return false;

    return true;
  }



  bool operator!=(const self_type& other) const {
    return !operator==(other);
  }

  template<typename Allocator>
  self_type& operator=(const nsTArray_Impl<E, Allocator>& other) {
    ReplaceElementsAt(0, Length(), other.Elements(), other.Length());
    return *this;
  }



  size_t SizeOfExcludingThis(nsMallocSizeOfFun mallocSizeOf) const {
    if (this->UsesAutoArrayBuffer() || Hdr() == EmptyHdr())
      return 0;
    return mallocSizeOf(this->Hdr());
  }



  size_t SizeOfIncludingThis(nsMallocSizeOfFun mallocSizeOf) const {
    return mallocSizeOf(this) + SizeOfExcludingThis(mallocSizeOf);
  }
# 698 "../../dist/include/nsTArray.h"
  elem_type* Elements() {
    return reinterpret_cast<elem_type *>(Hdr() + 1);
  }




  const elem_type* Elements() const {
    return reinterpret_cast<const elem_type *>(Hdr() + 1);
  }





  elem_type& ElementAt(index_type i) {
    do { } while(0);
    return Elements()[i];
  }





  const elem_type& ElementAt(index_type i) const {
    do { } while(0);
    return Elements()[i];
  }






  elem_type& SafeElementAt(index_type i, elem_type& def) {
    return i < Length() ? Elements()[i] : def;
  }






  const elem_type& SafeElementAt(index_type i, const elem_type& def) const {
    return i < Length() ? Elements()[i] : def;
  }


  elem_type& operator[](index_type i) {
    return ElementAt(i);
  }


  const elem_type& operator[](index_type i) const {
    return ElementAt(i);
  }


  elem_type& LastElement() {
    return ElementAt(Length() - 1);
  }


  const elem_type& LastElement() const {
    return ElementAt(Length() - 1);
  }


  elem_type& SafeLastElement(elem_type& def) {
    return SafeElementAt(Length() - 1, def);
  }


  const elem_type& SafeLastElement(const elem_type& def) const {
    return SafeElementAt(Length() - 1, def);
  }
# 784 "../../dist/include/nsTArray.h"
  template<class Item, class Comparator>
  bool Contains(const Item& item, const Comparator& comp) const {
    return IndexOf(item, 0, comp) != NoIndex;
  }






  template<class Item>
  bool Contains(const Item& item) const {
    return IndexOf(item) != NoIndex;
  }







  template<class Item, class Comparator>
  index_type IndexOf(const Item& item, index_type start,
                     const Comparator& comp) const {
    const elem_type* iter = Elements() + start, *end = Elements() + Length();
    for (; iter != end; ++iter) {
      if (comp.Equals(*iter, item))
        return index_type(iter - Elements());
    }
    return NoIndex;
  }







  template<class Item>
  index_type IndexOf(const Item& item, index_type start = 0) const {
    return IndexOf(item, start, nsDefaultComparator<elem_type, Item>());
  }
# 834 "../../dist/include/nsTArray.h"
  template<class Item, class Comparator>
  index_type LastIndexOf(const Item& item, index_type start,
                         const Comparator& comp) const {
    size_type endOffset = start >= Length() ? Length() : start + 1;
    const elem_type* end = Elements() - 1, *iter = end + endOffset;
    for (; iter != end; --iter) {
      if (comp.Equals(*iter, item))
        return index_type(iter - Elements());
    }
    return NoIndex;
  }
# 853 "../../dist/include/nsTArray.h"
  template<class Item>
  index_type LastIndexOf(const Item& item,
                         index_type start = NoIndex) const {
    return LastIndexOf(item, start, nsDefaultComparator<elem_type, Item>());
  }






  template<class Item, class Comparator>
  index_type BinaryIndexOf(const Item& item, const Comparator& comp) const {
    index_type low = 0, high = Length();
    while (high > low) {
      index_type mid = (high + low) >> 1;
      if (comp.Equals(ElementAt(mid), item))
        return mid;
      if (comp.LessThan(ElementAt(mid), item))
        low = mid + 1;
      else
        high = mid;
    }
    return NoIndex;
  }






  template<class Item>
  index_type BinaryIndexOf(const Item& item) const {
    return BinaryIndexOf(item, nsDefaultComparator<elem_type, Item>());
  }
# 903 "../../dist/include/nsTArray.h"
  template<class Item>
  elem_type *ReplaceElementsAt(index_type start, size_type count,
                               const Item* array, size_type arrayLen) {

    if (!Alloc::Successful(this->EnsureCapacity(Length() + arrayLen - count, sizeof(elem_type))))
      return nullptr;
    DestructRange(start, count);
    this->ShiftData(start, count, arrayLen, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
    AssignRange(start, arrayLen, array);
    return Elements() + start;
  }


  template<class Item>
  elem_type *ReplaceElementsAt(index_type start, size_type count,
                               const nsTArray<Item>& array) {
    return ReplaceElementsAt(start, count, array.Elements(), array.Length());
  }


  template<class Item>
  elem_type *ReplaceElementsAt(index_type start, size_type count,
                               const Item& item) {
    return ReplaceElementsAt(start, count, &item, 1);
  }


  template<class Item>
  elem_type *ReplaceElementAt(index_type index, const Item& item) {
    return ReplaceElementsAt(index, 1, &item, 1);
  }


  template<class Item>
  elem_type *InsertElementsAt(index_type index, const Item* array,
                              size_type arrayLen) {
    return ReplaceElementsAt(index, 0, array, arrayLen);
  }


  template<class Item, class Allocator>
  elem_type *InsertElementsAt(index_type index, const nsTArray_Impl<Item, Allocator>& array) {
    return ReplaceElementsAt(index, 0, array.Elements(), array.Length());
  }


  template<class Item>
  elem_type *InsertElementAt(index_type index, const Item& item) {
    return ReplaceElementsAt(index, 0, &item, 1);
  }




  elem_type* InsertElementAt(index_type index) {
    if (!Alloc::Successful(this->EnsureCapacity(Length() + 1, sizeof(elem_type))))
      return nullptr;
    this->ShiftData(index, 0, 1, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
    elem_type *elem = Elements() + index;
    elem_traits::Construct(elem);
    return elem;
  }
# 981 "../../dist/include/nsTArray.h"
  template<class Item, class Comparator>
  index_type
  IndexOfFirstElementGt(const Item& item,
                        const Comparator& comp) const {

    index_type low = 0, high = Length();
    while (high > low) {
      index_type mid = (high + low) >> 1;


      if (comp.LessThan(ElementAt(mid), item) ||
          comp.Equals(ElementAt(mid), item)) {

        low = mid + 1;
      } else {

        high = mid;
      }
    }
    do { } while(0);
    return low;
  }


  template<class Item>
  index_type
  IndexOfFirstElementGt(const Item& item) const {
    return IndexOfFirstElementGt(item, nsDefaultComparator<elem_type, Item>());
  }




  template<class Item, class Comparator>
  elem_type *InsertElementSorted(const Item& item, const Comparator& comp) {
    index_type index = IndexOfFirstElementGt(item, comp);
    return InsertElementAt(index, item);
  }


  template<class Item>
  elem_type *InsertElementSorted(const Item& item) {
    return InsertElementSorted(item, nsDefaultComparator<elem_type, Item>());
  }






  template<class Item>
  elem_type *AppendElements(const Item* array, size_type arrayLen) {
    if (!Alloc::Successful(this->EnsureCapacity(Length() + arrayLen, sizeof(elem_type))))
      return nullptr;
    index_type len = Length();
    AssignRange(len, arrayLen, array);
    this->IncrementLength(arrayLen);
    return Elements() + len;
  }


  template<class Item, class Allocator>
  elem_type *AppendElements(const nsTArray_Impl<Item, Allocator>& array) {
    return AppendElements(array.Elements(), array.Length());
  }


  template<class Item>
  elem_type *AppendElement(const Item& item) {
    return AppendElements(&item, 1);
  }




  elem_type *AppendElements(size_type count) {
    if (!Alloc::Successful(this->EnsureCapacity(Length() + count, sizeof(elem_type))))
      return nullptr;
    elem_type *elems = Elements() + Length();
    size_type i;
    for (i = 0; i < count; ++i) {
      elem_traits::Construct(elems + i);
    }
    this->IncrementLength(count);
    return elems;
  }




  elem_type *AppendElement() {
    return AppendElements(1);
  }




  template<class Item, class Allocator>
  elem_type *MoveElementsFrom(nsTArray_Impl<Item, Allocator>& array) {
    do { } while(0);
    index_type len = Length();
    index_type otherLen = array.Length();
    if (!Alloc::Successful(this->EnsureCapacity(len + otherLen, sizeof(elem_type))))
      return nullptr;
    memcpy(Elements() + len, array.Elements(), otherLen * sizeof(elem_type));
    this->IncrementLength(otherLen);
    array.ShiftData(0, otherLen, 0, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
    return Elements() + len;
  }




  void RemoveElementsAt(index_type start, size_type count) {
    do { } while(0);
    do { } while(0);

    do { } while(0);
    DestructRange(start, count);
    this->ShiftData(start, count, 0, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
  }


  void RemoveElementAt(index_type index) {
    RemoveElementsAt(index, 1);
  }


  void Clear() {
    RemoveElementsAt(0, Length());
  }






  template<class Item, class Comparator>
  bool RemoveElement(const Item& item, const Comparator& comp) {
    index_type i = IndexOf(item, 0, comp);
    if (i == NoIndex)
      return false;

    RemoveElementAt(i);
    return true;
  }



  template<class Item>
  bool RemoveElement(const Item& item) {
    return RemoveElement(item, nsDefaultComparator<elem_type, Item>());
  }







  template<class Item, class Comparator>
  bool RemoveElementSorted(const Item& item, const Comparator& comp) {
    index_type index = IndexOfFirstElementGt(item, comp);
    if (index > 0 && comp.Equals(ElementAt(index - 1), item)) {
      RemoveElementAt(index - 1);
      return true;
    }
    return false;
  }


  template<class Item>
  bool RemoveElementSorted(const Item& item) {
    return RemoveElementSorted(item, nsDefaultComparator<elem_type, Item>());
  }



  template<class Allocator>
  bool SwapElements(nsTArray_Impl<E, Allocator>& other) {
    return this->SwapArrayElements(other, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
  }
# 1174 "../../dist/include/nsTArray.h"
  typename Alloc::ResultType SetCapacity(size_type capacity) {
    return Alloc::Result(this->EnsureCapacity(capacity, sizeof(elem_type)));
  }
# 1186 "../../dist/include/nsTArray.h"
  bool SetLength(size_type newLen) {
    size_type oldLen = Length();
    if (newLen > oldLen) {
      return InsertElementsAt(oldLen, newLen - oldLen) != nullptr;
    }

    TruncateLength(newLen);
    return true;
  }







  void TruncateLength(size_type newLen) {
    size_type oldLen = Length();
    do { } while(0)
                                                            ;
    RemoveElementsAt(newLen, oldLen - newLen);
  }







  bool EnsureLengthAtLeast(size_type minLen) {
    size_type oldLen = Length();
    if (minLen > oldLen) {
      return InsertElementsAt(oldLen, minLen - oldLen) != nullptr;
    }
    return true;
  }






  elem_type *InsertElementsAt(index_type index, size_type count) {
    if (!base_type::InsertSlotsAt(index, count, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment)) {
      return nullptr;
    }


    elem_type *iter = Elements() + index, *end = iter + count;
    for (; iter != end; ++iter) {
      elem_traits::Construct(iter);
    }

    return Elements() + index;
  }
# 1249 "../../dist/include/nsTArray.h"
  template<class Item>
  elem_type *InsertElementsAt(index_type index, size_type count,
                              const Item& item) {
    if (!base_type::InsertSlotsAt(index, count, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment)) {
      return nullptr;
    }


    elem_type *iter = Elements() + index, *end = iter + count;
    for (; iter != end; ++iter) {
      elem_traits::Construct(iter, item);
    }

    return Elements() + index;
  }


  void Compact() {
    ShrinkCapacity(sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment);
  }
# 1277 "../../dist/include/nsTArray.h"
  template<class Comparator>
  static int Compare(const void* e1, const void* e2, void *data) {
    const Comparator* c = reinterpret_cast<const Comparator*>(data);
    const elem_type* a = static_cast<const elem_type*>(e1);
    const elem_type* b = static_cast<const elem_type*>(e2);
    return c->LessThan(*a, *b) ? -1 : (c->Equals(*a, *b) ? 0 : 1);
  }




  template<class Comparator>
  void Sort(const Comparator& comp) {
    NS_QuickSort(Elements(), Length(), sizeof(elem_type),
                 Compare<Comparator>, const_cast<Comparator*>(&comp));
  }



  void Sort() {
    Sort(nsDefaultComparator<elem_type, elem_type>());
  }







  template<class Comparator>
  void MakeHeap(const Comparator& comp) {
    if (!Length()) {
      return;
    }
    index_type index = (Length() - 1) / 2;
    do {
      SiftDown(index, comp);
    } while (index--);
  }


  void MakeHeap() {
    MakeHeap(nsDefaultComparator<elem_type, elem_type>());
  }




  template<class Item, class Comparator>
  elem_type *PushHeap(const Item& item, const Comparator& comp) {
    if (!base_type::InsertSlotsAt(Length(), 1, sizeof(elem_type), mozilla::AlignmentFinder<elem_type>::alignment)) {
      return nullptr;
    }

    elem_type *elem = Elements();
    index_type index = Length() - 1;
    index_type parent_index = (index - 1) / 2;
    while (index && comp.LessThan(elem[parent_index], item)) {
      elem[index] = elem[parent_index];
      index = parent_index;
      parent_index = (index - 1) / 2;
    }
    elem[index] = item;
    return &elem[index];
  }


  template<class Item>
  elem_type *PushHeap(const Item& item) {
    return PushHeap(item, nsDefaultComparator<elem_type, Item>());
  }



  template<class Comparator>
  void PopHeap(const Comparator& comp) {
    if (!Length()) {
      return;
    }
    index_type last_index = Length() - 1;
    elem_type *elem = Elements();
    elem[0] = elem[last_index];
    TruncateLength(last_index);
    if (Length()) {
      SiftDown(0, comp);
    }
  }


  void PopHeap() {
    PopHeap(nsDefaultComparator<elem_type, elem_type>());
  }

protected:
  using base_type::Hdr;
  using base_type::ShrinkCapacity;




  void DestructRange(index_type start, size_type count) {
    elem_type *iter = Elements() + start, *end = iter + count;
    for (; iter != end; ++iter) {
      elem_traits::Destruct(iter);
    }
  }





  template<class Item>
  void AssignRange(index_type start, size_type count,
                   const Item *values) {
    AssignRangeAlgorithm<mozilla::IsPod<Item>::value,
                         mozilla::IsSame<Item, elem_type>::value>
      ::implementation(Elements(), start, count, values);
  }




  template<class Comparator>
  void SiftDown(index_type index, const Comparator& comp) {
    elem_type *elem = Elements();
    elem_type item = elem[index];
    index_type end = Length() - 1;
    while ((index * 2) < end) {
      const index_type left = (index * 2) + 1;
      const index_type right = (index * 2) + 2;
      const index_type parent_index = index;
      if (comp.LessThan(item, elem[left])) {
        if (left < end &&
            comp.LessThan(elem[left], elem[right])) {
          index = right;
        } else {
          index = left;
        }
      } else if (left < end &&
                 comp.LessThan(item, elem[right])) {
        index = right;
      } else {
        break;
      }
      elem[parent_index] = elem[index];
    }
    elem[index] = item;
  }
};

template <typename E, typename Alloc>
inline void
ImplCycleCollectionUnlink(nsTArray_Impl<E, Alloc>& aField)
{
  aField.Clear();
}

template <typename E, typename Alloc>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsTArray_Impl<E, Alloc>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
  aFlags |= CycleCollectionEdgeNameArrayFlag;
  size_t length = aField.Length();
  for (size_t i = 0; i < length; ++i) {
    ImplCycleCollectionTraverse(aCallback, aField[i], aName, aFlags);
  }
}





template <class E>
class nsTArray : public nsTArray_Impl<E, nsTArrayInfallibleAllocator>
{
public:
  typedef nsTArray_Impl<E, nsTArrayInfallibleAllocator> base_type;
  typedef nsTArray<E> self_type;
  typedef typename base_type::size_type size_type;

  nsTArray() {}
  explicit nsTArray(size_type capacity) : base_type(capacity) {}
  explicit nsTArray(const nsTArray& other) : base_type(other) {}

  template<class Allocator>
  explicit nsTArray(const nsTArray_Impl<E, Allocator>& other) : base_type(other) {}
};




template <class E>
class FallibleTArray : public nsTArray_Impl<E, nsTArrayFallibleAllocator>
{
public:
  typedef nsTArray_Impl<E, nsTArrayFallibleAllocator> base_type;
  typedef FallibleTArray<E> self_type;
  typedef typename base_type::size_type size_type;

  FallibleTArray() {}
  explicit FallibleTArray(size_type capacity) : base_type(capacity) {}
  explicit FallibleTArray(const FallibleTArray<E>& other) : base_type(other) {}

  template<class Allocator>
  explicit FallibleTArray(const nsTArray_Impl<E, Allocator>& other) : base_type(other) {}
};





template <class TArrayBase, uint32_t N>
class nsAutoArrayBase : public TArrayBase
{
public:
  typedef nsAutoArrayBase<TArrayBase, N> self_type;
  typedef TArrayBase base_type;
  typedef typename base_type::Header Header;
  typedef typename base_type::elem_type elem_type;

  template<typename Allocator>
  self_type& operator=(const nsTArray_Impl<elem_type, Allocator>& other) {
    base_type::operator=(other);
    return *this;
  }

protected:
  nsAutoArrayBase() {
    Init();
  }





  nsAutoArrayBase(const TArrayBase &aOther) {
    Init();
    AppendElements(aOther);
  }

private:


  template<class Allocator>
  friend class nsTArray_base;

  void Init() {
    static_assert((mozilla::AlignmentFinder<elem_type>::alignment <= 8), "can't handle alignments greater than 8, " "see nsTArray_base::UsesAutoArrayBuffer()")

                                                                 ;

    Header** phdr = base_type::PtrToHdr();
    *phdr = reinterpret_cast<Header*>(&mAutoBuf);
    (*phdr)->mLength = 0;
    (*phdr)->mCapacity = N;
    (*phdr)->mIsAutoArray = 1;

    do { } while(0)

                                                      ;
  }





  union {
    char mAutoBuf[sizeof(nsTArrayHeader) + N * sizeof(elem_type)];

    mozilla::AlignedElem<(mozilla::AlignmentFinder<Header>::alignment > mozilla::AlignmentFinder<elem_type>::alignment)
                         ? mozilla::AlignmentFinder<Header>::alignment : mozilla::AlignmentFinder<elem_type>::alignment> mAlign;
  };
};
# 1562 "../../dist/include/nsTArray.h"
template<class E, uint32_t N>
class nsAutoTArray : public nsAutoArrayBase<nsTArray<E>, N>
{
  typedef nsAutoTArray<E, N> self_type;
  typedef nsAutoArrayBase<nsTArray<E>, N> Base;

public:
  nsAutoTArray() {}

  template<typename Allocator>
  explicit nsAutoTArray(const nsTArray_Impl<E, Allocator>& other) {
    Base::AppendElements(other);
  }

  operator const AutoFallibleTArray<E, N>&() const {
    return *reinterpret_cast<const AutoFallibleTArray<E, N>*>(this);
  }
};





template<class E, uint32_t N>
class AutoFallibleTArray : public nsAutoArrayBase<FallibleTArray<E>, N>
{
  typedef AutoFallibleTArray<E, N> self_type;
  typedef nsAutoArrayBase<FallibleTArray<E>, N> Base;

public:
  AutoFallibleTArray() {}

  template<typename Allocator>
  explicit AutoFallibleTArray(const nsTArray_Impl<E, Allocator>& other) {
    Base::AppendElements(other);
  }

  operator const nsAutoTArray<E, N>&() const {
    return *reinterpret_cast<const nsAutoTArray<E, N>*>(this);
  }
};
# 1617 "../../dist/include/nsTArray.h"
static_assert((sizeof(nsAutoTArray<uint32_t, 2>) == sizeof(void*) + sizeof(nsTArrayHeader) + sizeof(uint32_t) * 2), "nsAutoTArray shouldn't contain any extra padding, " "see the comment")


                                    ;


# 1 "../../dist/include/nsTArray-inl.h" 1
# 11 "../../dist/include/nsTArray-inl.h"
template<class Alloc>
nsTArray_base<Alloc>::nsTArray_base()
  : mHdr(EmptyHdr()) {
  ;
}

template<class Alloc>
nsTArray_base<Alloc>::~nsTArray_base() {
  if (mHdr != EmptyHdr() && !UsesAutoArrayBuffer()) {
    Alloc::Free(mHdr);
  }
  ;
}

template<class Alloc>
const nsTArrayHeader* nsTArray_base<Alloc>::GetAutoArrayBufferUnsafe(size_t elemAlign) const {



  const void* autoBuf = &reinterpret_cast<const nsAutoArrayBase<nsTArray<uint32_t>, 1>*>(this)->mAutoBuf;




  static_assert((sizeof(void*) != 4 || (mozilla::AlignmentFinder<mozilla::AlignedElem<8> >::alignment == 8 && sizeof(nsAutoTArray<mozilla::AlignedElem<8>, 1>) == sizeof(void*) + sizeof(nsTArrayHeader) + 4 + sizeof(mozilla::AlignedElem<8>))), "auto array padding wasn't what we expected")




                                                                 ;


  do { } while(0);
  if (sizeof(void*) == 4 && elemAlign == 8) {
    autoBuf = reinterpret_cast<const char*>(autoBuf) + 4;
  }

  return reinterpret_cast<const Header*>(autoBuf);
}

template<class Alloc>
bool nsTArray_base<Alloc>::UsesAutoArrayBuffer() const {
  if (!mHdr->mIsAutoArray) {
    return false;
  }
# 86 "../../dist/include/nsTArray-inl.h"
  static_assert((sizeof(nsTArrayHeader) > 4), "see comment above")
                                        ;







  return mHdr == GetAutoArrayBuffer(4) || mHdr == GetAutoArrayBuffer(8);
}


template<class Alloc>
typename Alloc::ResultTypeProxy
nsTArray_base<Alloc>::EnsureCapacity(size_type capacity, size_type elemSize) {

  if (capacity <= mHdr->mCapacity)
    return Alloc::SuccessResult();






  if ((uint64_t)capacity * elemSize > size_type(-1)/2) {
    Alloc::SizeTooBig();
    return Alloc::FailureResult();
  }

  if (mHdr == EmptyHdr()) {

    Header *header = static_cast<Header*>
                     (Alloc::Malloc(sizeof(Header) + capacity * elemSize));
    if (!header)
      return Alloc::FailureResult();
    header->mLength = 0;
    header->mCapacity = capacity;
    header->mIsAutoArray = 0;
    mHdr = header;

    return Alloc::SuccessResult();
  }




  const uint32_t pageSizeBytes = 12;
  const uint32_t pageSize = 1 << pageSizeBytes;

  uint32_t minBytes = capacity * elemSize + sizeof(Header);
  uint32_t bytesToAlloc;
  if (minBytes >= pageSize) {

    bytesToAlloc = pageSize * ((minBytes + pageSize - 1) / pageSize);
  }
  else {


    bytesToAlloc = minBytes - 1;
    bytesToAlloc |= bytesToAlloc >> 1;
    bytesToAlloc |= bytesToAlloc >> 2;
    bytesToAlloc |= bytesToAlloc >> 4;
    bytesToAlloc |= bytesToAlloc >> 8;
    bytesToAlloc |= bytesToAlloc >> 16;
    bytesToAlloc++;

    do { } while(0)
                                                                      ;
  }

  Header *header;
  if (UsesAutoArrayBuffer()) {

    header = static_cast<Header*>(Alloc::Malloc(bytesToAlloc));
    if (!header)
      return Alloc::FailureResult();

    memcpy(header, mHdr, sizeof(Header) + Length() * elemSize);
  } else {

    header = static_cast<Header*>(Alloc::Realloc(mHdr, bytesToAlloc));
    if (!header)
      return Alloc::FailureResult();
  }


  uint32_t newCapacity = (bytesToAlloc - sizeof(Header)) / elemSize;
  do { } while(0);
  header->mCapacity = newCapacity;

  mHdr = header;

  return Alloc::SuccessResult();
}

template<class Alloc>
void
nsTArray_base<Alloc>::ShrinkCapacity(size_type elemSize, size_t elemAlign) {
  if (mHdr == EmptyHdr() || UsesAutoArrayBuffer())
    return;

  if (mHdr->mLength >= mHdr->mCapacity)
    return;

  size_type length = Length();

  if (IsAutoArray() && GetAutoArrayBuffer(elemAlign)->mCapacity >= length) {
    Header* header = GetAutoArrayBuffer(elemAlign);


    header->mLength = length;
    memcpy(header + 1, mHdr + 1, length * elemSize);

    Alloc::Free(mHdr);
    mHdr = header;
    return;
  }

  if (length == 0) {
    do { } while(0);
    Alloc::Free(mHdr);
    mHdr = EmptyHdr();
    return;
  }

  size_type size = sizeof(Header) + length * elemSize;
  void *ptr = Alloc::Realloc(mHdr, size);
  if (!ptr)
    return;
  mHdr = static_cast<Header*>(ptr);
  mHdr->mCapacity = length;
}

template<class Alloc>
void
nsTArray_base<Alloc>::ShiftData(index_type start,
                                size_type oldLen, size_type newLen,
                                size_type elemSize, size_t elemAlign) {
  if (oldLen == newLen)
    return;


  size_type num = mHdr->mLength - (start + oldLen);


  mHdr->mLength += newLen - oldLen;
  if (mHdr->mLength == 0) {
    ShrinkCapacity(elemSize, elemAlign);
  } else {

    if (num == 0)
      return;

    start *= elemSize;
    newLen *= elemSize;
    oldLen *= elemSize;
    num *= elemSize;
    char *base = reinterpret_cast<char*>(mHdr + 1) + start;
    memmove(base + newLen, base + oldLen, num);
  }
}

template<class Alloc>
bool
nsTArray_base<Alloc>::InsertSlotsAt(index_type index, size_type count,
                                    size_type elementSize, size_t elemAlign) {
  do { } while(0);
  size_type newLen = Length() + count;

  EnsureCapacity(newLen, elementSize);


  if (Capacity() < newLen)
    return false;



  ShiftData(index, 0, count, elementSize, elemAlign);

  return true;
}
# 277 "../../dist/include/nsTArray-inl.h"
template<class Alloc>
nsTArray_base<Alloc>::IsAutoArrayRestorer::IsAutoArrayRestorer(
  nsTArray_base<Alloc> &array,
  size_t elemAlign)
  : mArray(array),
    mElemAlign(elemAlign),
    mIsAuto(array.IsAutoArray())
{
}

template<class Alloc>
nsTArray_base<Alloc>::IsAutoArrayRestorer::~IsAutoArrayRestorer() {

  if (mIsAuto && mArray.mHdr == mArray.EmptyHdr()) {


    mArray.mHdr = mArray.GetAutoArrayBufferUnsafe(mElemAlign);
    mArray.mHdr->mLength = 0;
  }
  else if (mArray.mHdr != mArray.EmptyHdr()) {
    mArray.mHdr->mIsAutoArray = mIsAuto;
  }
}

template<class Alloc>
template<class Allocator>
bool
nsTArray_base<Alloc>::SwapArrayElements(nsTArray_base<Allocator>& other,
                                        size_type elemSize,
                                        size_t elemAlign) {






  IsAutoArrayRestorer ourAutoRestorer(*this, elemAlign);
  typename nsTArray_base<Allocator>::IsAutoArrayRestorer otherAutoRestorer(other, elemAlign);




  if ((!UsesAutoArrayBuffer() || Capacity() < other.Length()) &&
      (!other.UsesAutoArrayBuffer() || other.Capacity() < Length())) {

    if (!EnsureNotUsingAutoArrayBuffer(elemSize) ||
        !other.EnsureNotUsingAutoArrayBuffer(elemSize)) {
      return false;
    }

    Header *temp = mHdr;
    mHdr = other.mHdr;
    other.mHdr = temp;

    return true;
  }
# 345 "../../dist/include/nsTArray-inl.h"
  if (!Alloc::Successful(EnsureCapacity(other.Length(), elemSize)) ||
      !Allocator::Successful(other.EnsureCapacity(Length(), elemSize))) {
    return false;
  }



  do { } while(0)

                                                                         ;

  size_type smallerLength = XPCOM_MIN(Length(), other.Length());
  size_type largerLength = XPCOM_MAX(Length(), other.Length());
  void *smallerElements, *largerElements;
  if (Length() <= other.Length()) {
    smallerElements = Hdr() + 1;
    largerElements = other.Hdr() + 1;
  }
  else {
    smallerElements = other.Hdr() + 1;
    largerElements = Hdr() + 1;
  }






  nsAutoArrayBase<nsTArray_Impl<uint8_t, Alloc>, 64> temp;
  if (!Alloc::Successful(temp.EnsureCapacity(smallerLength, elemSize))) {
    return false;
  }

  memcpy(temp.Elements(), smallerElements, smallerLength * elemSize);
  memcpy(smallerElements, largerElements, largerLength * elemSize);
  memcpy(largerElements, temp.Elements(), smallerLength * elemSize);


  do { } while(0)

                                                    ;
  size_type tempLength = Length();
  mHdr->mLength = other.Length();
  other.mHdr->mLength = tempLength;

  return true;
}

template<class Alloc>
bool
nsTArray_base<Alloc>::EnsureNotUsingAutoArrayBuffer(size_type elemSize) {
  if (UsesAutoArrayBuffer()) {





    if (Length() == 0) {
      mHdr = EmptyHdr();
      return true;
    }

    size_type size = sizeof(Header) + Length() * elemSize;

    Header* header = static_cast<Header*>(Alloc::Malloc(size));
    if (!header)
      return false;

    memcpy(header, mHdr, size);
    header->mCapacity = Length();
    mHdr = header;
  }

  return true;
}
# 1624 "../../dist/include/nsTArray.h" 2
# 13 "../../dist/include/nsCOMArray.h" 2






class nsCOMArray_base
{
    friend class nsArray;
protected:
    nsCOMArray_base() {}
    nsCOMArray_base(int32_t aCount) : mArray(aCount) {}
    nsCOMArray_base(const nsCOMArray_base& other);
    ~nsCOMArray_base();

    int32_t IndexOf(nsISupports* aObject, uint32_t aStartIndex = 0) const;
    bool Contains(nsISupports* aObject) const {
        return IndexOf(aObject) != -1;
    }

    int32_t IndexOfObject(nsISupports* aObject) const;
    bool ContainsObject(nsISupports* aObject) const {
        return IndexOfObject(aObject) != -1;
    }

    typedef bool (* nsBaseArrayEnumFunc)
        (void* aElement, void *aData);


    bool EnumerateForwards(nsBaseArrayEnumFunc aFunc, void* aData) const;

    bool EnumerateBackwards(nsBaseArrayEnumFunc aFunc, void* aData) const;

    typedef int (* nsBaseArrayComparatorFunc)
        (nsISupports* aElement1, nsISupports* aElement2, void* aData);

    struct nsCOMArrayComparatorContext {
        nsBaseArrayComparatorFunc mComparatorFunc;
        void* mData;
    };

    static int nsCOMArrayComparator(const void* aElement1, const void* aElement2, void* aData);
    void Sort(nsBaseArrayComparatorFunc aFunc, void* aData);

    bool InsertObjectAt(nsISupports* aObject, int32_t aIndex);
    void InsertElementAt(uint32_t aIndex, nsISupports* aElement);
    bool InsertObjectsAt(const nsCOMArray_base& aObjects, int32_t aIndex);
    void InsertElementsAt(uint32_t aIndex, const nsCOMArray_base& aElements);
    void InsertElementsAt(uint32_t aIndex, nsISupports* const* aElements, uint32_t aCount);
    bool ReplaceObjectAt(nsISupports* aObject, int32_t aIndex);
    void ReplaceElementAt(uint32_t aIndex, nsISupports* aElement) {
        nsISupports* oldElement = mArray[aIndex];
        ns_if_addref(mArray[aIndex] = aElement);
        do { if (oldElement) { (oldElement)->Release(); (oldElement) = 0; } } while (0);
    }
    bool AppendObject(nsISupports *aObject) {
        return InsertObjectAt(aObject, Count());
    }
    void AppendElement(nsISupports* aElement) {
        InsertElementAt(Length(), aElement);
    }
    bool AppendObjects(const nsCOMArray_base& aObjects) {
        return InsertObjectsAt(aObjects, Count());
    }
    void AppendElements(const nsCOMArray_base& aElements) {
        return InsertElementsAt(Length(), aElements);
    }
    void AppendElements(nsISupports* const* aElements, uint32_t aCount) {
        return InsertElementsAt(Length(), aElements, aCount);
    }
    bool RemoveObject(nsISupports *aObject);
    nsISupports** Elements() {
        return mArray.Elements();
    }
    void SwapElements(nsCOMArray_base& aOther) {
        mArray.SwapElements(aOther.mArray);
    }

public:

    int32_t Count() const {
        return mArray.Length();
    }

    uint32_t Length() const {
        return mArray.Length();
    }
    bool IsEmpty() const {
        return mArray.IsEmpty();
    }



    bool SetCount(int32_t aNewCount);

    void TruncateLength(uint32_t aNewLength) {
        if (mArray.Length() > aNewLength)
            RemoveElementsAt(aNewLength, mArray.Length() - aNewLength);
    }


    void Clear();

    nsISupports* ObjectAt(int32_t aIndex) const {
        return mArray[aIndex];
    }

    nsISupports* ElementAt(uint32_t aIndex) const {
        return mArray[aIndex];
    }

    nsISupports* SafeObjectAt(int32_t aIndex) const {
        return mArray.SafeElementAt(aIndex, nullptr);
    }

    nsISupports* SafeElementAt(uint32_t aIndex) const {
        return mArray.SafeElementAt(aIndex, nullptr);
    }

    nsISupports* operator[](int32_t aIndex) const {
        return mArray[aIndex];
    }



    bool RemoveObjectAt(int32_t aIndex);

    void RemoveElementAt(uint32_t aIndex);



    bool RemoveObjectsAt(int32_t aIndex, int32_t aCount);

    void RemoveElementsAt(uint32_t aIndex, uint32_t aCount);

    void SwapElementsAt(uint32_t aIndex1, uint32_t aIndex2) {
        nsISupports *tmp = mArray[aIndex1];
        mArray[aIndex1] = mArray[aIndex2];
        mArray[aIndex2] = tmp;
    }



    bool SetCapacity(uint32_t aCapacity) {
        mArray.SetCapacity(aCapacity);

        return true;
    }
    uint32_t Capacity() {
        return mArray.Capacity();
    }

    typedef size_t (* nsBaseArraySizeOfElementIncludingThisFunc)
        (nsISupports* aElement, nsMallocSizeOfFun aMallocSizeOf, void *aData);




    size_t SizeOfExcludingThis(
             nsBaseArraySizeOfElementIncludingThisFunc aSizeOfElementIncludingThis,
             nsMallocSizeOfFun aMallocSizeOf, void* aData = __null) const;

private:


    nsTArray<nsISupports*> mArray;


    nsCOMArray_base& operator=(const nsCOMArray_base& other) = delete;
};

inline void
ImplCycleCollectionUnlink(nsCOMArray_base& aField)
{
    aField.Clear();
}

inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsCOMArray_base& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
    aFlags |= CycleCollectionEdgeNameArrayFlag;
    size_t length = aField.Count();
    for (size_t i = 0; i < length; ++i) {
        CycleCollectionNoteChild(aCallback, aField[i], aName, aFlags);
    }
}
# 222 "../../dist/include/nsCOMArray.h"
template <class T>
class nsCOMArray : public nsCOMArray_base
{
 public:
    nsCOMArray() {}

    explicit
    nsCOMArray(int32_t aCount) : nsCOMArray_base(aCount) {}

    explicit
    nsCOMArray(const nsCOMArray<T>& aOther) : nsCOMArray_base(aOther) { }

    ~nsCOMArray() {}


    T* ObjectAt(int32_t aIndex) const {
        return static_cast<T*>(nsCOMArray_base::ObjectAt(aIndex));
    }

    T* ElementAt(uint32_t aIndex) const {
        return static_cast<T*>(nsCOMArray_base::ElementAt(aIndex));
    }


    T* SafeObjectAt(int32_t aIndex) const {
        return static_cast<T*>(nsCOMArray_base::SafeObjectAt(aIndex));
    }

    T* SafeElementAt(uint32_t aIndex) const {
        return static_cast<T*>(nsCOMArray_base::SafeElementAt(aIndex));
    }


    T* operator[](int32_t aIndex) const {
        return ObjectAt(aIndex);
    }




    int32_t IndexOf(T* aObject, uint32_t aStartIndex = 0) const {
        return nsCOMArray_base::IndexOf(aObject, aStartIndex);
    }
    bool Contains(nsISupports* aObject) const {
        return nsCOMArray_base::Contains(aObject);
    }






    int32_t IndexOfObject(T* aObject) const {
        return nsCOMArray_base::IndexOfObject(aObject);
    }
    bool ContainsObject(nsISupports* aObject) const {
        return nsCOMArray_base::ContainsObject(aObject);
    }



    bool InsertObjectAt(T* aObject, int32_t aIndex) {
        return nsCOMArray_base::InsertObjectAt(aObject, aIndex);
    }

    void InsertElementAt(uint32_t aIndex, T* aElement) {
        nsCOMArray_base::InsertElementAt(aIndex, aElement);
    }



    bool InsertObjectsAt(const nsCOMArray<T>& aObjects, int32_t aIndex) {
        return nsCOMArray_base::InsertObjectsAt(aObjects, aIndex);
    }

    void InsertElementsAt(uint32_t aIndex, const nsCOMArray<T>& aElements) {
        nsCOMArray_base::InsertElementsAt(aIndex, aElements);
    }
    void InsertElementsAt(uint32_t aIndex, T* const* aElements, uint32_t aCount) {
        nsCOMArray_base::InsertElementsAt(aIndex, reinterpret_cast<nsISupports* const*>(aElements), aCount);
    }



    bool ReplaceObjectAt(T* aObject, int32_t aIndex) {
        return nsCOMArray_base::ReplaceObjectAt(aObject, aIndex);
    }

    void ReplaceElementAt(uint32_t aIndex, T* aElement) {
        nsCOMArray_base::ReplaceElementAt(aIndex, aElement);
    }




    typedef bool (* nsCOMArrayEnumFunc)
        (T* aElement, void *aData);


    bool EnumerateForwards(nsCOMArrayEnumFunc aFunc, void* aData) {
        return nsCOMArray_base::EnumerateForwards(nsBaseArrayEnumFunc(aFunc),
                                                  aData);
    }

    bool EnumerateBackwards(nsCOMArrayEnumFunc aFunc, void* aData) {
        return nsCOMArray_base::EnumerateBackwards(nsBaseArrayEnumFunc(aFunc),
                                                  aData);
    }

    typedef int (* nsCOMArrayComparatorFunc)
        (T* aElement1, T* aElement2, void* aData);

    void Sort(nsCOMArrayComparatorFunc aFunc, void* aData) {
        nsCOMArray_base::Sort(nsBaseArrayComparatorFunc(aFunc), aData);
    }


    bool AppendObject(T *aObject) {
        return nsCOMArray_base::AppendObject(aObject);
    }

    void AppendElement(T* aElement) {
        nsCOMArray_base::AppendElement(aElement);
    }


    bool AppendObjects(const nsCOMArray<T>& aObjects) {
        return nsCOMArray_base::AppendObjects(aObjects);
    }

    void AppendElements(const nsCOMArray<T>& aElements) {
        return nsCOMArray_base::AppendElements(aElements);
    }
    void AppendElements(T* const* aElements, uint32_t aCount) {
        InsertElementsAt(Length(), aElements, aCount);
    }




    bool RemoveObject(T *aObject) {
        return nsCOMArray_base::RemoveObject(aObject);
    }

    bool RemoveElement(T* aElement) {
        return nsCOMArray_base::RemoveObject(aElement);
    }

    T** Elements() {
        return reinterpret_cast<T**>(nsCOMArray_base::Elements());
    }
    void SwapElements(nsCOMArray<T>& aOther) {
        nsCOMArray_base::SwapElements(aOther);
    }




    typedef size_t (* nsCOMArraySizeOfElementIncludingThisFunc)
        (T* aElement, nsMallocSizeOfFun aMallocSizeOf, void *aData);

    size_t SizeOfExcludingThis(
             nsCOMArraySizeOfElementIncludingThisFunc aSizeOfElementIncludingThis,
             nsMallocSizeOfFun aMallocSizeOf, void *aData = __null) const {
        return nsCOMArray_base::SizeOfExcludingThis(
                 nsBaseArraySizeOfElementIncludingThisFunc(aSizeOfElementIncludingThis),
                 aMallocSizeOf, aData);
    }

private:


    nsCOMArray<T>& operator=(const nsCOMArray<T>& other) = delete;
};

template <typename T>
inline void
ImplCycleCollectionUnlink(nsCOMArray<T>& aField)
{
    aField.Clear();
}

template <typename E>
inline void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback,
                            nsCOMArray<E>& aField,
                            const char* aName,
                            uint32_t aFlags = 0)
{
    aFlags |= CycleCollectionEdgeNameArrayFlag;
    size_t length = aField.Count();
    for (size_t i = 0; i < length; ++i) {
        CycleCollectionNoteChild(aCallback, aField[i], aName, aFlags);
    }
}
# 18 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheDevice.h" 2

class nsDiskCacheMap;
class nsIMemoryReporter;


class nsDiskCacheDevice : public nsCacheDevice {
public:
    nsDiskCacheDevice();
    virtual ~nsDiskCacheDevice();

    virtual nsresult Init();
    virtual nsresult Shutdown();

    virtual const char * GetDeviceID(void);
    virtual nsCacheEntry * FindEntry(nsCString * key, bool *collision);
    virtual nsresult DeactivateEntry(nsCacheEntry * entry);
    virtual nsresult BindEntry(nsCacheEntry * entry);
    virtual void DoomEntry( nsCacheEntry * entry );

    virtual nsresult OpenInputStreamForEntry(nsCacheEntry * entry,
                                             nsCacheAccessMode mode,
                                             uint32_t offset,
                                             nsIInputStream ** result);

    virtual nsresult OpenOutputStreamForEntry(nsCacheEntry * entry,
                                              nsCacheAccessMode mode,
                                              uint32_t offset,
                                              nsIOutputStream ** result);

    virtual nsresult GetFileForEntry(nsCacheEntry * entry,
                                            nsIFile ** result);

    virtual nsresult OnDataSizeChange(nsCacheEntry * entry, int32_t deltaSize);

    virtual nsresult Visit(nsICacheVisitor * visitor);

    virtual nsresult EvictEntries(const char * clientID);

    bool EntryIsTooBig(int64_t entrySize);

    size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf);




    void SetCacheParentDirectory(nsIFile * parentDir);
    void SetCapacity(uint32_t capacity);
    void SetMaxEntrySize(int32_t maxSizeInKilobytes);



    void getCacheDirectory(nsIFile ** result);
    uint32_t getCacheCapacity();
    uint32_t getCacheSize();
    uint32_t getEntryCount();

    nsDiskCacheMap * CacheMap() { return &mCacheMap; }

private:
    friend class nsDiskCacheDeviceDeactivateEntryEvent;
    friend class nsEvictDiskCacheEntriesEvent;
    friend class nsDiskCacheMap;




    inline bool IsValidBinding(nsDiskCacheBinding *binding)
    {
        do { } while(0);
        do { } while(0)
                                                          ;
        return (binding && !binding->mDeactivateEvent);
    }

    bool Initialized() { return mInitialized; }

    nsresult Shutdown_Private(bool flush);
    nsresult DeactivateEntry_Private(nsCacheEntry * entry,
                                                    nsDiskCacheBinding * binding);

    nsresult OpenDiskCache();
    nsresult ClearDiskCache();

    nsresult EvictDiskCacheEntries(uint32_t targetCapacity);




    nsCOMPtr<nsIFile> mCacheDirectory;
    nsDiskCacheBindery mBindery;
    uint32_t mCacheCapacity;
    int32_t mMaxEntrySize;

    nsDiskCacheMap mCacheMap;
    bool mInitialized;
    bool mClearingDiskCache;

    nsCOMPtr<nsIMemoryReporter> mReporter;
};
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h"
# 1 "../../dist/include/nsICacheService.h" 1
# 21 "../../dist/include/nsICacheService.h"
class nsISimpleEnumerator;

class nsICacheListener;

class nsICacheSession;

class nsICacheVisitor;

class nsIEventTarget;
# 39 "../../dist/include/nsICacheService.h"
class nsICacheService : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult CreateSession(const char * clientID, nsCacheStoragePolicy storagePolicy, bool streamBased, nsICacheSession * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult VisitEntries(nsICacheVisitor *visitor) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult EvictEntries(nsCacheStoragePolicy storagePolicy) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetCacheIOTarget(nsIEventTarget * *aCacheIOTarget) = 0;

};

  template <class Dummy> const nsIID nsICacheService::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x14dbe1e9, 0xf3bc, 0x45af, { 0x92, 0xf4, 0x2c, 0x57, 0x4f, 0xcd, 0x4e, 0x39 }};
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheSession.h" 1
# 10 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheSession.h"
# 1 "../../dist/system_wrappers/nspr.h" 1
       
# 2 "../../dist/system_wrappers/nspr.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 11 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheSession.h" 2


# 1 "../../dist/include/nsICacheSession.h" 1
# 21 "../../dist/include/nsICacheSession.h"
class nsICacheEntryDescriptor;

class nsICacheListener;

class nsIFile;
# 35 "../../dist/include/nsICacheSession.h"
class nsICacheSession : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetDoomEntriesIfExpired(bool *aDoomEntriesIfExpired) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetDoomEntriesIfExpired(bool aDoomEntriesIfExpired) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetProfileDirectory(nsIFile * *aProfileDirectory) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetProfileDirectory(nsIFile *aProfileDirectory) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult OpenCacheEntry(const nsACString_internal & key, nsCacheAccessMode accessRequested, bool blockingMode, nsICacheEntryDescriptor * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult AsyncOpenCacheEntry(const nsACString_internal & key, nsCacheAccessMode accessRequested, nsICacheListener *listener, bool noWait) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult EvictEntries(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult IsStorageEnabled(bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult DoomEntry(const nsACString_internal & key, nsICacheListener *listener) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetIsPrivate(bool *aIsPrivate) = 0;
  virtual __attribute__ ((visibility ("hidden"))) nsresult SetIsPrivate(bool aIsPrivate) = 0;

};

  template <class Dummy> const nsIID nsICacheSession::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x1dd7708c, 0xde48, 0x4ffe, { 0xb5, 0xaa, 0xcd, 0x21, 0x8c, 0x76, 0x28, 0x87 }};
# 14 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheSession.h" 2



class nsCacheSession : public nsICacheSession
{
public:
    public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
    virtual __attribute__ ((visibility ("hidden"))) nsresult GetDoomEntriesIfExpired(bool *aDoomEntriesIfExpired); virtual __attribute__ ((visibility ("hidden"))) nsresult SetDoomEntriesIfExpired(bool aDoomEntriesIfExpired); virtual __attribute__ ((visibility ("hidden"))) nsresult GetProfileDirectory(nsIFile * *aProfileDirectory); virtual __attribute__ ((visibility ("hidden"))) nsresult SetProfileDirectory(nsIFile *aProfileDirectory); virtual __attribute__ ((visibility ("hidden"))) nsresult OpenCacheEntry(const nsACString_internal & key, nsCacheAccessMode accessRequested, bool blockingMode, nsICacheEntryDescriptor * *_retval); virtual __attribute__ ((visibility ("hidden"))) nsresult AsyncOpenCacheEntry(const nsACString_internal & key, nsCacheAccessMode accessRequested, nsICacheListener *listener, bool noWait); virtual __attribute__ ((visibility ("hidden"))) nsresult EvictEntries(void); virtual __attribute__ ((visibility ("hidden"))) nsresult IsStorageEnabled(bool *_retval); virtual __attribute__ ((visibility ("hidden"))) nsresult DoomEntry(const nsACString_internal & key, nsICacheListener *listener); virtual __attribute__ ((visibility ("hidden"))) nsresult GetIsPrivate(bool *aIsPrivate); virtual __attribute__ ((visibility ("hidden"))) nsresult SetIsPrivate(bool aIsPrivate);

    nsCacheSession(const char * clientID, nsCacheStoragePolicy storagePolicy, bool streamBased);
    virtual ~nsCacheSession();

    nsCString * ClientID() { return &mClientID; }

    enum SessionInfo {
        eStoragePolicyMask = 0x000000FF,
        eStreamBasedMask = 0x00000100,
        eDoomEntriesIfExpiredMask = 0x00001000,
        ePrivateMask = 0x00010000
    };

    void MarkStreamBased() { mInfo |= eStreamBasedMask; }
    void ClearStreamBased() { mInfo &= ~eStreamBasedMask; }
    bool IsStreamBased() { return (mInfo & eStreamBasedMask) != 0; }

    void MarkDoomEntriesIfExpired() { mInfo |= eDoomEntriesIfExpiredMask; }
    void ClearDoomEntriesIfExpired() { mInfo &= ~eDoomEntriesIfExpiredMask; }
    bool WillDoomEntriesIfExpired() { return (0 != (mInfo & eDoomEntriesIfExpiredMask)); }

    void MarkPrivate() { mInfo |= ePrivateMask; }
    void MarkPublic() { mInfo &= ~ePrivateMask; }
    bool IsPrivate() { return (mInfo & ePrivateMask) != 0; }
    nsCacheStoragePolicy StoragePolicy()
    {
        return (nsCacheStoragePolicy)(mInfo & eStoragePolicyMask);
    }

    void SetStoragePolicy(nsCacheStoragePolicy policy)
    {
        do { } while(0);
        mInfo &= ~eStoragePolicyMask;
        mInfo |= policy;
    }

    nsIFile* ProfileDir() { return mProfileDir; }

private:
    nsCString mClientID;
    uint32_t mInfo;
    nsCOMPtr<nsIFile> mProfileDir;
};
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2


# 1 "../../dist/include/nsThreadUtils.h" 1
# 10 "../../dist/include/nsThreadUtils.h"
# 1 "../../dist/system_wrappers/prthread.h" 1
       
# 2 "../../dist/system_wrappers/prthread.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 11 "../../dist/include/nsThreadUtils.h" 2
# 1 "../../dist/system_wrappers/prinrval.h" 1
       
# 2 "../../dist/system_wrappers/prinrval.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prinrval.h" 1 3
# 4 "../../dist/system_wrappers/prinrval.h" 2 3
#pragma GCC visibility pop
# 12 "../../dist/include/nsThreadUtils.h" 2
# 1 "../../dist/include/nsIThreadManager.h" 1
# 17 "../../dist/include/nsIThreadManager.h"
class nsIThread;
# 27 "../../dist/include/nsIThreadManager.h"
class nsIThreadManager : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}

  enum {
    DEFAULT_STACK_SIZE = 0U
  };


  virtual __attribute__ ((visibility ("hidden"))) nsresult NewThread(uint32_t creationFlags, uint32_t stackSize, nsIThread * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetThreadFromPRThread(PRThread *prthread, nsIThread * *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetMainThread(nsIThread * *aMainThread) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetCurrentThread(nsIThread * *aCurrentThread) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetIsMainThread(bool *aIsMainThread) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetIsCycleCollectorThread(bool *aIsCycleCollectorThread) = 0;

};

  template <class Dummy> const nsIID nsIThreadManager::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x2bbbc38c, 0xcf96, 0x4099, { 0xba, 0x6b, 0xf6, 0xa4, 0x4d, 0x8b, 0x01, 0x4c }};
# 13 "../../dist/include/nsThreadUtils.h" 2
# 1 "../../dist/include/nsIThread.h" 1
# 14 "../../dist/include/nsThreadUtils.h" 2
# 1 "../../dist/include/nsIRunnable.h" 1
# 25 "../../dist/include/nsIRunnable.h"
class nsIRunnable : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Run(void) = 0;

};

  template <class Dummy> const nsIID nsIRunnable::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x4a2abaf0, 0x6886, 0x11d3, { 0x93, 0x82, 0x00, 0x10, 0x4b, 0xa0, 0xfd, 0x40 }};
# 15 "../../dist/include/nsThreadUtils.h" 2
# 1 "../../dist/include/nsICancelableRunnable.h" 1
# 25 "../../dist/include/nsICancelableRunnable.h"
class nsICancelableRunnable : public nsIRunnable {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Cancel(void) = 0;

};

  template <class Dummy> const nsIID nsICancelableRunnable::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xde93dc4c, 0x5eea, 0x4eb7, { 0xb6, 0xd1, 0xdb, 0xf1, 0xe0, 0xce, 0xf6, 0x5c }};
# 16 "../../dist/include/nsThreadUtils.h" 2
# 1 "../../dist/include/nsStringGlue.h" 1
# 15 "../../dist/include/nsStringGlue.h"
# 1 "../../dist/include/nsString.h" 1
# 16 "../../dist/include/nsStringGlue.h" 2
# 17 "../../dist/include/nsThreadUtils.h" 2

# 1 "../../dist/include/nsAutoPtr.h" 1
# 19 "../../dist/include/nsThreadUtils.h" 2
# 29 "../../dist/include/nsThreadUtils.h"
extern void
NS_SetThreadName(nsIThread *thread, const nsACString_internal &name);





template <size_t LEN>
inline void
NS_SetThreadName(nsIThread *thread, const char (&name)[LEN])
{
  static_assert((LEN <= 16), "Thread name must be no more than 16 characters")
                                                                     ;
  NS_SetThreadName(thread, nsDependentCString(name));
}
# 58 "../../dist/include/nsThreadUtils.h"
extern nsresult
NS_NewThread(nsIThread **result,
             nsIRunnable *initialEvent = nullptr,
             uint32_t stackSize = nsIThreadManager::DEFAULT_STACK_SIZE);




template <size_t LEN>
inline nsresult
NS_NewNamedThread(const char (&name)[LEN],
                  nsIThread **result,
                  nsIRunnable *initialEvent = nullptr,
                  uint32_t stackSize = nsIThreadManager::DEFAULT_STACK_SIZE)
{
    nsresult rv = NS_NewThread(result, initialEvent, stackSize);
    NS_SetThreadName<LEN>(*result, name);
    return rv;
}







extern nsresult
NS_GetCurrentThread(nsIThread **result);







extern nsresult
NS_GetMainThread(nsIThread **result);






extern __thread mozilla::threads::ID gTLSThreadID;
inline bool NS_IsMainThread()
{
  return gTLSThreadID == mozilla::threads::Main;
}
# 125 "../../dist/include/nsThreadUtils.h"
extern nsresult
NS_DispatchToCurrentThread(nsIRunnable *event);
# 139 "../../dist/include/nsThreadUtils.h"
extern nsresult
NS_DispatchToMainThread(nsIRunnable *event,
                        uint32_t dispatchFlags = nsIEventTarget::DISPATCH_NORMAL);
# 159 "../../dist/include/nsThreadUtils.h"
extern nsresult
NS_ProcessPendingEvents(nsIThread *thread,
                        PRIntervalTime timeout = 0xffffffffUL);
# 178 "../../dist/include/nsThreadUtils.h"
extern bool
NS_HasPendingEvents(nsIThread *thread = nullptr);
# 198 "../../dist/include/nsThreadUtils.h"
extern bool
NS_ProcessNextEvent(nsIThread *thread = nullptr, bool mayWait = true);




inline already_AddRefed<nsIThread>
do_GetCurrentThread() {
  nsIThread *thread = nullptr;
  NS_GetCurrentThread(&thread);
  return already_AddRefed<nsIThread>(thread);
}

inline already_AddRefed<nsIThread>
do_GetMainThread() {
  nsIThread *thread = nullptr;
  NS_GetMainThread(&thread);
  return already_AddRefed<nsIThread>(thread);
}
# 225 "../../dist/include/nsThreadUtils.h"
extern nsIThread *NS_GetCurrentThread();
# 236 "../../dist/include/nsThreadUtils.h"
class nsRunnable : public nsIRunnable
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual nsrefcnt AddRef(void); virtual nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
  virtual nsresult Run(void);

  nsRunnable() {
  }

protected:
  virtual ~nsRunnable() {
  }
};


class nsCancelableRunnable : public nsICancelableRunnable
{
public:
  public: virtual nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual nsrefcnt AddRef(void); virtual nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
  virtual nsresult Run(void);
  virtual nsresult Cancel(void);

  nsCancelableRunnable() {
  }

protected:
  virtual ~nsCancelableRunnable() {
  }
};







template <class ClassType,
          typename ReturnType = void,
          bool Owning = true>
class nsRunnableMethod : public nsRunnable
{
public:
  virtual void Revoke() = 0;




  template <typename OtherReturnType>
  class ReturnTypeEnforcer
  {
  public:
    typedef int ReturnTypeIsSafe;
  };

  template <class T>
  class ReturnTypeEnforcer<already_AddRefed<T> >
  {

  };


  typedef typename ReturnTypeEnforcer<ReturnType>::ReturnTypeIsSafe check;
};

template <class ClassType, bool Owning>
struct nsRunnableMethodReceiver {
  ClassType *mObj;
  nsRunnableMethodReceiver(ClassType *obj) : mObj(obj) { ns_if_addref(mObj); }
 ~nsRunnableMethodReceiver() { Revoke(); }
  void Revoke() { do { if (mObj) { (mObj)->Release(); (mObj) = 0; } } while (0); }
};

template <class ClassType>
struct nsRunnableMethodReceiver<ClassType, false> {
  ClassType *mObj;
  nsRunnableMethodReceiver(ClassType *obj) : mObj(obj) {}
  void Revoke() { mObj = nullptr; }
};

template <typename Method, bool Owning> struct nsRunnableMethodTraits;

template <class C, typename R, bool Owning>
struct nsRunnableMethodTraits<R (C::*)(), Owning> {
  typedef C class_type;
  typedef R return_type;
  typedef nsRunnableMethod<C, R, Owning> base_type;
};
# 333 "../../dist/include/nsThreadUtils.h"
template <typename Method, bool Owning>
class nsRunnableMethodImpl
  : public nsRunnableMethodTraits<Method, Owning>::base_type
{
  typedef typename nsRunnableMethodTraits<Method, Owning>::class_type ClassType;
  nsRunnableMethodReceiver<ClassType, Owning> mReceiver;
  Method mMethod;

public:
  nsRunnableMethodImpl(ClassType *obj,
                       Method method)
    : mReceiver(obj)
    , mMethod(method)
  {}

  virtual __attribute__ ((visibility ("hidden"))) nsresult Run() {
    if ((__builtin_expect(!!(mReceiver.mObj), 1)))
      ((*mReceiver.mObj).*mMethod)();
    return nsresult::NS_OK;
  }

  void Revoke() {
    mReceiver.Revoke();
  }
};
# 369 "../../dist/include/nsThreadUtils.h"
template<typename PtrType, typename Method>
typename nsRunnableMethodTraits<Method, true>::base_type*
NS_NewRunnableMethod(PtrType ptr, Method method)
{
  return new nsRunnableMethodImpl<Method, true>(ptr, method);
}

template<typename PtrType, typename Method>
typename nsRunnableMethodTraits<Method, false>::base_type*
NS_NewNonOwningRunnableMethod(PtrType ptr, Method method)
{
  return new nsRunnableMethodImpl<Method, false>(ptr, method);
}
# 430 "../../dist/include/nsThreadUtils.h"
template <class T>
class nsRevocableEventPtr {
public:
  nsRevocableEventPtr()
    : mEvent(nullptr) {
  }

  ~nsRevocableEventPtr() {
    Revoke();
  }

  const nsRevocableEventPtr& operator=(T *event) {
    if (mEvent != event) {
      Revoke();
      mEvent = event;
    }
    return *this;
  }

  void Revoke() {
    if (mEvent) {
      mEvent->Revoke();
      mEvent = nullptr;
    }
  }

  void Forget() {
    mEvent = nullptr;
  }

  bool IsPending() {
    return mEvent != nullptr;
  }

  T *get() { return mEvent; }

private:

  nsRevocableEventPtr(const nsRevocableEventPtr&);
  nsRevocableEventPtr& operator=(const nsRevocableEventPtr&);

  nsRefPtr<T> mEvent;
};





class nsThreadPoolNaming
{
public:
  nsThreadPoolNaming() : mCounter(0) {}






  void SetThreadPoolName(const nsACString_internal & aPoolName,
                         nsIThread * aThread = nullptr);

private:
  volatile uint32_t mCounter;

  nsThreadPoolNaming(const nsThreadPoolNaming &) = delete;
  void operator=(const nsThreadPoolNaming &) = delete;
};







class nsAutoLowPriorityIO
{
public:
  nsAutoLowPriorityIO();
  ~nsAutoLowPriorityIO();

private:
  bool lowIOPrioritySet;



};
# 15 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2
# 1 "../../dist/include/nsICacheListener.h" 1
# 21 "../../dist/include/nsICacheListener.h"
class nsICacheEntryDescriptor;
# 31 "../../dist/include/nsICacheListener.h"
class nsICacheListener : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult OnCacheEntryAvailable(nsICacheEntryDescriptor *descriptor, nsCacheAccessMode accessGranted, nsresult status) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult OnCacheEntryDoomed(nsresult status) = 0;

};

  template <class Dummy> const nsIID nsICacheListener::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x8eadf2ed, 0x8cac, 0x4961, { 0x80, 0x25, 0x6d, 0xa6, 0xd5, 0x82, 0x7e, 0x74 }};
# 16 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2

# 1 "../../dist/system_wrappers/prthread.h" 1
       
# 2 "../../dist/system_wrappers/prthread.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 18 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2


# 1 "../../dist/include/nsTArray.h" 1
# 21 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2
# 1 "../../dist/include/nsRefPtrHashtable.h" 1
# 9 "../../dist/include/nsRefPtrHashtable.h"
# 1 "../../dist/include/nsBaseHashtable.h" 1
# 9 "../../dist/include/nsBaseHashtable.h"
# 1 "../../dist/include/nsTHashtable.h" 1
# 10 "../../dist/include/nsTHashtable.h"
# 1 "../../dist/include/pldhash.h" 1
# 11 "../../dist/include/nsTHashtable.h" 2





 PLDHashOperator
PL_DHashStubEnumRemove(PLDHashTable *table,
                       PLDHashEntryHdr *entry,
                       uint32_t ordinal,
                       void *userArg);
# 74 "../../dist/include/nsTHashtable.h"
template<class EntryType>
class nsTHashtable
{
  typedef mozilla::fallible_t fallible_t;

public:



  nsTHashtable();




  ~nsTHashtable();







  void Init(uint32_t initSize = 16)
  {
    if (!Init(initSize, fallible_t()))
      NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTHashtable.h", 99);
  }
  bool Init(const fallible_t&) __attribute__((warn_unused_result))
  { return Init(16, fallible_t()); }
  bool Init(uint32_t initSize, const fallible_t&) __attribute__((warn_unused_result));





  bool IsInitialized() const { return !!mTable.entrySize; }





  uint32_t GetGeneration() const { return mTable.generation; }




  typedef typename EntryType::KeyType KeyType;




  typedef typename EntryType::KeyTypePointer KeyTypePointer;





  uint32_t Count() const { return mTable.entryCount; }







  EntryType* GetEntry(KeyType aKey) const
  {
    do { } while(0);

    EntryType* entry =
      reinterpret_cast<EntryType*>
                      (PL_DHashTableOperate(
                            const_cast<PLDHashTable*>(&mTable),
                            EntryType::KeyToPointer(aKey),
                            PL_DHASH_LOOKUP));
    return (!((entry)->keyHash == 0)) ? entry : nullptr;
  }






  bool Contains(KeyType aKey) const
  {
    return !!GetEntry(aKey);
  }







  EntryType* PutEntry(KeyType aKey)
  {
    EntryType* e = PutEntry(aKey, fallible_t());
    if (!e)
      NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsTHashtable.h", 172);
    return e;
  }

  EntryType* PutEntry(KeyType aKey, const fallible_t&) __attribute__((warn_unused_result))
  {
    do { } while(0);

    return static_cast<EntryType*>
                      (PL_DHashTableOperate(
                            &mTable,
                            EntryType::KeyToPointer(aKey),
                            PL_DHASH_ADD));
  }





  void RemoveEntry(KeyType aKey)
  {
    do { } while(0);

    PL_DHashTableOperate(&mTable,
                         EntryType::KeyToPointer(aKey),
                         PL_DHASH_REMOVE);
  }
# 208 "../../dist/include/nsTHashtable.h"
  void RawRemoveEntry(EntryType* aEntry)
  {
    PL_DHashTableRawRemove(&mTable, aEntry);
  }
# 223 "../../dist/include/nsTHashtable.h"
  typedef PLDHashOperator (* Enumerator)(EntryType* aEntry, void* userArg);
# 232 "../../dist/include/nsTHashtable.h"
  uint32_t EnumerateEntries(Enumerator enumFunc, void* userArg)
  {
    do { } while(0);

    s_EnumArgs args = { enumFunc, userArg };
    return PL_DHashTableEnumerate(&mTable, s_EnumStub, &args);
  }




  void Clear()
  {
    do { } while(0);

    PL_DHashTableEnumerate(&mTable, PL_DHashStubEnumRemove, nullptr);
  }
# 258 "../../dist/include/nsTHashtable.h"
  typedef size_t (* SizeOfEntryExcludingThisFun)(EntryType* aEntry,
                                                 nsMallocSizeOfFun mallocSizeOf,
                                                 void *arg);
# 274 "../../dist/include/nsTHashtable.h"
  size_t SizeOfExcludingThis(SizeOfEntryExcludingThisFun sizeOfEntryExcludingThis,
                             nsMallocSizeOfFun mallocSizeOf, void *userArg = __null) const
  {
    if (!IsInitialized()) {
      return 0;
    }
    if (sizeOfEntryExcludingThis) {
      s_SizeOfArgs args = { sizeOfEntryExcludingThis, userArg };
      return PL_DHashTableSizeOfExcludingThis(&mTable, s_SizeOfStub, mallocSizeOf, &args);
    }
    return PL_DHashTableSizeOfExcludingThis(&mTable, __null, mallocSizeOf);
  }
# 302 "../../dist/include/nsTHashtable.h"
protected:
  PLDHashTable mTable;

  static const void* s_GetKey(PLDHashTable *table,
                              PLDHashEntryHdr *entry);

  static PLDHashNumber s_HashKey(PLDHashTable *table,
                                 const void *key);

  static bool s_MatchEntry(PLDHashTable *table,
                             const PLDHashEntryHdr *entry,
                             const void *key);

  static void s_CopyEntry(PLDHashTable *table,
                          const PLDHashEntryHdr *from,
                          PLDHashEntryHdr *to);

  static void s_ClearEntry(PLDHashTable *table,
                           PLDHashEntryHdr *entry);

  static bool s_InitEntry(PLDHashTable *table,
                            PLDHashEntryHdr *entry,
                            const void *key);
# 333 "../../dist/include/nsTHashtable.h"
  struct s_EnumArgs
  {
    Enumerator userFunc;
    void* userArg;
  };

  static PLDHashOperator s_EnumStub(PLDHashTable *table,
                                    PLDHashEntryHdr *entry,
                                    uint32_t number,
                                    void *arg);
# 351 "../../dist/include/nsTHashtable.h"
  struct s_SizeOfArgs
  {
    SizeOfEntryExcludingThisFun userFunc;
    void* userArg;
  };

  static size_t s_SizeOfStub(PLDHashEntryHdr *entry,
                             nsMallocSizeOfFun mallocSizeOf,
                             void *arg);

private:

  nsTHashtable(nsTHashtable<EntryType>& toCopy);


  nsTHashtable<EntryType>& operator= (nsTHashtable<EntryType>& toEqual);
};





template<class EntryType>
nsTHashtable<EntryType>::nsTHashtable()
{

  mTable.entrySize = 0;
}

template<class EntryType>
nsTHashtable<EntryType>::~nsTHashtable()
{
  if (mTable.entrySize)
    PL_DHashTableFinish(&mTable);
}

template<class EntryType>
bool
nsTHashtable<EntryType>::Init(uint32_t initSize, const fallible_t&)
{
  if (mTable.entrySize)
  {
    do { } while(0);
    return true;
  }

  static PLDHashTableOps sOps =
  {
    ::PL_DHashAllocTable,
    ::PL_DHashFreeTable,
    s_HashKey,
    s_MatchEntry,
    ::PL_DHashMoveEntryStub,
    s_ClearEntry,
    ::PL_DHashFinalizeStub,
    s_InitEntry
  };

  if (!EntryType::ALLOW_MEMMOVE)
  {
    sOps.moveEntry = s_CopyEntry;
  }

  if (!PL_DHashTableInit(&mTable, &sOps, nullptr, sizeof(EntryType), initSize))
  {

    mTable.entrySize = 0;
    return false;
  }

  return true;
}



template<class EntryType>
PLDHashNumber
nsTHashtable<EntryType>::s_HashKey(PLDHashTable *table,
                                   const void *key)
{
  return EntryType::HashKey(reinterpret_cast<const KeyTypePointer>(key));
}

template<class EntryType>
bool
nsTHashtable<EntryType>::s_MatchEntry(PLDHashTable *table,
                                      const PLDHashEntryHdr *entry,
                                      const void *key)
{
  return ((const EntryType*) entry)->KeyEquals(
    reinterpret_cast<const KeyTypePointer>(key));
}

template<class EntryType>
void
nsTHashtable<EntryType>::s_CopyEntry(PLDHashTable *table,
                                     const PLDHashEntryHdr *from,
                                     PLDHashEntryHdr *to)
{
  EntryType* fromEntry =
    const_cast<EntryType*>(reinterpret_cast<const EntryType*>(from));

  new(to) EntryType(*fromEntry);

  fromEntry->~EntryType();
}

template<class EntryType>
void
nsTHashtable<EntryType>::s_ClearEntry(PLDHashTable *table,
                                      PLDHashEntryHdr *entry)
{
  reinterpret_cast<EntryType*>(entry)->~EntryType();
}

template<class EntryType>
bool
nsTHashtable<EntryType>::s_InitEntry(PLDHashTable *table,
                                     PLDHashEntryHdr *entry,
                                     const void *key)
{
  new(entry) EntryType(reinterpret_cast<KeyTypePointer>(key));
  return true;
}

template<class EntryType>
PLDHashOperator
nsTHashtable<EntryType>::s_EnumStub(PLDHashTable *table,
                                    PLDHashEntryHdr *entry,
                                    uint32_t number,
                                    void *arg)
{

  return (* reinterpret_cast<s_EnumArgs*>(arg)->userFunc)(
    reinterpret_cast<EntryType*>(entry),
    reinterpret_cast<s_EnumArgs*>(arg)->userArg);
}

template<class EntryType>
size_t
nsTHashtable<EntryType>::s_SizeOfStub(PLDHashEntryHdr *entry,
                                      nsMallocSizeOfFun mallocSizeOf,
                                      void *arg)
{

  return (* reinterpret_cast<s_SizeOfArgs*>(arg)->userFunc)(
    reinterpret_cast<EntryType*>(entry),
    mallocSizeOf,
    reinterpret_cast<s_SizeOfArgs*>(arg)->userArg);
}
# 10 "../../dist/include/nsBaseHashtable.h" 2
# 1 "../../dist/system_wrappers/prlock.h" 1
       
# 2 "../../dist/system_wrappers/prlock.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prlock.h" 1 3
# 4 "../../dist/system_wrappers/prlock.h" 2 3
#pragma GCC visibility pop
# 11 "../../dist/include/nsBaseHashtable.h" 2


template<class KeyClass,class DataType,class UserDataType>
class nsBaseHashtable;






template<class KeyClass,class DataType>
class nsBaseHashtableET : public KeyClass
{
public:
  DataType mData;
  friend class nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >;

private:
  typedef typename KeyClass::KeyType KeyType;
  typedef typename KeyClass::KeyTypePointer KeyTypePointer;

  nsBaseHashtableET(KeyTypePointer aKey);
  nsBaseHashtableET(nsBaseHashtableET<KeyClass,DataType>& toCopy);
  ~nsBaseHashtableET();
};
# 49 "../../dist/include/nsBaseHashtable.h"
template<class KeyClass,class DataType,class UserDataType>
class nsBaseHashtable :
  protected nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >
{
  typedef mozilla::fallible_t fallible_t;

public:
  typedef typename KeyClass::KeyType KeyType;
  typedef nsBaseHashtableET<KeyClass,DataType> EntryType;
# 68 "../../dist/include/nsBaseHashtable.h"
  void Init(uint32_t initSize = 16)
  { nsTHashtable<EntryType>::Init(initSize); }

  bool Init(const fallible_t&) __attribute__((warn_unused_result))
  { return Init(16, fallible_t()); }

  bool Init(uint32_t initSize, const fallible_t&) __attribute__((warn_unused_result))
  { return nsTHashtable<EntryType>::Init(initSize, fallible_t()); }
# 84 "../../dist/include/nsBaseHashtable.h"
  bool IsInitialized() const { return !!this->mTable.entrySize; }





  uint32_t Count() const
  { return nsTHashtable<EntryType>::Count(); }
# 102 "../../dist/include/nsBaseHashtable.h"
  bool Get(KeyType aKey, UserDataType* pData) const
  {
    EntryType* ent = this->GetEntry(aKey);

    if (!ent)
      return false;

    if (pData)
      *pData = ent->mData;

    return true;
  }
# 124 "../../dist/include/nsBaseHashtable.h"
  UserDataType Get(KeyType aKey) const
  {
    EntryType* ent = this->GetEntry(aKey);
    if (!ent)
      return 0;

    return ent->mData;
  }







  void Put(KeyType aKey, const UserDataType& aData)
  {
    if (!Put(aKey, aData, fallible_t()))
      NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsBaseHashtable.h", 142);
  }

  bool Put(KeyType aKey, const UserDataType& aData, const fallible_t&) __attribute__((warn_unused_result))
  {
    EntryType* ent = this->PutEntry(aKey);

    if (!ent)
      return false;

    ent->mData = aData;

    return true;
  }





  void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
# 172 "../../dist/include/nsBaseHashtable.h"
  typedef PLDHashOperator
    (* EnumReadFunction)(KeyType aKey,
                         UserDataType aData,
                         void* userArg);






  uint32_t EnumerateRead(EnumReadFunction enumFunc, void* userArg) const
  {
    do { } while(0)
                                                                 ;

    s_EnumReadArgs enumData = { enumFunc, userArg };
    return PL_DHashTableEnumerate(const_cast<PLDHashTable*>(&this->mTable),
                                  s_EnumReadStub,
                                  &enumData);
  }
# 204 "../../dist/include/nsBaseHashtable.h"
  typedef PLDHashOperator
    (* EnumFunction)(KeyType aKey,
                     DataType& aData,
                     void* userArg);







  uint32_t Enumerate(EnumFunction enumFunc, void* userArg)
  {
    do { } while(0)
                                                                 ;

    s_EnumArgs enumData = { enumFunc, userArg };
    return PL_DHashTableEnumerate(&this->mTable,
                                  s_EnumStub,
                                  &enumData);
  }




  void Clear() { nsTHashtable<EntryType>::Clear(); }
# 240 "../../dist/include/nsBaseHashtable.h"
  typedef size_t
    (* SizeOfEntryExcludingThisFun)(KeyType aKey,
                                    const DataType &aData,
                                    nsMallocSizeOfFun mallocSizeOf,
                                    void* userArg);
# 258 "../../dist/include/nsBaseHashtable.h"
  size_t SizeOfIncludingThis(SizeOfEntryExcludingThisFun sizeOfEntryExcludingThis,
                             nsMallocSizeOfFun mallocSizeOf, void *userArg = nullptr)
  {
    return mallocSizeOf(this) + this->SizeOfExcludingThis(sizeOfEntryExcludingThis,
                                                          mallocSizeOf, userArg);
  }
# 277 "../../dist/include/nsBaseHashtable.h"
  size_t SizeOfExcludingThis(SizeOfEntryExcludingThisFun sizeOfEntryExcludingThis,
                             nsMallocSizeOfFun mallocSizeOf, void *userArg = nullptr) const
  {
    if (!IsInitialized()) {
      return 0;
    }
    if (sizeOfEntryExcludingThis) {
      s_SizeOfArgs args = { sizeOfEntryExcludingThis, userArg };
      return PL_DHashTableSizeOfExcludingThis(&this->mTable, s_SizeOfStub,
                                              mallocSizeOf, &args);
    }
    return PL_DHashTableSizeOfExcludingThis(&this->mTable, __null, mallocSizeOf);
  }

protected:





  struct s_EnumReadArgs
  {
    EnumReadFunction func;
    void* userArg;
  };

  static PLDHashOperator s_EnumReadStub(PLDHashTable *table,
                                        PLDHashEntryHdr *hdr,
                                        uint32_t number,
                                        void *arg);

  struct s_EnumArgs
  {
    EnumFunction func;
    void* userArg;
  };

  static PLDHashOperator s_EnumStub(PLDHashTable *table,
                                    PLDHashEntryHdr *hdr,
                                    uint32_t number,
                                    void *arg);

  struct s_SizeOfArgs
  {
    SizeOfEntryExcludingThisFun func;
    void* userArg;
  };

  static size_t s_SizeOfStub(PLDHashEntryHdr *entry,
                             nsMallocSizeOfFun mallocSizeOf,
                             void *arg);
};





template<class KeyClass,class DataType,class UserDataType>
class nsBaseHashtableMT :
  protected nsBaseHashtable<KeyClass,DataType,UserDataType>
{
public:
  typedef typename
    nsBaseHashtable<KeyClass,DataType,UserDataType>::EntryType EntryType;
  typedef typename
    nsBaseHashtable<KeyClass,DataType,UserDataType>::KeyType KeyType;
  typedef typename
    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumFunction EnumFunction;
  typedef typename
    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumReadFunction EnumReadFunction;

  nsBaseHashtableMT() : mLock(nullptr) { }
  ~nsBaseHashtableMT();

  void Init(uint32_t initSize = 16);
  bool IsInitialized() const { return mLock != nullptr; }
  uint32_t Count() const;
  bool Get(KeyType aKey, UserDataType* pData) const;
  void Put(KeyType aKey, UserDataType aData);
  void Remove(KeyType aKey);

  uint32_t EnumerateRead(EnumReadFunction enumFunc, void* userArg) const;
  uint32_t Enumerate(EnumFunction enumFunc, void* userArg);
  void Clear();

protected:
  PRLock* mLock;
};






template<class KeyClass,class DataType>
nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET(KeyTypePointer aKey) :
  KeyClass(aKey)
{ }

template<class KeyClass,class DataType>
nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET
  (nsBaseHashtableET<KeyClass,DataType>& toCopy) :
  KeyClass(toCopy),
  mData(toCopy.mData)
{ }

template<class KeyClass,class DataType>
nsBaseHashtableET<KeyClass,DataType>::~nsBaseHashtableET()
{ }






template<class KeyClass,class DataType,class UserDataType>
PLDHashOperator
nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumReadStub
  (PLDHashTable *table, PLDHashEntryHdr *hdr, uint32_t number, void* arg)
{
  EntryType* ent = static_cast<EntryType*>(hdr);
  s_EnumReadArgs* eargs = (s_EnumReadArgs*) arg;

  PLDHashOperator res = (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);

  do { } while(0)
                                                                             ;

  if (res & PL_DHASH_STOP)
    return PL_DHASH_STOP;

  return PL_DHASH_NEXT;
}

template<class KeyClass,class DataType,class UserDataType>
PLDHashOperator
nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumStub
  (PLDHashTable *table, PLDHashEntryHdr *hdr, uint32_t number, void* arg)
{
  EntryType* ent = static_cast<EntryType*>(hdr);
  s_EnumArgs* eargs = (s_EnumArgs*) arg;

  return (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
}

template<class KeyClass,class DataType,class UserDataType>
size_t
nsBaseHashtable<KeyClass,DataType,UserDataType>::s_SizeOfStub
  (PLDHashEntryHdr *hdr, nsMallocSizeOfFun mallocSizeOf, void *arg)
{
  EntryType* ent = static_cast<EntryType*>(hdr);
  s_SizeOfArgs* eargs = static_cast<s_SizeOfArgs*>(arg);

  return (eargs->func)(ent->GetKey(), ent->mData, mallocSizeOf, eargs->userArg);
}





template<class KeyClass,class DataType,class UserDataType>
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::~nsBaseHashtableMT()
{
  if (this->mLock)
    PR_DestroyLock(this->mLock);
}

template<class KeyClass,class DataType,class UserDataType>
void
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Init(uint32_t initSize)
{
  if (!nsTHashtable<EntryType>::IsInitialized())
    nsTHashtable<EntryType>::Init(initSize);

  this->mLock = PR_NewLock();
  if (!this->mLock)
    NS_DebugBreak(NS_DEBUG_ABORT, "OOM", nullptr, "../../dist/include/nsBaseHashtable.h", 453);
}

template<class KeyClass,class DataType,class UserDataType>
uint32_t
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Count() const
{
  PR_Lock(this->mLock);
  uint32_t count = nsTHashtable<EntryType>::Count();
  PR_Unlock(this->mLock);

  return count;
}

template<class KeyClass,class DataType,class UserDataType>
bool
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Get(KeyType aKey,
                                                           UserDataType* pData) const
{
  PR_Lock(this->mLock);
  bool res =
    nsBaseHashtable<KeyClass,DataType,UserDataType>::Get(aKey, pData);
  PR_Unlock(this->mLock);

  return res;
}

template<class KeyClass,class DataType,class UserDataType>
void
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Put(KeyType aKey,
                                                           UserDataType aData)
{
  PR_Lock(this->mLock);
  nsBaseHashtable<KeyClass,DataType,UserDataType>::Put(aKey, aData);
  PR_Unlock(this->mLock);
}

template<class KeyClass,class DataType,class UserDataType>
void
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Remove(KeyType aKey)
{
  PR_Lock(this->mLock);
  nsBaseHashtable<KeyClass,DataType,UserDataType>::Remove(aKey);
  PR_Unlock(this->mLock);
}

template<class KeyClass,class DataType,class UserDataType>
uint32_t
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::EnumerateRead
  (EnumReadFunction fEnumCall, void* userArg) const
{
  PR_Lock(this->mLock);
  uint32_t count =
    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumerateRead(fEnumCall, userArg);
  PR_Unlock(this->mLock);

  return count;
}

template<class KeyClass,class DataType,class UserDataType>
uint32_t
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Enumerate
  (EnumFunction fEnumCall, void* userArg)
{
  PR_Lock(this->mLock);
  uint32_t count =
    nsBaseHashtable<KeyClass,DataType,UserDataType>::Enumerate(fEnumCall, userArg);
  PR_Unlock(this->mLock);

  return count;
}

template<class KeyClass,class DataType,class UserDataType>
void
nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Clear()
{
  PR_Lock(this->mLock);
  nsBaseHashtable<KeyClass,DataType,UserDataType>::Clear();
  PR_Unlock(this->mLock);
}
# 10 "../../dist/include/nsRefPtrHashtable.h" 2
# 1 "../../dist/include/nsHashKeys.h" 1
# 11 "../../dist/include/nsHashKeys.h"
# 1 "../../dist/include/nsIHashable.h" 1
# 25 "../../dist/include/nsIHashable.h"
class nsIHashable : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Equals(nsIHashable *aOther, bool *_retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetHashCode(uint32_t *aHashCode) = 0;

};

  template <class Dummy> const nsIID nsIHashable::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x17e595fa, 0xb57a, 0x4933, { 0xbd, 0x0f, 0xb1, 0x81, 0x2e, 0x8a, 0xb1, 0x88 }};
# 12 "../../dist/include/nsHashKeys.h" 2






# 1 "../../dist/include/nsCRTGlue.h" 1
# 18 "../../dist/include/nsCRTGlue.h"
 const char*
NS_strspnp(const char *delims, const char *str);
# 37 "../../dist/include/nsCRTGlue.h"
 char*
NS_strtok(const char *delims, char **str);




 uint32_t
NS_strlen(const PRUnichar *aString);




 int
NS_strcmp(const PRUnichar *a, const PRUnichar *b);




 PRUnichar*
NS_strdup(const PRUnichar *aString);




 char*
NS_strdup(const char *aString);





 PRUnichar*
NS_strndup(const PRUnichar *aString, uint32_t aLen);





class nsLowerUpperUtils {
public:
  static const unsigned char kLower2Upper[256];
  static const unsigned char kUpper2Lower[256];
};

inline char NS_ToUpper(char aChar)
{
  return (char)nsLowerUpperUtils::kLower2Upper[(unsigned char)aChar];
}

inline char NS_ToLower(char aChar)
{
  return (char)nsLowerUpperUtils::kUpper2Lower[(unsigned char)aChar];
}

 bool NS_IsUpper(char aChar);
 bool NS_IsLower(char aChar);

 bool NS_IsAscii(PRUnichar aChar);
 bool NS_IsAscii(const PRUnichar* aString);
 bool NS_IsAsciiAlpha(PRUnichar aChar);
 bool NS_IsAsciiDigit(PRUnichar aChar);
 bool NS_IsAsciiWhitespace(PRUnichar aChar);
 bool NS_IsAscii(const char* aString);
 bool NS_IsAscii(const char* aString, uint32_t aLength);


 void NS_MakeRandomString(char *buf, int32_t bufLen);
# 19 "../../dist/include/nsHashKeys.h" 2
# 1 "../../dist/include/nsUnicharUtils.h" 1
# 19 "../../dist/include/nsUnicharUtils.h"
void ToLowerCase(nsAString_internal&);
void ToUpperCase(nsAString_internal&);

void ToLowerCase(const nsAString_internal& aSource, nsAString_internal& aDest);
void ToUpperCase(const nsAString_internal& aSource, nsAString_internal& aDest);

uint32_t ToLowerCase(uint32_t);
uint32_t ToUpperCase(uint32_t);
uint32_t ToTitleCase(uint32_t);

void ToLowerCase(const PRUnichar*, PRUnichar*, uint32_t);
void ToUpperCase(const PRUnichar*, PRUnichar*, uint32_t);

inline bool IsUpperCase(uint32_t c) {
  return ToLowerCase(c) != c;
}

inline bool IsLowerCase(uint32_t c) {
  return ToUpperCase(c) != c;
}



class nsCaseInsensitiveStringComparator : public nsStringComparator
{
public:
  virtual int32_t operator() (const PRUnichar*,
                              const PRUnichar*,
                              uint32_t,
                              uint32_t) const;
};

class nsCaseInsensitiveUTF8StringComparator : public nsCStringComparator
{
public:
  virtual int32_t operator() (const char*,
                              const char*,
                              uint32_t,
                              uint32_t) const;
};

class nsCaseInsensitiveStringArrayComparator
{
public:
  template<class A, class B>
  bool Equals(const A& a, const B& b) const {
    return a.Equals(b, nsCaseInsensitiveStringComparator());
  }
};

class nsASCIICaseInsensitiveStringComparator : public nsStringComparator
{
public:
  nsASCIICaseInsensitiveStringComparator() {}
  virtual int operator() (const PRUnichar*,
                          const PRUnichar*,
                          uint32_t,
                          uint32_t) const;
};

inline bool
CaseInsensitiveFindInReadable(const nsAString_internal& aPattern,
                              nsAString_internal::const_iterator& aSearchStart,
                              nsAString_internal::const_iterator& aSearchEnd)
{
  return FindInReadable(aPattern, aSearchStart, aSearchEnd,
                        nsCaseInsensitiveStringComparator());
}

inline bool
CaseInsensitiveFindInReadable(const nsAString_internal& aPattern,
                              const nsAString_internal& aHay)
{
  nsAString_internal::const_iterator searchBegin, searchEnd;
  return FindInReadable(aPattern, aHay.BeginReading(searchBegin),
                        aHay.EndReading(searchEnd),
                        nsCaseInsensitiveStringComparator());
}



int32_t
CaseInsensitiveCompare(const PRUnichar *a, const PRUnichar *b, uint32_t len);

int32_t
CaseInsensitiveCompare(const char* aLeft, const char* aRight,
                       uint32_t aLeftBytes, uint32_t aRightBytes);
# 126 "../../dist/include/nsUnicharUtils.h"
bool
CaseInsensitiveUTF8CharsEqual(const char* aLeft, const char* aRight,
                              const char* aLeftEnd, const char* aRightEnd,
                              const char** aLeftNext, const char** aRightNext,
                              bool* aErr);

namespace mozilla {
# 142 "../../dist/include/nsUnicharUtils.h"
uint32_t
HashUTF8AsUTF16(const char* aUTF8, uint32_t aLength, bool* aErr);

}
# 20 "../../dist/include/nsHashKeys.h" 2

# 1 "../../dist/system_wrappers/stdlib.h" 1
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 22 "../../dist/include/nsHashKeys.h" 2
# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "../../dist/include/nsHashKeys.h" 2

# 1 "../../dist/include/mozilla/HashFunctions.h" 1
# 54 "../../dist/include/mozilla/HashFunctions.h"
namespace mozilla {




static const uint32_t GoldenRatioU32 = 0x9E3779B9U;

inline uint32_t
RotateBitsLeft32(uint32_t value, uint8_t bits)
{
  do { } while(0);
  return (value << bits) | (value >> (32 - bits));
}

namespace detail {

inline uint32_t
AddU32ToHash(uint32_t hash, uint32_t value)
{
# 112 "../../dist/include/mozilla/HashFunctions.h"
  return GoldenRatioU32 * (RotateBitsLeft32(hash, 5) ^ value);
}




template<size_t PtrSize>
inline uint32_t
AddUintptrToHash(uint32_t hash, uintptr_t value);

template<>
inline uint32_t
AddUintptrToHash<4>(uint32_t hash, uintptr_t value)
{
  return AddU32ToHash(hash, static_cast<uint32_t>(value));
}

template<>
inline uint32_t
AddUintptrToHash<8>(uint32_t hash, uintptr_t value)
{







  uint32_t v1 = static_cast<uint32_t>(value);
  uint32_t v2 = static_cast<uint32_t>(static_cast<uint64_t>(value) >> 32);
  return AddU32ToHash(AddU32ToHash(hash, v1), v2);
}

}
# 154 "../../dist/include/mozilla/HashFunctions.h"
template<typename A>
__attribute__ ((warn_unused_result))
inline uint32_t
AddToHash(uint32_t hash, A a)
{




  return detail::AddU32ToHash(hash, a);
}

template<typename A>
__attribute__ ((warn_unused_result))
inline uint32_t
AddToHash(uint32_t hash, A* a)
{





  static_assert((sizeof(a) == sizeof(uintptr_t)), "Strange pointer!")
                                       ;

  return detail::AddUintptrToHash<sizeof(uintptr_t)>(hash, uintptr_t(a));
}

template<>
__attribute__ ((warn_unused_result))
inline uint32_t
AddToHash(uint32_t hash, uintptr_t a)
{
  return detail::AddUintptrToHash<sizeof(uintptr_t)>(hash, a);
}

template<typename A, typename B>
__attribute__ ((warn_unused_result))
uint32_t
AddToHash(uint32_t hash, A a, B b)
{
  return AddToHash(AddToHash(hash, a), b);
}

template<typename A, typename B, typename C>
__attribute__ ((warn_unused_result))
uint32_t
AddToHash(uint32_t hash, A a, B b, C c)
{
  return AddToHash(AddToHash(hash, a, b), c);
}

template<typename A, typename B, typename C, typename D>
__attribute__ ((warn_unused_result))
uint32_t
AddToHash(uint32_t hash, A a, B b, C c, D d)
{
  return AddToHash(AddToHash(hash, a, b, c), d);
}

template<typename A, typename B, typename C, typename D, typename E>
__attribute__ ((warn_unused_result))
uint32_t
AddToHash(uint32_t hash, A a, B b, C c, D d, E e)
{
  return AddToHash(AddToHash(hash, a, b, c, d), e);
}
# 229 "../../dist/include/mozilla/HashFunctions.h"
template<typename A>
__attribute__ ((warn_unused_result))
inline uint32_t
HashGeneric(A a)
{
  return AddToHash(0, a);
}

template<typename A, typename B>
__attribute__ ((warn_unused_result))
inline uint32_t
HashGeneric(A a, B b)
{
  return AddToHash(0, a, b);
}

template<typename A, typename B, typename C>
__attribute__ ((warn_unused_result))
inline uint32_t
HashGeneric(A a, B b, C c)
{
  return AddToHash(0, a, b, c);
}

template<typename A, typename B, typename C, typename D>
__attribute__ ((warn_unused_result))
inline uint32_t
HashGeneric(A a, B b, C c, D d)
{
  return AddToHash(0, a, b, c, d);
}

template<typename A, typename B, typename C, typename D, typename E>
__attribute__ ((warn_unused_result))
inline uint32_t
HashGeneric(A a, B b, C c, D d, E e)
{
  return AddToHash(0, a, b, c, d, e);
}

namespace detail {

template<typename T>
uint32_t
HashUntilZero(const T* str)
{
  uint32_t hash = 0;
  for (T c; (c = *str); str++)
    hash = AddToHash(hash, c);
  return hash;
}

template<typename T>
uint32_t
HashKnownLength(const T* str, size_t length)
{
  uint32_t hash = 0;
  for (size_t i = 0; i < length; i++)
    hash = AddToHash(hash, str[i]);
  return hash;
}

}







__attribute__ ((warn_unused_result))
inline uint32_t
HashString(const char* str)
{
  return detail::HashUntilZero(str);
}

__attribute__ ((warn_unused_result))
inline uint32_t
HashString(const char* str, size_t length)
{
  return detail::HashKnownLength(str, length);
}

__attribute__ ((warn_unused_result))
inline uint32_t
HashString(const uint16_t* str)
{
  return detail::HashUntilZero(str);
}

__attribute__ ((warn_unused_result))
inline uint32_t
HashString(const uint16_t* str, size_t length)
{
  return detail::HashKnownLength(str, length);
}
# 353 "../../dist/include/mozilla/HashFunctions.h"
__attribute__ ((warn_unused_result))
extern __attribute__((weak)) __attribute__((visibility("default"))) uint32_t
HashBytes(const void* bytes, size_t length);

}
# 25 "../../dist/include/nsHashKeys.h" 2

namespace mozilla {



inline uint32_t
HashString(const nsAString_internal& aStr)
{
  return HashString(aStr.BeginReading(), aStr.Length());
}

inline uint32_t
HashString(const nsACString_internal& aStr)
{
  return HashString(aStr.BeginReading(), aStr.Length());
}

}
# 71 "../../dist/include/nsHashKeys.h"
class nsStringHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsAString_internal& KeyType;
  typedef const nsAString_internal* KeyTypePointer;

  nsStringHashKey(KeyTypePointer aStr) : mStr(*aStr) { }
  nsStringHashKey(const nsStringHashKey& toCopy) : mStr(toCopy.mStr) { }
  ~nsStringHashKey() { }

  KeyType GetKey() const { return mStr; }
  bool KeyEquals(const KeyTypePointer aKey) const
  {
    return mStr.Equals(*aKey);
  }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(const KeyTypePointer aKey)
  {
    return mozilla::HashString(*aKey);
  }
  enum { ALLOW_MEMMOVE = true };

private:
  const nsString mStr;
};
# 108 "../../dist/include/nsHashKeys.h"
class nsStringCaseInsensitiveHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsAString_internal& KeyType;
  typedef const nsAString_internal* KeyTypePointer;

  nsStringCaseInsensitiveHashKey(KeyTypePointer aStr) : mStr(*aStr) { }
  nsStringCaseInsensitiveHashKey(const nsStringCaseInsensitiveHashKey& toCopy) : mStr(toCopy.mStr) { }
  ~nsStringCaseInsensitiveHashKey() { }

  KeyType GetKey() const { return mStr; }
  bool KeyEquals(const KeyTypePointer aKey) const
  {
    return mStr.Equals(*aKey, nsCaseInsensitiveStringComparator());
  }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(const KeyTypePointer aKey)
  {
      nsAutoString tmKey(*aKey);
      ToLowerCase(tmKey);
      return mozilla::HashString(tmKey);
  }
  enum { ALLOW_MEMMOVE = true };

private:
  const nsString mStr;
};
# 144 "../../dist/include/nsHashKeys.h"
class nsCStringHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsACString_internal& KeyType;
  typedef const nsACString_internal* KeyTypePointer;

  nsCStringHashKey(const nsACString_internal* aStr) : mStr(*aStr) { }
  nsCStringHashKey(const nsCStringHashKey& toCopy) : mStr(toCopy.mStr) { }
  ~nsCStringHashKey() { }

  KeyType GetKey() const { return mStr; }

  bool KeyEquals(KeyTypePointer aKey) const { return mStr.Equals(*aKey); }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return mozilla::HashString(*aKey);
  }
  enum { ALLOW_MEMMOVE = true };

private:
  const nsCString mStr;
};






class nsUint32HashKey : public PLDHashEntryHdr
{
public:
  typedef const uint32_t& KeyType;
  typedef const uint32_t* KeyTypePointer;

  nsUint32HashKey(KeyTypePointer aKey) : mValue(*aKey) { }
  nsUint32HashKey(const nsUint32HashKey& toCopy) : mValue(toCopy.mValue) { }
  ~nsUint32HashKey() { }

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return *aKey; }
  enum { ALLOW_MEMMOVE = true };

private:
  const uint32_t mValue;
};






class nsUint64HashKey : public PLDHashEntryHdr
{
public:
  typedef const uint64_t& KeyType;
  typedef const uint64_t* KeyTypePointer;

  nsUint64HashKey(KeyTypePointer aKey) : mValue(*aKey) { }
  nsUint64HashKey(const nsUint64HashKey& toCopy) : mValue(toCopy.mValue) { }
  ~nsUint64HashKey() { }

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return PLDHashNumber(*aKey); }
  enum { ALLOW_MEMMOVE = true };

private:
  const uint64_t mValue;
};






class nsFloatHashKey : public PLDHashEntryHdr
{
public:
  typedef const float& KeyType;
  typedef const float* KeyTypePointer;

  nsFloatHashKey(KeyTypePointer aKey) : mValue(*aKey) { }
  nsFloatHashKey(const nsFloatHashKey& toCopy) : mValue(toCopy.mValue) { }
  ~nsFloatHashKey() { }

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return *reinterpret_cast<const uint32_t*>(aKey); }
  enum { ALLOW_MEMMOVE = true };

private:
  const float mValue;
};






class nsISupportsHashKey : public PLDHashEntryHdr
{
public:
  typedef nsISupports* KeyType;
  typedef const nsISupports* KeyTypePointer;

  nsISupportsHashKey(const nsISupports* key) :
    mSupports(const_cast<nsISupports*>(key)) { }
  nsISupportsHashKey(const nsISupportsHashKey& toCopy) :
    mSupports(toCopy.mSupports) { }
  ~nsISupportsHashKey() { }

  KeyType GetKey() const { return mSupports; }

  bool KeyEquals(KeyTypePointer aKey) const { return aKey == mSupports; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return ((int32_t) (intptr_t) (aKey)) >>2;
  }
  enum { ALLOW_MEMMOVE = true };

private:
  nsCOMPtr<nsISupports> mSupports;
};






template<class T>
class nsRefPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef T* KeyType;
  typedef const T* KeyTypePointer;

  nsRefPtrHashKey(const T* key) :
    mKey(const_cast<T*>(key)) { }
  nsRefPtrHashKey(const nsRefPtrHashKey& toCopy) :
    mKey(toCopy.mKey) { }
  ~nsRefPtrHashKey() { }

  KeyType GetKey() const { return mKey; }

  bool KeyEquals(KeyTypePointer aKey) const { return aKey == mKey; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {
    return ((int32_t) (intptr_t) (aKey)) >>2;
  }
  enum { ALLOW_MEMMOVE = true };

private:
  nsRefPtr<T> mKey;
};






template<class T>
class nsPtrHashKey : public PLDHashEntryHdr
{
 public:
  typedef T *KeyType;
  typedef const T *KeyTypePointer;

  nsPtrHashKey(const T *key) : mKey(const_cast<T*>(key)) {}
  nsPtrHashKey(const nsPtrHashKey<T> &toCopy) : mKey(toCopy.mKey) {}
  ~nsPtrHashKey() {}

  KeyType GetKey() const { return mKey; }

  bool KeyEquals(KeyTypePointer key) const { return key == mKey; }

  static KeyTypePointer KeyToPointer(KeyType key) { return key; }
  static PLDHashNumber HashKey(KeyTypePointer key)
  {
    return ((int32_t) (intptr_t) (key)) >> 2;
  }
  enum { ALLOW_MEMMOVE = true };

 protected:
  T *mKey;
};
# 351 "../../dist/include/nsHashKeys.h"
template<class T>
class nsClearingPtrHashKey : public nsPtrHashKey<T>
{
 public:
  nsClearingPtrHashKey(const T *key) : nsPtrHashKey<T>(key) {}
  nsClearingPtrHashKey(const nsClearingPtrHashKey<T> &toCopy) :
    nsPtrHashKey<T>(toCopy) {}
  ~nsClearingPtrHashKey() { nsPtrHashKey<T>::mKey = nullptr; }
};

typedef nsPtrHashKey<const void> nsVoidPtrHashKey;
typedef nsClearingPtrHashKey<const void> nsClearingVoidPtrHashKey;






class nsIDHashKey : public PLDHashEntryHdr
{
public:
  typedef const nsID& KeyType;
  typedef const nsID* KeyTypePointer;

  nsIDHashKey(const nsID* inID) : mID(*inID) { }
  nsIDHashKey(const nsIDHashKey& toCopy) : mID(toCopy.mID) { }
  ~nsIDHashKey() { }

  KeyType GetKey() const { return mID; }

  bool KeyEquals(KeyTypePointer aKey) const { return aKey->Equals(mID); }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey)
  {

    return mozilla::HashBytes(aKey, sizeof(KeyType));
  }

  enum { ALLOW_MEMMOVE = true };

private:
  const nsID mID;
};
# 406 "../../dist/include/nsHashKeys.h"
class nsDepCharHashKey : public PLDHashEntryHdr
{
public:
  typedef const char* KeyType;
  typedef const char* KeyTypePointer;

  nsDepCharHashKey(const char* aKey) { mKey = aKey; }
  nsDepCharHashKey(const nsDepCharHashKey& toCopy) { mKey = toCopy.mKey; }
  ~nsDepCharHashKey() { }

  const char* GetKey() const { return mKey; }
  bool KeyEquals(const char* aKey) const
  {
    return !strcmp(mKey, aKey);
  }

  static const char* KeyToPointer(const char* aKey) { return aKey; }
  static PLDHashNumber HashKey(const char* aKey) { return mozilla::HashString(aKey); }
  enum { ALLOW_MEMMOVE = true };

private:
  const char* mKey;
};






class nsCharPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef const char* KeyType;
  typedef const char* KeyTypePointer;

  nsCharPtrHashKey(const char* aKey) : mKey(moz_strdup(aKey)) { }
  nsCharPtrHashKey(const nsCharPtrHashKey& toCopy) : mKey(moz_strdup(toCopy.mKey)) { }
  ~nsCharPtrHashKey() { if (mKey) moz_free(const_cast<char *>(mKey)); }

  const char* GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const
  {
    return !strcmp(mKey, aKey);
  }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return mozilla::HashString(aKey); }

  enum { ALLOW_MEMMOVE = true };

private:
  const char* mKey;
};






class nsUnicharPtrHashKey : public PLDHashEntryHdr
{
public:
  typedef const PRUnichar* KeyType;
  typedef const PRUnichar* KeyTypePointer;

  nsUnicharPtrHashKey(const PRUnichar* aKey) : mKey(NS_strdup(aKey)) { }
  nsUnicharPtrHashKey(const nsUnicharPtrHashKey& toCopy) : mKey(NS_strdup(toCopy.mKey)) { }
  ~nsUnicharPtrHashKey() { if (mKey) NS_Free(const_cast<PRUnichar *>(mKey)); }

  const PRUnichar* GetKey() const { return mKey; }
  bool KeyEquals(KeyTypePointer aKey) const
  {
    return !NS_strcmp(mKey, aKey);
  }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) { return mozilla::HashString(aKey); }

  enum { ALLOW_MEMMOVE = true };

private:
  const PRUnichar* mKey;
};




class nsHashableHashKey : public PLDHashEntryHdr
{
public:
    typedef nsIHashable* KeyType;
    typedef const nsIHashable* KeyTypePointer;

    nsHashableHashKey(const nsIHashable* aKey) :
        mKey(const_cast<nsIHashable*>(aKey)) { }
    nsHashableHashKey(const nsHashableHashKey& toCopy) :
        mKey(toCopy.mKey) { }
    ~nsHashableHashKey() { }

    nsIHashable* GetKey() const { return mKey; }

    bool KeyEquals(const nsIHashable* aKey) const {
        bool eq;
        if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(mKey->Equals(const_cast<nsIHashable*>(aKey), &eq))), 1)))) {
            return eq;
        }
        return false;
    }

    static const nsIHashable* KeyToPointer(nsIHashable* aKey) { return aKey; }
    static PLDHashNumber HashKey(const nsIHashable* aKey) {
        uint32_t code = 8888;



        const_cast<nsIHashable*>(aKey)->GetHashCode(&code);
        do { } while(0);
        return code;
    }

    enum { ALLOW_MEMMOVE = true };

private:
    nsCOMPtr<nsIHashable> mKey;
};
# 11 "../../dist/include/nsRefPtrHashtable.h" 2
# 21 "../../dist/include/nsRefPtrHashtable.h"
template<class KeyClass, class RefPtr>
class nsRefPtrHashtable :
  public nsBaseHashtable< KeyClass, nsRefPtr<RefPtr> , RefPtr* >
{
public:
  typedef typename KeyClass::KeyType KeyType;
  typedef RefPtr* UserDataType;
  typedef nsBaseHashtable< KeyClass, nsRefPtr<RefPtr> , RefPtr* > base_type;






  bool Get(KeyType aKey, UserDataType* pData) const;







  RefPtr* GetWeak(KeyType aKey, bool* aFound = nullptr) const;
};







template<class KeyClass, class RefPtr>
class nsRefPtrHashtableMT :
  public nsBaseHashtableMT< KeyClass, nsRefPtr<RefPtr> , RefPtr* >
{
public:
  typedef typename KeyClass::KeyType KeyType;
  typedef RefPtr* UserDataType;
  typedef nsBaseHashtableMT< KeyClass, nsRefPtr<RefPtr> , RefPtr* > base_type;






  bool Get(KeyType aKey, UserDataType* pData) const;




};






template<class KeyClass, class RefPtr>
bool
nsRefPtrHashtable<KeyClass,RefPtr>::Get
  (KeyType aKey, UserDataType* pRefPtr) const
{
  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent)
  {
    if (pRefPtr)
    {
      *pRefPtr = ent->mData;

      ns_if_addref(*pRefPtr);
    }

    return true;
  }



  if (pRefPtr)
    *pRefPtr = nullptr;

  return false;
}

template<class KeyClass, class RefPtr>
RefPtr*
nsRefPtrHashtable<KeyClass,RefPtr>::GetWeak
  (KeyType aKey, bool* aFound) const
{
  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent)
  {
    if (aFound)
      *aFound = true;

    return ent->mData;
  }


  if (aFound)
    *aFound = false;
  return nullptr;
}





template<class KeyClass, class RefPtr>
bool
nsRefPtrHashtableMT<KeyClass,RefPtr>::Get
  (KeyType aKey, UserDataType* pRefPtr) const
{
  PR_Lock(this->mLock);

  typename base_type::EntryType* ent = this->GetEntry(aKey);

  if (ent)
  {
    if (pRefPtr)
    {
      *pRefPtr = ent->mData;

      ns_if_addref(*pRefPtr);
    }

    PR_Unlock(this->mLock);

    return true;
  }



  if (pRefPtr)
    *pRefPtr = nullptr;

  PR_Unlock(this->mLock);

  return false;
}
# 22 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2
# 1 "../../dist/include/mozilla/CondVar.h" 1
# 10 "../../dist/include/mozilla/CondVar.h"
# 1 "../../dist/system_wrappers/prcvar.h" 1
       
# 2 "../../dist/system_wrappers/prcvar.h" 3
#pragma GCC visibility push(default)
# 1 "/builds/slave/try-l64-0000000000000000000000/build/obj-firefox/dist/include/nspr/prcvar.h" 1 3
# 4 "../../dist/system_wrappers/prcvar.h" 2 3
#pragma GCC visibility pop
# 11 "../../dist/include/mozilla/CondVar.h" 2

# 1 "../../dist/include/mozilla/BlockingResourceBase.h" 1
# 11 "../../dist/include/mozilla/BlockingResourceBase.h"
# 1 "../../dist/system_wrappers/prlog.h" 1
       
# 2 "../../dist/system_wrappers/prlog.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 12 "../../dist/include/mozilla/BlockingResourceBase.h" 2




# 1 "../../dist/include/nsTraceRefcnt.h" 1
# 17 "../../dist/include/mozilla/BlockingResourceBase.h" 2
# 32 "../../dist/include/mozilla/BlockingResourceBase.h"
namespace mozilla {







class BlockingResourceBase
{
public:

    enum BlockingResourceType { eMutex, eReentrantMonitor, eCondVar };





    static const char* const kResourceTypeName[];
# 332 "../../dist/include/mozilla/BlockingResourceBase.h"
    BlockingResourceBase(const char* aName, BlockingResourceType aType)
    {
    }

    ~BlockingResourceBase()
    {
    }


};


}
# 13 "../../dist/include/mozilla/CondVar.h" 2
# 1 "../../dist/include/mozilla/Mutex.h" 1
# 10 "../../dist/include/mozilla/Mutex.h"
# 1 "../../dist/system_wrappers/prlock.h" 1
       
# 2 "../../dist/system_wrappers/prlock.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 11 "../../dist/include/mozilla/Mutex.h" 2


# 1 "../../dist/include/mozilla/GuardObjects.h" 1
# 14 "../../dist/include/mozilla/Mutex.h" 2
# 26 "../../dist/include/mozilla/Mutex.h"
namespace mozilla {
# 35 "../../dist/include/mozilla/Mutex.h"
class Mutex : BlockingResourceBase
{
public:







    Mutex(const char* name) :
        BlockingResourceBase(name, eMutex)
    {
        ;
        mLock = PR_NewLock();
        if (!mLock)
            NS_DebugBreak(NS_DEBUG_ABORT, "Can't allocate mozilla::Mutex", nullptr, "../../dist/include/mozilla/Mutex.h", 51);
    }




    ~Mutex()
    {
        do { } while(0)
                                                                  ;

        PR_DestroyLock(mLock);
        mLock = 0;
        ;
    }






    void Lock()
    {
        PR_Lock(mLock);
    }





    void Unlock()
    {
        PR_Unlock(mLock);
    }





    void AssertCurrentThreadOwns () const
    {
    }





    void AssertNotCurrentThreadOwns () const
    {
    }
# 118 "../../dist/include/mozilla/Mutex.h"
private:
    Mutex();
    Mutex(const Mutex&);
    Mutex& operator=(const Mutex&);

    PRLock* mLock;

    friend class CondVar;
};
# 136 "../../dist/include/mozilla/Mutex.h"
template<typename T>
class BaseAutoLock
{
public:
# 148 "../../dist/include/mozilla/Mutex.h"
    BaseAutoLock(T& aLock ) :
        mLock(&aLock)
    {
        do { } while (0);
        do { } while(0);
        mLock->Lock();
    }

    ~BaseAutoLock(void) {
        mLock->Unlock();
    }

private:
    BaseAutoLock();
    BaseAutoLock(BaseAutoLock&);
    BaseAutoLock& operator=(BaseAutoLock&);
    static void* operator new(size_t) throw();
    static void operator delete(void*);

    T* mLock;
   
};

typedef BaseAutoLock<Mutex> MutexAutoLock;
# 180 "../../dist/include/mozilla/Mutex.h"
template<typename T>
class BaseAutoUnlock
{
public:
    BaseAutoUnlock(T& aLock ) :
        mLock(&aLock)
    {
        do { } while (0);
        do { } while(0);
        mLock->Unlock();
    }

    ~BaseAutoUnlock()
    {
        mLock->Lock();
    }

private:
    BaseAutoUnlock();
    BaseAutoUnlock(BaseAutoUnlock&);
    BaseAutoUnlock& operator =(BaseAutoUnlock&);
    static void* operator new(size_t) throw();
    static void operator delete(void*);

    T* mLock;
   
};

typedef BaseAutoUnlock<Mutex> MutexAutoUnlock;

}
# 14 "../../dist/include/mozilla/CondVar.h" 2

namespace mozilla {







class CondVar : BlockingResourceBase
{
public:
# 37 "../../dist/include/mozilla/CondVar.h"
    CondVar(Mutex& aLock, const char* aName) :
        BlockingResourceBase(aName, eCondVar),
        mLock(&aLock)
    {
        ;

        mCvar = PR_NewCondVar(mLock->mLock);
        if (!mCvar)
            NS_DebugBreak(NS_DEBUG_ABORT, "Can't allocate mozilla::CondVar", nullptr, "../../dist/include/mozilla/CondVar.h", 45);
    }





    ~CondVar()
    {
        do { } while(0)
                                                                     ;
        PR_DestroyCondVar(mCvar);
        mCvar = 0;
        mLock = 0;
        ;
    }






    nsresult Wait(PRIntervalTime interval = 0xffffffffUL)
    {

        return PR_WaitCondVar(mCvar, interval) == PR_SUCCESS
            ? nsresult::NS_OK : nsresult::NS_ERROR_FAILURE;
    }
# 81 "../../dist/include/mozilla/CondVar.h"
    nsresult Notify()
    {

        return PR_NotifyCondVar(mCvar) == PR_SUCCESS
            ? nsresult::NS_OK : nsresult::NS_ERROR_FAILURE;
    }





    nsresult NotifyAll()
    {

        return PR_NotifyAllCondVar(mCvar) == PR_SUCCESS
            ? nsresult::NS_OK : nsresult::NS_ERROR_FAILURE;
    }
# 119 "../../dist/include/mozilla/CondVar.h"
    void AssertCurrentThreadOwnsMutex()
    {
    }
    void AssertNotCurrentThreadOwnsMutex()
    {
    }



private:
    CondVar();
    CondVar(CondVar&);
    CondVar& operator=(CondVar&);

    Mutex* mLock;
    PRCondVar* mCvar;
};


}
# 23 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2

# 1 "../../dist/include/mozilla/Telemetry.h" 1
# 10 "../../dist/include/mozilla/Telemetry.h"
# 1 "../../dist/include/mozilla/TimeStamp.h" 1
# 12 "../../dist/include/mozilla/TimeStamp.h"
# 1 "../../dist/system_wrappers/prinrval.h" 1
       
# 2 "../../dist/system_wrappers/prinrval.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 13 "../../dist/include/mozilla/TimeStamp.h" 2


namespace IPC {
template <typename T> struct ParamTraits;
}







namespace mozilla {


typedef uint64_t TimeStampValue;


class TimeStamp;
# 43 "../../dist/include/mozilla/TimeStamp.h"
class TimeDuration
{
public:

  TimeDuration() : mValue(0) {}


  struct _SomethingVeryRandomHere;
  TimeDuration(_SomethingVeryRandomHere* aZero) : mValue(0) {
    do { } while(0);
  }


  double ToSeconds() const;



  double ToSecondsSigDigits() const;
  double ToMilliseconds() const {
    return ToSeconds() * 1000.0;
  }
  double ToMicroseconds() const {
    return ToMilliseconds() * 1000.0;
  }






  static inline TimeDuration FromSeconds(double aSeconds) {
    return FromMilliseconds(aSeconds * 1000.0);
  }
  static TimeDuration FromMilliseconds(double aMilliseconds);
  static inline TimeDuration FromMicroseconds(double aMicroseconds) {
    return FromMilliseconds(aMicroseconds / 1000.0);
  }

  TimeDuration operator+(const TimeDuration& aOther) const {
    return TimeDuration::FromTicks(mValue + aOther.mValue);
  }
  TimeDuration operator-(const TimeDuration& aOther) const {
    return TimeDuration::FromTicks(mValue - aOther.mValue);
  }
  TimeDuration& operator+=(const TimeDuration& aOther) {
    mValue += aOther.mValue;
    return *this;
  }
  TimeDuration& operator-=(const TimeDuration& aOther) {
    mValue -= aOther.mValue;
    return *this;
  }

private:


  TimeDuration operator*(const double aMultiplier) const = delete;

public:
  TimeDuration MultDouble(double aMultiplier) const {
    return TimeDuration::FromTicks(static_cast<int64_t>(mValue * aMultiplier));
  }
  TimeDuration operator*(const int32_t aMultiplier) const {
    return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
  }
  TimeDuration operator*(const uint32_t aMultiplier) const {
    return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
  }
  TimeDuration operator*(const int64_t aMultiplier) const {
    return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
  }
  double operator/(const TimeDuration& aOther) {
    return static_cast<double>(mValue) / aOther.mValue;
  }

  bool operator<(const TimeDuration& aOther) const {
    return mValue < aOther.mValue;
  }
  bool operator<=(const TimeDuration& aOther) const {
    return mValue <= aOther.mValue;
  }
  bool operator>=(const TimeDuration& aOther) const {
    return mValue >= aOther.mValue;
  }
  bool operator>(const TimeDuration& aOther) const {
    return mValue > aOther.mValue;
  }
  bool operator==(const TimeDuration& aOther) const {
    return mValue == aOther.mValue;
  }





  static TimeDuration Resolution();
# 147 "../../dist/include/mozilla/TimeStamp.h"
private:
  friend class TimeStamp;
  friend struct IPC::ParamTraits<mozilla::TimeDuration>;

  static TimeDuration FromTicks(int64_t aTicks) {
    TimeDuration t;
    t.mValue = aTicks;
    return t;
  }

  static TimeDuration FromTicks(double aTicks) {


    if (aTicks >= double((9223372036854775807L)))
      return TimeDuration::FromTicks((9223372036854775807L));


    if (aTicks <= double((-9223372036854775807L -1)))
      return TimeDuration::FromTicks((-9223372036854775807L -1));

    return TimeDuration::FromTicks(int64_t(aTicks));
  }


  int64_t mValue;
};
# 204 "../../dist/include/mozilla/TimeStamp.h"
class TimeStamp
{
public:



  TimeStamp() : mValue(0) {}





  bool IsNull() const { return mValue == 0; }
# 230 "../../dist/include/mozilla/TimeStamp.h"
  static TimeStamp Now() { return Now(true); }
  static TimeStamp NowLoRes() { return Now(false); }



  TimeDuration operator-(const TimeStamp& aOther) const {
    do { } while(0);
    do { } while(0);
    extern void pr_static_assert(int arg[(-(9223372036854775807L) > (-9223372036854775807L -1)) ? 1 : -1]);
    int64_t ticks = int64_t(mValue - aOther.mValue);

    if (mValue > aOther.mValue) {
      if (ticks < 0) {
        ticks = (9223372036854775807L);
      }
    } else {
      if (ticks > 0) {
        ticks = (-9223372036854775807L -1);
      }
    }
    return TimeDuration::FromTicks(ticks);
  }

  TimeStamp operator+(const TimeDuration& aOther) const {
    do { } while(0);
    return TimeStamp(mValue + aOther.mValue);
  }
  TimeStamp operator-(const TimeDuration& aOther) const {
    do { } while(0);
    return TimeStamp(mValue - aOther.mValue);
  }
  TimeStamp& operator+=(const TimeDuration& aOther) {
    do { } while(0);
    mValue += aOther.mValue;
    return *this;
  }
  TimeStamp& operator-=(const TimeDuration& aOther) {
    do { } while(0);
    mValue -= aOther.mValue;
    return *this;
  }

  bool operator<(const TimeStamp& aOther) const {
    do { } while(0);
    do { } while(0);
    return mValue < aOther.mValue;
  }
  bool operator<=(const TimeStamp& aOther) const {
    do { } while(0);
    do { } while(0);
    return mValue <= aOther.mValue;
  }
  bool operator>=(const TimeStamp& aOther) const {
    do { } while(0);
    do { } while(0);
    return mValue >= aOther.mValue;
  }
  bool operator>(const TimeStamp& aOther) const {
    do { } while(0);
    do { } while(0);
    return mValue > aOther.mValue;
  }
  bool operator==(const TimeStamp& aOther) const {

    do { } while(0);
    do { } while(0);
    return mValue == aOther.mValue;
  }
  bool operator!=(const TimeStamp& aOther) const {

    do { } while(0);
    do { } while(0);
    return mValue != aOther.mValue;
  }





  static __attribute__ ((visibility ("hidden"))) nsresult Startup();
  static __attribute__ ((visibility ("hidden"))) void Shutdown();

private:
  friend struct IPC::ParamTraits<mozilla::TimeStamp>;

  TimeStamp(TimeStampValue aValue) : mValue(aValue) {}

  static TimeStamp Now(bool aHighResolution);
# 332 "../../dist/include/mozilla/TimeStamp.h"
  TimeStampValue mValue;
};

}
# 11 "../../dist/include/mozilla/Telemetry.h" 2
# 1 "../../dist/include/mozilla/StartupTimeline.h" 1
# 24 "../../dist/include/mozilla/StartupTimeline.h"
# 1 "../../dist/system_wrappers/prtime.h" 1
       
# 2 "../../dist/system_wrappers/prtime.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "../../dist/include/mozilla/StartupTimeline.h" 2

# 1 "../../dist/include/GeckoProfiler.h" 1
# 52 "../../dist/include/GeckoProfiler.h"
# 1 "../../dist/include/jsfriendapi.h" 1
# 10 "../../dist/include/jsfriendapi.h"
# 1 "../../dist/include/mozilla/GuardObjects.h" 1
# 11 "../../dist/include/jsfriendapi.h" 2

# 1 "../../dist/include/jsclass.h" 1
# 16 "../../dist/include/jsclass.h"
# 1 "../../dist/include/jsapi.h" 1
# 14 "../../dist/include/jsapi.h"
# 1 "../../dist/include/mozilla/FloatingPoint.h" 1
# 40 "../../dist/include/mozilla/FloatingPoint.h"
static_assert((sizeof(double) == sizeof(uint64_t)), "double must be 64 bits");
# 53 "../../dist/include/mozilla/FloatingPoint.h"
static_assert(((0x8000000000000000ULL & 0x7ff0000000000000ULL) == 0), "sign bit doesn't overlap exponent bits")
                                                           ;
static_assert(((0x8000000000000000ULL & 0x000fffffffffffffULL) == 0), "sign bit doesn't overlap significand bits")
                                                              ;
static_assert(((0x7ff0000000000000ULL & 0x000fffffffffffffULL) == 0), "exponent bits don't overlap significand bits")
                                                                 ;

static_assert(((0x8000000000000000ULL | 0x7ff0000000000000ULL | 0x000fffffffffffffULL) == ~(uint64_t)0), "all bits accounted for")

                                           ;


extern "C" {






union MozDoublePun {






    uint64_t u;
    double d;
};


static __attribute__((always_inline)) inline int
MOZ_DOUBLE_IS_NaN(double d)
{
  union MozDoublePun pun;
  pun.d = d;





  return (pun.u & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL &&
         (pun.u & 0x000fffffffffffffULL) != 0;
}


static __attribute__((always_inline)) inline int
MOZ_DOUBLE_IS_INFINITE(double d)
{
  union MozDoublePun pun;
  pun.d = d;


  return (pun.u & ~0x8000000000000000ULL) == 0x7ff0000000000000ULL;
}


static __attribute__((always_inline)) inline int
MOZ_DOUBLE_IS_FINITE(double d)
{
  union MozDoublePun pun;
  pun.d = d;





  return (pun.u & 0x7ff0000000000000ULL) != 0x7ff0000000000000ULL;
}





static __attribute__((always_inline)) inline int
MOZ_DOUBLE_IS_NEGATIVE(double d)
{
  union MozDoublePun pun;
  pun.d = d;

  do { } while(0);


  return (pun.u & 0x8000000000000000ULL) != 0;
}


static __attribute__((always_inline)) inline int
MOZ_DOUBLE_IS_NEGATIVE_ZERO(double d)
{
  union MozDoublePun pun;
  pun.d = d;


  return pun.u == 0x8000000000000000ULL;
}


static __attribute__((always_inline)) inline int_fast16_t
MOZ_DOUBLE_EXPONENT(double d)
{
  union MozDoublePun pun;
  pun.d = d;





  return (int_fast16_t)((pun.u & 0x7ff0000000000000ULL) >> 52) -
                        1023;
}


static __attribute__((always_inline)) inline double
MOZ_DOUBLE_POSITIVE_INFINITY()
{
  union MozDoublePun pun;





  pun.u = 0x7ff0000000000000ULL;
  return pun.d;
}


static __attribute__((always_inline)) inline double
MOZ_DOUBLE_NEGATIVE_INFINITY()
{
  union MozDoublePun pun;





  pun.u = 0x8000000000000000ULL | 0x7ff0000000000000ULL;
  return pun.d;
}


static __attribute__((always_inline)) inline double
MOZ_DOUBLE_SPECIFIC_NaN(int signbit, uint64_t significand)
{
  union MozDoublePun pun;

  do { } while(0);
  do { } while(0);
  do { } while(0);

  pun.u = (signbit ? 0x8000000000000000ULL : 0) |
          0x7ff0000000000000ULL |
          significand;
  do { } while(0);
  return pun.d;
}





static __attribute__((always_inline)) inline double
MOZ_DOUBLE_NaN()
{
  return MOZ_DOUBLE_SPECIFIC_NaN(0, 0xfffffffffffffULL);
}


static __attribute__((always_inline)) inline double
MOZ_DOUBLE_MIN_VALUE()
{
  union MozDoublePun pun;
  pun.u = 1;
  return pun.d;
}

static __attribute__((always_inline)) inline int
MOZ_DOUBLE_IS_INT32(double d, int32_t* i)
{





  return !MOZ_DOUBLE_IS_NEGATIVE_ZERO(d) && d == (*i = (int32_t)d);
}


}
# 15 "../../dist/include/jsapi.h" 2

# 1 "../../dist/include/mozilla/RangedPtr.h" 1
# 18 "../../dist/include/mozilla/RangedPtr.h"
namespace mozilla {
# 39 "../../dist/include/mozilla/RangedPtr.h"
template<typename T>
class RangedPtr
{
    T* ptr;






    typedef void (RangedPtr::* ConvertibleToBool)();
    void nonNull() {}

    void checkSanity() {
      do { } while(0);
      do { } while(0);
    }


    RangedPtr<T> create(T *p) const {



      return RangedPtr<T>(p, __null, size_t(0));

    }

    uintptr_t asUintptr() const { return uintptr_t(ptr); }

  public:
    RangedPtr(T* p, T* start, T* end)
      : ptr(p)



    {
      do { } while(0);
      checkSanity();
    }
    RangedPtr(T* p, T* start, size_t length)
      : ptr(p)



    {
      do { } while(0);
      do { } while(0);
      checkSanity();
    }


    RangedPtr(T* p, size_t length)
      : ptr(p)



    {
      do { } while(0);
      do { } while(0);
      checkSanity();
    }


    template<size_t N>
    RangedPtr(T (&arr)[N])
      : ptr(arr)



    {
      checkSanity();
    }

    T* get() const {
      return ptr;
    }

    operator ConvertibleToBool() const { return ptr ? &RangedPtr::nonNull : 0; }
# 128 "../../dist/include/mozilla/RangedPtr.h"
    RangedPtr<T>& operator=(const RangedPtr<T>& other) {
      do { } while(0);
      do { } while(0);
      ptr = other.ptr;
      checkSanity();
      return *this;
    }

    RangedPtr<T> operator+(size_t inc) {
      do { } while(0);
      do { } while(0);
      return create(ptr + inc);
    }

    RangedPtr<T> operator-(size_t dec) {
      do { } while(0);
      do { } while(0);
      return create(ptr - dec);
    }





    template <typename U>
    RangedPtr<T>& operator=(U* p) {
      *this = create(p);
      return *this;
    }

    template <typename U>
    RangedPtr<T>& operator=(const RangedPtr<U>& p) {
      do { } while(0);
      do { } while(0);
      ptr = p.ptr;
      checkSanity();
      return *this;
    }

    RangedPtr<T>& operator++() {
      return (*this += 1);
    }

    RangedPtr<T> operator++(int) {
      RangedPtr<T> rcp = *this;
      ++*this;
      return rcp;
    }

    RangedPtr<T>& operator--() {
      return (*this -= 1);
    }

    RangedPtr<T> operator--(int) {
      RangedPtr<T> rcp = *this;
      --*this;
      return rcp;
    }

    RangedPtr<T>& operator+=(size_t inc) {
      *this = *this + inc;
      return *this;
    }

    RangedPtr<T>& operator-=(size_t dec) {
      *this = *this - dec;
      return *this;
    }

    T& operator[](int index) const {
      do { } while(0);
      return *create(ptr + index);
    }

    T& operator*() const {
      return *ptr;
    }

    template <typename U>
    bool operator==(const RangedPtr<U>& other) const {
      return ptr == other.ptr;
    }
    template <typename U>
    bool operator!=(const RangedPtr<U>& other) const {
      return !(*this == other);
    }

    template<typename U>
    bool operator==(const U* u) const {
      return ptr == u;
    }
    template<typename U>
    bool operator!=(const U* u) const {
      return !(*this == u);
    }

    template <typename U>
    bool operator<(const RangedPtr<U>& other) const {
      return ptr < other.ptr;
    }
    template <typename U>
    bool operator<=(const RangedPtr<U>& other) const {
      return ptr <= other.ptr;
    }

    template <typename U>
    bool operator>(const RangedPtr<U>& other) const {
      return ptr > other.ptr;
    }
    template <typename U>
    bool operator>=(const RangedPtr<U>& other) const {
      return ptr >= other.ptr;
    }

    size_t operator-(const RangedPtr<T>& other) const {
      do { } while(0);
      return PointerRangeSize(other.ptr, ptr);
    }

  private:
    RangedPtr() = delete;
    T* operator&() = delete;
};

}
# 17 "../../dist/include/jsapi.h" 2

# 1 "../../dist/include/mozilla/ThreadLocal.h" 1
# 25 "../../dist/include/mozilla/ThreadLocal.h"
# 1 "../../dist/system_wrappers/pthread.h" 1
       
# 2 "../../dist/system_wrappers/pthread.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "../../dist/system_wrappers/endian.h" 1 3 4
       
# 2 "../../dist/system_wrappers/endian.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 24 "/usr/include/sched.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/sched.h" 2 3 4





# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 31 "/usr/include/sched.h" 2 3 4



# 1 "../../dist/system_wrappers/time.h" 1 3 4
       
# 2 "../../dist/system_wrappers/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 4 "../../dist/system_wrappers/time.h" 2 3
#pragma GCC visibility pop
# 35 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 74 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 116 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 199 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 118 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "../../dist/system_wrappers/time.h" 1 3 4
       
# 2 "../../dist/system_wrappers/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 28 "/usr/include/time.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/time.h" 2 3 4

extern "C" {







# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 180 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 4 "../../dist/system_wrappers/time.h" 2 3
#pragma GCC visibility pop
# 27 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 31 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 147 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 182 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 220 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 478 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 490 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 524 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 664 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 676 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 699 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;
# 712 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 790 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 872 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 984 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1028 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1095 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1129 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 4 "../../dist/system_wrappers/pthread.h" 2 3
#pragma GCC visibility pop
# 26 "../../dist/include/mozilla/ThreadLocal.h" 2
# 1 "../../dist/system_wrappers/signal.h" 1
       
# 2 "../../dist/system_wrappers/signal.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "../../dist/include/mozilla/ThreadLocal.h" 2





namespace mozilla {







typedef sig_atomic_t sig_safe_t;
# 67 "../../dist/include/mozilla/ThreadLocal.h"
template<typename T>
class ThreadLocal
{



    typedef pthread_key_t key_t;


    union Helper {
      void* ptr;
      T value;
    };

  public:
    __attribute__ ((warn_unused_result)) inline bool init();

    inline T get() const;

    inline void set(const T value);

    bool initialized() const {
      return inited;
    }

  private:
    key_t key;
    bool inited;
};

template<typename T>
inline bool
ThreadLocal<T>::init()
{
  static_assert((sizeof(T) <= sizeof(void*)), "mozilla::ThreadLocal can't be used for types larger than " "a pointer")

                                ;
  do { } while(0);




  inited = !pthread_key_create(&key, __null);

  return inited;
}

template<typename T>
inline T
ThreadLocal<T>::get() const
{
  do { } while(0);
  Helper h;



  h.ptr = pthread_getspecific(key);

  return h.value;
}

template<typename T>
inline void
ThreadLocal<T>::set(const T value)
{
  do { } while(0);
  Helper h;
  h.value = value;
  bool succeeded;



  succeeded = !pthread_setspecific(key, h.ptr);

  if (!succeeded)
    do { *((volatile int*) __null) = 123; ::abort(); } while (0);
}

}
# 19 "../../dist/include/jsapi.h" 2

# 1 "../../dist/system_wrappers/stddef.h" 1
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 21 "../../dist/include/jsapi.h" 2
# 1 "../../dist/system_wrappers/stdio.h" 1
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 22 "../../dist/include/jsapi.h" 2

# 1 "../../dist/include/js-config.h" 1
# 24 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/jsalloc.h" 1
# 11 "../../dist/include/jsalloc.h"
# 1 "../../dist/include/jsutil.h" 1
# 17 "../../dist/include/jsutil.h"
# 1 "../../dist/include/js/Utility.h" 1
# 13 "../../dist/include/js/Utility.h"
# 1 "../../dist/include/mozilla/Scoped.h" 1
# 56 "../../dist/include/mozilla/Scoped.h"
namespace mozilla {
# 72 "../../dist/include/mozilla/Scoped.h"
template<typename Traits>
class Scoped
{
  public:
    typedef typename Traits::type Resource;

    explicit Scoped()
      : value(Traits::empty())
    {
      do { } while (0);
    }
    explicit Scoped(const Resource& v
                    )
      : value(v)
    {
      do { } while (0);
    }
    ~Scoped() {
      Traits::release(value);
    }


    operator const Resource&() const { return value; }
    const Resource& operator->() const { return value; }
    const Resource& get() const { return value; }

    Resource& rwget() { return value; }
# 109 "../../dist/include/mozilla/Scoped.h"
    Resource forget() {
      Resource tmp = value;
      value = Traits::empty();
      return tmp;
    }






    void dispose() {
      Traits::release(value);
      value = Traits::empty();
    }

    bool operator==(const Resource& other) const {
      return value == other;
    }
# 137 "../../dist/include/mozilla/Scoped.h"
    Scoped<Traits>& operator=(const Resource& other) {
      return reset(other);
    }
    Scoped<Traits>& reset(const Resource& other) {
      Traits::release(value);
      value = other;
      return *this;
    }

  private:
    explicit Scoped(const Scoped<Traits>& value) = delete;
    Scoped<Traits>& operator=(const Scoped<Traits>& value) = delete;

  private:
    Resource value;
   
};
# 192 "../../dist/include/mozilla/Scoped.h"
template<typename T>
struct ScopedFreePtrTraits
{
    typedef T* type;
    static T* empty() { return __null; }
    static void release(T* ptr) { moz_free(ptr); }
};
template<typename Type> struct ScopedFreePtr : public mozilla::Scoped<ScopedFreePtrTraits<Type> > { typedef mozilla::Scoped<ScopedFreePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedFreePtr& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit ScopedFreePtr() : Super() {} explicit ScopedFreePtr(Resource ptr ) : Super(ptr ) {} private: explicit ScopedFreePtr(ScopedFreePtr& source) = delete; ScopedFreePtr& operator=(ScopedFreePtr& source) = delete; };







template<typename T>
struct ScopedDeletePtrTraits : public ScopedFreePtrTraits<T>
{
    static void release(T* ptr) { delete ptr; }
};
template<typename Type> struct ScopedDeletePtr : public mozilla::Scoped<ScopedDeletePtrTraits<Type> > { typedef mozilla::Scoped<ScopedDeletePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedDeletePtr& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit ScopedDeletePtr() : Super() {} explicit ScopedDeletePtr(Resource ptr ) : Super(ptr ) {} private: explicit ScopedDeletePtr(ScopedDeletePtr& source) = delete; ScopedDeletePtr& operator=(ScopedDeletePtr& source) = delete; };







template<typename T>
struct ScopedDeleteArrayTraits : public ScopedFreePtrTraits<T>
{
    static void release(T* ptr) { delete [] ptr; }
};
template<typename Type> struct ScopedDeleteArray : public mozilla::Scoped<ScopedDeleteArrayTraits<Type> > { typedef mozilla::Scoped<ScopedDeleteArrayTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedDeleteArray& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit ScopedDeleteArray() : Super() {} explicit ScopedDeleteArray(Resource ptr ) : Super(ptr ) {} private: explicit ScopedDeleteArray(ScopedDeleteArray& source) = delete; ScopedDeleteArray& operator=(ScopedDeleteArray& source) = delete; };
# 253 "../../dist/include/mozilla/Scoped.h"
template <typename T> void TypeSpecificDelete(T * value);

template <typename T>
struct TypeSpecificScopedPointerTraits
{
    typedef T* type;
    const static type empty() { return __null; }
    const static void release(type value)
    {
      if (value)
        TypeSpecificDelete(value);
    }
};

template<typename Type> struct TypeSpecificScopedPointer : public mozilla::Scoped<TypeSpecificScopedPointerTraits<Type> > { typedef mozilla::Scoped<TypeSpecificScopedPointerTraits<Type> > Super; typedef typename Super::Resource Resource; TypeSpecificScopedPointer& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit TypeSpecificScopedPointer() : Super() {} explicit TypeSpecificScopedPointer(Resource ptr ) : Super(ptr ) {} private: explicit TypeSpecificScopedPointer(TypeSpecificScopedPointer& source) = delete; TypeSpecificScopedPointer& operator=(TypeSpecificScopedPointer& source) = delete; };

}
# 14 "../../dist/include/js/Utility.h" 2

# 1 "../../dist/system_wrappers/stdlib.h" 1
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 16 "../../dist/include/js/Utility.h" 2
# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 17 "../../dist/include/js/Utility.h" 2






# 1 "../../dist/include/jstypes.h" 1
# 150 "../../dist/include/jstypes.h"
# 1 "../../dist/include/jscpucfg.h" 1
# 48 "../../dist/include/jscpucfg.h"
# 1 "../../dist/system_wrappers/endian.h" 1
       
# 2 "../../dist/system_wrappers/endian.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 49 "../../dist/include/jscpucfg.h" 2
# 151 "../../dist/include/jstypes.h" 2
# 191 "../../dist/include/jstypes.h"
typedef int JSBool;
# 24 "../../dist/include/js/Utility.h" 2

# 1 "../../dist/include/js/TemplateLib.h" 1
# 20 "../../dist/include/js/TemplateLib.h"
namespace js {
namespace tl {


template <size_t i, size_t j> struct Min {
    static const size_t result = i < j ? i : j;
};
template <size_t i, size_t j> struct Max {
    static const size_t result = i > j ? i : j;
};
template <size_t i, size_t min, size_t max> struct Clamp {
    static const size_t result = i < min ? min : (i > max ? max : i);
};


template <size_t x, size_t y> struct Pow {
    static const size_t result = x * Pow<x, y - 1>::result;
};
template <size_t x> struct Pow<x,0> {
    static const size_t result = 1;
};


template <size_t i> struct FloorLog2 {
    static const size_t result = 1 + FloorLog2<i / 2>::result;
};
template <> struct FloorLog2<0> { };
template <> struct FloorLog2<1> { static const size_t result = 0; };


template <size_t i> struct CeilingLog2 {
    static const size_t result = FloorLog2<2 * i - 1>::result;
};


template <size_t i> struct RoundUpPow2 {
    static const size_t result = size_t(1) << CeilingLog2<i>::result;
};
template <> struct RoundUpPow2<0> {
    static const size_t result = 1;
};


template <class T> struct BitSize {
    static const size_t result = sizeof(T) * 8;
};





template <size_t N> struct NBitMask {




    static const size_t checkPrecondition = 0 / size_t(N < BitSize<size_t>::result);
    static const size_t result = (size_t(1) << N) - 1 + checkPrecondition;
};
template <> struct NBitMask<BitSize<size_t>::result> {
    static const size_t result = size_t(-1);
};





template <size_t N> struct MulOverflowMask {
    static const size_t result =
        ~NBitMask<BitSize<size_t>::result - CeilingLog2<N>::result>::result;
};
template <> struct MulOverflowMask<0> { };
template <> struct MulOverflowMask<1> { static const size_t result = 0; };






template <class T> struct UnsafeRangeSizeMask {




    static const size_t result = MulOverflowMask<2 * sizeof(T)>::result;
};


template <class T> struct StripConst { typedef T result; };
template <class T> struct StripConst<const T> { typedef T result; };

template <bool cond, typename T, T v1, T v2> struct If { static const T result = v1; };
template <typename T, T v1, T v2> struct If<false, T, v1, v2> { static const T result = v2; };




template <class T> struct IsRelocatableHeapType { static const bool result = true; };

}
}
# 26 "../../dist/include/js/Utility.h" 2


namespace JS {}


namespace mozilla {}


namespace js {}
# 69 "../../dist/include/js/Utility.h"
extern __attribute__((noreturn)) __attribute__((visibility("default"))) void
JS_Assert(const char *s, const char *file, int ln);






extern __attribute__((visibility("default"))) void JS_Abort(void);
# 148 "../../dist/include/js/Utility.h"
static inline void* js_malloc(size_t bytes)
{
    do {} while(0);
    return moz_malloc(bytes);
}

static inline void* js_calloc(size_t bytes)
{
    do {} while(0);
    return moz_calloc(bytes, 1);
}

static inline void* js_realloc(void* p, size_t bytes)
{
    do {} while(0);
    return moz_realloc(p, bytes);
}

static inline void js_free(void* p)
{
    moz_free(p);
}


extern "C" {
# 333 "../../dist/include/js/Utility.h"
}
# 349 "../../dist/include/js/Utility.h"
static __attribute__((always_inline)) inline size_t
JS_FLOOR_LOG2W(size_t n)
{
    do { } while(0);
    return ((size_t)((8 * 8) - 1 - __builtin_clzll(n)));
}
# 499 "../../dist/include/js/Utility.h"
template <class T> static __attribute__((always_inline)) inline T *js_new() { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T () : __null; } template <class T, class P1> static __attribute__((always_inline)) inline T *js_new(P1 p1) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1) : __null; } template <class T, class P1, class P2> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2) : __null; } template <class T, class P1, class P2, class P3> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3) : __null; } template <class T, class P1, class P2, class P3, class P4> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6, p7) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6, p7, p8) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6, p7, p8, p9) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9, class P10> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9, class P10, class P11> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11) : __null; } template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9, class P10, class P11, class P12> static __attribute__((always_inline)) inline T *js_new(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12) { void *memory = js_malloc(sizeof(T)); return memory ? new(memory) T (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12) : __null; }

template <class T>
static __attribute__((always_inline)) inline void
js_delete(T *p)
{
    if (p) {
        p->~T();
        js_free(p);
    }
}

template <class T>
static __attribute__((always_inline)) inline T *
js_pod_malloc()
{
    return (T *)js_malloc(sizeof(T));
}

template <class T>
static __attribute__((always_inline)) inline T *
js_pod_calloc()
{
    return (T *)js_calloc(sizeof(T));
}

template <class T>
static __attribute__((always_inline)) inline T *
js_pod_malloc(size_t numElems)
{
    if (numElems & js::tl::MulOverflowMask<sizeof(T)>::result)
        return __null;
    return (T *)js_malloc(numElems * sizeof(T));
}

template <class T>
static __attribute__((always_inline)) inline T *
js_pod_calloc(size_t numElems)
{
    if (numElems & js::tl::MulOverflowMask<sizeof(T)>::result)
        return __null;
    return (T *)js_calloc(numElems * sizeof(T));
}

namespace js {

template<typename T>
struct ScopedFreePtrTraits
{
    typedef T* type;
    static T* empty() { return __null; }
    static void release(T* ptr) { js_free(ptr); }
};
template<typename Type> struct ScopedJSFreePtr : public mozilla::Scoped<ScopedFreePtrTraits<Type> > { typedef mozilla::Scoped<ScopedFreePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedJSFreePtr& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit ScopedJSFreePtr() : Super() {} explicit ScopedJSFreePtr(Resource ptr ) : Super(ptr ) {} private: explicit ScopedJSFreePtr(ScopedJSFreePtr& source) = delete; ScopedJSFreePtr& operator=(ScopedJSFreePtr& source) = delete; };

template <typename T>
struct ScopedDeletePtrTraits : public ScopedFreePtrTraits<T>
{
    static void release(T *ptr) { js_delete(ptr); }
};
template<typename Type> struct ScopedJSDeletePtr : public mozilla::Scoped<ScopedDeletePtrTraits<Type> > { typedef mozilla::Scoped<ScopedDeletePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedJSDeletePtr& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit ScopedJSDeletePtr() : Super() {} explicit ScopedJSDeletePtr(Resource ptr ) : Super(ptr ) {} private: explicit ScopedJSDeletePtr(ScopedJSDeletePtr& source) = delete; ScopedJSDeletePtr& operator=(ScopedJSDeletePtr& source) = delete; };

template <typename T>
struct ScopedReleasePtrTraits : public ScopedFreePtrTraits<T>
{
    static void release(T *ptr) { if (ptr) ptr->release(); }
};
template<typename Type> struct ScopedReleasePtr : public mozilla::Scoped<ScopedReleasePtrTraits<Type> > { typedef mozilla::Scoped<ScopedReleasePtrTraits<Type> > Super; typedef typename Super::Resource Resource; ScopedReleasePtr& operator=(Resource ptr) { Super::operator=(ptr); return *this; } explicit ScopedReleasePtr() : Super() {} explicit ScopedReleasePtr(Resource ptr ) : Super(ptr ) {} private: explicit ScopedReleasePtr(ScopedReleasePtr& source) = delete; ScopedReleasePtr& operator=(ScopedReleasePtr& source) = delete; };

}

namespace js {
# 672 "../../dist/include/js/Utility.h"
template<typename T>
class MoveRef {
  public:
    typedef T Referent;
    explicit MoveRef(T &t) : pointer(&t) { }
    T &operator*() const { return *pointer; }
    T *operator->() const { return pointer; }
    operator T& () const { return *pointer; }
  private:
    T *pointer;
};

template<typename T>
MoveRef<T> Move(T &t) { return MoveRef<T>(t); }

template<typename T>
MoveRef<T> Move(const T &t) { return MoveRef<T>(const_cast<T &>(t)); }


class ReentrancyGuard
{

    ReentrancyGuard(const ReentrancyGuard &);
    void operator=(const ReentrancyGuard &);




  public:
    template <class T>




    ReentrancyGuard(T & )

    {




    }
    ~ReentrancyGuard()
    {



    }
};

template <class T>
__attribute__((always_inline)) inline static void
Swap(T &t, T &u)
{
    T tmp(Move(t));
    t = Move(u);
    u = Move(tmp);
}





__attribute__((always_inline)) inline size_t
RoundUpPow2(size_t x)
{
    return size_t(1) << ((x) <= 1 ? 0 : 1 + JS_FLOOR_LOG2W((x) - 1));
}


typedef uint32_t HashNumber;
const unsigned HashNumberSizeBits = 32;

namespace detail {
# 762 "../../dist/include/js/Utility.h"
inline HashNumber
ScrambleHashCode(HashNumber h)
{
# 780 "../../dist/include/js/Utility.h"
    static const HashNumber goldenRatio = 0x9E3779B9U;
    return h * goldenRatio;
}

}

}

namespace JS {
# 801 "../../dist/include/js/Utility.h"
inline void PoisonPtr(void *v)
{




}

template <typename T>
inline bool IsPoisonedPtr(T *v)
{




    return false;

}

}




typedef size_t(*JSMallocSizeOfFun)(const void *p);
# 18 "../../dist/include/jsutil.h" 2






struct JSContext;

static __attribute__((always_inline)) inline void *
js_memcpy(void *dst_, const void *src_, size_t len)
{
    char *dst = (char *) dst_;
    const char *src = (const char *) src_;
    do { } while (0);
    do { } while (0);

    return memcpy(dst, src, len);
}


namespace js {

template <class T>
struct AlignmentTestStruct
{
    char c;
    T t;
};





template <class T>
class AlignedPtrAndFlag
{
    uintptr_t bits;

  public:
    AlignedPtrAndFlag(T *t, bool aFlag) {
        do { } while(0);
        bits = uintptr_t(t) | uintptr_t(aFlag);
    }

    T *ptr() const {
        return (T *)(bits & ~uintptr_t(1));
    }

    bool flag() const {
        return (bits & 1) != 0;
    }

    void setPtr(T *t) {
        do { } while(0);
        bits = uintptr_t(t) | uintptr_t(flag());
    }

    void setFlag() {
        bits |= 1;
    }

    void unsetFlag() {
        bits &= ~uintptr_t(1);
    }

    void set(T *t, bool aFlag) {
        do { } while(0);
        bits = uintptr_t(t) | aFlag;
    }
};

template <class T>
static inline void
Reverse(T *beg, T *end)
{
    while (beg != end) {
        if (--end == beg)
            return;
        T tmp = *beg;
        *beg = *end;
        *end = tmp;
        ++beg;
    }
}

template <class T>
static inline T *
Find(T *beg, T *end, const T &v)
{
    for (T *p = beg; p != end; ++p) {
        if (*p == v)
            return p;
    }
    return end;
}

template <class Container>
static inline typename Container::ElementType *
Find(Container &c, const typename Container::ElementType &v)
{
    return Find(c.begin(), c.end(), v);
}

template <typename InputIterT, typename CallableT>
void
ForEach(InputIterT begin, InputIterT end, CallableT f)
{
    for (; begin != end; ++begin)
        f(*begin);
}

template <class T>
static inline T
Min(T t1, T t2)
{
    return t1 < t2 ? t1 : t2;
}

template <class T>
static inline T
Max(T t1, T t2)
{
    return t1 > t2 ? t1 : t2;
}


template <class T>
static T&
InitConst(const T &t)
{
    return const_cast<T &>(t);
}

template <class T, class U>
__attribute__((always_inline)) inline T &
ImplicitCast(U &u)
{
    T &t = u;
    return t;
}

template<typename T>
class AutoScopedAssign
{
  public:
    AutoScopedAssign(T *addr, const T &value
                     )
        : addr_(addr), old(*addr_)
    {
        do { } while (0);
        *addr_ = value;
    }

    ~AutoScopedAssign() { *addr_ = old; }

  private:
   
    T *addr_;
    T old;
};

template <class T>
__attribute__((always_inline)) inline static void
PodZero(T *t)
{
    memset(t, 0, sizeof(T));
}

template <class T>
__attribute__((always_inline)) inline static void
PodZero(T *t, size_t nelem)
{






    for (T *end = t + nelem; t != end; ++t)
        memset(t, 0, sizeof(T));
}
# 207 "../../dist/include/jsutil.h"
template <class T, size_t N> static void PodZero(T (&)[N]);
template <class T, size_t N> static void PodZero(T (&)[N], size_t);

template <class T, size_t N>
__attribute__((always_inline)) inline static void
PodArrayZero(T (&t)[N])
{
    memset(t, 0, N * sizeof(T));
}

template <class T>
__attribute__((always_inline)) inline static void
PodAssign(T *dst, const T *src)
{
    js_memcpy((char *) dst, (const char *) src, sizeof(T));
}

template <class T>
__attribute__((always_inline)) inline static void
PodCopy(T *dst, const T *src, size_t nelem)
{

    do { } while (0);
    do { } while (0);

    if (nelem < 128) {




        for (const T *srcend = src + nelem; src != srcend; ++src, ++dst)
            PodAssign(dst, src);
    } else {
        memcpy(dst, src, nelem * sizeof(T));
    }
}

template <class T>
__attribute__((always_inline)) inline static bool
PodEqual(T *one, T *two, size_t len)
{
    if (len < 128) {
        T *p1end = one + len;
        for (T *p1 = one, *p2 = two; p1 != p1end; ++p1, ++p2) {
            if (*p1 != *p2)
                return false;
        }
        return true;
    }

    return !memcmp(one, two, len * sizeof(T));
}

template <typename T>
static inline bool
IsPowerOfTwo(T t)
{
    return t && !(t & (t - 1));
}

template <typename T, typename U>
static inline U
ComputeByteAlignment(T bytes, U alignment)
{
    do { } while(0);
    return (alignment - (bytes % alignment)) % alignment;
}

template <typename T, typename U>
static inline T
AlignBytes(T bytes, U alignment)
{
    return bytes + ComputeByteAlignment(bytes, alignment);
}

__attribute__((always_inline)) inline static size_t
UnsignedPtrDiff(const void *bigger, const void *smaller)
{
    return size_t(bigger) - size_t(smaller);
}
# 295 "../../dist/include/jsutil.h"
enum MaybeReportError { REPORT_ERROR = true, DONT_REPORT_ERROR = false };





static inline unsigned
NumWordsForBitArrayOfLength(size_t length)
{
    return (length + ((8 * 8) - 1)) / (8 * 8);
}

static inline unsigned
BitArrayIndexToWordIndex(size_t length, size_t bitIndex)
{
    unsigned wordIndex = bitIndex / (8 * 8);
    do { } while(0);
    return wordIndex;
}

static inline size_t
BitArrayIndexToWordMask(size_t i)
{
    return size_t(1) << (i % (8 * 8));
}

static inline bool
IsBitArrayElementSet(size_t *array, size_t length, size_t i)
{
    return array[BitArrayIndexToWordIndex(length, i)] & BitArrayIndexToWordMask(i);
}

static inline bool
IsAnyBitArrayElementSet(size_t *array, size_t length)
{
    unsigned numWords = NumWordsForBitArrayOfLength(length);
    for (unsigned i = 0; i < numWords; ++i) {
        if (array[i])
            return true;
    }
    return false;
}

static inline void
SetBitArrayElement(size_t *array, size_t length, size_t i)
{
    array[BitArrayIndexToWordIndex(length, i)] |= BitArrayIndexToWordMask(i);
}

static inline void
ClearBitArrayElement(size_t *array, size_t length, size_t i)
{
    array[BitArrayIndexToWordIndex(length, i)] &= ~BitArrayIndexToWordMask(i);
}

static inline void
ClearAllBitArrayElements(size_t *array, size_t length)
{
    for (unsigned i = 0; i < length; ++i)
        array[i] = 0;
}
# 392 "../../dist/include/jsutil.h"
}
# 438 "../../dist/include/jsutil.h"
typedef size_t jsbitmap;
# 12 "../../dist/include/jsalloc.h" 2

namespace js {
# 33 "../../dist/include/jsalloc.h"
class SystemAllocPolicy
{
  public:
    void *malloc_(size_t bytes) { return js_malloc(bytes); }
    void *calloc_(size_t bytes) { return js_calloc(bytes); }
    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return js_realloc(p, bytes); }
    void free_(void *p) { js_free(p); }
    void reportAllocOverflow() const {}
};
# 52 "../../dist/include/jsalloc.h"
class TempAllocPolicy
{
    JSContext *const cx_;





    __attribute__((visibility("default"))) void * onOutOfMemory(void *p, size_t nbytes);

  public:
    TempAllocPolicy(JSContext *cx) : cx_(cx) {}

    JSContext *context() const {
        return cx_;
    }

    void *malloc_(size_t bytes) {
        void *p = js_malloc(bytes);
        if ((__builtin_expect((!p), 0)))
            p = onOutOfMemory(__null, bytes);
        return p;
    }

    void *calloc_(size_t bytes) {
        void *p = js_calloc(bytes);
        if ((__builtin_expect((!p), 0)))
            p = onOutOfMemory(__null, bytes);
        return p;
    }

    void *realloc_(void *p, size_t oldBytes, size_t bytes) {
        void *p2 = js_realloc(p, bytes);
        if ((__builtin_expect((!p2), 0)))
            p2 = onOutOfMemory(p2, bytes);
        return p2;
    }

    void free_(void *p) {
        js_free(p);
    }

    __attribute__((visibility("default"))) void reportAllocOverflow() const;
};

}
# 25 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/jspubtd.h" 1
# 14 "../../dist/include/jspubtd.h"
# 1 "../../dist/include/jsprototypes.h" 1
# 13 "../../dist/include/jsprototypes.h"
# 1 "../../dist/include/jsversion.h" 1
# 14 "../../dist/include/jsprototypes.h" 2
# 15 "../../dist/include/jspubtd.h" 2
# 1 "../../dist/include/jstypes.h" 1
# 16 "../../dist/include/jspubtd.h" 2


namespace JS {





class Value;

template <typename T>
class Rooted;

struct Zone;

}
# 63 "../../dist/include/jspubtd.h"
typedef ptrdiff_t jsid;
# 74 "../../dist/include/jspubtd.h"
typedef uint16_t jschar;







typedef enum JSVersion {
    JSVERSION_ECMA_3 = 148,
    JSVERSION_1_6 = 160,
    JSVERSION_1_7 = 170,
    JSVERSION_1_8 = 180,
    JSVERSION_ECMA_5 = 185,
    JSVERSION_DEFAULT = 0,
    JSVERSION_UNKNOWN = -1,
    JSVERSION_LATEST = JSVERSION_ECMA_5
} JSVersion;


typedef enum JSType {
    JSTYPE_VOID,
    JSTYPE_OBJECT,
    JSTYPE_FUNCTION,
    JSTYPE_STRING,
    JSTYPE_NUMBER,
    JSTYPE_BOOLEAN,
    JSTYPE_NULL,
    JSTYPE_LIMIT
} JSType;


typedef enum JSProtoKey {

    JSProto_Null = 0, JSProto_Object = 1, JSProto_Function = 2, JSProto_Array = 3, JSProto_Boolean = 4, JSProto_JSON = 5, JSProto_Date = 6, JSProto_Math = 7, JSProto_Number = 8, JSProto_String = 9, JSProto_RegExp = 10, JSProto_Error = 11, JSProto_InternalError = 12, JSProto_EvalError = 13, JSProto_RangeError = 14, JSProto_ReferenceError = 15, JSProto_SyntaxError = 16, JSProto_TypeError = 17, JSProto_URIError = 18, JSProto_Iterator = 19, JSProto_StopIteration = 20, JSProto_ArrayBuffer = 21, JSProto_Int8Array = 22, JSProto_Uint8Array = 23, JSProto_Int16Array = 24, JSProto_Uint16Array = 25, JSProto_Int32Array = 26, JSProto_Uint32Array = 27, JSProto_Float32Array = 28, JSProto_Float64Array = 29, JSProto_Uint8ClampedArray = 30, JSProto_Proxy = 31, JSProto_WeakMap = 32, JSProto_Map = 33, JSProto_Set = 34, JSProto_DataView = 35, JSProto_ParallelArray = 36, JSProto_Intl = 37,

    JSProto_LIMIT
} JSProtoKey;


typedef enum JSAccessMode {
    JSACC_PROTO = 0,
# 127 "../../dist/include/jspubtd.h"
    JSACC_WATCH = 3,
    JSACC_READ = 4,
    JSACC_WRITE = 8,
    JSACC_LIMIT
} JSAccessMode;







typedef enum JSIterateOp {

    JSENUMERATE_INIT,


    JSENUMERATE_INIT_ALL,


    JSENUMERATE_NEXT,


    JSENUMERATE_DESTROY
} JSIterateOp;


typedef enum {
    JSTRACE_OBJECT,
    JSTRACE_STRING,
    JSTRACE_SCRIPT,





    JSTRACE_IONCODE,
    JSTRACE_SHAPE,
    JSTRACE_BASE_SHAPE,
    JSTRACE_TYPE_OBJECT,
    JSTRACE_LAST = JSTRACE_TYPE_OBJECT
} JSGCTraceKind;


typedef struct JSClass JSClass;
typedef struct JSCompartment JSCompartment;
typedef struct JSConstDoubleSpec JSConstDoubleSpec;
typedef struct JSContext JSContext;
typedef struct JSCrossCompartmentCall JSCrossCompartmentCall;
typedef struct JSErrorReport JSErrorReport;
typedef struct JSExceptionState JSExceptionState;
typedef struct JSFunctionSpec JSFunctionSpec;
typedef struct JSIdArray JSIdArray;
typedef struct JSLocaleCallbacks JSLocaleCallbacks;
typedef struct JSObjectMap JSObjectMap;
typedef struct JSPrincipals JSPrincipals;
typedef struct JSPropertyDescriptor JSPropertyDescriptor;
typedef struct JSPropertyName JSPropertyName;
typedef struct JSPropertySpec JSPropertySpec;
typedef struct JSRuntime JSRuntime;
typedef struct JSSecurityCallbacks JSSecurityCallbacks;
typedef struct JSStructuredCloneCallbacks JSStructuredCloneCallbacks;
typedef struct JSStructuredCloneReader JSStructuredCloneReader;
typedef struct JSStructuredCloneWriter JSStructuredCloneWriter;
typedef struct JSTracer JSTracer;


class JSFlatString;
class JSFunction;
class JSObject;
class JSScript;
class JSStableString;
class JSString;
# 209 "../../dist/include/jspubtd.h"
typedef struct PRCallOnceType JSCallOnceType;



typedef JSBool (*JSInitCallback)(void);



namespace js {

class Allocator;

class SkipRoot;

enum ThingRootKind
{
    THING_ROOT_OBJECT,
    THING_ROOT_SHAPE,
    THING_ROOT_BASE_SHAPE,
    THING_ROOT_TYPE_OBJECT,
    THING_ROOT_STRING,
    THING_ROOT_ION_CODE,
    THING_ROOT_SCRIPT,
    THING_ROOT_ID,
    THING_ROOT_PROPERTY_ID,
    THING_ROOT_VALUE,
    THING_ROOT_TYPE,
    THING_ROOT_BINDINGS,
    THING_ROOT_LIMIT
};

template <typename T>
struct RootKind;






template<typename T, ThingRootKind Kind>
struct SpecificRootKind
{
    static ThingRootKind rootKind() { return Kind; }
};

template <> struct RootKind<JSObject *> : SpecificRootKind<JSObject *, THING_ROOT_OBJECT> {};
template <> struct RootKind<JSFunction *> : SpecificRootKind<JSFunction *, THING_ROOT_OBJECT> {};
template <> struct RootKind<JSString *> : SpecificRootKind<JSString *, THING_ROOT_STRING> {};
template <> struct RootKind<JSScript *> : SpecificRootKind<JSScript *, THING_ROOT_SCRIPT> {};
template <> struct RootKind<jsid> : SpecificRootKind<jsid, THING_ROOT_ID> {};
template <> struct RootKind<JS::Value> : SpecificRootKind<JS::Value, THING_ROOT_VALUE> {};

struct ContextFriendFields {
    JSRuntime *const runtime;


    JSCompartment *compartment;


    JS::Zone *zone_;

    explicit ContextFriendFields(JSRuntime *rt)
      : runtime(rt), compartment(__null), zone_(__null)
    { }

    static const ContextFriendFields *get(const JSContext *cx) {
        return reinterpret_cast<const ContextFriendFields *>(cx);
    }

    static ContextFriendFields *get(JSContext *cx) {
        return reinterpret_cast<ContextFriendFields *>(cx);
    }
# 301 "../../dist/include/jspubtd.h"
};

struct RuntimeFriendFields {




    volatile int32_t interrupt;

    RuntimeFriendFields()
      : interrupt(0) { }

    static const RuntimeFriendFields *get(const JSRuntime *rt) {
        return reinterpret_cast<const RuntimeFriendFields *>(rt);
    }
};

class PerThreadData;

struct PerThreadDataFriendFields
{
  private:



    struct RuntimeDummy : RuntimeFriendFields
    {
        struct PerThreadDummy {
            void *field1;
            uintptr_t field2;



        } mainThread;
    };

  public:

    PerThreadDataFriendFields();
# 362 "../../dist/include/jspubtd.h"
    uintptr_t nativeStackLimit;

    static const size_t RuntimeMainThreadOffset = __builtin_offsetof (RuntimeDummy, mainThread);

    static inline PerThreadDataFriendFields *get(js::PerThreadData *pt) {
        return reinterpret_cast<PerThreadDataFriendFields *>(pt);
    }

    static inline PerThreadDataFriendFields *getMainThread(JSRuntime *rt) {


        return reinterpret_cast<PerThreadDataFriendFields *>(
            reinterpret_cast<char*>(rt) + RuntimeMainThreadOffset);
    }

    static inline const PerThreadDataFriendFields *getMainThread(const JSRuntime *rt) {


        return reinterpret_cast<const PerThreadDataFriendFields *>(
            reinterpret_cast<const char*>(rt) + RuntimeMainThreadOffset);
    }
};

}
# 26 "../../dist/include/jsapi.h" 2


# 1 "../../dist/include/js/Anchor.h" 1
# 15 "../../dist/include/js/Anchor.h"
class JSFunction;
class JSObject;
class JSScript;
class JSString;

namespace JS { class Value; }

namespace JS {
# 84 "../../dist/include/js/Anchor.h"
template<typename T> class AnchorPermitted;
template<> class AnchorPermitted<JSObject *> { };
template<> class AnchorPermitted<const JSObject *> { };
template<> class AnchorPermitted<JSFunction *> { };
template<> class AnchorPermitted<const JSFunction *> { };
template<> class AnchorPermitted<JSString *> { };
template<> class AnchorPermitted<const JSString *> { };
template<> class AnchorPermitted<Value> { };
template<> class AnchorPermitted<const JSScript *> { };
template<> class AnchorPermitted<JSScript *> { };

template<typename T>
class Anchor : AnchorPermitted<T>
{
  public:
    Anchor() { }
    explicit Anchor(T t) { hold = t; }
    inline ~Anchor();
    T &get() { return hold; }
    const T &get() const { return hold; }
    void set(const T &t) { hold = t; }
    void operator=(const T &t) { hold = t; }
    void clear() { hold = 0; }

  private:
    T hold;
    Anchor(const Anchor &other) = delete;
    void operator=(const Anchor &other) = delete;
};

template<typename T>
inline Anchor<T>::~Anchor()
{
# 129 "../../dist/include/js/Anchor.h"
    asm volatile("":: "g" (hold) : "memory");
# 159 "../../dist/include/js/Anchor.h"
}

}
# 29 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/js/CallArgs.h" 1
# 38 "../../dist/include/js/CallArgs.h"
# 1 "../../dist/include/js/RootingAPI.h" 1
# 12 "../../dist/include/js/RootingAPI.h"
# 1 "../../dist/include/mozilla/TypeTraits.h" 1
# 13 "../../dist/include/js/RootingAPI.h" 2

# 1 "../../dist/include/js/Utility.h" 1
# 15 "../../dist/include/js/RootingAPI.h" 2


# 1 "../../dist/include/jspubtd.h" 1
# 18 "../../dist/include/js/RootingAPI.h" 2
# 105 "../../dist/include/js/RootingAPI.h"
namespace js {

class Module;

template <typename T>
struct RootMethods {};

template <typename T>
class RootedBase {};

template <typename T>
class HandleBase {};

template <typename T>
class MutableHandleBase {};
# 134 "../../dist/include/js/RootingAPI.h"
struct NullPtr
{
    static void * const constNullValue;
};

}

namespace JS {

template <typename T> class Rooted;

template <typename T> class Handle;
template <typename T> class MutableHandle;


__attribute__((visibility("default"))) bool isGCEnabled();
# 165 "../../dist/include/js/RootingAPI.h"
struct __attribute__((visibility("default"))) NullPtr
{
    static void * const constNullValue;
};
# 178 "../../dist/include/js/RootingAPI.h"
template <typename T>
class Handle : public js::HandleBase<T>
{
    friend class MutableHandle<T>;

  public:

    template <typename S>
    Handle(Handle<S> handle,
           typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0)
    {
        ptr = reinterpret_cast<const T *>(handle.address());
    }


    Handle(js::NullPtr) {
        static_assert((mozilla::IsPointer<T>::value), "js::NullPtr overload not valid for non-pointer types")
                                                                                 ;
        ptr = reinterpret_cast<const T *>(&js::NullPtr::constNullValue);
    }


    Handle(JS::NullPtr) {
        static_assert((mozilla::IsPointer<T>::value), "JS::NullPtr overload not valid for non-pointer types")
                                                                                 ;
        ptr = reinterpret_cast<const T *>(&JS::NullPtr::constNullValue);
    }

    Handle(MutableHandle<T> handle) {
        ptr = handle.address();
    }
# 217 "../../dist/include/js/RootingAPI.h"
    static Handle fromMarkedLocation(const T *p) {
        Handle h;
        h.ptr = p;
        return h;
    }





    template <typename S>
    inline
    Handle(Rooted<S> &root,
           typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);


    template <typename S>
    inline
    Handle(MutableHandle<S> &root,
           typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);

    const T *address() const { return ptr; }
    T get() const { return *ptr; }

    operator T() const { return get(); }
    T operator->() const { return get(); }

    bool operator!=(const T &other) { return *ptr != other; }
    bool operator==(const T &other) { return *ptr == other; }

  private:
    Handle() {}

    const T *ptr;

    template <typename S>
    void operator=(S v) = delete;
};

typedef Handle<JSObject*> HandleObject;
typedef Handle<js::Module*> HandleModule;
typedef Handle<JSFunction*> HandleFunction;
typedef Handle<JSScript*> HandleScript;
typedef Handle<JSString*> HandleString;
typedef Handle<jsid> HandleId;
typedef Handle<Value> HandleValue;
# 272 "../../dist/include/js/RootingAPI.h"
template <typename T>
class MutableHandle : public js::MutableHandleBase<T>
{
  public:
    inline MutableHandle(Rooted<T> *root);

    void set(T v) {
        do { } while(0);
        *ptr = v;
    }
# 290 "../../dist/include/js/RootingAPI.h"
    static MutableHandle fromMarkedLocation(T *p) {
        MutableHandle h;
        h.ptr = p;
        return h;
    }

    T *address() const { return ptr; }
    T get() const { return *ptr; }

    operator T() const { return get(); }
    T operator->() const { return get(); }

  private:
    MutableHandle() {}

    T *ptr;

    template <typename S>
    void operator=(S v) = delete;
};

typedef MutableHandle<JSObject*> MutableHandleObject;
typedef MutableHandle<JSFunction*> MutableHandleFunction;
typedef MutableHandle<JSScript*> MutableHandleScript;
typedef MutableHandle<JSString*> MutableHandleString;
typedef MutableHandle<jsid> MutableHandleId;
typedef MutableHandle<Value> MutableHandleValue;

}

namespace js {





typedef JSObject * RawObject;
typedef JSString * RawString;
typedef jsid RawId;
typedef JS::Value RawValue;







template <typename T>
class InternalHandle {};

template <typename T>
class InternalHandle<T*>
{
    void * const *holder;
    size_t offset;

  public:




    template<typename H>
    InternalHandle(const JS::Handle<H> &handle, T *field)
      : holder((void**)handle.address()), offset(uintptr_t(field) - uintptr_t(handle.get()))
    {}




    template<typename R>
    InternalHandle(const JS::Rooted<R> &root, T *field)
      : holder((void**)root.address()), offset(uintptr_t(field) - uintptr_t(root.get()))
    {}

    T *get() const { return reinterpret_cast<T*>(uintptr_t(*holder) + offset); }

    const T &operator*() const { return *get(); }
    T *operator->() const { return get(); }

    static InternalHandle<T*> fromMarkedLocation(T *fieldPtr) {
        return InternalHandle(fieldPtr);
    }

  private:
# 383 "../../dist/include/js/RootingAPI.h"
    InternalHandle(T *field)
      : holder(reinterpret_cast<void * const *>(&js::NullPtr::constNullValue)),
        offset(uintptr_t(field))
    {}
};
# 408 "../../dist/include/js/RootingAPI.h"
template <typename T>
struct RootKind<T *>
{
    static ThingRootKind rootKind() { return T::rootKind(); }
};

template <typename T>
struct RootMethods<T *>
{
    static T *initial() { return __null; }
    static ThingRootKind kind() { return RootKind<T *>::rootKind(); }
    static bool poisoned(T *v) { return JS::IsPoisonedPtr(v); }
};

}

namespace JS {
# 434 "../../dist/include/js/RootingAPI.h"
template <typename T>
class Rooted : public js::RootedBase<T>
{
    void init(JSContext *cxArg) {




    }

    void init(js::PerThreadData *ptArg) {




    }

  public:
    Rooted(JSContext *cx
           )
      : ptr(js::RootMethods<T>::initial())
    {
        do { } while (0);
        init(cx);
    }

    Rooted(JSContext *cx, T initial
           )
      : ptr(initial)
    {
        do { } while (0);
        init(cx);
    }

    Rooted(js::PerThreadData *pt
           )
      : ptr(js::RootMethods<T>::initial())
    {
        do { } while (0);
        init(pt);
    }

    Rooted(js::PerThreadData *pt, T initial
           )
      : ptr(initial)
    {
        do { } while (0);
        init(pt);
    }

    ~Rooted() {




    }





    operator T() const { return ptr; }
    T operator->() const { return ptr; }
    T *address() { return &ptr; }
    const T *address() const { return &ptr; }
    T &get() { return ptr; }
    const T &get() const { return ptr; }

    T &operator=(T value) {
        do { } while(0);
        ptr = value;
        return ptr;
    }

    T &operator=(const Rooted &value) {
        ptr = value;
        return ptr;
    }

    bool operator!=(const T &other) { return ptr != other; }
    bool operator==(const T &other) { return ptr == other; }

  private:
    void commonInit(Rooted<void*> **thingGCRooters) {
# 526 "../../dist/include/js/RootingAPI.h"
    }
# 542 "../../dist/include/js/RootingAPI.h"
    T ptr;

   

    Rooted(const Rooted &) = delete;
};



template <>
class Rooted<JSStableString *>;


typedef Rooted<JSObject*> RootedObject;
typedef Rooted<js::Module*> RootedModule;
typedef Rooted<JSFunction*> RootedFunction;
typedef Rooted<JSScript*> RootedScript;
typedef Rooted<JSString*> RootedString;
typedef Rooted<jsid> RootedId;
typedef Rooted<JS::Value> RootedValue;

}

namespace js {







class SkipRoot
{
# 621 "../../dist/include/js/RootingAPI.h"
  public:
    template <typename T>
    SkipRoot(JSContext *cx, const T *ptr, size_t count = 1
             )
    {
        do { } while (0);
    }

    template <typename T>
    SkipRoot(PerThreadData *ptd, const T *ptr, size_t count = 1
             )
    {
        do { } while (0);
    }



   
};


template <typename T>
class FakeRooted : public RootedBase<T>
{
  public:
    FakeRooted(JSContext *cx
                )
      : ptr(RootMethods<T>::initial())
    {
        do { } while (0);
    }

    FakeRooted(JSContext *cx, T initial
                )
      : ptr(initial)
    {
        do { } while (0);
    }

    operator T() const { return ptr; }
    T operator->() const { return ptr; }
    T *address() { return &ptr; }
    const T *address() const { return &ptr; }
    T &get() { return ptr; }
    const T &get() const { return ptr; }

    T &operator=(T value) {
        do { } while(0);
        ptr = value;
        return ptr;
    }

    bool operator!=(const T &other) { return ptr != other; }
    bool operator==(const T &other) { return ptr == other; }

  private:
    T ptr;

   

    FakeRooted(const FakeRooted &) = delete;
};


template <typename T>
class FakeMutableHandle : public js::MutableHandleBase<T>
{
  public:
    FakeMutableHandle(T *t) {
        ptr = t;
    }

    FakeMutableHandle(FakeRooted<T> *root) {
        ptr = root->address();
    }

    void set(T v) {
        do { } while(0);
        *ptr = v;
    }

    T *address() const { return ptr; }
    T get() const { return *ptr; }

    operator T() const { return get(); }
    T operator->() const { return get(); }

  private:
    FakeMutableHandle() {}

    T *ptr;

    template <typename S>
    void operator=(S v) = delete;
};
# 726 "../../dist/include/js/RootingAPI.h"
enum AllowGC {
    NoGC = 0,
    CanGC = 1
};
template <typename T, AllowGC allowGC>
class MaybeRooted
{
};

template <typename T> class MaybeRooted<T, CanGC>
{
  public:
    typedef JS::Handle<T> HandleType;
    typedef JS::Rooted<T> RootType;
    typedef JS::MutableHandle<T> MutableHandleType;

    static inline JS::Handle<T> toHandle(HandleType v) {
        return v;
    }

    static inline JS::MutableHandle<T> toMutableHandle(MutableHandleType v) {
        return v;
    }
};

template <typename T> class MaybeRooted<T, NoGC>
{
  public:
    typedef T HandleType;
    typedef FakeRooted<T> RootType;
    typedef FakeMutableHandle<T> MutableHandleType;

    static inline JS::Handle<T> toHandle(HandleType v) {
        __builtin_unreachable();
        return JS::Handle<T>::fromMarkedLocation(__null);
    }

    static inline JS::MutableHandle<T> toMutableHandle(MutableHandleType v) {
        __builtin_unreachable();
        return JS::MutableHandle<T>::fromMarkedLocation(__null);
    }
};

}

namespace JS {

template <typename T> template <typename S>
inline
Handle<T>::Handle(Rooted<S> &root,
                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
{
    ptr = reinterpret_cast<const T *>(root.address());
}

template <typename T> template <typename S>
inline
Handle<T>::Handle(MutableHandle<S> &root,
                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
{
    ptr = reinterpret_cast<const T *>(root.address());
}

template <typename T>
inline
MutableHandle<T>::MutableHandle(Rooted<T> *root)
{
    ptr = root->address();
}

}

namespace js {





inline void MaybeCheckStackRoots(JSContext *cx)
{



}

namespace gc {
struct Cell;
}


class CompilerRootNode
{
  protected:
    CompilerRootNode(js::gc::Cell *ptr) : next(__null), ptr_(ptr) {}

  public:
    void **address() { return (void **)&ptr_; }

  public:
    CompilerRootNode *next;

  protected:
    js::gc::Cell *ptr_;
};

}

class JSScript; namespace js { typedef JSScript * RawScript; } class JSScript;
class JSFunction; namespace js { typedef JSFunction * RawFunction; } class JSFunction;
class JSObject; namespace js { typedef JSObject * RawObject; } class JSObject;
# 39 "../../dist/include/js/CallArgs.h" 2
# 1 "../../dist/include/js/Value.h" 1
# 14 "../../dist/include/js/Value.h"
# 1 "../../dist/include/mozilla/FloatingPoint.h" 1
# 15 "../../dist/include/js/Value.h" 2
# 1 "../../dist/include/mozilla/Likely.h" 1
# 16 "../../dist/include/js/Value.h" 2

# 1 "../../dist/stl_wrappers/limits" 1
# 18 "../../dist/stl_wrappers/limits"
       
# 19 "../../dist/stl_wrappers/limits" 3
# 33 "../../dist/stl_wrappers/limits" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/limits" 2 3
# 54 "../../dist/stl_wrappers/limits" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/limits" 1 3
       
# 2 "../../dist/system_wrappers/limits" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/limits" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/limits" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/limits" 3
# 148 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 192 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;



    static constexpr bool is_integer = false;





    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;





    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 303 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return static_cast<_Tp>(0); }


      static constexpr _Tp
      max() noexcept { return static_cast<_Tp>(0); }




      static constexpr _Tp
      lowest() noexcept { return static_cast<_Tp>(0); }




      static constexpr _Tp
      epsilon() noexcept { return static_cast<_Tp>(0); }


      static constexpr _Tp
      round_error() noexcept { return static_cast<_Tp>(0); }


      static constexpr _Tp
      infinity() noexcept { return static_cast<_Tp>(0); }



      static constexpr _Tp
      quiet_NaN() noexcept { return static_cast<_Tp>(0); }



      static constexpr _Tp
      signaling_NaN() noexcept { return static_cast<_Tp>(0); }




      static constexpr _Tp
      denorm_min() noexcept { return static_cast<_Tp>(0); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<__int128>
    {
      static constexpr bool is_specialized = true;

      static constexpr __int128
      min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); }

      static constexpr __int128
      max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); }


      static constexpr __int128
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(__int128) * 8 - ((__int128)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr __int128
      epsilon() noexcept { return 0; }

      static constexpr __int128
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr __int128
      infinity() noexcept
      { return static_cast<__int128>(0); }

      static constexpr __int128
      quiet_NaN() noexcept
      { return static_cast<__int128>(0); }

      static constexpr __int128
      signaling_NaN() noexcept
      { return static_cast<__int128>(0); }

      static constexpr __int128
      denorm_min() noexcept
      { return static_cast<__int128>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps
       = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned __int128>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned __int128
      min() noexcept { return 0; }

      static constexpr unsigned __int128
      max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); }


      static constexpr unsigned __int128
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned __int128
      epsilon() noexcept { return 0; }

      static constexpr unsigned __int128
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned __int128
      infinity() noexcept
      { return static_cast<unsigned __int128>(0); }

      static constexpr unsigned __int128
      quiet_NaN() noexcept
      { return static_cast<unsigned __int128>(0); }

      static constexpr unsigned __int128
      signaling_NaN() noexcept
      { return static_cast<unsigned __int128>(0); }

      static constexpr unsigned __int128
      denorm_min() noexcept
      { return static_cast<unsigned __int128>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 4 "../../dist/system_wrappers/limits" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/limits" 2 3
#pragma GCC visibility pop
# 18 "../../dist/include/js/Value.h" 2

# 1 "../../dist/include/js/Anchor.h" 1
# 20 "../../dist/include/js/Value.h" 2



namespace JS { class Value; }
# 68 "../../dist/include/js/Value.h"
enum JSValueType
{
    JSVAL_TYPE_DOUBLE = 0x00,
    JSVAL_TYPE_INT32 = 0x01,
    JSVAL_TYPE_UNDEFINED = 0x02,
    JSVAL_TYPE_BOOLEAN = 0x03,
    JSVAL_TYPE_MAGIC = 0x04,
    JSVAL_TYPE_STRING = 0x05,
    JSVAL_TYPE_NULL = 0x06,
    JSVAL_TYPE_OBJECT = 0x07,


    JSVAL_TYPE_UNKNOWN = 0x20,
    JSVAL_TYPE_MISSING = 0x21
} __attribute__((packed));

static_assert((sizeof(JSValueType) == 1), "JS_STATIC_ASSERT");
# 106 "../../dist/include/js/Value.h"
enum JSValueTag
{
    JSVAL_TAG_MAX_DOUBLE = 0x1FFF0,
    JSVAL_TAG_INT32 = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_INT32,
    JSVAL_TAG_UNDEFINED = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_UNDEFINED,
    JSVAL_TAG_STRING = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_STRING,
    JSVAL_TAG_BOOLEAN = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_BOOLEAN,
    JSVAL_TAG_MAGIC = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_MAGIC,
    JSVAL_TAG_NULL = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_NULL,
    JSVAL_TAG_OBJECT = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_OBJECT
} __attribute__((packed));

static_assert((sizeof(JSValueTag) == sizeof(uint32_t)), "JS_STATIC_ASSERT");

enum JSValueShiftedTag
{
    JSVAL_SHIFTED_TAG_MAX_DOUBLE = ((((uint64_t)JSVAL_TAG_MAX_DOUBLE) << 47) | 0xFFFFFFFF),
    JSVAL_SHIFTED_TAG_INT32 = (((uint64_t)JSVAL_TAG_INT32) << 47),
    JSVAL_SHIFTED_TAG_UNDEFINED = (((uint64_t)JSVAL_TAG_UNDEFINED) << 47),
    JSVAL_SHIFTED_TAG_STRING = (((uint64_t)JSVAL_TAG_STRING) << 47),
    JSVAL_SHIFTED_TAG_BOOLEAN = (((uint64_t)JSVAL_TAG_BOOLEAN) << 47),
    JSVAL_SHIFTED_TAG_MAGIC = (((uint64_t)JSVAL_TAG_MAGIC) << 47),
    JSVAL_SHIFTED_TAG_NULL = (((uint64_t)JSVAL_TAG_NULL) << 47),
    JSVAL_SHIFTED_TAG_OBJECT = (((uint64_t)JSVAL_TAG_OBJECT) << 47)
} __attribute__((packed));

static_assert((sizeof(JSValueShiftedTag) == sizeof(uint64_t)), "JS_STATIC_ASSERT");
# 219 "../../dist/include/js/Value.h"
typedef enum JSWhyMagic
{
    JS_ELEMENTS_HOLE,
    JS_NATIVE_ENUMERATE,


    JS_NO_ITER_VALUE,
    JS_GENERATOR_CLOSING,
    JS_NO_CONSTANT,
    JS_THIS_POISON,
    JS_ARG_POISON,
    JS_SERIALIZE_NO_NODE,
    JS_LAZY_ARGUMENTS,
    JS_OPTIMIZED_ARGUMENTS,
    JS_IS_CONSTRUCTING,
    JS_OVERWRITTEN_CALLEE,
    JS_FORWARD_TO_CALL_OBJECT,
    JS_BLOCK_NEEDS_CLONE,
    JS_HASH_KEY_EMPTY,
    JS_ION_ERROR,
    JS_ION_BAILOUT,
    JS_GENERIC_MAGIC
} JSWhyMagic;
# 266 "../../dist/include/js/Value.h"
typedef union jsval_layout
{
    uint64_t asBits;


    struct {
        uint64_t payload47 : 47;
        JSValueTag tag : 17;
    } debugView;

    struct {
        union {
            int32_t i32;
            uint32_t u32;
            JSWhyMagic why;
        } payload;
    } s;
    double asDouble;
    void *asPtr;
    size_t asWord;
    uintptr_t asUIntPtr;
} __attribute__((aligned (8))) jsval_layout;
# 335 "../../dist/include/js/Value.h"
static_assert((sizeof(jsval_layout) == 8), "JS_STATIC_ASSERT");
# 574 "../../dist/include/js/Value.h"
static inline jsval_layout
BUILD_JSVAL(JSValueTag tag, uint64_t payload)
{
    jsval_layout l;
    l.asBits = (((uint64_t)(uint32_t)tag) << 47) | payload;
    return l;
}

static inline JSBool
JSVAL_IS_DOUBLE_IMPL(jsval_layout l)
{
    return l.asBits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE;
}

static inline jsval_layout
DOUBLE_TO_JSVAL_IMPL(double d)
{
    jsval_layout l;
    l.asDouble = d;
    do { } while(0);
    return l;
}

static inline JSBool
JSVAL_IS_INT32_IMPL(jsval_layout l)
{
    return (uint32_t)(l.asBits >> 47) == JSVAL_TAG_INT32;
}

static inline int32_t
JSVAL_TO_INT32_IMPL(jsval_layout l)
{
    return (int32_t)l.asBits;
}

static inline jsval_layout
INT32_TO_JSVAL_IMPL(int32_t i32)
{
    jsval_layout l;
    l.asBits = ((uint64_t)(uint32_t)i32) | JSVAL_SHIFTED_TAG_INT32;
    return l;
}

static inline JSBool
JSVAL_IS_NUMBER_IMPL(jsval_layout l)
{
    return l.asBits < JSVAL_SHIFTED_TAG_UNDEFINED;
}

static inline JSBool
JSVAL_IS_UNDEFINED_IMPL(jsval_layout l)
{
    return l.asBits == JSVAL_SHIFTED_TAG_UNDEFINED;
}

static inline JSBool
JSVAL_IS_STRING_IMPL(jsval_layout l)
{
    return (uint32_t)(l.asBits >> 47) == JSVAL_TAG_STRING;
}

static inline jsval_layout
STRING_TO_JSVAL_IMPL(JSString *str)
{
    jsval_layout l;
    uint64_t strBits = (uint64_t)str;
    do { } while(0);
    do { } while(0);
    l.asBits = strBits | JSVAL_SHIFTED_TAG_STRING;
    return l;
}

static inline JSString *
JSVAL_TO_STRING_IMPL(jsval_layout l)
{
    return (JSString *)(l.asBits & 0x00007FFFFFFFFFFFLL);
}

static inline JSBool
JSVAL_IS_BOOLEAN_IMPL(jsval_layout l)
{
    return (uint32_t)(l.asBits >> 47) == JSVAL_TAG_BOOLEAN;
}

static inline JSBool
JSVAL_TO_BOOLEAN_IMPL(jsval_layout l)
{
    return (JSBool)l.asBits;
}

static inline jsval_layout
BOOLEAN_TO_JSVAL_IMPL(JSBool b)
{
    jsval_layout l;
    do { } while(0);
    l.asBits = ((uint64_t)(uint32_t)b) | JSVAL_SHIFTED_TAG_BOOLEAN;
    return l;
}

static inline JSBool
JSVAL_IS_MAGIC_IMPL(jsval_layout l)
{
    return (l.asBits >> 47) == JSVAL_TAG_MAGIC;
}

static inline JSBool
JSVAL_IS_PRIMITIVE_IMPL(jsval_layout l)
{
    return l.asBits < JSVAL_SHIFTED_TAG_OBJECT;
}

static inline JSBool
JSVAL_IS_OBJECT_IMPL(jsval_layout l)
{
    do { } while(0);
    return l.asBits >= JSVAL_SHIFTED_TAG_OBJECT;
}

static inline JSBool
JSVAL_IS_OBJECT_OR_NULL_IMPL(jsval_layout l)
{
    do { } while(0);
    return l.asBits >= JSVAL_SHIFTED_TAG_NULL;
}

static inline JSObject *
JSVAL_TO_OBJECT_IMPL(jsval_layout l)
{
    uint64_t ptrBits = l.asBits & 0x00007FFFFFFFFFFFLL;
    do { } while(0);
    return (JSObject *)ptrBits;
}

static inline jsval_layout
OBJECT_TO_JSVAL_IMPL(JSObject *obj)
{
    jsval_layout l;
    uint64_t objBits = (uint64_t)obj;
    do { } while(0);
    do { } while(0);
    l.asBits = objBits | JSVAL_SHIFTED_TAG_OBJECT;
    return l;
}

static inline JSBool
JSVAL_IS_NULL_IMPL(jsval_layout l)
{
    return l.asBits == JSVAL_SHIFTED_TAG_NULL;
}

static inline JSBool
JSVAL_IS_GCTHING_IMPL(jsval_layout l)
{
    return l.asBits >= JSVAL_SHIFTED_TAG_STRING;
}

static inline void *
JSVAL_TO_GCTHING_IMPL(jsval_layout l)
{
    uint64_t ptrBits = l.asBits & 0x00007FFFFFFFFFFFLL;
    do { } while(0);
    return (void *)ptrBits;
}

static inline JSBool
JSVAL_IS_TRACEABLE_IMPL(jsval_layout l)
{
    return JSVAL_IS_GCTHING_IMPL(l) && !JSVAL_IS_NULL_IMPL(l);
}

static inline uint32_t
JSVAL_TRACE_KIND_IMPL(jsval_layout l)
{
    return (uint32_t)(JSBool)!(JSVAL_IS_OBJECT_IMPL(l));
}

static inline jsval_layout
PRIVATE_PTR_TO_JSVAL_IMPL(void *ptr)
{
    jsval_layout l;
    uint64_t ptrBits = (uint64_t)ptr;
    do { } while(0);
    l.asBits = ptrBits >> 1;
    do { } while(0);
    return l;
}

static inline void *
JSVAL_TO_PRIVATE_PTR_IMPL(jsval_layout l)
{
    do { } while(0);
    return (void *)(l.asBits << 1);
}

static inline JSBool
JSVAL_IS_SPECIFIC_INT32_IMPL(jsval_layout l, int32_t i32)
{
    return l.asBits == (((uint64_t)(uint32_t)i32) | JSVAL_SHIFTED_TAG_INT32);
}

static inline JSBool
JSVAL_IS_SPECIFIC_BOOLEAN(jsval_layout l, JSBool b)
{
    return l.asBits == (((uint64_t)(uint32_t)b) | JSVAL_SHIFTED_TAG_BOOLEAN);
}

static inline jsval_layout
MAGIC_TO_JSVAL_IMPL(JSWhyMagic why)
{
    jsval_layout l;
    l.asBits = ((uint64_t)(uint32_t)why) | JSVAL_SHIFTED_TAG_MAGIC;
    return l;
}

static inline JSBool
JSVAL_SAME_TYPE_IMPL(jsval_layout lhs, jsval_layout rhs)
{
    uint64_t lbits = lhs.asBits, rbits = rhs.asBits;
    return (lbits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE && rbits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE) ||
           (((lbits ^ rbits) & 0xFFFF800000000000LL) == 0);
}

static inline JSValueType
JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL(jsval_layout l)
{
   uint64_t type = (l.asBits >> 47) & 0xF;
   do { } while(0);
   return (JSValueType)type;
}



static inline double
JS_CANONICALIZE_NAN(double d)
{
    if ((__builtin_expect(!!(d != d), 0))) {
        jsval_layout l;
        l.asBits = 0x7FF8000000000000LL;
        return l.asDouble;
    }
    return d;
}

static inline jsval_layout JSVAL_TO_IMPL(JS::Value v);
static inline JS::Value IMPL_TO_JSVAL(jsval_layout l);

namespace JS {
# 857 "../../dist/include/js/Value.h"
class Value
{
  public:







    void setNull() {
        data.asBits = BUILD_JSVAL(JSVAL_TAG_NULL, 0).asBits;
    }

    void setUndefined() {
        data.asBits = BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0).asBits;
    }

    void setInt32(int32_t i) {
        data = INT32_TO_JSVAL_IMPL(i);
    }

    int32_t &getInt32Ref() {
        do { } while(0);
        return data.s.payload.i32;
    }

    void setDouble(double d) {
        data = DOUBLE_TO_JSVAL_IMPL(d);
    }

    double &getDoubleRef() {
        do { } while(0);
        return data.asDouble;
    }

    void setString(JSString *str) {
        do { } while(0);
        data = STRING_TO_JSVAL_IMPL(str);
    }

    void setString(const JS::Anchor<JSString *> &str) {
        setString(str.get());
    }

    void setObject(JSObject &obj) {
        do { } while(0);
        data = OBJECT_TO_JSVAL_IMPL(&obj);
    }

    void setBoolean(bool b) {
        data = BOOLEAN_TO_JSVAL_IMPL(b);
    }

    void setMagic(JSWhyMagic why) {
        data = MAGIC_TO_JSVAL_IMPL(why);
    }

    bool setNumber(uint32_t ui) {
        if (ui > ((int32_t)0x7fffffff)) {
            setDouble((double)ui);
            return false;
        } else {
            setInt32((int32_t)ui);
            return true;
        }
    }

    bool setNumber(double d) {
        int32_t i;
        if (MOZ_DOUBLE_IS_INT32(d, &i)) {
            setInt32(i);
            return true;
        } else {
            setDouble(d);
            return false;
        }
    }

    void setObjectOrNull(JSObject *arg) {
        if (arg)
            setObject(*arg);
        else
            setNull();
    }

    void swap(Value &rhs) {
        uint64_t tmp = rhs.data.asBits;
        rhs.data.asBits = data.asBits;
        data.asBits = tmp;
    }



    bool isUndefined() const {
        return JSVAL_IS_UNDEFINED_IMPL(data);
    }

    bool isNull() const {
        return JSVAL_IS_NULL_IMPL(data);
    }

    bool isNullOrUndefined() const {
        return isNull() || isUndefined();
    }

    bool isInt32() const {
        return JSVAL_IS_INT32_IMPL(data);
    }

    bool isInt32(int32_t i32) const {
        return JSVAL_IS_SPECIFIC_INT32_IMPL(data, i32);
    }

    bool isDouble() const {
        return JSVAL_IS_DOUBLE_IMPL(data);
    }

    bool isNumber() const {
        return JSVAL_IS_NUMBER_IMPL(data);
    }

    bool isString() const {
        return JSVAL_IS_STRING_IMPL(data);
    }

    bool isObject() const {
        return JSVAL_IS_OBJECT_IMPL(data);
    }

    bool isPrimitive() const {
        return JSVAL_IS_PRIMITIVE_IMPL(data);
    }

    bool isObjectOrNull() const {
        return JSVAL_IS_OBJECT_OR_NULL_IMPL(data);
    }

    bool isGCThing() const {
        return JSVAL_IS_GCTHING_IMPL(data);
    }

    bool isBoolean() const {
        return JSVAL_IS_BOOLEAN_IMPL(data);
    }

    bool isTrue() const {
        return JSVAL_IS_SPECIFIC_BOOLEAN(data, true);
    }

    bool isFalse() const {
        return JSVAL_IS_SPECIFIC_BOOLEAN(data, false);
    }

    bool isMagic() const {
        return JSVAL_IS_MAGIC_IMPL(data);
    }

    bool isMagic(JSWhyMagic why) const {
        do { } while (0);
        return JSVAL_IS_MAGIC_IMPL(data);
    }

    bool isMarkable() const {
        return JSVAL_IS_TRACEABLE_IMPL(data);
    }

    JSGCTraceKind gcKind() const {
        do { } while(0);
        return JSGCTraceKind(JSVAL_TRACE_KIND_IMPL(data));
    }

    JSWhyMagic whyMagic() const {
        do { } while(0);
        return data.s.payload.why;
    }



    bool operator==(const Value &rhs) const {
        return data.asBits == rhs.data.asBits;
    }

    bool operator!=(const Value &rhs) const {
        return data.asBits != rhs.data.asBits;
    }

    friend inline bool SameType(const Value &lhs, const Value &rhs);



    int32_t toInt32() const {
        do { } while(0);
        return JSVAL_TO_INT32_IMPL(data);
    }

    double toDouble() const {
        do { } while(0);
        return data.asDouble;
    }

    double toNumber() const {
        do { } while(0);
        return isDouble() ? toDouble() : double(toInt32());
    }

    JSString *toString() const {
        do { } while(0);
        return JSVAL_TO_STRING_IMPL(data);
    }

    JSObject &toObject() const {
        do { } while(0);
        return *JSVAL_TO_OBJECT_IMPL(data);
    }

    JSObject *toObjectOrNull() const {
        do { } while(0);
        return JSVAL_TO_OBJECT_IMPL(data);
    }

    void *toGCThing() const {
        do { } while(0);
        return JSVAL_TO_GCTHING_IMPL(data);
    }

    bool toBoolean() const {
        do { } while(0);
        return JSVAL_TO_BOOLEAN_IMPL(data);
    }

    uint32_t payloadAsRawUint32() const {
        do { } while(0);
        return data.s.payload.u32;
    }

    uint64_t asRawBits() const {
        return data.asBits;
    }

    JSValueType extractNonDoubleType() const {
        return JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL(data);
    }
# 1110 "../../dist/include/js/Value.h"
    void setPrivate(void *ptr) {
        data = PRIVATE_PTR_TO_JSVAL_IMPL(ptr);
    }

    void *toPrivate() const {
        do { } while(0);
        return JSVAL_TO_PRIVATE_PTR_IMPL(data);
    }

    void setPrivateUint32(uint32_t ui) {
        do { } while(0);
        setInt32(int32_t(ui));
    }

    uint32_t toPrivateUint32() const {
        return uint32_t(toInt32());
    }







    void setUnmarkedPtr(void *ptr) {
        data.asPtr = ptr;
    }

    void *toUnmarkedPtr() const {
        return data.asPtr;
    }

    const size_t *payloadWord() const {



        return &data.asWord;

    }

    const uintptr_t *payloadUIntPtr() const {



        return &data.asUIntPtr;

    }





  private:


    jsval_layout data;

  private:
    void staticAssertions() {
        static_assert((sizeof(JSValueType) == 1), "JS_STATIC_ASSERT");
        static_assert((sizeof(JSValueTag) == 4), "JS_STATIC_ASSERT");
        static_assert((sizeof(JSBool) == 4), "JS_STATIC_ASSERT");
        static_assert((sizeof(JSWhyMagic) <= 4), "JS_STATIC_ASSERT");
        static_assert((sizeof(Value) == 8), "JS_STATIC_ASSERT");
    }

    friend jsval_layout (::JSVAL_TO_IMPL)(Value);
    friend Value (::IMPL_TO_JSVAL)(jsval_layout l);
};

inline bool
IsPoisonedValue(const Value &v)
{
    if (v.isString())
        return IsPoisonedPtr(v.toString());
    if (v.isObject())
        return IsPoisonedPtr(&v.toObject());
    return false;
}



static inline Value
NullValue()
{
    Value v;
    v.setNull();
    return v;
}

static inline Value
UndefinedValue()
{
    Value v;
    v.setUndefined();
    return v;
}

static inline Value
Int32Value(int32_t i32)
{
    Value v;
    v.setInt32(i32);
    return v;
}

static inline Value
DoubleValue(double dbl)
{
    Value v;
    v.setDouble(dbl);
    return v;
}

static inline Value
StringValue(JSString *str)
{
    Value v;
    v.setString(str);
    return v;
}

static inline Value
BooleanValue(bool boo)
{
    Value v;
    v.setBoolean(boo);
    return v;
}

static inline Value
ObjectValue(JSObject &obj)
{
    Value v;
    v.setObject(obj);
    return v;
}

static inline Value
ObjectValueCrashOnTouch()
{
    Value v;
    v.setObject(*reinterpret_cast<JSObject *>(0x42));
    return v;
}

static inline Value
MagicValue(JSWhyMagic why)
{
    Value v;
    v.setMagic(why);
    return v;
}

static inline Value
NumberValue(float f)
{
    Value v;
    v.setNumber(f);
    return v;
}

static inline Value
NumberValue(double dbl)
{
    Value v;
    v.setNumber(dbl);
    return v;
}

static inline Value
NumberValue(int8_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(uint8_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(int16_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(uint16_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(int32_t i)
{
    return Int32Value(i);
}

static inline Value
NumberValue(uint32_t i)
{
    Value v;
    v.setNumber(i);
    return v;
}

namespace detail {

template <bool Signed>
class MakeNumberValue
{
  public:
    template<typename T>
    static inline Value create(const T t)
    {
        Value v;
        if (((int32_t)0x80000000) <= t && t <= ((int32_t)0x7fffffff))
            v.setInt32(int32_t(t));
        else
            v.setDouble(double(t));
        return v;
    }
};

template <>
class MakeNumberValue<false>
{
  public:
    template<typename T>
    static inline Value create(const T t)
    {
        Value v;
        if (t <= ((int32_t)0x7fffffff))
            v.setInt32(int32_t(t));
        else
            v.setDouble(double(t));
        return v;
    }
};

}

template <typename T>
static inline Value
NumberValue(const T t)
{
    do { } while(0);
    return detail::MakeNumberValue<std::numeric_limits<T>::is_signed>::create(t);
}

static inline Value
ObjectOrNullValue(JSObject *obj)
{
    Value v;
    v.setObjectOrNull(obj);
    return v;
}

static inline Value
PrivateValue(void *ptr)
{
    Value v;
    v.setPrivate(ptr);
    return v;
}

static inline Value
PrivateUint32Value(uint32_t ui)
{
    Value v;
    v.setPrivateUint32(ui);
    return v;
}

inline bool
SameType(const Value &lhs, const Value &rhs)
{
    return JSVAL_SAME_TYPE_IMPL(lhs.data, rhs.data);
}

}



namespace js {

template <> struct RootMethods<const JS::Value>
{
    static JS::Value initial() { return JS::UndefinedValue(); }
    static ThingRootKind kind() { return THING_ROOT_VALUE; }
    static bool poisoned(const JS::Value &v) { return JS::IsPoisonedValue(v); }
};

template <> struct RootMethods<JS::Value>
{
    static JS::Value initial() { return JS::UndefinedValue(); }
    static ThingRootKind kind() { return THING_ROOT_VALUE; }
    static bool poisoned(const JS::Value &v) { return JS::IsPoisonedValue(v); }
};

template <class Outer> class MutableValueOperations;







template <class Outer>
class ValueOperations
{
    friend class MutableValueOperations<Outer>;
    const JS::Value * value() const { return static_cast<const Outer*>(this)->extract(); }

  public:
    bool isUndefined() const { return value()->isUndefined(); }
    bool isNull() const { return value()->isNull(); }
    bool isBoolean() const { return value()->isBoolean(); }
    bool isTrue() const { return value()->isTrue(); }
    bool isFalse() const { return value()->isFalse(); }
    bool isNumber() const { return value()->isNumber(); }
    bool isInt32() const { return value()->isInt32(); }
    bool isDouble() const { return value()->isDouble(); }
    bool isString() const { return value()->isString(); }
    bool isObject() const { return value()->isObject(); }
    bool isMagic() const { return value()->isMagic(); }
    bool isMagic(JSWhyMagic why) const { return value()->isMagic(why); }
    bool isMarkable() const { return value()->isMarkable(); }
    bool isPrimitive() const { return value()->isPrimitive(); }
    bool isGCThing() const { return value()->isGCThing(); }

    bool isNullOrUndefined() const { return value()->isNullOrUndefined(); }
    bool isObjectOrNull() const { return value()->isObjectOrNull(); }

    bool toBoolean() const { return value()->toBoolean(); }
    double toNumber() const { return value()->toNumber(); }
    int32_t toInt32() const { return value()->toInt32(); }
    double toDouble() const { return value()->toDouble(); }
    JSString *toString() const { return value()->toString(); }
    JSObject &toObject() const { return value()->toObject(); }
    JSObject *toObjectOrNull() const { return value()->toObjectOrNull(); }
    void *toGCThing() const { return value()->toGCThing(); }

    JSValueType extractNonDoubleType() const { return value()->extractNonDoubleType(); }

    JSWhyMagic whyMagic() const { return value()->whyMagic(); }
};







template <class Outer>
class MutableValueOperations : public ValueOperations<Outer>
{
    JS::Value * value() { return static_cast<Outer*>(this)->extractMutable(); }

  public:
    void setNull() { value()->setNull(); }
    void setUndefined() { value()->setUndefined(); }
    void setInt32(int32_t i) { value()->setInt32(i); }
    void setDouble(double d) { value()->setDouble(d); }
    void setString(JSString *str) { value()->setString(str); }
    void setString(const JS::Anchor<JSString *> &str) { value()->setString(str); }
    void setObject(JSObject &obj) { value()->setObject(obj); }
    void setBoolean(bool b) { value()->setBoolean(b); }
    void setMagic(JSWhyMagic why) { value()->setMagic(why); }
    bool setNumber(uint32_t ui) { return value()->setNumber(ui); }
    bool setNumber(double d) { return value()->setNumber(d); }
    void setObjectOrNull(JSObject *arg) { value()->setObjectOrNull(arg); }
};





template <>
class HandleBase<JS::Value> : public ValueOperations<JS::Handle<JS::Value> >
{
    friend class ValueOperations<JS::Handle<JS::Value> >;
    const JS::Value * extract() const {
        return static_cast<const JS::Handle<JS::Value>*>(this)->address();
    }
};





template <>
class MutableHandleBase<JS::Value> : public MutableValueOperations<JS::MutableHandle<JS::Value> >
{
    friend class ValueOperations<JS::MutableHandle<JS::Value> >;
    const JS::Value * extract() const {
        return static_cast<const JS::MutableHandle<JS::Value>*>(this)->address();
    }

    friend class MutableValueOperations<JS::MutableHandle<JS::Value> >;
    JS::Value * extractMutable() {
        return static_cast<JS::MutableHandle<JS::Value>*>(this)->address();
    }
};





template <>
class RootedBase<JS::Value> : public MutableValueOperations<JS::Rooted<JS::Value> >
{
    friend class ValueOperations<JS::Rooted<JS::Value> >;
    const JS::Value * extract() const {
        return static_cast<const JS::Rooted<JS::Value>*>(this)->address();
    }

    friend class MutableValueOperations<JS::Rooted<JS::Value> >;
    JS::Value * extractMutable() {
        return static_cast<JS::Rooted<JS::Value>*>(this)->address();
    }
};

}

inline jsval_layout
JSVAL_TO_IMPL(JS::Value v)
{
    return v.data;
}

inline JS::Value
IMPL_TO_JSVAL(jsval_layout l)
{
    JS::Value v;
    v.data = l;
    return v;
}

namespace JS {
# 1587 "../../dist/include/js/Value.h"
}






typedef JS::Value jsval;

static_assert((sizeof(jsval_layout) == sizeof(JS::Value)), "jsval_layout and JS::Value must have identical layouts")
                                                                           ;



static inline JSBool
JSVAL_IS_NULL(jsval v)
{
    return JSVAL_IS_NULL_IMPL(JSVAL_TO_IMPL(v));
}

static inline JSBool
JSVAL_IS_VOID(jsval v)
{
    return JSVAL_IS_UNDEFINED_IMPL(JSVAL_TO_IMPL(v));
}

static inline JSBool
JSVAL_IS_INT(jsval v)
{
    return JSVAL_IS_INT32_IMPL(JSVAL_TO_IMPL(v));
}

static inline int32_t
JSVAL_TO_INT(jsval v)
{
    do { } while(0);
    return JSVAL_TO_INT32_IMPL(JSVAL_TO_IMPL(v));
}

static inline jsval
INT_TO_JSVAL(int32_t i)
{
    return IMPL_TO_JSVAL(INT32_TO_JSVAL_IMPL(i));
}

static inline JSBool
JSVAL_IS_DOUBLE(jsval v)
{
    return JSVAL_IS_DOUBLE_IMPL(JSVAL_TO_IMPL(v));
}

static inline double
JSVAL_TO_DOUBLE(jsval v)
{
    jsval_layout l;
    do { } while(0);
    l = JSVAL_TO_IMPL(v);
    return l.asDouble;
}

static inline jsval
DOUBLE_TO_JSVAL(double d)
{






    jsval_layout l;
    if ((__builtin_expect(!!(d != d), 0)))
        l.asBits = 0x7FF8000000000000LL;
    else
        l.asDouble = d;
    return IMPL_TO_JSVAL(l);
}

static inline jsval
UINT_TO_JSVAL(uint32_t i)
{
    if (i <= ((int32_t)0x7fffffff))
        return INT_TO_JSVAL((int32_t)i);
    return DOUBLE_TO_JSVAL((double)i);
}

static inline JSBool
JSVAL_IS_NUMBER(jsval v)
{
    return JSVAL_IS_NUMBER_IMPL(JSVAL_TO_IMPL(v));
}

static inline JSBool
JSVAL_IS_STRING(jsval v)
{
    return JSVAL_IS_STRING_IMPL(JSVAL_TO_IMPL(v));
}

static inline JSString *
JSVAL_TO_STRING(jsval v)
{
    do { } while(0);
    return JSVAL_TO_STRING_IMPL(JSVAL_TO_IMPL(v));
}

static inline jsval
STRING_TO_JSVAL(JSString *str)
{
    return IMPL_TO_JSVAL(STRING_TO_JSVAL_IMPL(str));
}

static inline JSObject *
JSVAL_TO_OBJECT(jsval v)
{
    do { } while(0);
    return JSVAL_TO_OBJECT_IMPL(JSVAL_TO_IMPL(v));
}

static inline jsval
OBJECT_TO_JSVAL(JSObject *obj)
{
    if (obj)
        return IMPL_TO_JSVAL(OBJECT_TO_JSVAL_IMPL(obj));
    return IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_NULL, 0));
}

static inline JSBool
JSVAL_IS_BOOLEAN(jsval v)
{
    return JSVAL_IS_BOOLEAN_IMPL(JSVAL_TO_IMPL(v));
}

static inline JSBool
JSVAL_TO_BOOLEAN(jsval v)
{
    do { } while(0);
    return JSVAL_TO_BOOLEAN_IMPL(JSVAL_TO_IMPL(v));
}

static inline jsval
BOOLEAN_TO_JSVAL(JSBool b)
{
    return IMPL_TO_JSVAL(BOOLEAN_TO_JSVAL_IMPL(b));
}

static inline JSBool
JSVAL_IS_PRIMITIVE(jsval v)
{
    return JSVAL_IS_PRIMITIVE_IMPL(JSVAL_TO_IMPL(v));
}

static inline JSBool
JSVAL_IS_GCTHING(jsval v)
{
    return JSVAL_IS_GCTHING_IMPL(JSVAL_TO_IMPL(v));
}

static inline void *
JSVAL_TO_GCTHING(jsval v)
{
    do { } while(0);
    return JSVAL_TO_GCTHING_IMPL(JSVAL_TO_IMPL(v));
}



static inline jsval
PRIVATE_TO_JSVAL(void *ptr)
{
    return IMPL_TO_JSVAL(PRIVATE_PTR_TO_JSVAL_IMPL(ptr));
}

static inline void *
JSVAL_TO_PRIVATE(jsval v)
{
    do { } while(0);
    return JSVAL_TO_PRIVATE_PTR_IMPL(JSVAL_TO_IMPL(v));
}
# 40 "../../dist/include/js/CallArgs.h" 2

struct JSContext;
class JSObject;


typedef JSBool
(* JSNative)(JSContext *cx, unsigned argc, JS::Value *vp);

namespace JS {
# 84 "../../dist/include/js/CallArgs.h"
class CallReceiver
{
  protected:





    void setUsedRval() const {}
    void clearUsedRval() const {}


    Value *argv_;

    friend CallReceiver CallReceiverFromVp(Value *vp);
    friend CallReceiver CallReceiverFromArgv(Value *argv);

  public:




    JSObject &callee() const {
        do { } while(0);
        return argv_[-2].toObject();
    }





    HandleValue calleev() const {
        do { } while(0);
        return HandleValue::fromMarkedLocation(&argv_[-2]);
    }







    HandleValue thisv() const {



        return HandleValue::fromMarkedLocation(&argv_[-1]);
    }
# 144 "../../dist/include/js/CallArgs.h"
    MutableHandleValue rval() const {
        setUsedRval();
        return MutableHandleValue::fromMarkedLocation(&argv_[-2]);
    }

  public:



    Value *base() const { return argv_ - 2; }

    Value *spAfterCall() const {
        setUsedRval();
        return argv_ - 1;
    }

  public:




    void setCallee(Value aCalleev) const {
        clearUsedRval();
        argv_[-2] = aCalleev;
    }

    void setThis(Value aThisv) const {
        argv_[-1] = aThisv;
    }

    MutableHandleValue mutableThisv() const {
        return MutableHandleValue::fromMarkedLocation(&argv_[-1]);
    }
};

__attribute__((always_inline)) inline CallReceiver
CallReceiverFromArgv(Value *argv)
{
    CallReceiver receiver;
    receiver.clearUsedRval();
    receiver.argv_ = argv;
    return receiver;
}

__attribute__((always_inline)) inline CallReceiver
CallReceiverFromVp(Value *vp)
{
    return CallReceiverFromArgv(vp + 2);
}
# 218 "../../dist/include/js/CallArgs.h"
class CallArgs : public CallReceiver
{
  protected:
    unsigned argc_;

    friend CallArgs CallArgsFromVp(unsigned argc, Value *vp);
    friend CallArgs CallArgsFromSp(unsigned argc, Value *sp);

    static CallArgs create(unsigned argc, Value *argv) {
        CallArgs args;
        args.clearUsedRval();
        args.argv_ = argv;
        args.argc_ = argc;
        return args;
    }

  public:

    unsigned length() const { return argc_; }


    Value &operator[](unsigned i) const {
        do { } while(0);
        return argv_[i];
    }


    MutableHandleValue handleAt(unsigned i) {
        do { } while(0);
        return MutableHandleValue::fromMarkedLocation(&argv_[i]);
    }


    HandleValue handleAt(unsigned i) const {
        do { } while(0);
        return HandleValue::fromMarkedLocation(&argv_[i]);
    }





    Value get(unsigned i) const {
        return i < length() ? argv_[i] : UndefinedValue();
    }





    bool hasDefined(unsigned i) const {
        return i < argc_ && !argv_[i].isUndefined();
    }

  public:




    Value *array() const { return argv_; }
    Value *end() const { return argv_ + argc_; }
};

__attribute__((always_inline)) inline CallArgs
CallArgsFromVp(unsigned argc, Value *vp)
{
    return CallArgs::create(argc, vp + 2);
}




__attribute__((always_inline)) inline CallArgs
CallArgsFromSp(unsigned argc, Value *sp)
{
    return CallArgs::create(argc, sp - argc);
}

}
# 307 "../../dist/include/js/CallArgs.h"
extern __attribute__((visibility("default"))) JS::Value
JS_ComputeThis(JSContext *cx, JS::Value *vp);
# 327 "../../dist/include/js/CallArgs.h"
__attribute__((always_inline)) inline JS::Value
JS_THIS(JSContext *cx, JS::Value *vp)
{
    return JSVAL_IS_PRIMITIVE(vp[1]) ? JS_ComputeThis(cx, vp) : vp[1];
}
# 30 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/js/CharacterEncoding.h" 1
# 11 "../../dist/include/js/CharacterEncoding.h"
# 1 "../../dist/include/mozilla/Range.h" 1
# 11 "../../dist/include/mozilla/Range.h"
# 1 "../../dist/include/mozilla/NullPtr.h" 1
# 12 "../../dist/include/mozilla/Range.h" 2
# 1 "../../dist/include/mozilla/RangedPtr.h" 1
# 13 "../../dist/include/mozilla/Range.h" 2

# 1 "../../dist/system_wrappers/stddef.h" 1
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 15 "../../dist/include/mozilla/Range.h" 2

namespace mozilla {


template <typename T>
class Range
{
    RangedPtr<T> mStart;
    RangedPtr<T> mEnd;

    typedef void (Range::* ConvertibleToBool)();
    void nonNull() {}

  public:
    Range() : mStart(nullptr, 0), mEnd(nullptr, 0) {}
    Range(T* p, size_t len)
      : mStart(p, p, p + len),
        mEnd(p + len, p, p + len)
    {}

    RangedPtr<T> start() const { return mStart; }
    RangedPtr<T> end() const { return mEnd; }
    size_t length() const { return mEnd - mStart; }

    T& operator[](size_t offset) {
      return mStart[offset];
    }

    operator ConvertibleToBool() const { return mStart ? &Range::nonNull : 0; }
};

}
# 12 "../../dist/include/js/CharacterEncoding.h" 2





namespace JS {







class Latin1Chars : public mozilla::Range<unsigned char>
{
    typedef mozilla::Range<unsigned char> Base;

  public:
    Latin1Chars() : Base() {}
    Latin1Chars(char *aBytes, size_t aLength) : Base(reinterpret_cast<unsigned char *>(aBytes), aLength) {}
    Latin1Chars(const char *aBytes, size_t aLength)
      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(aBytes)), aLength)
    {}
};




class Latin1CharsZ : public mozilla::RangedPtr<unsigned char>
{
    typedef mozilla::RangedPtr<unsigned char> Base;

  public:
    Latin1CharsZ() : Base(__null, 0) {}

    Latin1CharsZ(char *aBytes, size_t aLength)
      : Base(reinterpret_cast<unsigned char *>(aBytes), aLength)
    {
        do { } while(0);
    }

    Latin1CharsZ(unsigned char *aBytes, size_t aLength)
      : Base(aBytes, aLength)
    {
        do { } while(0);
    }

    char *c_str() { return reinterpret_cast<char *>(get()); }
};




class UTF8CharsZ : public mozilla::RangedPtr<unsigned char>
{
    typedef mozilla::RangedPtr<unsigned char> Base;

  public:
    UTF8CharsZ() : Base(__null, 0) {}

    UTF8CharsZ(char *aBytes, size_t aLength)
      : Base(reinterpret_cast<unsigned char *>(aBytes), aLength)
    {
        do { } while(0);
    }

    UTF8CharsZ(unsigned char *aBytes, size_t aLength)
      : Base(aBytes, aLength)
    {
        do { } while(0);
    }

    char *c_str() { return reinterpret_cast<char *>(get()); }
};
# 95 "../../dist/include/js/CharacterEncoding.h"
class TwoByteChars : public mozilla::Range<jschar>
{
    typedef mozilla::Range<jschar> Base;

  public:
    TwoByteChars() : Base() {}
    TwoByteChars(jschar *aChars, size_t aLength) : Base(aChars, aLength) {}
    TwoByteChars(const jschar *aChars, size_t aLength) : Base(const_cast<jschar *>(aChars), aLength) {}
};






class StableTwoByteChars : public mozilla::Range<jschar>
{
    typedef mozilla::Range<jschar> Base;

  public:
    StableTwoByteChars() : Base() {}
    StableTwoByteChars(jschar *aChars, size_t aLength) : Base(aChars, aLength) {}
    StableTwoByteChars(const jschar *aChars, size_t aLength) : Base(const_cast<jschar *>(aChars), aLength) {}
};




class TwoByteCharsZ : public mozilla::RangedPtr<jschar>
{
    typedef mozilla::RangedPtr<jschar> Base;

  public:
    TwoByteCharsZ(jschar *chars, size_t length)
      : Base(chars, length)
    {
        do { } while(0);
    }
};
# 145 "../../dist/include/js/CharacterEncoding.h"
extern Latin1CharsZ
LossyTwoByteCharsToNewLatin1CharsZ(JSContext *cx, TwoByteChars tbchars);

extern UTF8CharsZ
TwoByteCharsToNewUTF8CharsZ(JSContext *cx, TwoByteChars tbchars);

}

inline void JS_free(JS::Latin1CharsZ &ptr) { js_free((void*)ptr.get()); }
inline void JS_free(JS::UTF8CharsZ &ptr) { js_free((void*)ptr.get()); }
# 31 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/js/HashTable.h" 1
# 13 "../../dist/include/js/HashTable.h"
# 1 "../../dist/include/mozilla/DebugOnly.h" 1
# 14 "../../dist/include/mozilla/DebugOnly.h"
namespace mozilla {
# 30 "../../dist/include/mozilla/DebugOnly.h"
template<typename T>
class DebugOnly
{
  public:
# 59 "../../dist/include/mozilla/DebugOnly.h"
    DebugOnly() { }
    DebugOnly(const T&) { }
    DebugOnly(const DebugOnly&) { }
    DebugOnly& operator=(const T&) { return *this; }
    void operator++(int) { }
    void operator--(int) { }







    ~DebugOnly() {}
};

}
# 14 "../../dist/include/js/HashTable.h" 2






namespace js {

class TempAllocPolicy;
template <class> struct DefaultHasher;
template <class, class> class HashMapEntry;
namespace detail {
    template <class T> class HashTableEntry;
    template <class T, class HashPolicy, class AllocPolicy> class HashTable;
}
# 47 "../../dist/include/js/HashTable.h"
template <class Key,
          class Value,
          class HashPolicy = DefaultHasher<Key>,
          class AllocPolicy = TempAllocPolicy>
class HashMap
{
    typedef HashMapEntry<Key, Value> TableEntry;

    struct MapHashPolicy : HashPolicy
    {
        typedef Key KeyType;
        static const Key &getKey(TableEntry &e) { return e.key; }
        static void setKey(TableEntry &e, Key &k) { const_cast<Key &>(e.key) = k; }
    };

    typedef detail::HashTable<TableEntry, MapHashPolicy, AllocPolicy> Impl;
    Impl impl;

  public:
    typedef typename HashPolicy::Lookup Lookup;
    typedef TableEntry Entry;



    HashMap(AllocPolicy a = AllocPolicy())
      : impl(a)
    {
        static_assert((tl::IsRelocatableHeapType<Key>::result), "Key type must be relocatable")
                                                         ;
        static_assert((tl::IsRelocatableHeapType<Value>::result), "Value type must be relocatable")
                                                           ;
    }

    bool init(uint32_t len = 16) { return impl.init(len); }
    bool initialized() const { return impl.initialized(); }
# 94 "../../dist/include/js/HashTable.h"
    typedef typename Impl::Ptr Ptr;
    Ptr lookup(const Lookup &l) const { return impl.lookup(l); }



    Ptr readonlyThreadsafeLookup(const Lookup &l) const { return impl.readonlyThreadsafeLookup(l); }


    void remove(Ptr p) { impl.remove(p); }
# 137 "../../dist/include/js/HashTable.h"
    typedef typename Impl::AddPtr AddPtr;
    AddPtr lookupForAdd(const Lookup &l) const {
        return impl.lookupForAdd(l);
    }

    template<typename KeyInput, typename ValueInput>
    bool add(AddPtr &p, const KeyInput &k, const ValueInput &v) {
        Entry e(k, v);
        return impl.add(p, Move(e));
    }

    bool add(AddPtr &p, const Key &k) {
        Entry e(k, Value());
        return impl.add(p, Move(e));
    }

    template<typename KeyInput, typename ValueInput>
    bool relookupOrAdd(AddPtr &p, const KeyInput &k, const ValueInput &v) {
        Entry e(k, v);
        return impl.relookupOrAdd(p, k, Move(e));
    }
# 167 "../../dist/include/js/HashTable.h"
    typedef typename Impl::Range Range;
    Range all() const { return impl.all(); }
# 181 "../../dist/include/js/HashTable.h"
    typedef typename Impl::Enum Enum;



    void clear() { impl.clear(); }


    void clearWithoutCallingDestructors() { impl.clearWithoutCallingDestructors(); }



    void finish() { impl.finish(); }


    bool empty() const { return impl.empty(); }


    uint32_t count() const { return impl.count(); }



    size_t capacity() const { return impl.capacity(); }



    size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return impl.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return mallocSizeOf(this) + impl.sizeOfExcludingThis(mallocSizeOf);
    }



    unsigned generation() const { return impl.generation(); }



    bool has(const Lookup &l) const {
        return impl.lookup(l) != __null;
    }


    template<typename KeyInput, typename ValueInput>
    bool put(const KeyInput &k, const ValueInput &v) {
        AddPtr p = lookupForAdd(k);
        if (p) {
            p->value = v;
            return true;
        }
        return add(p, k, v);
    }


    template<typename KeyInput, typename ValueInput>
    bool putNew(const KeyInput &k, const ValueInput &v) {
        Entry e(k, v);
        return impl.putNew(k, Move(e));
    }


    Ptr lookupWithDefault(const Key &k, const Value &defaultValue) {
        AddPtr p = lookupForAdd(k);
        if (p)
            return p;
        (void)add(p, k, defaultValue);
        return p;
    }


    void remove(const Lookup &l) {
        if (Ptr p = lookup(l))
            remove(p);
    }


    HashMap(MoveRef<HashMap> rhs) : impl(Move(rhs->impl)) {}
    void operator=(MoveRef<HashMap> rhs) { impl = Move(rhs->impl); }

  private:

    HashMap(const HashMap &hm) = delete;
    HashMap &operator=(const HashMap &hm) = delete;

    friend class Impl::Enum;
};
# 285 "../../dist/include/js/HashTable.h"
template <class T,
          class HashPolicy = DefaultHasher<T>,
          class AllocPolicy = TempAllocPolicy>
class HashSet
{
    struct SetOps : HashPolicy
    {
        typedef T KeyType;
        static const KeyType &getKey(const T &t) { return t; }
        static void setKey(T &t, KeyType &k) { t = k; }
    };

    typedef detail::HashTable<const T, SetOps, AllocPolicy> Impl;
    Impl impl;

  public:
    typedef typename HashPolicy::Lookup Lookup;
    typedef T Entry;



    HashSet(AllocPolicy a = AllocPolicy()) : impl(a)
    {
        static_assert((tl::IsRelocatableHeapType<T>::result), "Set element type must be relocatable")
                                                                 ;
    }
    bool init(uint32_t len = 16) { return impl.init(len); }
    bool initialized() const { return impl.initialized(); }
# 323 "../../dist/include/js/HashTable.h"
    typedef typename Impl::Ptr Ptr;
    Ptr lookup(const Lookup &l) const { return impl.lookup(l); }


    void remove(Ptr p) { impl.remove(p); }
# 361 "../../dist/include/js/HashTable.h"
    typedef typename Impl::AddPtr AddPtr;
    AddPtr lookupForAdd(const Lookup &l) const { return impl.lookupForAdd(l); }

    bool add(AddPtr &p, const T &t) { return impl.add(p, t); }

    bool relookupOrAdd(AddPtr &p, const Lookup &l, const T &t) {
        return impl.relookupOrAdd(p, l, t);
    }
# 378 "../../dist/include/js/HashTable.h"
    typedef typename Impl::Range Range;
    Range all() const { return impl.all(); }
# 392 "../../dist/include/js/HashTable.h"
    typedef typename Impl::Enum Enum;



    void clear() { impl.clear(); }



    void finish() { impl.finish(); }


    bool empty() const { return impl.empty(); }


    uint32_t count() const { return impl.count(); }



    size_t capacity() const { return impl.capacity(); }



    size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return impl.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return mallocSizeOf(this) + impl.sizeOfExcludingThis(mallocSizeOf);
    }



    unsigned generation() const { return impl.generation(); }



    bool has(const Lookup &l) const {
        return impl.lookup(l) != __null;
    }


    bool put(const T &t) {
        AddPtr p = lookupForAdd(t);
        return p ? true : add(p, t);
    }


    bool putNew(const T &t) {
        return impl.putNew(t, t);
    }

    bool putNew(const Lookup &l, const T &t) {
        return impl.putNew(l, t);
    }

    void remove(const Lookup &l) {
        if (Ptr p = lookup(l))
            remove(p);
    }


    HashSet(MoveRef<HashSet> rhs) : impl(Move(rhs->impl)) {}
    void operator=(MoveRef<HashSet> rhs) { impl = Move(rhs->impl); }

  private:

    HashSet(const HashSet &hs) = delete;
    HashSet &operator=(const HashSet &hs) = delete;

    friend class Impl::Enum;
};
# 492 "../../dist/include/js/HashTable.h"
template <typename Key, size_t zeroBits>
struct PointerHasher
{
    typedef Key Lookup;
    static HashNumber hash(const Lookup &l) {
        do { } while(0);
        size_t word = reinterpret_cast<size_t>(l) >> zeroBits;
        static_assert((sizeof(HashNumber) == 4), "JS_STATIC_ASSERT");



        static_assert((sizeof word == 8), "JS_STATIC_ASSERT");
        return HashNumber((word >> 32) ^ word);

    }
    static bool match(const Key &k, const Lookup &l) {
        do { } while(0);
        do { } while(0);
        return k == l;
    }
};





template <class Key>
struct DefaultHasher
{
    typedef Key Lookup;
    static HashNumber hash(const Lookup &l) {

        return l;
    }
    static bool match(const Key &k, const Lookup &l) {

        return k == l;
    }
};



template <class T>
struct DefaultHasher<T *> : PointerHasher<T *, tl::FloorLog2<sizeof(void *)>::result>
{};


template <>
struct DefaultHasher<double>
{
    typedef double Lookup;
    static HashNumber hash(double d) {
        static_assert((sizeof(HashNumber) == 4), "JS_STATIC_ASSERT");
        union {
            struct {
                uint32_t lo;
                uint32_t hi;
            } s;
            double d;
        } u;
        u.d = d;
        return u.s.lo ^ u.s.hi;
    }
    static bool match(double lhs, double rhs) {
        return lhs == rhs;
    }
};
# 567 "../../dist/include/js/HashTable.h"
template <class Key, class Value>
class HashMapEntry
{
    template <class, class, class> friend class detail::HashTable;
    template <class> friend class detail::HashTableEntry;

    HashMapEntry(const HashMapEntry &) = delete;
    void operator=(const HashMapEntry &) = delete;

  public:
    template<typename KeyInput, typename ValueInput>
    HashMapEntry(const KeyInput &k, const ValueInput &v) : key(k), value(v) {}

    HashMapEntry(MoveRef<HashMapEntry> rhs)
      : key(Move(rhs->key)), value(Move(rhs->value)) { }

    const Key key;
    Value value;
};

}

namespace mozilla {

template <typename T>
struct IsPod<js::detail::HashTableEntry<T> > : IsPod<T> {};

template <typename K, typename V>
struct IsPod<js::HashMapEntry<K, V> >
  : IntegralConstant<bool, IsPod<K>::value && IsPod<V>::value>
{};

}

namespace js {

namespace detail {

template <class T, class HashPolicy, class AllocPolicy>
class HashTable;

template <class T>
class HashTableEntry
{
    template <class, class, class> friend class HashTable;
    typedef typename tl::StripConst<T>::result NonConstT;

    HashNumber keyHash;
    mozilla::AlignedStorage2<NonConstT> mem;

    static const HashNumber sFreeKey = 0;
    static const HashNumber sRemovedKey = 1;
    static const HashNumber sCollisionBit = 1;


    static_assert((sFreeKey == 0), "JS_STATIC_ASSERT");

    static bool isLiveHash(HashNumber hash)
    {
        return hash > sRemovedKey;
    }

    HashTableEntry(const HashTableEntry &) = delete;
    void operator=(const HashTableEntry &) = delete;
    ~HashTableEntry() = delete;

  public:


    void destroyIfLive() {
        if (isLive())
            mem.addr()->~T();
    }

    void destroy() {
        do { } while(0);
        mem.addr()->~T();
    }

    void swap(HashTableEntry *other) {
        Swap(keyHash, other->keyHash);
        Swap(mem, other->mem);
    }

    T &get() { do { } while(0); return *mem.addr(); }

    bool isFree() const { return keyHash == sFreeKey; }
    void clearLive() { do { } while(0); keyHash = sFreeKey; mem.addr()->~T(); }
    void clear() { if (isLive()) mem.addr()->~T(); keyHash = sFreeKey; }
    void clearNoDtor() { keyHash = sFreeKey; }
    bool isRemoved() const { return keyHash == sRemovedKey; }
    void removeLive() { do { } while(0); keyHash = sRemovedKey; mem.addr()->~T(); }
    bool isLive() const { return isLiveHash(keyHash); }
    void setCollision() { do { } while(0); keyHash |= sCollisionBit; }
    void setCollision(HashNumber bit) { do { } while(0); keyHash |= bit; }
    void unsetCollision() { keyHash &= ~sCollisionBit; }
    bool hasCollision() const { return keyHash & sCollisionBit; }
    bool matchHash(HashNumber hn) { return (keyHash & ~sCollisionBit) == hn; }
    HashNumber getKeyHash() const { return keyHash & ~sCollisionBit; }

    template <class U>
    void setLive(HashNumber hn, const U &u)
    {
        do { } while(0);
        keyHash = hn;
        new(mem.addr()) T(u);
        do { } while(0);
    }
};

template <class T, class HashPolicy, class AllocPolicy>
class HashTable : private AllocPolicy
{
    typedef typename tl::StripConst<T>::result NonConstT;
    typedef typename HashPolicy::KeyType Key;
    typedef typename HashPolicy::Lookup Lookup;

  public:
    typedef HashTableEntry<T> Entry;





    class Ptr
    {
        friend class HashTable;
        typedef void (Ptr::* ConvertibleToBool)();
        void nonNull() {}

        Entry *entry_;

      protected:
        Ptr(Entry &entry) : entry_(&entry) {}

      public:

        Ptr() {



        }

        bool found() const { return entry_->isLive(); }
        operator ConvertibleToBool() const { return found() ? &Ptr::nonNull : 0; }
        bool operator==(const Ptr &rhs) const { do { } while(0); return entry_ == rhs.entry_; }
        bool operator!=(const Ptr &rhs) const { return !(*this == rhs); }

        T &operator*() const { return entry_->get(); }
        T *operator->() const { return &entry_->get(); }
    };


    class AddPtr : public Ptr
    {
        friend class HashTable;
        HashNumber keyHash;
        mozilla::DebugOnly<uint64_t> mutationCount;

        AddPtr(Entry &entry, HashNumber hn) : Ptr(entry), keyHash(hn) {}
      public:

        AddPtr() {}
    };





    class Range
    {
      protected:
        friend class HashTable;

        Range(Entry *c, Entry *e) : cur(c), end(e), validEntry(true) {
            while (cur < end && !cur->isLive())
                ++cur;
        }

        Entry *cur, *end;
        mozilla::DebugOnly<bool> validEntry;

      public:
        Range() : cur(__null), end(__null), validEntry(false) {}

        bool empty() const {
            return cur == end;
        }

        T &front() const {
            do { } while(0);
            do { } while(0);
            return cur->get();
        }

        void popFront() {
            do { } while(0);
            while (++cur < end && !cur->isLive())
                continue;
            validEntry = true;
        }
    };






    class Enum : public Range
    {
        friend class HashTable;

        HashTable &table;
        bool rekeyed;
        bool removed;


        Enum(const Enum &);
        void operator=(const Enum &);

      public:
        template<class Map> explicit
        Enum(Map &map) : Range(map.all()), table(map.impl), rekeyed(false), removed(false) {}
# 798 "../../dist/include/js/HashTable.h"
        void removeFront() {
            table.remove(*this->cur);
            removed = true;
            this->validEntry = false;
        }




        void rekeyFront(const Lookup &l, const Key &k) {
            typename HashTableEntry<T>::NonConstT t(Move(this->cur->get()));
            HashPolicy::setKey(t, const_cast<Key &>(k));
            table.remove(*this->cur);
            table.putNewInfallible(l, Move(t));
            rekeyed = true;
            this->validEntry = false;
        }

        void rekeyFront(const Key &k) {
            rekeyFront(k, k);
        }


        ~Enum() {
            if (rekeyed) {
                table.gen++;
                table.checkOverRemoved();
            }

            if (removed)
                table.compactIfUnderloaded();
        }
    };


    HashTable(MoveRef<HashTable> rhs)
      : AllocPolicy(*rhs)
    {
        PodAssign(this, &*rhs);
        rhs->table = __null;
    }
    void operator=(MoveRef<HashTable> rhs) {
        if (table)
            destroyTable(*this, table, capacity());
        PodAssign(this, &*rhs);
        rhs->table = __null;
    }

  private:

    HashTable(const HashTable &) = delete;
    void operator=(const HashTable &) = delete;

  private:
    uint32_t hashShift;
    uint32_t entryCount;
    uint32_t gen;
    uint32_t removedCount;
    Entry *table;

    void setTableSizeLog2(unsigned sizeLog2)
    {
        hashShift = sHashBits - sizeLog2;
    }
# 883 "../../dist/include/js/HashTable.h"
    friend class js::ReentrancyGuard;
    mutable mozilla::DebugOnly<bool> entered;
    mozilla::DebugOnly<uint64_t> mutationCount;



    static const unsigned sMinCapacityLog2 = 2;
    static const unsigned sMinCapacity = 1 << sMinCapacityLog2;
    static const unsigned sMaxInit = ((uint32_t)1 << (23));
    static const unsigned sMaxCapacity = ((uint32_t)1 << (24));
    static const unsigned sHashBits = tl::BitSize<HashNumber>::result;
    static const uint8_t sMinAlphaFrac = 64;
    static const uint8_t sMaxAlphaFrac = 192;
    static const uint8_t sInvMaxAlpha = 171;
    static const HashNumber sFreeKey = Entry::sFreeKey;
    static const HashNumber sRemovedKey = Entry::sRemovedKey;
    static const HashNumber sCollisionBit = Entry::sCollisionBit;

    static void staticAsserts()
    {

        static_assert((((sMaxInit * sInvMaxAlpha) >> 7) < sMaxCapacity), "JS_STATIC_ASSERT");
        static_assert(((sMaxCapacity * sInvMaxAlpha) <= (4294967295U)), "JS_STATIC_ASSERT");
        static_assert(((sMaxCapacity * sizeof(Entry)) <= (4294967295U)), "JS_STATIC_ASSERT");
    }

    static bool isLiveHash(HashNumber hash)
    {
        return Entry::isLiveHash(hash);
    }

    static HashNumber prepareHash(const Lookup& l)
    {
        HashNumber keyHash = ScrambleHashCode(HashPolicy::hash(l));


        if (!isLiveHash(keyHash))
            keyHash -= (sRemovedKey + 1);
        return keyHash & ~sCollisionBit;
    }

    static Entry *createTable(AllocPolicy &alloc, uint32_t capacity)
    {

        return (Entry *)alloc.calloc_(capacity * sizeof(Entry));
    }

    static void destroyTable(AllocPolicy &alloc, Entry *oldTable, uint32_t capacity)
    {
        for (Entry *e = oldTable, *end = e + capacity; e < end; ++e)
            e->destroyIfLive();
        alloc.free_(oldTable);
    }

  public:
    HashTable(AllocPolicy ap)
      : AllocPolicy(ap),
        hashShift(sHashBits),
        entryCount(0),
        gen(0),
        removedCount(0),
        table(__null),
        entered(false),
        mutationCount(0)
    {}

    __attribute__ ((warn_unused_result)) bool init(uint32_t length)
    {
        do { } while(0);



        if (length > sMaxInit) {
            this->reportAllocOverflow();
            return false;
        }
        uint32_t newCapacity = (length * sInvMaxAlpha) >> 7;

        if (newCapacity < sMinCapacity)
            newCapacity = sMinCapacity;


        uint32_t roundUp = sMinCapacity, roundUpLog2 = sMinCapacityLog2;
        while (roundUp < newCapacity) {
            roundUp <<= 1;
            ++roundUpLog2;
        }

        newCapacity = roundUp;
        do { } while(0);

        table = createTable(*this, newCapacity);
        if (!table)
            return false;

        setTableSizeLog2(roundUpLog2);
        ;
        return true;
    }

    bool initialized() const
    {
        return !!table;
    }

    ~HashTable()
    {
        if (table)
            destroyTable(*this, table, capacity());
    }

  private:
    HashNumber hash1(HashNumber hash0) const
    {
        return hash0 >> hashShift;
    }

    struct DoubleHash
    {
        HashNumber h2;
        HashNumber sizeMask;
    };

    DoubleHash hash2(HashNumber curKeyHash) const
    {
        unsigned sizeLog2 = sHashBits - hashShift;
        DoubleHash dh = {
            ((curKeyHash << sizeLog2) >> hashShift) | 1,
            (HashNumber(1) << sizeLog2) - 1
        };
        return dh;
    }

    static HashNumber applyDoubleHash(HashNumber h1, const DoubleHash &dh)
    {
        return (h1 - dh.h2) & dh.sizeMask;
    }

    bool overloaded()
    {
        return entryCount + removedCount >= ((sMaxAlphaFrac * capacity()) >> 8);
    }


    static bool wouldBeUnderloaded(uint32_t capacity, uint32_t entryCount)
    {
        return capacity > sMinCapacity && entryCount <= ((sMinAlphaFrac * capacity) >> 8);
    }

    bool underloaded()
    {
        return wouldBeUnderloaded(capacity(), entryCount);
    }

    static bool match(Entry &e, const Lookup &l)
    {
        return HashPolicy::match(HashPolicy::getKey(e.get()), l);
    }

    Entry &lookup(const Lookup &l, HashNumber keyHash, unsigned collisionBit) const
    {
        do { } while(0);
        do { } while(0);
        do { } while(0);
        do { } while(0);
        ;


        HashNumber h1 = hash1(keyHash);
        Entry *entry = &table[h1];


        if (entry->isFree()) {
            ;
            return *entry;
        }


        if (entry->matchHash(keyHash) && match(*entry, l)) {
            ;
            return *entry;
        }


        DoubleHash dh = hash2(keyHash);


        Entry *firstRemoved = __null;

        while(true) {
            if ((__builtin_expect((entry->isRemoved()), 0))) {
                if (!firstRemoved)
                    firstRemoved = entry;
            } else {
                entry->setCollision(collisionBit);
            }

            ;
            h1 = applyDoubleHash(h1, dh);

            entry = &table[h1];
            if (entry->isFree()) {
                ;
                return firstRemoved ? *firstRemoved : *entry;
            }

            if (entry->matchHash(keyHash) && match(*entry, l)) {
                ;
                return *entry;
            }
        }
    }







    Entry &findFreeEntry(HashNumber keyHash)
    {
        do { } while(0);
        do { } while(0);
        ;




        HashNumber h1 = hash1(keyHash);
        Entry *entry = &table[h1];


        if (!entry->isLive()) {
            ;
            return *entry;
        }


        DoubleHash dh = hash2(keyHash);

        while(true) {
            do { } while(0);
            entry->setCollision();

            ;
            h1 = applyDoubleHash(h1, dh);

            entry = &table[h1];
            if (!entry->isLive()) {
                ;
                return *entry;
            }
        }
    }

    enum RebuildStatus { NotOverloaded, Rehashed, RehashFailed };

    RebuildStatus changeTableSize(int deltaLog2)
    {

        Entry *oldTable = table;
        uint32_t oldCap = capacity();
        uint32_t newLog2 = sHashBits - hashShift + deltaLog2;
        uint32_t newCapacity = ((uint32_t)1 << (newLog2));
        if (newCapacity > sMaxCapacity) {
            this->reportAllocOverflow();
            return RehashFailed;
        }

        Entry *newTable = createTable(*this, newCapacity);
        if (!newTable)
            return RehashFailed;


        setTableSizeLog2(newLog2);
        removedCount = 0;
        gen++;
        table = newTable;


        for (Entry *src = oldTable, *end = src + oldCap; src < end; ++src) {
            if (src->isLive()) {
                HashNumber hn = src->getKeyHash();
                findFreeEntry(hn).setLive(hn, Move(src->get()));
                src->destroy();
            }
        }


        this->free_(oldTable);
        return Rehashed;
    }

    RebuildStatus checkOverloaded()
    {
        if (!overloaded())
            return NotOverloaded;


        int deltaLog2;
        if (removedCount >= (capacity() >> 2)) {
            ;
            deltaLog2 = 0;
        } else {
            ;
            deltaLog2 = 1;
        }

        return changeTableSize(deltaLog2);
    }


    void checkOverRemoved()
    {
        if (overloaded()) {
            if (checkOverloaded() == RehashFailed)
                rehashTableInPlace();
        }
    }

    void remove(Entry &e)
    {
        do { } while(0);
        ;

        if (e.hasCollision()) {
            e.removeLive();
            removedCount++;
        } else {
            ;
            e.clearLive();
        }
        entryCount--;
        mutationCount++;
    }

    void checkUnderloaded()
    {
        if (underloaded()) {
            ;
            (void) changeTableSize(-1);
        }
    }




    void compactIfUnderloaded()
    {
        int32_t resizeLog2 = 0;
        uint32_t newCapacity = capacity();
        while (wouldBeUnderloaded(newCapacity, entryCount)) {
            newCapacity = newCapacity >> 1;
            resizeLog2--;
        }

        if (resizeLog2 != 0) {
            changeTableSize(resizeLog2);
        }
    }






    void rehashTableInPlace()
    {
        ;
        removedCount = 0;
        for (size_t i = 0; i < capacity(); ++i)
            table[i].unsetCollision();

        for (size_t i = 0; i < capacity();) {
            Entry *src = &table[i];

            if (!src->isLive() || src->hasCollision()) {
                ++i;
                continue;
            }

            HashNumber keyHash = src->getKeyHash();
            HashNumber h1 = hash1(keyHash);
            DoubleHash dh = hash2(keyHash);
            Entry *tgt = &table[h1];
            while (true) {
                if (!tgt->hasCollision()) {
                    src->swap(tgt);
                    tgt->setCollision();
                    break;
                }

                h1 = applyDoubleHash(h1, dh);
                tgt = &table[h1];
            }
        }






    }

  public:
    void clear()
    {
        if (mozilla::IsPod<Entry>::value) {
            memset(table, 0, sizeof(*table) * capacity());
        } else {
            uint32_t tableCapacity = capacity();
            for (Entry *e = table, *end = table + tableCapacity; e < end; ++e)
                e->clear();
        }
        removedCount = 0;
        entryCount = 0;
        mutationCount++;
    }

    void clearWithoutCallingDestructors()
    {
        if (mozilla::IsPod<Entry>::value) {
            memset(table, 0, sizeof(*table) * capacity());
        } else {
            uint32_t tableCapacity = capacity();
            for (Entry *e = table, *end = table + tableCapacity; e < end; ++e)
                e->clearNoDtor();
        }
        removedCount = 0;
        entryCount = 0;
        mutationCount++;
    }

    void finish()
    {
        do { } while(0);

        if (!table)
            return;

        destroyTable(*this, table, capacity());
        table = __null;
        gen++;
        entryCount = 0;
        removedCount = 0;
        mutationCount++;
    }

    Range all() const
    {
        do { } while(0);
        return Range(table, table + capacity());
    }

    bool empty() const
    {
        do { } while(0);
        return !entryCount;
    }

    uint32_t count() const
    {
        do { } while(0);
        return entryCount;
    }

    uint32_t capacity() const
    {
        do { } while(0);
        return ((uint32_t)1 << (sHashBits - hashShift));
    }

    uint32_t generation() const
    {
        do { } while(0);
        return gen;
    }

    size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const
    {
        return mallocSizeOf(table);
    }

    size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const
    {
        return mallocSizeOf(this) + sizeOfExcludingThis(mallocSizeOf);
    }

    Ptr lookup(const Lookup &l) const
    {
        ReentrancyGuard g(*this);
        HashNumber keyHash = prepareHash(l);
        return Ptr(lookup(l, keyHash, 0));
    }

    Ptr readonlyThreadsafeLookup(const Lookup &l) const
    {
        HashNumber keyHash = prepareHash(l);
        return Ptr(lookup(l, keyHash, 0));
    }

    AddPtr lookupForAdd(const Lookup &l) const
    {
        ReentrancyGuard g(*this);
        HashNumber keyHash = prepareHash(l);
        Entry &entry = lookup(l, keyHash, sCollisionBit);
        AddPtr p(entry, keyHash);
        p.mutationCount = mutationCount;
        return p;
    }

    template <class U>
    bool add(AddPtr &p, const U &rhs)
    {
        ReentrancyGuard g(*this);
        do { } while(0);
        do { } while(0);
        do { } while(0);
        do { } while(0);



        if (p.entry_->isRemoved()) {
            ;
            removedCount--;
            p.keyHash |= sCollisionBit;
        } else {

            RebuildStatus status = checkOverloaded();
            if (status == RehashFailed)
                return false;
            if (status == Rehashed)
                p.entry_ = &findFreeEntry(p.keyHash);
        }

        p.entry_->setLive(p.keyHash, rhs);
        entryCount++;
        mutationCount++;
        return true;
    }

    template <class U>
    void putNewInfallible(const Lookup &l, const U &u)
    {
        do { } while(0);

        HashNumber keyHash = prepareHash(l);
        Entry *entry = &findFreeEntry(keyHash);

        if (entry->isRemoved()) {
            ;
            removedCount--;
            keyHash |= sCollisionBit;
        }

        entry->setLive(keyHash, u);
        entryCount++;
        mutationCount++;
    }

    template <class U>
    bool putNew(const Lookup &l, const U &u)
    {
        if (checkOverloaded() == RehashFailed)
            return false;

        putNewInfallible(l, u);
        return true;
    }

    template <class U>
    bool relookupOrAdd(AddPtr& p, const Lookup &l, const U &u)
    {
        p.mutationCount = mutationCount;
        {
            ReentrancyGuard g(*this);
            p.entry_ = &lookup(l, p.keyHash, sCollisionBit);
        }
        return p.found() || add(p, u);
    }

    void remove(Ptr p)
    {
        do { } while(0);
        ReentrancyGuard g(*this);
        do { } while(0);
        remove(*p.entry_);
        checkUnderloaded();
    }


};

}
}
# 32 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/js/PropertyKey.h" 1
# 17 "../../dist/include/js/PropertyKey.h"
struct JSContext;

namespace JS {

class PropertyKey;

namespace detail {

extern __attribute__((visibility("default"))) bool
ToPropertyKeySlow(JSContext *cx, HandleValue v, PropertyKey *key);

}
# 38 "../../dist/include/js/PropertyKey.h"
class PropertyKey
{
    Value v;
    friend __attribute__((visibility("default"))) bool detail::ToPropertyKeySlow(JSContext *cx, HandleValue v, PropertyKey *key);

  public:
    explicit PropertyKey(uint32_t index) : v(PrivateUint32Value(index)) {}






    bool isIndex(uint32_t *index) {



        if (!v.isInt32())
            return false;
        *index = v.toPrivateUint32();
        return true;
    }






    bool isName(JSString **str) {
        uint32_t dummy;
        if (isIndex(&dummy))
            return false;
        *str = v.toString();
        return true;
    }
# 81 "../../dist/include/js/PropertyKey.h"
    bool isSymbol() {
        return false;
    }
};

inline bool
ToPropertyKey(JSContext *cx, HandleValue v, PropertyKey *key)
{
    if (v.isInt32() && v.toInt32() >= 0) {
        *key = PropertyKey(uint32_t(v.toInt32()));
        return true;
    }

    return detail::ToPropertyKeySlow(cx, v, key);
}

}
# 33 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/js/RootingAPI.h" 1
# 34 "../../dist/include/jsapi.h" 2

# 1 "../../dist/include/js/Value.h" 1
# 36 "../../dist/include/jsapi.h" 2
# 1 "../../dist/include/js/Vector.h" 1
# 14 "../../dist/include/js/Vector.h"
# 1 "../../dist/include/js/TemplateLib.h" 1
# 15 "../../dist/include/js/Vector.h" 2
# 1 "../../dist/include/js/Utility.h" 1
# 16 "../../dist/include/js/Vector.h" 2







namespace js {

class TempAllocPolicy;

template <class T,
          size_t MinInlineCapacity = 0,
          class AllocPolicy = TempAllocPolicy>
class Vector;







template <typename T>
static bool CapacityHasExcessSpace(size_t cap)
{
    size_t size = cap * sizeof(T);
    return RoundUpPow2(size) - size >= sizeof(T);
}





template <class T, size_t N, class AP, bool IsPod>
struct VectorImpl
{

    static inline void destroy(T *begin, T *end) {
        for (T *p = begin; p != end; ++p)
            p->~T();
    }


    static inline void initialize(T *begin, T *end) {
        for (T *p = begin; p != end; ++p)
            new(p) T();
    }





    template <class U>
    static inline void copyConstruct(T *dst, const U *srcbeg, const U *srcend) {
        for (const U *p = srcbeg; p != srcend; ++p, ++dst)
            new(dst) T(*p);
    }





    template <class U>
    static inline void moveConstruct(T *dst, const U *srcbeg, const U *srcend) {
        for (const U *p = srcbeg; p != srcend; ++p, ++dst)
            new(dst) T(Move(*p));
    }





    template <class U>
    static inline void copyConstructN(T *dst, size_t n, const U &u) {
        for (T *end = dst + n; dst != end; ++dst)
            new(dst) T(u);
    }







    static inline bool growTo(Vector<T,N,AP> &v, size_t newCap) {
        do { } while(0);
        do { } while(0);
        T *newbuf = reinterpret_cast<T *>(v.malloc_(newCap * sizeof(T)));
        if (!newbuf)
            return false;
        for (T *dst = newbuf, *src = v.beginNoCheck(); src != v.endNoCheck(); ++dst, ++src)
            new(dst) T(Move(*src));
        VectorImpl::destroy(v.beginNoCheck(), v.endNoCheck());
        v.free_(v.mBegin);
        v.mBegin = newbuf;

        v.mCapacity = newCap;
        return true;
    }
};






template <class T, size_t N, class AP>
struct VectorImpl<T, N, AP, true>
{
    static inline void destroy(T *, T *) {}

    static inline void initialize(T *begin, T *end) {
# 136 "../../dist/include/js/Vector.h"
        for (T *p = begin; p != end; ++p)
            new(p) T();
    }

    template <class U>
    static inline void copyConstruct(T *dst, const U *srcbeg, const U *srcend) {







        for (const U *p = srcbeg; p != srcend; ++p, ++dst)
            *dst = *p;
    }

    template <class U>
    static inline void moveConstruct(T *dst, const U *srcbeg, const U *srcend) {
        copyConstruct(dst, srcbeg, srcend);
    }

    static inline void copyConstructN(T *dst, size_t n, const T &t) {
        for (T *p = dst, *end = dst + n; p != end; ++p)
            *p = t;
    }

    static inline bool growTo(Vector<T,N,AP> &v, size_t newCap) {
        do { } while(0);
        do { } while(0);
        size_t oldSize = sizeof(T) * v.mCapacity;
        size_t newSize = sizeof(T) * newCap;
        T *newbuf = reinterpret_cast<T *>(v.realloc_(v.mBegin, oldSize, newSize));
        if (!newbuf)
            return false;
        v.mBegin = newbuf;

        v.mCapacity = newCap;
        return true;
    }
};
# 196 "../../dist/include/js/Vector.h"
template <class T, size_t N, class AllocPolicy>
class Vector : private AllocPolicy
{




    static const bool sElemIsPod = mozilla::IsPod<T>::value;
    typedef VectorImpl<T, N, AllocPolicy, sElemIsPod> Impl;
    friend struct VectorImpl<T, N, AllocPolicy, sElemIsPod>;

    bool growStorageBy(size_t incr);
    bool convertToHeapStorage(size_t newCap);

    template <bool InitNewElems> inline bool growByImpl(size_t inc);



    static const int sMaxInlineBytes = 1024;
# 227 "../../dist/include/js/Vector.h"
    template <int M, int Dummy>
    struct ElemSize {
        static const size_t result = sizeof(T);
    };
    template <int Dummy>
    struct ElemSize<0, Dummy> {
        static const size_t result = 1;
    };

    static const size_t sInlineCapacity =
        tl::Min<N, sMaxInlineBytes / ElemSize<N, 0>::result>::result;


    static const size_t sInlineBytes =
        tl::Max<1, sInlineCapacity * ElemSize<N, 0>::result>::result;
# 252 "../../dist/include/js/Vector.h"
    T *mBegin;
    size_t mLength;
    size_t mCapacity;




    mozilla::AlignedStorage<sInlineBytes> storage;






    Vector(const Vector &) = delete;
    Vector &operator=(const Vector &) = delete;



    bool usingInlineStorage() const {
        return mBegin == inlineStorage();
    }

    T *inlineStorage() const {
        return (T *)storage.addr();
    }

    T *beginNoCheck() const {
        return mBegin;
    }

    T *endNoCheck() {
        return mBegin + mLength;
    }

    const T *endNoCheck() const {
        return mBegin + mLength;
    }
# 300 "../../dist/include/js/Vector.h"
    template <class U> void internalAppend(U u);
    void internalAppendN(const T &t, size_t n);
    template <class U> void internalAppend(const U *begin, size_t length);
    template <class U, size_t O, class BP> void internalAppend(const Vector<U,O,BP> &other);

  public:
    static const size_t sMaxInlineStorage = N;

    typedef T ElementType;

    Vector(AllocPolicy = AllocPolicy());
    Vector(MoveRef<Vector>);
    Vector &operator=(MoveRef<Vector>);
    ~Vector();



    const AllocPolicy &allocPolicy() const {
        return *this;
    }

    AllocPolicy &allocPolicy() {
        return *this;
    }

    enum { InlineLength = N };

    size_t length() const {
        return mLength;
    }

    bool empty() const {
        return mLength == 0;
    }

    size_t capacity() const {
        return mCapacity;
    }

    T *begin() {
        do { } while(0);
        return mBegin;
    }

    const T *begin() const {
        do { } while(0);
        return mBegin;
    }

    T *end() {
        do { } while(0);
        return mBegin + mLength;
    }

    const T *end() const {
        do { } while(0);
        return mBegin + mLength;
    }

    T &operator[](size_t i) {
        do { } while(0);
        return begin()[i];
    }

    const T &operator[](size_t i) const {
        do { } while(0);
        return begin()[i];
    }

    T &back() {
        do { } while(0);
        return *(end() - 1);
    }

    const T &back() const {
        do { } while(0);
        return *(end() - 1);
    }

    class Range {
        friend class Vector;
        T *cur_, *end_;
        Range(T *cur, T *end) : cur_(cur), end_(end) {}
      public:
        Range() {}
        bool empty() const { return cur_ == end_; }
        size_t remain() const { return end_ - cur_; }
        T &front() const { return *cur_; }
        void popFront() { do { } while(0); ++cur_; }
        T popCopyFront() { do { } while(0); return *cur_++; }
    };

    Range all() {
        return Range(begin(), end());
    }




    bool initCapacity(size_t request);


    bool reserve(size_t request);





    void shrinkBy(size_t incr);


    bool growBy(size_t incr);


    bool resize(size_t newLength);


    bool growByUninitialized(size_t incr);
    bool resizeUninitialized(size_t newLength);


    void clear();


    void clearAndFree();


    bool canAppendWithoutRealloc(size_t needed) const;
# 437 "../../dist/include/js/Vector.h"
    template <class U> bool append(U t);
    bool appendN(const T &t, size_t n);
    template <class U> bool append(const U *begin, const U *end);
    template <class U> bool append(const U *begin, size_t length);
    template <class U, size_t O, class BP> bool append(const Vector<U,O,BP> &other);





    template <class U> void infallibleAppend(const U &u) {
        internalAppend(u);
    }
    void infallibleAppendN(const T &t, size_t n) {
        internalAppendN(t, n);
    }
    template <class U> void infallibleAppend(const U *aBegin, const U *aEnd) {
        internalAppend(aBegin, mozilla::PointerRangeSize(aBegin, aEnd));
    }
    template <class U> void infallibleAppend(const U *aBegin, size_t aLength) {
        internalAppend(aBegin, aLength);
    }
    template <class U, size_t O, class BP> void infallibleAppend(const Vector<U,O,BP> &other) {
        internalAppend(other);
    }

    void popBack();

    T popCopy();
# 475 "../../dist/include/js/Vector.h"
    T *extractRawBuffer();






    void replaceRawBuffer(T *p, size_t length);
# 497 "../../dist/include/js/Vector.h"
    T *insert(T *p, const T &val);





    void erase(T *t);




    size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const;





    size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const;

    void swap(Vector &other);
};
# 529 "../../dist/include/js/Vector.h"
template <class T, size_t N, class AllocPolicy>
__attribute__((always_inline)) inline
Vector<T,N,AllocPolicy>::Vector(AllocPolicy ap)
  : AllocPolicy(ap), mBegin((T *)storage.addr()), mLength(0),
    mCapacity(sInlineCapacity)



{}


template <class T, size_t N, class AllocPolicy>
__attribute__((always_inline)) inline
Vector<T, N, AllocPolicy>::Vector(MoveRef<Vector> rhs)
    : AllocPolicy(rhs)



{
    mLength = rhs->mLength;
    mCapacity = rhs->mCapacity;




    if (rhs->usingInlineStorage()) {

        mBegin = (T *)storage.addr();
        Impl::moveConstruct(mBegin, rhs->beginNoCheck(), rhs->endNoCheck());




    } else {




        mBegin = rhs->mBegin;
        rhs->mBegin = (T *) rhs->storage.addr();
        rhs->mCapacity = sInlineCapacity;
        rhs->mLength = 0;



    }
}


template <class T, size_t N, class AP>
__attribute__((always_inline)) inline
Vector<T, N, AP> &
Vector<T, N, AP>::operator=(MoveRef<Vector> rhs)
{
    this->~Vector();
    new(this) Vector(rhs);
    return *this;
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline
Vector<T,N,AP>::~Vector()
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    Impl::destroy(beginNoCheck(), endNoCheck());
    if (!usingInlineStorage())
        this->free_(beginNoCheck());
}






template <class T, size_t N, class AP>
inline bool
Vector<T,N,AP>::convertToHeapStorage(size_t newCap)
{
    do { } while(0);


    do { } while(0);
    T *newBuf = reinterpret_cast<T *>(this->malloc_(newCap * sizeof(T)));
    if (!newBuf)
        return false;


    Impl::moveConstruct(newBuf, beginNoCheck(), endNoCheck());
    Impl::destroy(beginNoCheck(), endNoCheck());


    mBegin = newBuf;

    mCapacity = newCap;
    return true;
}

template <class T, size_t N, class AP>
__attribute__((noinline)) bool
Vector<T,N,AP>::growStorageBy(size_t incr)
{
    do { } while(0);
    do { } while (0);
# 641 "../../dist/include/js/Vector.h"
    size_t newCap;

    if (incr == 1) {
        if (usingInlineStorage()) {

            size_t newSize = tl::RoundUpPow2<(sInlineCapacity + 1) * sizeof(T)>::result;
            newCap = newSize / sizeof(T);
            goto convert;
        }

        if (mLength == 0) {

            newCap = 1;
            goto grow;
        }
# 665 "../../dist/include/js/Vector.h"
        if (mLength & tl::MulOverflowMask<4 * sizeof(T)>::result) {
            this->reportAllocOverflow();
            return false;
        }






        newCap = mLength * 2;
        if (CapacityHasExcessSpace<T>(newCap))
            newCap += 1;

    } else {

        size_t newMinCap = mLength + incr;


        if (newMinCap < mLength ||
            newMinCap & tl::MulOverflowMask<2 * sizeof(T)>::result)
        {
            this->reportAllocOverflow();
            return false;
        }

        size_t newMinSize = newMinCap * sizeof(T);
        size_t newSize = RoundUpPow2(newMinSize);
        newCap = newSize / sizeof(T);
    }

    if (usingInlineStorage()) {
      convert:
        return convertToHeapStorage(newCap);
    }

  grow:
    return Impl::growTo(*this, newCap);
}

template <class T, size_t N, class AP>
inline bool
Vector<T,N,AP>::initCapacity(size_t request)
{
    do { } while(0);
    do { } while(0);
    if (request == 0)
        return true;
    T *newbuf = reinterpret_cast<T *>(this->malloc_(request * sizeof(T)));
    if (!newbuf)
        return false;
    mBegin = newbuf;
    mCapacity = request;



    return true;
}

template <class T, size_t N, class AP>
inline bool
Vector<T,N,AP>::reserve(size_t request)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    if (request > mCapacity && !growStorageBy(request - mLength))
        return false;







    return true;
}

template <class T, size_t N, class AP>
inline void
Vector<T,N,AP>::shrinkBy(size_t incr)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    do { } while(0);
    Impl::destroy(endNoCheck() - incr, endNoCheck());
    mLength -= incr;
}

template <class T, size_t N, class AP>
template <bool InitNewElems>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::growByImpl(size_t incr)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    if (incr > mCapacity - mLength && !growStorageBy(incr))
        return false;

    do { } while(0);
    T *newend = endNoCheck() + incr;
    if (InitNewElems)
        Impl::initialize(endNoCheck(), newend);
    mLength += incr;




    return true;
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::growBy(size_t incr)
{
    return growByImpl<true>(incr);
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::growByUninitialized(size_t incr)
{
    return growByImpl<false>(incr);
}

template <class T, size_t N, class AP>

inline bool
Vector<T,N,AP>::resize(size_t newLength)
{
    size_t curLength = mLength;
    if (newLength > curLength)
        return growBy(newLength - curLength);
    shrinkBy(curLength - newLength);
    return true;
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::resizeUninitialized(size_t newLength)
{
    size_t curLength = mLength;
    if (newLength > curLength)
        return growByUninitialized(newLength - curLength);
    shrinkBy(curLength - newLength);
    return true;
}

template <class T, size_t N, class AP>
inline void
Vector<T,N,AP>::clear()
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    Impl::destroy(beginNoCheck(), endNoCheck());
    mLength = 0;
}

template <class T, size_t N, class AP>
inline void
Vector<T,N,AP>::clearAndFree()
{
    clear();

    if (usingInlineStorage())
        return;

    this->free_(beginNoCheck());
    mBegin = (T *)storage.addr();
    mCapacity = sInlineCapacity;



}

template <class T, size_t N, class AP>
inline bool
Vector<T,N,AP>::canAppendWithoutRealloc(size_t needed) const
{
    return mLength + needed <= mCapacity;
}

template <class T, size_t N, class AP>
template <class U>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::append(U t)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    if (mLength == mCapacity && !growStorageBy(1))
        return false;





    internalAppend(t);
    return true;
}

template <class T, size_t N, class AP>
template <class U>
__attribute__((always_inline)) inline void
Vector<T,N,AP>::internalAppend(U u)
{
    do { } while(0);
    do { } while(0);
    new(endNoCheck()) T(u);
    ++mLength;
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::appendN(const T &t, size_t needed)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    if (mLength + needed > mCapacity && !growStorageBy(needed))
        return false;





    internalAppendN(t, needed);
    return true;
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T,N,AP>::internalAppendN(const T &t, size_t needed)
{
    do { } while(0);
    do { } while(0);
    Impl::copyConstructN(endNoCheck(), needed, t);
    mLength += needed;
}

template <class T, size_t N, class AP>
inline T *
Vector<T,N,AP>::insert(T *p, const T &val)
{
    do { } while(0);
    size_t pos = p - begin();
    do { } while(0);
    size_t oldLength = mLength;
    if (pos == oldLength) {
        if (!append(val))
            return __null;
    } else {
        T oldBack = back();
        if (!append(oldBack))
            return __null;
        for (size_t i = oldLength; i > pos; --i)
            (*this)[i] = (*this)[i - 1];
        (*this)[pos] = val;
    }
    return begin() + pos;
}

template<typename T, size_t N, class AP>
inline void
Vector<T,N,AP>::erase(T *it)
{
    do { } while(0);
    while (it + 1 != end()) {
        *it = *(it + 1);
        ++it;
    }
    popBack();
}

template <class T, size_t N, class AP>
template <class U>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::append(const U *insBegin, const U *insEnd)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    size_t needed = mozilla::PointerRangeSize(insBegin, insEnd);
    if (mLength + needed > mCapacity && !growStorageBy(needed))
        return false;





    internalAppend(insBegin, needed);
    return true;
}

template <class T, size_t N, class AP>
template <class U>
__attribute__((always_inline)) inline void
Vector<T,N,AP>::internalAppend(const U *insBegin, size_t insLength)
{
    do { } while(0);
    do { } while(0);
    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + insLength);
    mLength += insLength;
}

template <class T, size_t N, class AP>
template <class U, size_t O, class BP>
inline bool
Vector<T,N,AP>::append(const Vector<U,O,BP> &other)
{
    return append(other.begin(), other.end());
}

template <class T, size_t N, class AP>
template <class U, size_t O, class BP>
inline void
Vector<T,N,AP>::internalAppend(const Vector<U,O,BP> &other)
{
    internalAppend(other.begin(), other.length());
}

template <class T, size_t N, class AP>
template <class U>
__attribute__((always_inline)) inline bool
Vector<T,N,AP>::append(const U *insBegin, size_t insLength)
{
    return this->append(insBegin, insBegin + insLength);
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline void
Vector<T,N,AP>::popBack()
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);
    do { } while(0);
    --mLength;
    endNoCheck()->~T();
}

template <class T, size_t N, class AP>
__attribute__((always_inline)) inline T
Vector<T,N,AP>::popCopy()
{
    T ret = back();
    popBack();
    return ret;
}

template <class T, size_t N, class AP>
inline T *
Vector<T,N,AP>::extractRawBuffer()
{
    T *ret;
    if (usingInlineStorage()) {
        ret = reinterpret_cast<T *>(this->malloc_(mLength * sizeof(T)));
        if (!ret)
            return __null;
        Impl::copyConstruct(ret, beginNoCheck(), endNoCheck());
        Impl::destroy(beginNoCheck(), endNoCheck());

        mLength = 0;
    } else {
        ret = mBegin;
        mBegin = (T *)storage.addr();
        mLength = 0;
        mCapacity = sInlineCapacity;



    }
    return ret;
}

template <class T, size_t N, class AP>
inline void
Vector<T,N,AP>::replaceRawBuffer(T *p, size_t aLength)
{
    ReentrancyGuard g(*this); do { } while (0); do { } while(0); do { } while(0); do { } while(0);


    Impl::destroy(beginNoCheck(), endNoCheck());
    if (!usingInlineStorage())
        this->free_(beginNoCheck());


    if (aLength <= sInlineCapacity) {





        mBegin = (T *)storage.addr();
        mLength = aLength;
        mCapacity = sInlineCapacity;
        Impl::moveConstruct(mBegin, p, p + aLength);
        Impl::destroy(p, p + aLength);
        this->free_(p);
    } else {
        mBegin = p;
        mLength = aLength;
        mCapacity = aLength;
    }



}

template <class T, size_t N, class AP>
inline size_t
Vector<T,N,AP>::sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const
{
    return usingInlineStorage() ? 0 : mallocSizeOf(beginNoCheck());
}

template <class T, size_t N, class AP>
inline size_t
Vector<T,N,AP>::sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const
{
    return mallocSizeOf(this) + sizeOfExcludingThis(mallocSizeOf);
}

template <class T, size_t N, class AP>
inline void
Vector<T,N,AP>::swap(Vector &other)
{

    static_assert((N == 0), "JS_STATIC_ASSERT");


    if (!usingInlineStorage() && other.usingInlineStorage()) {
        other.mBegin = mBegin;
        mBegin = inlineStorage();
    } else if (usingInlineStorage() && !other.usingInlineStorage()) {
        mBegin = other.mBegin;
        other.mBegin = other.inlineStorage();
    } else if (!usingInlineStorage() && !other.usingInlineStorage()) {
        Swap(mBegin, other.mBegin);
    } else {

    }

    Swap(mLength, other.mLength);
    Swap(mCapacity, other.mCapacity);



}

}
# 37 "../../dist/include/jsapi.h" 2



namespace JS {

typedef mozilla::RangedPtr<const jschar> CharPtr;

class StableCharPtr : public CharPtr {
  public:
    StableCharPtr(const StableCharPtr &s) : CharPtr(s) {}
    StableCharPtr(const mozilla::RangedPtr<const jschar> &s) : CharPtr(s) {}
    StableCharPtr(const jschar *s, size_t len) : CharPtr(s, len) {}
    StableCharPtr(const jschar *pos, const jschar *start, size_t len)
      : CharPtr(pos, start, len)
    {}
};
# 83 "../../dist/include/jsapi.h"
inline void AssertArgumentsAreSane(JSContext *cx, const Value &v) {

}


class __attribute__((visibility("default"))) AutoGCRooter {
  public:
    AutoGCRooter(JSContext *cx, ptrdiff_t tag);

    ~AutoGCRooter() {
        do { } while(0);
        *stackTop = down;
    }


    inline void trace(JSTracer *trc);
    static void traceAll(JSTracer *trc);
    static void traceAllWrappers(JSTracer *trc);

  protected:
    AutoGCRooter * const down;
# 112 "../../dist/include/jsapi.h"
    ptrdiff_t tag_;

    enum {
        JSVAL = -1,
        VALARRAY = -2,
        PARSER = -3,
        SHAPEVECTOR = -4,
        IDARRAY = -6,
        DESCRIPTORS = -7,


        OBJECT = -10,
        ID = -11,
        VALVECTOR = -12,
        DESCRIPTOR = -13,
        STRING = -14,
        IDVECTOR = -15,
        OBJVECTOR = -16,
        STRINGVECTOR =-17,
        SCRIPTVECTOR =-18,
        PROPDESC = -19,
        STACKSHAPE = -21,
        STACKBASESHAPE=-22,
        GETTERSETTER =-24,
        REGEXPSTATICS=-25,
        NAMEVECTOR = -26,
        HASHABLEVALUE=-27,
        IONMASM = -28,
        IONALLOC = -29,
        WRAPVECTOR = -30,
        WRAPPER = -31,
        OBJOBJHASHMAP=-32,
        OBJU32HASHMAP=-33,
        OBJHASHSET = -34,
        JSONPARSER = -35
    };

  private:
    AutoGCRooter ** const stackTop;


    AutoGCRooter(AutoGCRooter &ida) = delete;
    void operator=(AutoGCRooter &ida) = delete;
};

class AutoValueRooter : private AutoGCRooter
{
  public:
    explicit AutoValueRooter(JSContext *cx
                             )
      : AutoGCRooter(cx, JSVAL), val(NullValue())
    {
        do { } while (0);
    }

    AutoValueRooter(JSContext *cx, const Value &v
                    )
      : AutoGCRooter(cx, JSVAL), val(v)
    {
        do { } while (0);
    }







    void set(Value v) {
        do { } while(0);
        val = v;
    }

    const Value &value() const {
        do { } while(0);
        return val;
    }

    Value *addr() {
        do { } while(0);
        return &val;
    }

    const Value &jsval_value() const {
        do { } while(0);
        return val;
    }

    Value *jsval_addr() {
        do { } while(0);
        return &val;
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    Value val;
   
};

class AutoObjectRooter : private AutoGCRooter
{
  public:
    AutoObjectRooter(JSContext *cx, JSObject *obj = __null
                     )
      : AutoGCRooter(cx, OBJECT), obj_(obj)
    {
        do { } while (0);
    }

    void setObject(JSObject *obj) {
        obj_ = obj;
    }

    JSObject * object() const {
        return obj_;
    }

    JSObject ** addr() {
        return &obj_;
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    JSObject *obj_;
   
};

class AutoStringRooter : private AutoGCRooter {
  public:
    AutoStringRooter(JSContext *cx, JSString *str = __null
                     )
      : AutoGCRooter(cx, STRING), str_(str)
    {
        do { } while (0);
    }

    void setString(JSString *str) {
        str_ = str;
    }

    JSString * string() const {
        return str_;
    }

    JSString ** addr() {
        return &str_;
    }

    JSString * const * addr() const {
        return &str_;
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    JSString *str_;
   
};

class AutoArrayRooter : private AutoGCRooter {
  public:
    AutoArrayRooter(JSContext *cx, size_t len, Value *vec
                    )
      : AutoGCRooter(cx, len), array(vec), skip(cx, array, len)
    {
        do { } while (0);
        do { } while(0);
    }

    void changeLength(size_t newLength) {
        tag_ = ptrdiff_t(newLength);
        do { } while(0);
    }

    void changeArray(Value *newArray, size_t newLength) {
        changeLength(newLength);
        array = newArray;
    }

    Value *array;

    MutableHandleValue handleAt(size_t i)
    {
        do { } while(0);
        return MutableHandleValue::fromMarkedLocation(&array[i]);
    }
    HandleValue handleAt(size_t i) const
    {
        do { } while(0);
        return HandleValue::fromMarkedLocation(&array[i]);
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
   

    js::SkipRoot skip;
};

template<class T>
class AutoVectorRooter : protected AutoGCRooter
{
  public:
    explicit AutoVectorRooter(JSContext *cx, ptrdiff_t tag
                              )
      : AutoGCRooter(cx, tag), vector(cx), vectorRoot(cx, &vector)
    {
        do { } while (0);
    }

    typedef T ElementType;

    size_t length() const { return vector.length(); }
    bool empty() const { return vector.empty(); }

    bool append(const T &v) { return vector.append(v); }
    bool append(const AutoVectorRooter<T> &other) {
        return vector.append(other.vector);
    }


    void infallibleAppend(const T &v) { vector.infallibleAppend(v); }

    void popBack() { vector.popBack(); }
    T popCopy() { return vector.popCopy(); }

    bool growBy(size_t inc) {
        size_t oldLength = vector.length();
        if (!vector.growByUninitialized(inc))
            return false;
        makeRangeGCSafe(oldLength);
        return true;
    }

    bool resize(size_t newLength) {
        size_t oldLength = vector.length();
        if (newLength <= oldLength) {
            vector.shrinkBy(oldLength - newLength);
            return true;
        }
        if (!vector.growByUninitialized(newLength - oldLength))
            return false;
        makeRangeGCSafe(oldLength);
        return true;
    }

    void clear() { vector.clear(); }

    bool reserve(size_t newLength) {
        return vector.reserve(newLength);
    }

    T &operator[](size_t i) { return vector[i]; }
    const T &operator[](size_t i) const { return vector[i]; }

    JS::MutableHandle<T> handleAt(size_t i) { return JS::MutableHandle<T>::fromMarkedLocation(&vector[i]); }
    JS::Handle<T> handleAt(size_t i) const { return JS::Handle<T>::fromMarkedLocation(&vector[i]); }

    const T *begin() const { return vector.begin(); }
    T *begin() { return vector.begin(); }

    const T *end() const { return vector.end(); }
    T *end() { return vector.end(); }

    const T &back() const { return vector.back(); }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    void makeRangeGCSafe(size_t oldLength) {
        T *t = vector.begin() + oldLength;
        for (size_t i = oldLength; i < vector.length(); ++i, ++t)
            memset(t, 0, sizeof(T));
    }

    typedef js::Vector<T, 8> VectorImpl;
    VectorImpl vector;


    js::SkipRoot vectorRoot;

   
};

template<class Key, class Value>
class AutoHashMapRooter : protected AutoGCRooter
{
  private:
    typedef js::HashMap<Key, Value> HashMapImpl;

  public:
    explicit AutoHashMapRooter(JSContext *cx, ptrdiff_t tag
                               )
      : AutoGCRooter(cx, tag), map(cx)
    {
        do { } while (0);
    }

    typedef Key KeyType;
    typedef Value ValueType;
    typedef typename HashMapImpl::Lookup Lookup;
    typedef typename HashMapImpl::Ptr Ptr;
    typedef typename HashMapImpl::AddPtr AddPtr;

    bool init(uint32_t len = 16) {
        return map.init(len);
    }
    bool initialized() const {
        return map.initialized();
    }
    Ptr lookup(const Lookup &l) const {
        return map.lookup(l);
    }
    void remove(Ptr p) {
        map.remove(p);
    }
    AddPtr lookupForAdd(const Lookup &l) const {
        return map.lookupForAdd(l);
    }

    template<typename KeyInput, typename ValueInput>
    bool add(AddPtr &p, const KeyInput &k, const ValueInput &v) {
        return map.add(p, k, v);
    }

    bool add(AddPtr &p, const Key &k) {
        return map.add(p, k);
    }

    template<typename KeyInput, typename ValueInput>
    bool relookupOrAdd(AddPtr &p, const KeyInput &k, const ValueInput &v) {
        return map.relookupOrAdd(p, k, v);
    }

    typedef typename HashMapImpl::Range Range;
    Range all() const {
        return map.all();
    }

    typedef typename HashMapImpl::Enum Enum;

    void clear() {
        map.clear();
    }

    void finish() {
        map.finish();
    }

    bool empty() const {
        return map.empty();
    }

    uint32_t count() const {
        return map.count();
    }

    size_t capacity() const {
        return map.capacity();
    }

    size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return map.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return map.sizeOfIncludingThis(mallocSizeOf);
    }

    unsigned generation() const {
        return map.generation();
    }



    bool has(const Lookup &l) const {
        return map.has(l);
    }

    template<typename KeyInput, typename ValueInput>
    bool put(const KeyInput &k, const ValueInput &v) {
        return map.put(k, v);
    }

    template<typename KeyInput, typename ValueInput>
    bool putNew(const KeyInput &k, const ValueInput &v) {
        return map.putNew(k, v);
    }

    Ptr lookupWithDefault(const Key &k, const Value &defaultValue) {
        return map.lookupWithDefault(k, defaultValue);
    }

    void remove(const Lookup &l) {
        map.remove(l);
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    AutoHashMapRooter(const AutoHashMapRooter &hmr) = delete;
    AutoHashMapRooter &operator=(const AutoHashMapRooter &hmr) = delete;

    HashMapImpl map;

   
};

template<class T>
class AutoHashSetRooter : protected AutoGCRooter
{
  private:
    typedef js::HashSet<T> HashSetImpl;

  public:
    explicit AutoHashSetRooter(JSContext *cx, ptrdiff_t tag
                               )
      : AutoGCRooter(cx, tag), set(cx)
    {
        do { } while (0);
    }

    typedef typename HashSetImpl::Lookup Lookup;
    typedef typename HashSetImpl::Ptr Ptr;
    typedef typename HashSetImpl::AddPtr AddPtr;

    bool init(uint32_t len = 16) {
        return set.init(len);
    }
    bool initialized() const {
        return set.initialized();
    }
    Ptr lookup(const Lookup &l) const {
        return set.lookup(l);
    }
    void remove(Ptr p) {
        set.remove(p);
    }
    AddPtr lookupForAdd(const Lookup &l) const {
        return set.lookupForAdd(l);
    }

    bool add(AddPtr &p, const T &t) {
        return set.add(p, t);
    }

    bool relookupOrAdd(AddPtr &p, const Lookup &l, const T &t) {
        return set.relookupOrAdd(p, l, t);
    }

    typedef typename HashSetImpl::Range Range;
    Range all() const {
        return set.all();
    }

    typedef typename HashSetImpl::Enum Enum;

    void clear() {
        set.clear();
    }

    void finish() {
        set.finish();
    }

    bool empty() const {
        return set.empty();
    }

    uint32_t count() const {
        return set.count();
    }

    size_t capacity() const {
        return set.capacity();
    }

    size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return set.sizeOfExcludingThis(mallocSizeOf);
    }
    size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const {
        return set.sizeOfIncludingThis(mallocSizeOf);
    }

    unsigned generation() const {
        return set.generation();
    }



    bool has(const Lookup &l) const {
        return set.has(l);
    }

    bool put(const T &t) {
        return set.put(t);
    }

    bool putNew(const T &t) {
        return set.putNew(t);
    }

    void remove(const Lookup &l) {
        set.remove(l);
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    AutoHashSetRooter(const AutoHashSetRooter &hmr) = delete;
    AutoHashSetRooter &operator=(const AutoHashSetRooter &hmr) = delete;

    HashSetImpl set;

   
};

class AutoValueVector : public AutoVectorRooter<Value>
{
  public:
    explicit AutoValueVector(JSContext *cx
                             )
        : AutoVectorRooter<Value>(cx, VALVECTOR)
    {
        do { } while (0);
    }

   
};

class AutoIdVector : public AutoVectorRooter<jsid>
{
  public:
    explicit AutoIdVector(JSContext *cx
                          )
        : AutoVectorRooter<jsid>(cx, IDVECTOR)
    {
        do { } while (0);
    }

   
};

class AutoScriptVector : public AutoVectorRooter<JSScript *>
{
  public:
    explicit AutoScriptVector(JSContext *cx
                              )
        : AutoVectorRooter<JSScript *>(cx, SCRIPTVECTOR)
    {
        do { } while (0);
    }

   
};


typedef bool (*IsAcceptableThis)(const Value &v);





typedef bool (*NativeImpl)(JSContext *cx, CallArgs args);

namespace detail {


extern __attribute__((visibility("default"))) bool
CallMethodIfWrapped(JSContext *cx, IsAcceptableThis test, NativeImpl impl, CallArgs args);

}
# 751 "../../dist/include/jsapi.h"
template<IsAcceptableThis Test, NativeImpl Impl>
__attribute__((always_inline)) inline bool
CallNonGenericMethod(JSContext *cx, CallArgs args)
{
    const Value &thisv = args.thisv();
    if (Test(thisv))
        return Impl(cx, args);

    return detail::CallMethodIfWrapped(cx, Test, Impl, args);
}

__attribute__((always_inline)) inline bool
CallNonGenericMethod(JSContext *cx, IsAcceptableThis Test, NativeImpl Impl, CallArgs args)
{
    const Value &thisv = args.thisv();
    if (Test(thisv))
        return Impl(cx, args);

    return detail::CallMethodIfWrapped(cx, Test, Impl, args);
}

}



typedef JS::Handle<JSObject*> JSHandleObject;
typedef JS::Handle<JSString*> JSHandleString;
typedef JS::Handle<JS::Value> JSHandleValue;
typedef JS::Handle<jsid> JSHandleId;

typedef JS::MutableHandle<JSObject*> JSMutableHandleObject;
typedef JS::MutableHandle<JSFunction*> JSMutableHandleFunction;
typedef JS::MutableHandle<JSScript*> JSMutableHandleScript;
typedef JS::MutableHandle<JSString*> JSMutableHandleString;
typedef JS::MutableHandle<JS::Value> JSMutableHandleValue;
typedef JS::MutableHandle<jsid> JSMutableHandleId;

typedef js::RawObject JSRawObject;
typedef js::RawFunction JSRawFunction;
typedef js::RawScript JSRawScript;
typedef js::RawString JSRawString;
typedef js::RawId JSRawId;
typedef js::RawValue JSRawValue;
# 804 "../../dist/include/jsapi.h"
typedef JSBool
(* JSPropertyOp)(JSContext *cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp);
# 814 "../../dist/include/jsapi.h"
typedef JSBool
(* JSStrictPropertyOp)(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, JSMutableHandleValue vp);
# 849 "../../dist/include/jsapi.h"
typedef JSBool
(* JSNewEnumerateOp)(JSContext *cx, JSHandleObject obj, JSIterateOp enum_op,
                     JSMutableHandleValue statep, JSMutableHandleId idp);





typedef JSBool
(* JSEnumerateOp)(JSContext *cx, JSHandleObject obj);
# 872 "../../dist/include/jsapi.h"
typedef JSBool
(* JSResolveOp)(JSContext *cx, JSHandleObject obj, JSHandleId id);
# 887 "../../dist/include/jsapi.h"
typedef JSBool
(* JSNewResolveOp)(JSContext *cx, JSHandleObject obj, JSHandleId id, unsigned flags,
                   JSMutableHandleObject objp);





typedef JSBool
(* JSConvertOp)(JSContext *cx, JSHandleObject obj, JSType type, JSMutableHandleValue vp);

typedef struct JSFreeOp JSFreeOp;

struct JSFreeOp {
  private:
    JSRuntime *runtime_;

  protected:
    JSFreeOp(JSRuntime *rt)
      : runtime_(rt) { }

  public:
    JSRuntime *runtime() const {
        return runtime_;
    }
};






typedef void
(* JSFinalizeOp)(JSFreeOp *fop, JSObject *obj);




typedef struct JSStringFinalizer JSStringFinalizer;

struct JSStringFinalizer {
    void (*finalize)(const JSStringFinalizer *fin, jschar *chars);
};







typedef JSBool
(* JSCheckAccessOp)(JSContext *cx, JSHandleObject obj, JSHandleId id, JSAccessMode mode,
                    JSMutableHandleValue vp);






typedef JSBool
(* JSHasInstanceOp)(JSContext *cx, JSHandleObject obj, JSMutableHandleValue vp, JSBool *bp);
# 963 "../../dist/include/jsapi.h"
typedef void
(* JSTraceOp)(JSTracer *trc, JSRawObject obj);





typedef void
(* JSTraceNamePrinter)(JSTracer *trc, char *buf, size_t bufsize);

typedef JSRawObject
(* JSWeakmapKeyDelegateOp)(JSRawObject obj);



typedef enum JSContextOp {
    JSCONTEXT_NEW,
    JSCONTEXT_DESTROY
} JSContextOp;
# 996 "../../dist/include/jsapi.h"
typedef JSBool
(* JSContextCallback)(JSContext *cx, unsigned contextOp);

typedef enum JSGCStatus {
    JSGC_BEGIN,
    JSGC_END
} JSGCStatus;

typedef void
(* JSGCCallback)(JSRuntime *rt, JSGCStatus status);

typedef enum JSFinalizeStatus {





    JSFINALIZE_GROUP_START,







    JSFINALIZE_GROUP_END,




    JSFINALIZE_COLLECTION_END
} JSFinalizeStatus;

typedef void
(* JSFinalizeCallback)(JSFreeOp *fop, JSFinalizeStatus status, JSBool isCompartment);





typedef void
(* JSTraceDataOp)(JSTracer *trc, void *data);

typedef JSBool
(* JSOperationCallback)(JSContext *cx);

typedef void
(* JSErrorReporter)(JSContext *cx, const char *message, JSErrorReport *report);
# 1058 "../../dist/include/jsapi.h"
typedef enum JSExnType {
    JSEXN_NONE = -1,
      JSEXN_ERR,
        JSEXN_INTERNALERR,
        JSEXN_EVALERR,
        JSEXN_RANGEERR,
        JSEXN_REFERENCEERR,
        JSEXN_SYNTAXERR,
        JSEXN_TYPEERR,
        JSEXN_URIERR,
        JSEXN_LIMIT
} JSExnType;

typedef struct JSErrorFormatString {

    const char *format;


    uint16_t argCount;


    int16_t exnType;
} JSErrorFormatString;

typedef const JSErrorFormatString *
(* JSErrorCallback)(void *userRef, const char *locale,
                    const unsigned errorNumber);

typedef JSBool
(* JSLocaleToUpperCase)(JSContext *cx, JSString *src, jsval *rval);

typedef JSBool
(* JSLocaleToLowerCase)(JSContext *cx, JSString *src, jsval *rval);

typedef JSBool
(* JSLocaleCompare)(JSContext *cx, JSString *src1, JSString *src2,
                    jsval *rval);

typedef JSBool
(* JSLocaleToUnicode)(JSContext *cx, const char *src, jsval *rval);





typedef void
(* JSDestroyPrincipalsOp)(JSPrincipals *principals);





typedef JSBool
(* JSCSPEvalChecker)(JSContext *cx);
# 1122 "../../dist/include/jsapi.h"
typedef JSObject *
(* JSWrapObjectCallback)(JSContext *cx, JSObject *existing, JSObject *obj,
                         JSObject *proto, JSObject *parent,
                         unsigned flags);






typedef JSObject *
(* JSPreWrapCallback)(JSContext *cx, JSObject *scope, JSObject *obj, unsigned flags);
# 1145 "../../dist/include/jsapi.h"
typedef JSObject *
(* JSSameCompartmentWrapObjectCallback)(JSContext *cx, JSObject *obj);

typedef void
(* JSDestroyCompartmentCallback)(JSFreeOp *fop, JSCompartment *compartment);

typedef void
(* JSCompartmentNameCallback)(JSRuntime *rt, JSCompartment *compartment,
                              char *buf, size_t bufsize);
# 1164 "../../dist/include/jsapi.h"
typedef JSObject *(*ReadStructuredCloneOp)(JSContext *cx, JSStructuredCloneReader *r,
                                           uint32_t tag, uint32_t data, void *closure);
# 1178 "../../dist/include/jsapi.h"
typedef JSBool (*WriteStructuredCloneOp)(JSContext *cx, JSStructuredCloneWriter *w,
                                         JSObject *obj, void *closure);






typedef void (*StructuredCloneErrorOp)(JSContext *cx, uint32_t errorid);
# 1196 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) const jsval JSVAL_NULL;
extern __attribute__((visibility("default"))) const jsval JSVAL_ZERO;
extern __attribute__((visibility("default"))) const jsval JSVAL_ONE;
extern __attribute__((visibility("default"))) const jsval JSVAL_FALSE;
extern __attribute__((visibility("default"))) const jsval JSVAL_TRUE;
extern __attribute__((visibility("default"))) const jsval JSVAL_VOID;

static __attribute__((always_inline)) inline jsval
JS_NumberValue(double d)
{
    int32_t i;
    d = JS_CANONICALIZE_NAN(d);
    if (MOZ_DOUBLE_IS_INT32(d, &i))
        return INT_TO_JSVAL(i);
    return DOUBLE_TO_JSVAL(d);
}
# 1237 "../../dist/include/jsapi.h"
static __attribute__((always_inline)) inline JSBool
JSID_IS_STRING(jsid iden)
{
    return ((iden) & 0x7) == 0;
}

static __attribute__((always_inline)) inline JSString *
JSID_TO_STRING(jsid iden)
{
    do { } while(0);
    return (JSString *)(iden);
}

static __attribute__((always_inline)) inline JSBool
JSID_IS_ZERO(jsid iden)
{
    return (iden) == 0;
}

__attribute__((visibility("default"))) JSBool
JS_StringHasBeenInterned(JSContext *cx, JSString *str);
# 1266 "../../dist/include/jsapi.h"
__attribute__((visibility("default"))) jsid
INTERNED_STRING_TO_JSID(JSContext *cx, JSString *str);

static __attribute__((always_inline)) inline JSBool
JSID_IS_INT(jsid iden)
{
    return !!((iden) & 0x1);
}

static __attribute__((always_inline)) inline int32_t
JSID_TO_INT(jsid iden)
{
    do { } while(0);
    return ((uint32_t)(iden)) >> 1;
}




static __attribute__((always_inline)) inline JSBool
INT_FITS_IN_JSID(int32_t i)
{
    return i >= 0;
}

static __attribute__((always_inline)) inline jsid
INT_TO_JSID(int32_t i)
{
    jsid iden;
    do { } while(0);
    (iden) = ((i << 1) | 0x1);
    return iden;
}

static __attribute__((always_inline)) inline JSBool
JSID_IS_OBJECT(jsid iden)
{
    return ((iden) & 0x7) == 0x4 &&
           (size_t)(iden) != 0x4;
}

static __attribute__((always_inline)) inline JSObject *
JSID_TO_OBJECT(jsid iden)
{
    do { } while(0);
    return (JSObject *)((iden) & ~(size_t)0x7);
}

static __attribute__((always_inline)) inline jsid
OBJECT_TO_JSID(JSRawObject obj)
{
    jsid iden;
    do { } while(0);
    do { } while(0);
    (iden) = ((size_t)obj | 0x4);
    return iden;
}

static __attribute__((always_inline)) inline JSBool
JSID_IS_GCTHING(jsid iden)
{
    return JSID_IS_STRING(iden) || JSID_IS_OBJECT(iden);
}

static __attribute__((always_inline)) inline void *
JSID_TO_GCTHING(jsid iden)
{
    return (void *)((iden) & ~(size_t)0x7);
}
# 1343 "../../dist/include/jsapi.h"
static __attribute__((always_inline)) inline JSBool
JSID_IS_VOID(const js::RawId iden)
{
    do { } while (0)
                                                 ;
    return ((size_t)(iden) == 0x2);
}

static __attribute__((always_inline)) inline JSBool
JSID_IS_EMPTY(const js::RawId iden)
{
    return ((size_t)(iden) == 0x4);
}
# 1371 "../../dist/include/jsapi.h"
static __attribute__((always_inline)) inline JSBool
JSVAL_IS_UNIVERSAL(jsval v)
{
    return !JSVAL_IS_GCTHING(v);
}

namespace JS {

class AutoIdRooter : private AutoGCRooter
{
  public:
    explicit AutoIdRooter(JSContext *cx, jsid aId = INT_TO_JSID(0)
                          )
      : AutoGCRooter(cx, ID), id_(aId)
    {
        do { } while (0);
    }

    jsid id() {
        return id_;
    }

    jsid * addr() {
        return &id_;
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

  private:
    jsid id_;
   
};

}
# 1457 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_CallOnce(JSCallOnceType *once, JSInitCallback func);


extern __attribute__((visibility("default"))) int64_t
JS_Now(void);


extern __attribute__((visibility("default"))) jsval
JS_GetNaNValue(JSContext *cx);

extern __attribute__((visibility("default"))) jsval
JS_GetNegativeInfinityValue(JSContext *cx);

extern __attribute__((visibility("default"))) jsval
JS_GetPositiveInfinityValue(JSContext *cx);

extern __attribute__((visibility("default"))) jsval
JS_GetEmptyStringValue(JSContext *cx);

extern __attribute__((visibility("default"))) JSString *
JS_GetEmptyString(JSRuntime *rt);
# 1512 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_ConvertArguments(JSContext *cx, unsigned argc, jsval *argv, const char *format,
                    ...);


extern __attribute__((visibility("default"))) JSBool
JS_ConvertArgumentsVA(JSContext *cx, unsigned argc, jsval *argv,
                      const char *format, va_list ap);


extern __attribute__((visibility("default"))) JSBool
JS_ConvertValue(JSContext *cx, jsval v, JSType type, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_ValueToObject(JSContext *cx, jsval v, JSObject **objp);

extern __attribute__((visibility("default"))) JSFunction *
JS_ValueToFunction(JSContext *cx, jsval v);

extern __attribute__((visibility("default"))) JSFunction *
JS_ValueToConstructor(JSContext *cx, jsval v);

extern __attribute__((visibility("default"))) JSString *
JS_ValueToString(JSContext *cx, jsval v);

extern __attribute__((visibility("default"))) JSString *
JS_ValueToSource(JSContext *cx, jsval v);

extern __attribute__((visibility("default"))) JSBool
JS_ValueToNumber(JSContext *cx, jsval v, double *dp);

namespace js {



extern __attribute__((visibility("default"))) bool
ToNumberSlow(JSContext *cx, JS::Value v, double *dp);




extern __attribute__((visibility("default"))) bool
ToBooleanSlow(const JS::Value &v);
}

namespace JS {


__attribute__((always_inline)) inline bool
ToNumber(JSContext *cx, const Value &v, double *out)
{
    AssertArgumentsAreSane(cx, v);
    {
        js::SkipRoot root(cx, &v);
        js::MaybeCheckStackRoots(cx);
    }

    if (v.isNumber()) {
        *out = v.toNumber();
        return true;
    }
    return js::ToNumberSlow(cx, v, out);
}

__attribute__((always_inline)) inline bool
ToBoolean(const Value &v)
{
    if (v.isBoolean())
        return v.toBoolean();
    if (v.isInt32())
        return v.toInt32() != 0;
    if (v.isNullOrUndefined())
        return false;
    if (v.isDouble()) {
        double d = v.toDouble();
        return !MOZ_DOUBLE_IS_NaN(d) && d != 0;
    }


    return js::ToBooleanSlow(v);
}

}

extern __attribute__((visibility("default"))) JSBool
JS_DoubleIsInt32(double d, int32_t *ip);

extern __attribute__((visibility("default"))) int32_t
JS_DoubleToInt32(double d);

extern __attribute__((visibility("default"))) uint32_t
JS_DoubleToUint32(double d);





extern __attribute__((visibility("default"))) JSBool
JS_ValueToECMAInt32(JSContext *cx, jsval v, int32_t *ip);





extern __attribute__((visibility("default"))) JSBool
JS_ValueToInt64(JSContext *cx, jsval v, int64_t *ip);





extern __attribute__((visibility("default"))) JSBool
JS_ValueToUint64(JSContext *cx, jsval v, uint64_t *ip);

namespace js {

extern __attribute__((visibility("default"))) bool
ToUint16Slow(JSContext *cx, const JS::Value &v, uint16_t *out);


extern __attribute__((visibility("default"))) bool
ToInt32Slow(JSContext *cx, const JS::Value &v, int32_t *out);


extern __attribute__((visibility("default"))) bool
ToUint32Slow(JSContext *cx, const JS::Value &v, uint32_t *out);


extern __attribute__((visibility("default"))) bool
ToInt64Slow(JSContext *cx, const JS::Value &v, int64_t *out);


extern __attribute__((visibility("default"))) bool
ToUint64Slow(JSContext *cx, const JS::Value &v, uint64_t *out);
}

namespace JS {

__attribute__((always_inline)) inline bool
ToUint16(JSContext *cx, const JS::Value &v, uint16_t *out)
{
    AssertArgumentsAreSane(cx, v);
    {
        js::SkipRoot skip(cx, &v);
        js::MaybeCheckStackRoots(cx);
    }

    if (v.isInt32()) {
        *out = uint16_t(v.toInt32());
        return true;
    }
    return js::ToUint16Slow(cx, v, out);
}

__attribute__((always_inline)) inline bool
ToInt32(JSContext *cx, const JS::Value &v, int32_t *out)
{
    AssertArgumentsAreSane(cx, v);
    {
        js::SkipRoot root(cx, &v);
        js::MaybeCheckStackRoots(cx);
    }

    if (v.isInt32()) {
        *out = v.toInt32();
        return true;
    }
    return js::ToInt32Slow(cx, v, out);
}

__attribute__((always_inline)) inline bool
ToUint32(JSContext *cx, const JS::Value &v, uint32_t *out)
{
    AssertArgumentsAreSane(cx, v);
    {
        js::SkipRoot root(cx, &v);
        js::MaybeCheckStackRoots(cx);
    }

    if (v.isInt32()) {
        *out = uint32_t(v.toInt32());
        return true;
    }
    return js::ToUint32Slow(cx, v, out);
}

__attribute__((always_inline)) inline bool
ToInt64(JSContext *cx, const JS::Value &v, int64_t *out)
{
    AssertArgumentsAreSane(cx, v);
    {
        js::SkipRoot skip(cx, &v);
        js::MaybeCheckStackRoots(cx);
    }

    if (v.isInt32()) {
        *out = int64_t(v.toInt32());
        return true;
    }

    return js::ToInt64Slow(cx, v, out);
}

__attribute__((always_inline)) inline bool
ToUint64(JSContext *cx, const JS::Value &v, uint64_t *out)
{
    AssertArgumentsAreSane(cx, v);
    {
        js::SkipRoot skip(cx, &v);
        js::MaybeCheckStackRoots(cx);
    }

    if (v.isInt32()) {

        *out = uint64_t(int64_t(v.toInt32()));
        return true;
    }

    return js::ToUint64Slow(cx, v, out);
}


}





extern __attribute__((visibility("default"))) JSBool
JS_ValueToECMAUint32(JSContext *cx, jsval v, uint32_t *ip);






extern __attribute__((visibility("default"))) JSBool
JS_ValueToInt32(JSContext *cx, jsval v, int32_t *ip);




extern __attribute__((visibility("default"))) JSBool
JS_ValueToUint16(JSContext *cx, jsval v, uint16_t *ip);

extern __attribute__((visibility("default"))) JSBool
JS_ValueToBoolean(JSContext *cx, jsval v, JSBool *bp);

extern __attribute__((visibility("default"))) JSType
JS_TypeOfValue(JSContext *cx, jsval v);

extern __attribute__((visibility("default"))) const char *
JS_GetTypeName(JSContext *cx, JSType type);

extern __attribute__((visibility("default"))) JSBool
JS_StrictlyEqual(JSContext *cx, jsval v1, jsval v2, JSBool *equal);

extern __attribute__((visibility("default"))) JSBool
JS_LooselyEqual(JSContext *cx, jsval v1, jsval v2, JSBool *equal);

extern __attribute__((visibility("default"))) JSBool
JS_SameValue(JSContext *cx, jsval v1, jsval v2, JSBool *same);


extern __attribute__((visibility("default"))) JSBool
JS_IsBuiltinEvalFunction(JSFunction *fun);


extern __attribute__((visibility("default"))) JSBool
JS_IsBuiltinFunctionConstructor(JSFunction *fun);
# 1793 "../../dist/include/jsapi.h"
typedef enum JSUseHelperThreads
{
    JS_NO_HELPER_THREADS,
    JS_USE_HELPER_THREADS
} JSUseHelperThreads;

extern __attribute__((visibility("default"))) JSRuntime *
JS_NewRuntime(uint32_t maxbytes, JSUseHelperThreads useHelperThreads);

extern __attribute__((visibility("default"))) void
JS_DestroyRuntime(JSRuntime *rt);

extern __attribute__((visibility("default"))) void
JS_ShutDown(void);

__attribute__((visibility("default"))) void *
JS_GetRuntimePrivate(JSRuntime *rt);

extern __attribute__((visibility("default"))) JSRuntime *
JS_GetRuntime(JSContext *cx);

__attribute__((visibility("default"))) void
JS_SetRuntimePrivate(JSRuntime *rt, void *data);

extern __attribute__((visibility("default"))) void
JS_BeginRequest(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_EndRequest(JSContext *cx);

extern __attribute__((visibility("default"))) JSBool
JS_IsInRequest(JSRuntime *rt);

namespace JS {

inline bool
IsPoisonedId(jsid iden)
{
    if (JSID_IS_STRING(iden))
        return JS::IsPoisonedPtr(JSID_TO_STRING(iden));
    if (JSID_IS_OBJECT(iden))
        return JS::IsPoisonedPtr(JSID_TO_OBJECT(iden));
    return false;
}

}

namespace js {

template <> struct RootMethods<jsid>
{
    static jsid initial() { return ((jsid)0x2); }
    static ThingRootKind kind() { return THING_ROOT_ID; }
    static bool poisoned(jsid id) { return JS::IsPoisonedId(id); }
};

}

class JSAutoRequest
{
  public:
    JSAutoRequest(JSContext *cx
                  )
      : mContext(cx)
    {
        do { } while (0);
        JS_BeginRequest(mContext);
    }
    ~JSAutoRequest() {
        JS_EndRequest(mContext);
    }

  protected:
    JSContext *mContext;
   






};

class JSAutoCheckRequest
{
  public:
    JSAutoCheckRequest(JSContext *cx
                       )
    {




        do { } while (0);
    }

    ~JSAutoCheckRequest() {



    }


  private:



   
};

extern __attribute__((visibility("default"))) JSContextCallback
JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback);

extern __attribute__((visibility("default"))) JSContext *
JS_NewContext(JSRuntime *rt, size_t stackChunkSize);

extern __attribute__((visibility("default"))) void
JS_DestroyContext(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_DestroyContextNoGC(JSContext *cx);

extern __attribute__((visibility("default"))) void *
JS_GetContextPrivate(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_SetContextPrivate(JSContext *cx, void *data);

extern __attribute__((visibility("default"))) void *
JS_GetSecondContextPrivate(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_SetSecondContextPrivate(JSContext *cx, void *data);

extern __attribute__((visibility("default"))) JSRuntime *
JS_GetRuntime(JSContext *cx);

extern __attribute__((visibility("default"))) JSContext *
JS_ContextIterator(JSRuntime *rt, JSContext **iterp);

extern __attribute__((visibility("default"))) JSVersion
JS_GetVersion(JSContext *cx);

extern __attribute__((visibility("default"))) JSVersion
JS_SetVersion(JSContext *cx, JSVersion version);

extern __attribute__((visibility("default"))) const char *
JS_VersionToString(JSVersion version);

extern __attribute__((visibility("default"))) JSVersion
JS_StringToVersion(const char *string);
# 2016 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) uint32_t
JS_GetOptions(JSContext *cx);

extern __attribute__((visibility("default"))) uint32_t
JS_SetOptions(JSContext *cx, uint32_t options);

extern __attribute__((visibility("default"))) uint32_t
JS_ToggleOptions(JSContext *cx, uint32_t options);

extern __attribute__((visibility("default"))) void
JS_SetJitHardening(JSRuntime *rt, JSBool enabled);

extern __attribute__((visibility("default"))) const char *
JS_GetImplementationVersion(void);

extern __attribute__((visibility("default"))) void
JS_SetDestroyCompartmentCallback(JSRuntime *rt, JSDestroyCompartmentCallback callback);

extern __attribute__((visibility("default"))) void
JS_SetCompartmentNameCallback(JSRuntime *rt, JSCompartmentNameCallback callback);

extern __attribute__((visibility("default"))) JSWrapObjectCallback
JS_SetWrapObjectCallbacks(JSRuntime *rt,
                          JSWrapObjectCallback callback,
                          JSSameCompartmentWrapObjectCallback sccallback,
                          JSPreWrapCallback precallback);

extern __attribute__((visibility("default"))) void
JS_SetCompartmentPrivate(JSCompartment *compartment, void *data);

extern __attribute__((visibility("default"))) void *
JS_GetCompartmentPrivate(JSCompartment *compartment);

extern __attribute__((visibility("default"))) JSBool
JS_WrapObject(JSContext *cx, JSObject **objp);

extern __attribute__((visibility("default"))) JSBool
JS_WrapValue(JSContext *cx, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_WrapId(JSContext *cx, jsid *idp);

extern __attribute__((visibility("default"))) JSObject *
JS_TransplantObject(JSContext *cx, JSObject *origobj, JSObject *target);

extern __attribute__((visibility("default"))) JSObject *
js_TransplantObjectWithWrapper(JSContext *cx,
                               JSObject *origobj,
                               JSObject *origwrapper,
                               JSObject *targetobj,
                               JSObject *targetwrapper);

extern __attribute__((visibility("default"))) JSBool
JS_RefreshCrossCompartmentWrappers(JSContext *cx, JSObject *ob);
# 2106 "../../dist/include/jsapi.h"
class __attribute__((visibility("default"))) JSAutoCompartment
{
    JSContext *cx_;
    JSCompartment *oldCompartment_;
  public:
    JSAutoCompartment(JSContext *cx, JSRawObject target);
    JSAutoCompartment(JSContext *cx, JSScript *target);
    ~JSAutoCompartment();
};


extern __attribute__((visibility("default"))) JSCompartment *
JS_EnterCompartment(JSContext *cx, JSRawObject target);

extern __attribute__((visibility("default"))) void
JS_LeaveCompartment(JSContext *cx, JSCompartment *oldCompartment);

typedef void (*JSIterateCompartmentCallback)(JSRuntime *rt, void *data, JSCompartment *compartment);






extern __attribute__((visibility("default"))) void
JS_IterateCompartments(JSRuntime *rt, void *data,
                       JSIterateCompartmentCallback compartmentCallback);

extern __attribute__((visibility("default"))) JSObject *
JS_GetGlobalObject(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_SetGlobalObject(JSContext *cx, JSRawObject obj);
# 2147 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_InitStandardClasses(JSContext *cx, JSObject *obj);
# 2163 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_ResolveStandardClass(JSContext *cx, JSObject *obj, jsid id,
                        JSBool *resolved);

extern __attribute__((visibility("default"))) JSBool
JS_EnumerateStandardClasses(JSContext *cx, JSObject *obj);






extern __attribute__((visibility("default"))) JSIdArray *
JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *obj,
                                    JSIdArray *ida);

extern __attribute__((visibility("default"))) JSBool
JS_GetClassObject(JSContext *cx, JSRawObject obj, JSProtoKey key, JSObject **objp);

extern __attribute__((visibility("default"))) JSBool
JS_GetClassPrototype(JSContext *cx, JSProtoKey key, JSObject **objp);

extern __attribute__((visibility("default"))) JSProtoKey
JS_IdentifyClassPrototype(JSContext *cx, JSObject *obj);





extern __attribute__((visibility("default"))) JSObject *
JS_GetFunctionPrototype(JSContext *cx, JSRawObject forObj);





extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectPrototype(JSContext *cx, JSRawObject forObj);

extern __attribute__((visibility("default"))) JSObject *
JS_GetGlobalForObject(JSContext *cx, JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_IsGlobalObject(JSRawObject obj);





extern __attribute__((visibility("default"))) JSObject *
JS_GetGlobalForCompartmentOrNull(JSContext *cx, JSCompartment *c);

extern __attribute__((visibility("default"))) JSObject *
JS_GetGlobalForScopeChain(JSContext *cx);
# 2227 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSObject *
JS_GetScriptedGlobal(JSContext *cx);




extern __attribute__((visibility("default"))) JSObject *
JS_InitReflect(JSContext *cx, JSObject *global);






extern __attribute__((visibility("default"))) JSBool
JS_InitCTypesClass(JSContext *cx, JSObject *global);






typedef char *
(* JSCTypesUnicodeToNativeFun)(JSContext *cx, const jschar *source, size_t slen);






struct JSCTypesCallbacks {
    JSCTypesUnicodeToNativeFun unicodeToNative;
};

typedef struct JSCTypesCallbacks JSCTypesCallbacks;







extern __attribute__((visibility("default"))) void
JS_SetCTypesCallbacks(JSRawObject ctypesObj, JSCTypesCallbacks *callbacks);


typedef JSBool
(* JSEnumerateDiagnosticMemoryCallback)(void *ptr, size_t length);





extern __attribute__((visibility("default"))) void
JS_EnumerateDiagnosticMemoryRegions(JSEnumerateDiagnosticMemoryCallback callback);

extern __attribute__((visibility("default"))) void *
JS_malloc(JSContext *cx, size_t nbytes);

extern __attribute__((visibility("default"))) void *
JS_realloc(JSContext *cx, void *p, size_t nbytes);






extern __attribute__((visibility("default"))) void
JS_free(JSContext *cx, void *p);





extern __attribute__((visibility("default"))) void
JS_freeop(JSFreeOp *fop, void *p);

extern __attribute__((visibility("default"))) JSFreeOp *
JS_GetDefaultFreeOp(JSRuntime *rt);

extern __attribute__((visibility("default"))) void
JS_updateMallocCounter(JSContext *cx, size_t nbytes);

extern __attribute__((visibility("default"))) char *
JS_strdup(JSContext *cx, const char *s);


extern __attribute__((visibility("default"))) char *
JS_strdup(JSRuntime *rt, const char *s);
# 2343 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_AddValueRoot(JSContext *cx, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_AddStringRoot(JSContext *cx, JSString **rp);

extern __attribute__((visibility("default"))) JSBool
JS_AddObjectRoot(JSContext *cx, JSObject **rp);
# 2360 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_AddNamedValueRoot(JSContext *cx, jsval *vp, const char *name);

extern __attribute__((visibility("default"))) JSBool
JS_AddNamedValueRootRT(JSRuntime *rt, jsval *vp, const char *name);

extern __attribute__((visibility("default"))) JSBool
JS_AddNamedStringRoot(JSContext *cx, JSString **rp, const char *name);

extern __attribute__((visibility("default"))) JSBool
JS_AddNamedObjectRoot(JSContext *cx, JSObject **rp, const char *name);

extern __attribute__((visibility("default"))) JSBool
JS_AddNamedScriptRoot(JSContext *cx, JSScript **rp, const char *name);

extern __attribute__((visibility("default"))) void
JS_RemoveValueRoot(JSContext *cx, jsval *vp);

extern __attribute__((visibility("default"))) void
JS_RemoveStringRoot(JSContext *cx, JSString **rp);

extern __attribute__((visibility("default"))) void
JS_RemoveObjectRoot(JSContext *cx, JSObject **rp);

extern __attribute__((visibility("default"))) void
JS_RemoveScriptRoot(JSContext *cx, JSScript **rp);

extern __attribute__((visibility("default"))) void
JS_RemoveValueRootRT(JSRuntime *rt, jsval *vp);

extern __attribute__((visibility("default"))) void
JS_RemoveStringRootRT(JSRuntime *rt, JSString **rp);

extern __attribute__((visibility("default"))) void
JS_RemoveObjectRootRT(JSRuntime *rt, JSObject **rp);

extern __attribute__((visibility("default"))) void
JS_RemoveScriptRootRT(JSRuntime *rt, JSScript **rp);



extern __attribute__((visibility("default"))) void
js_RemoveRoot(JSRuntime *rt, void *rp);





extern __attribute__((noinline)) __attribute__((visibility("default"))) void
JS_AnchorPtr(void *p);
# 2418 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_SetExtraGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data);
# 2434 "../../dist/include/jsapi.h"
static __attribute__((always_inline)) inline JSBool
JSVAL_IS_TRACEABLE(jsval v)
{
    return JSVAL_IS_TRACEABLE_IMPL(JSVAL_TO_IMPL(v));
}

static __attribute__((always_inline)) inline void *
JSVAL_TO_TRACEABLE(jsval v)
{
    return JSVAL_TO_GCTHING(v);
}

static __attribute__((always_inline)) inline JSGCTraceKind
JSVAL_TRACE_KIND(jsval v)
{
    do { } while(0);
    return (JSGCTraceKind) JSVAL_TRACE_KIND_IMPL(JSVAL_TO_IMPL(v));
}
# 2469 "../../dist/include/jsapi.h"
typedef void
(* JSTraceCallback)(JSTracer *trc, void **thingp, JSGCTraceKind kind);

enum WeakMapTraceKind {
    DoNotTraceWeakMaps = 0,
    TraceWeakMapValues = 1
};

struct JSTracer {
    JSRuntime *runtime;
    JSTraceCallback callback;
    JSTraceNamePrinter debugPrinter;
    const void *debugPrintArg;
    size_t debugPrintIndex;
    WeakMapTraceKind eagerlyTraceWeakMaps;



};
# 2553 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_CallValueTracer(JSTracer *trc, JS::Value value, const char *name);

extern __attribute__((visibility("default"))) void
JS_CallIdTracer(JSTracer *trc, jsid id, const char *name);

extern __attribute__((visibility("default"))) void
JS_CallObjectTracer(JSTracer *trc, JSObject *obj, const char *name);

extern __attribute__((visibility("default"))) void
JS_CallStringTracer(JSTracer *trc, JSString *str, const char *name);

extern __attribute__((visibility("default"))) void
JS_CallScriptTracer(JSTracer *trc, JSScript *script, const char *name);

extern __attribute__((visibility("default"))) void
JS_CallGenericTracer(JSTracer *trc, void *gcthing, const char *name);




extern __attribute__((visibility("default"))) void
JS_TracerInit(JSTracer *trc, JSRuntime *rt, JSTraceCallback callback);

extern __attribute__((visibility("default"))) void
JS_TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind);

extern __attribute__((visibility("default"))) void
JS_TraceRuntime(JSTracer *trc);

extern __attribute__((visibility("default"))) void
JS_GetTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc,
                     void *thing, JSGCTraceKind kind, JSBool includeDetails);

extern __attribute__((visibility("default"))) const char *
JS_GetTraceEdgeName(JSTracer *trc, char *buffer, int bufferSize);
# 2616 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_GC(JSRuntime *rt);

extern __attribute__((visibility("default"))) void
JS_MaybeGC(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_SetGCCallback(JSRuntime *rt, JSGCCallback cb);

extern __attribute__((visibility("default"))) void
JS_SetFinalizeCallback(JSRuntime *rt, JSFinalizeCallback cb);

extern __attribute__((visibility("default"))) JSBool
JS_IsGCMarkingTracer(JSTracer *trc);
# 2647 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_IsAboutToBeFinalized(JSObject **obj);

typedef enum JSGCParamKey {

    JSGC_MAX_BYTES = 0,


    JSGC_MAX_MALLOC_BYTES = 1,


    JSGC_BYTES = 3,


    JSGC_NUMBER = 4,


    JSGC_MAX_CODE_CACHE_BYTES = 5,


    JSGC_MODE = 6,


    JSGC_UNUSED_CHUNKS = 7,


    JSGC_TOTAL_CHUNKS = 8,


    JSGC_SLICE_TIME_BUDGET = 9,


    JSGC_MARK_STACK_LIMIT = 10,





    JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,


    JSGC_HIGH_FREQUENCY_LOW_LIMIT = 12,


    JSGC_HIGH_FREQUENCY_HIGH_LIMIT = 13,


    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX = 14,


    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN = 15,


    JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,





    JSGC_DYNAMIC_HEAP_GROWTH = 17,


    JSGC_DYNAMIC_MARK_SLICE = 18,


    JSGC_ANALYSIS_PURGE_TRIGGER = 19,


    JSGC_ALLOCATION_THRESHOLD = 20,
} JSGCParamKey;

typedef enum JSGCMode {

    JSGC_MODE_GLOBAL = 0,


    JSGC_MODE_COMPARTMENT = 1,





    JSGC_MODE_INCREMENTAL = 2
} JSGCMode;

extern __attribute__((visibility("default"))) void
JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32_t value);

extern __attribute__((visibility("default"))) uint32_t
JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key);

extern __attribute__((visibility("default"))) void
JS_SetGCParameterForThread(JSContext *cx, JSGCParamKey key, uint32_t value);

extern __attribute__((visibility("default"))) uint32_t
JS_GetGCParameterForThread(JSContext *cx, JSGCParamKey key);





extern __attribute__((visibility("default"))) JSString *
JS_NewExternalString(JSContext *cx, const jschar *chars, size_t length,
                     const JSStringFinalizer *fin);





extern __attribute__((visibility("default"))) JSBool
JS_IsExternalString(JSString *str);





extern __attribute__((visibility("default"))) const JSStringFinalizer *
JS_GetExternalStringFinalizer(JSString *str);





extern __attribute__((visibility("default"))) void
JS_SetNativeStackQuota(JSRuntime *cx, size_t stackSize);






typedef void (*JSClassInternal)();

struct JSClass {
    const char *name;
    uint32_t flags;


    JSPropertyOp addProperty;
    JSPropertyOp delProperty;
    JSPropertyOp getProperty;
    JSStrictPropertyOp setProperty;
    JSEnumerateOp enumerate;
    JSResolveOp resolve;
    JSConvertOp convert;
    JSFinalizeOp finalize;


    JSCheckAccessOp checkAccess;
    JSNative call;
    JSHasInstanceOp hasInstance;
    JSNative construct;
    JSTraceOp trace;

    void *reserved[40];
};
# 2890 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) int
JS_IdArrayLength(JSContext *cx, JSIdArray *ida);

extern __attribute__((visibility("default"))) jsid
JS_IdArrayGet(JSContext *cx, JSIdArray *ida, int index);

extern __attribute__((visibility("default"))) void
JS_DestroyIdArray(JSContext *cx, JSIdArray *ida);

namespace JS {

class AutoIdArray : private AutoGCRooter
{
  public:
    AutoIdArray(JSContext *cx, JSIdArray *ida
                )
      : AutoGCRooter(cx, IDARRAY), context(cx), idArray(ida)
    {
        do { } while (0);
    }
    ~AutoIdArray() {
        if (idArray)
            JS_DestroyIdArray(context, idArray);
    }
    bool operator!() {
        return !idArray;
    }
    jsid operator[](size_t i) const {
        do { } while(0);
        do { } while(0);
        return JS_IdArrayGet(context, idArray, i);
    }
    size_t length() const {
        return JS_IdArrayLength(context, idArray);
    }

    friend void AutoGCRooter::trace(JSTracer *trc);

    JSIdArray *steal() {
        JSIdArray *copy = idArray;
        idArray = __null;
        return copy;
    }

  protected:
    inline void trace(JSTracer *trc);

  private:
    JSContext *context;
    JSIdArray *idArray;
   


    AutoIdArray(AutoIdArray &ida) = delete;
    void operator=(AutoIdArray &ida) = delete;
};

}

extern __attribute__((visibility("default"))) JSBool
JS_ValueToId(JSContext *cx, jsval v, jsid *idp);

extern __attribute__((visibility("default"))) JSBool
JS_IdToValue(JSContext *cx, jsid id, jsval *vp);
# 2966 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_PropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp);

extern __attribute__((visibility("default"))) JSBool
JS_StrictPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, JSMutableHandleValue vp);

extern __attribute__((visibility("default"))) JSBool
JS_EnumerateStub(JSContext *cx, JSHandleObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_ResolveStub(JSContext *cx, JSHandleObject obj, JSHandleId id);

extern __attribute__((visibility("default"))) JSBool
JS_ConvertStub(JSContext *cx, JSHandleObject obj, JSType type, JSMutableHandleValue vp);

struct JSConstDoubleSpec {
    double dval;
    const char *name;
    uint8_t flags;
    uint8_t spare[3];
};

typedef struct JSJitInfo JSJitInfo;






typedef struct JSStrictPropertyOpWrapper {
    JSStrictPropertyOp op;
    const JSJitInfo *info;
} JSStrictPropertyOpWrapper;

typedef struct JSPropertyOpWrapper {
    JSPropertyOp op;
    const JSJitInfo *info;
} JSPropertyOpWrapper;




typedef struct JSNativeWrapper {
    JSNative op;
    const JSJitInfo *info;
} JSNativeWrapper;
# 3028 "../../dist/include/jsapi.h"
struct JSPropertySpec {
    const char *name;
    int8_t tinyid;
    uint8_t flags;
    JSPropertyOpWrapper getter;
    JSStrictPropertyOpWrapper setter;
};






struct JSFunctionSpec {
    const char *name;
    JSNativeWrapper call;
    uint16_t nargs;
    uint16_t flags;
    const char *selfHostedName;
};
# 3067 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSObject *
JS_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
             JSClass *clasp, JSNative constructor, unsigned nargs,
             JSPropertySpec *ps, JSFunctionSpec *fs,
             JSPropertySpec *static_ps, JSFunctionSpec *static_fs);





extern __attribute__((visibility("default"))) JSBool
JS_LinkConstructorAndPrototype(JSContext *cx, JSObject *ctor, JSObject *proto);

extern __attribute__((visibility("default"))) JSClass *
JS_GetClass(JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_InstanceOf(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv);

extern __attribute__((visibility("default"))) JSBool
JS_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);

extern __attribute__((visibility("default"))) void *
JS_GetPrivate(JSRawObject obj);

extern __attribute__((visibility("default"))) void
JS_SetPrivate(JSRawObject obj, void *data);

extern __attribute__((visibility("default"))) void *
JS_GetInstancePrivate(JSContext *cx, JSObject *obj, JSClass *clasp,
                      jsval *argv);

extern __attribute__((visibility("default"))) JSBool
JS_GetPrototype(JSContext *cx, JSObject *obj, JSObject **protop);

extern __attribute__((visibility("default"))) JSBool
JS_SetPrototype(JSContext *cx, JSObject *obj, JSObject *proto);

extern __attribute__((visibility("default"))) JSObject *
JS_GetParent(JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_SetParent(JSContext *cx, JSObject *obj, JSObject *parent);

extern __attribute__((visibility("default"))) JSObject *
JS_GetConstructor(JSContext *cx, JSObject *proto);






extern __attribute__((visibility("default"))) JSBool
JS_GetObjectId(JSContext *cx, JSRawObject obj, jsid *idp);

namespace JS {

enum {
    FreshZone,
    SystemZone,
    SpecificZones
};

typedef uintptr_t ZoneSpecifier;

inline ZoneSpecifier
SameZoneAs(JSObject *obj)
{
    do { } while(0);
    return ZoneSpecifier(obj);
}

}

extern __attribute__((visibility("default"))) JSObject *
JS_NewGlobalObject(JSContext *cx, JSClass *clasp, JSPrincipals *principals,
                   JS::ZoneSpecifier zoneSpec = JS::FreshZone);

extern __attribute__((visibility("default"))) JSObject *
JS_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent);


extern __attribute__((visibility("default"))) JSBool
JS_IsExtensible(JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_IsNative(JSRawObject obj);

extern __attribute__((visibility("default"))) JSRuntime *
JS_GetObjectRuntime(JSRawObject obj);





extern __attribute__((visibility("default"))) JSObject *
JS_NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
                           JSObject *parent);






extern __attribute__((visibility("default"))) JSBool
JS_DeepFreezeObject(JSContext *cx, JSObject *obj);




extern __attribute__((visibility("default"))) JSBool
JS_FreezeObject(JSContext *cx, JSObject *obj);

extern __attribute__((visibility("default"))) JSObject *
JS_New(JSContext *cx, JSObject *ctor, unsigned argc, jsval *argv);

extern __attribute__((visibility("default"))) JSObject *
JS_DefineObject(JSContext *cx, JSObject *obj, const char *name, JSClass *clasp,
                JSObject *proto, unsigned attrs);

extern __attribute__((visibility("default"))) JSBool
JS_DefineConstDoubles(JSContext *cx, JSObject *obj, JSConstDoubleSpec *cds);

extern __attribute__((visibility("default"))) JSBool
JS_DefineProperties(JSContext *cx, JSObject *obj, JSPropertySpec *ps);

extern __attribute__((visibility("default"))) JSBool
JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
                  JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs);

extern __attribute__((visibility("default"))) JSBool
JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
                      JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs);

extern __attribute__((visibility("default"))) JSBool
JS_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, jsval descriptor, JSBool *bp);







extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
                         unsigned *attrsp, JSBool *foundp);






extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
                                   const char *name,
                                   unsigned *attrsp, JSBool *foundp,
                                   JSPropertyOp *getterp,
                                   JSStrictPropertyOp *setterp);

extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *obj,
                                       jsid id,
                                       unsigned *attrsp, JSBool *foundp,
                                       JSPropertyOp *getterp,
                                       JSStrictPropertyOp *setterp);







extern __attribute__((visibility("default"))) JSBool
JS_SetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
                         unsigned attrs, JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *obj, const char *name,
                            int8_t tinyid, jsval value,
                            JSPropertyOp getter, JSStrictPropertyOp setter,
                            unsigned attrs);

extern __attribute__((visibility("default"))) JSBool
JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, const char *name,
                         JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id,
                             JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name,
                           unsigned flags, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id,
                               unsigned flags, JSObject **objp, jsval *vp);

struct JSPropertyDescriptor {
    JSObject *obj;
    unsigned attrs;
    unsigned shortid;
    JSPropertyOp getter;
    JSStrictPropertyOp setter;
    jsval value;

    JSPropertyDescriptor() : obj(__null), attrs(0), shortid(0), getter(__null),
                             setter(__null), value(JSVAL_VOID)
    {}
};






extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyDescriptorById(JSContext *cx, JSObject *obj, jsid id, unsigned flags,
                             JSPropertyDescriptor *desc);

extern __attribute__((visibility("default"))) JSBool
JS_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyDefault(JSContext *cx, JSObject *obj, const char *name, jsval def, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetPropertyByIdDefault(JSContext *cx, JSObject *obj, jsid id, jsval def, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_ForwardGetPropertyTo(JSContext *cx, JSObject *obj, jsid id, JSObject *onBehalfOf, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetMethodById(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
                 jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetMethod(JSContext *cx, JSObject *obj, const char *name, JSObject **objp,
             jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_SetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name);

extern __attribute__((visibility("default"))) JSBool
JS_DeleteProperty2(JSContext *cx, JSObject *obj, const char *name,
                   jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id);

extern __attribute__((visibility("default"))) JSBool
JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_DefineUCProperty(JSContext *cx, JSObject *obj,
                    const jschar *name, size_t namelen, jsval value,
                    JSPropertyOp getter, JSStrictPropertyOp setter,
                    unsigned attrs);







extern __attribute__((visibility("default"))) JSBool
JS_GetUCPropertyAttributes(JSContext *cx, JSObject *obj,
                           const jschar *name, size_t namelen,
                           unsigned *attrsp, JSBool *foundp);






extern __attribute__((visibility("default"))) JSBool
JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
                                     const jschar *name, size_t namelen,
                                     unsigned *attrsp, JSBool *foundp,
                                     JSPropertyOp *getterp,
                                     JSStrictPropertyOp *setterp);







extern __attribute__((visibility("default"))) JSBool
JS_SetUCPropertyAttributes(JSContext *cx, JSObject *obj,
                           const jschar *name, size_t namelen,
                           unsigned attrs, JSBool *foundp);


extern __attribute__((visibility("default"))) JSBool
JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *obj,
                              const jschar *name, size_t namelen,
                              int8_t tinyid, jsval value,
                              JSPropertyOp getter, JSStrictPropertyOp setter,
                              unsigned attrs);

extern __attribute__((visibility("default"))) JSBool
JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *obj, const jschar *name,
                           size_t namelen, JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_HasUCProperty(JSContext *cx, JSObject *obj,
                 const jschar *name, size_t namelen,
                 JSBool *vp);

extern __attribute__((visibility("default"))) JSBool
JS_LookupUCProperty(JSContext *cx, JSObject *obj,
                    const jschar *name, size_t namelen,
                    jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetUCProperty(JSContext *cx, JSObject *obj,
                 const jschar *name, size_t namelen,
                 jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_SetUCProperty(JSContext *cx, JSObject *obj,
                 const jschar *name, size_t namelen,
                 jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_DeleteUCProperty2(JSContext *cx, JSObject *obj,
                     const jschar *name, size_t namelen,
                     jsval *rval);

extern __attribute__((visibility("default"))) JSObject *
JS_NewArrayObject(JSContext *cx, int length, jsval *vector);

extern __attribute__((visibility("default"))) JSBool
JS_IsArrayObject(JSContext *cx, JSObject *obj);

extern __attribute__((visibility("default"))) JSBool
JS_GetArrayLength(JSContext *cx, JSObject *obj, uint32_t *lengthp);

extern __attribute__((visibility("default"))) JSBool
JS_SetArrayLength(JSContext *cx, JSObject *obj, uint32_t length);

extern __attribute__((visibility("default"))) JSBool
JS_DefineElement(JSContext *cx, JSObject *obj, uint32_t index, jsval value,
                 JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs);

extern __attribute__((visibility("default"))) JSBool
JS_AlreadyHasOwnElement(JSContext *cx, JSObject *obj, uint32_t index, JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_HasElement(JSContext *cx, JSObject *obj, uint32_t index, JSBool *foundp);

extern __attribute__((visibility("default"))) JSBool
JS_LookupElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_GetElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_ForwardGetElementTo(JSContext *cx, JSObject *obj, uint32_t index, JSObject *onBehalfOf,
                       jsval *vp);






extern __attribute__((visibility("default"))) JSBool
JS_GetElementIfPresent(JSContext *cx, JSObject *obj, uint32_t index, JSObject *onBehalfOf,
                       jsval *vp, JSBool* present);

extern __attribute__((visibility("default"))) JSBool
JS_SetElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_DeleteElement(JSContext *cx, JSObject *obj, uint32_t index);

extern __attribute__((visibility("default"))) JSBool
JS_DeleteElement2(JSContext *cx, JSObject *obj, uint32_t index, jsval *rval);





__attribute__((visibility("default"))) void
JS_ClearNonGlobalObject(JSContext *cx, JSObject *objArg);





__attribute__((visibility("default"))) void
JS_SetAllNonReservedSlotsToUndefined(JSContext *cx, JSObject *objArg);







extern __attribute__((visibility("default"))) JSObject *
JS_NewArrayBufferWithContents(JSContext *cx, void *contents);
# 3503 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_StealArrayBufferContents(JSContext *cx, JSObject *obj, void **contents,
                            uint8_t **data);
# 3516 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_AllocateArrayBufferContents(JSContext *cx, uint32_t nbytes, void **contents, uint8_t **data);


extern __attribute__((visibility("default"))) JSIdArray *
JS_Enumerate(JSContext *cx, JSObject *obj);






extern __attribute__((visibility("default"))) JSObject *
JS_NewPropertyIterator(JSContext *cx, JSObject *obj);






extern __attribute__((visibility("default"))) JSBool
JS_NextProperty(JSContext *cx, JSObject *iterobj, jsid *idp);







extern __attribute__((visibility("default"))) JSBool
JS_ArrayIterator(JSContext *cx, unsigned argc, jsval *vp);

extern __attribute__((visibility("default"))) JSBool
JS_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
               jsval *vp, unsigned *attrsp);

extern __attribute__((visibility("default"))) jsval
JS_GetReservedSlot(JSRawObject obj, uint32_t index);

extern __attribute__((visibility("default"))) void
JS_SetReservedSlot(JSRawObject obj, uint32_t index, jsval v);






struct JSPrincipals {

    int refcount;






    void setDebugToken(uint32_t token) {



    }





    __attribute__((visibility("default"))) void dump();
};

extern __attribute__((visibility("default"))) void
JS_HoldPrincipals(JSPrincipals *principals);

extern __attribute__((visibility("default"))) void
JS_DropPrincipals(JSRuntime *rt, JSPrincipals *principals);

struct JSSecurityCallbacks {
    JSCheckAccessOp checkObjectAccess;
    JSCSPEvalChecker contentSecurityPolicyAllows;
};

extern __attribute__((visibility("default"))) void
JS_SetSecurityCallbacks(JSRuntime *rt, const JSSecurityCallbacks *callbacks);

extern __attribute__((visibility("default"))) const JSSecurityCallbacks *
JS_GetSecurityCallbacks(JSRuntime *rt);
# 3614 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_SetTrustedPrincipals(JSRuntime *rt, JSPrincipals *prin);






extern __attribute__((visibility("default"))) void
JS_InitDestroyPrincipalsCallback(JSRuntime *rt, JSDestroyPrincipalsOp destroyPrincipals);






extern __attribute__((visibility("default"))) JSFunction *
JS_NewFunction(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
               JSObject *parent, const char *name);





extern __attribute__((visibility("default"))) JSFunction *
JS_NewFunctionById(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
                   JSObject *parent, jsid id);

extern __attribute__((visibility("default"))) JSObject *
JS_GetFunctionObject(JSFunction *fun);







extern __attribute__((visibility("default"))) JSString *
JS_GetFunctionId(JSFunction *fun);
# 3661 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSString *
JS_GetFunctionDisplayId(JSFunction *fun);




extern __attribute__((visibility("default"))) uint16_t
JS_GetFunctionArity(JSFunction *fun);







extern __attribute__((visibility("default"))) JSBool
JS_ObjectIsFunction(JSContext *cx, JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_ObjectIsCallable(JSContext *cx, JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_IsNativeFunction(JSRawObject funobj, JSNative call);


extern __attribute__((visibility("default"))) JSBool
JS_IsConstructor(JSFunction *fun);






extern __attribute__((visibility("default"))) JSObject*
JS_BindCallable(JSContext *cx, JSObject *callable, JSRawObject newThis);

extern __attribute__((visibility("default"))) JSBool
JS_DefineFunctions(JSContext *cx, JSObject *obj, JSFunctionSpec *fs);

extern __attribute__((visibility("default"))) JSFunction *
JS_DefineFunction(JSContext *cx, JSObject *obj, const char *name, JSNative call,
                  unsigned nargs, unsigned attrs);

extern __attribute__((visibility("default"))) JSFunction *
JS_DefineUCFunction(JSContext *cx, JSObject *obj,
                    const jschar *name, size_t namelen, JSNative call,
                    unsigned nargs, unsigned attrs);

extern __attribute__((visibility("default"))) JSFunction *
JS_DefineFunctionById(JSContext *cx, JSObject *obj, jsid id, JSNative call,
                      unsigned nargs, unsigned attrs);





extern __attribute__((visibility("default"))) JSObject *
JS_CloneFunctionObject(JSContext *cx, JSObject *funobj, JSRawObject parent);
# 3727 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_BufferIsCompilableUnit(JSContext *cx, JSObject *obj, const char *utf8, size_t length);

extern __attribute__((visibility("default"))) JSScript *
JS_CompileScript(JSContext *cx, JSObject *obj,
                 const char *ascii, size_t length,
                 const char *filename, unsigned lineno);

extern __attribute__((visibility("default"))) JSScript *
JS_CompileScriptForPrincipals(JSContext *cx, JSObject *obj,
                              JSPrincipals *principals,
                              const char *ascii, size_t length,
                              const char *filename, unsigned lineno);

extern __attribute__((visibility("default"))) JSScript *
JS_CompileUCScript(JSContext *cx, JSObject *obj,
                   const jschar *chars, size_t length,
                   const char *filename, unsigned lineno);

extern __attribute__((visibility("default"))) JSScript *
JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *obj,
                                JSPrincipals *principals,
                                const jschar *chars, size_t length,
                                const char *filename, unsigned lineno);

extern __attribute__((visibility("default"))) JSObject *
JS_GetGlobalFromScript(JSScript *script);

extern __attribute__((visibility("default"))) JSFunction *
JS_CompileFunction(JSContext *cx, JSObject *obj, const char *name,
                   unsigned nargs, const char **argnames,
                   const char *bytes, size_t length,
                   const char *filename, unsigned lineno);

extern __attribute__((visibility("default"))) JSFunction *
JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *obj,
                                JSPrincipals *principals, const char *name,
                                unsigned nargs, const char **argnames,
                                const char *bytes, size_t length,
                                const char *filename, unsigned lineno);

extern __attribute__((visibility("default"))) JSFunction *
JS_CompileUCFunction(JSContext *cx, JSObject *obj, const char *name,
                     unsigned nargs, const char **argnames,
                     const jschar *chars, size_t length,
                     const char *filename, unsigned lineno);

namespace JS {


struct __attribute__((visibility("default"))) CompileOptions {
    JSPrincipals *principals;
    JSPrincipals *originPrincipals;
    JSVersion version;
    bool versionSet;
    bool utf8;
    const char *filename;
    unsigned lineno;
    bool compileAndGo;
    bool noScriptRval;
    bool selfHostingMode;
    bool userBit;
    enum SourcePolicy {
        NO_SOURCE,
        LAZY_SOURCE,
        SAVE_SOURCE
    } sourcePolicy;

    explicit CompileOptions(JSContext *cx);
    CompileOptions &setPrincipals(JSPrincipals *p) { principals = p; return *this; }
    CompileOptions &setOriginPrincipals(JSPrincipals *p) { originPrincipals = p; return *this; }
    CompileOptions &setVersion(JSVersion v) { version = v; versionSet = true; return *this; }
    CompileOptions &setUTF8(bool u) { utf8 = u; return *this; }
    CompileOptions &setFileAndLine(const char *f, unsigned l) {
        filename = f; lineno = l; return *this;
    }
    CompileOptions &setCompileAndGo(bool cng) { compileAndGo = cng; return *this; }
    CompileOptions &setNoScriptRval(bool nsr) { noScriptRval = nsr; return *this; }
    CompileOptions &setSelfHostingMode(bool shm) { selfHostingMode = shm; return *this; }
    CompileOptions &setUserBit(bool bit) { userBit = bit; return *this; }
    CompileOptions &setSourcePolicy(SourcePolicy sp) { sourcePolicy = sp; return *this; }
};

extern __attribute__((visibility("default"))) JSScript *
Compile(JSContext *cx, JSHandleObject obj, CompileOptions options,
        const char *bytes, size_t length);

extern __attribute__((visibility("default"))) JSScript *
Compile(JSContext *cx, JSHandleObject obj, CompileOptions options,
        const jschar *chars, size_t length);

extern __attribute__((visibility("default"))) JSScript *
Compile(JSContext *cx, JSHandleObject obj, CompileOptions options, FILE *file);

extern __attribute__((visibility("default"))) JSScript *
Compile(JSContext *cx, JSHandleObject obj, CompileOptions options, const char *filename);

extern __attribute__((visibility("default"))) JSFunction *
CompileFunction(JSContext *cx, JSHandleObject obj, CompileOptions options,
                const char *name, unsigned nargs, const char **argnames,
                const char *bytes, size_t length);

extern __attribute__((visibility("default"))) JSFunction *
CompileFunction(JSContext *cx, JSHandleObject obj, CompileOptions options,
                const char *name, unsigned nargs, const char **argnames,
                const jschar *chars, size_t length);

}

extern __attribute__((visibility("default"))) JSString *
JS_DecompileScript(JSContext *cx, JSScript *script, const char *name, unsigned indent);







extern __attribute__((visibility("default"))) JSString *
JS_DecompileFunction(JSContext *cx, JSFunction *fun, unsigned indent);

extern __attribute__((visibility("default"))) JSString *
JS_DecompileFunctionBody(JSContext *cx, JSFunction *fun, unsigned indent);
# 3886 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_ExecuteScript(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_ExecuteScriptVersion(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval,
                        JSVersion version);





typedef enum JSExecPart { JSEXEC_PROLOG, JSEXEC_MAIN } JSExecPart;

extern __attribute__((visibility("default"))) JSBool
JS_EvaluateScript(JSContext *cx, JSObject *obj,
                  const char *bytes, unsigned length,
                  const char *filename, unsigned lineno,
                  jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *obj,
                               JSPrincipals *principals,
                               const char *bytes, unsigned length,
                               const char *filename, unsigned lineno,
                               jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_EvaluateScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
                                      JSPrincipals *principals,
                                      const char *bytes, unsigned length,
                                      const char *filename, unsigned lineno,
                                      jsval *rval, JSVersion version);

extern __attribute__((visibility("default"))) JSBool
JS_EvaluateUCScript(JSContext *cx, JSObject *obj,
                    const jschar *chars, unsigned length,
                    const char *filename, unsigned lineno,
                    jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *obj,
                                 JSPrincipals *principals,
                                 const jschar *chars, unsigned length,
                                 const char *filename, unsigned lineno,
                                 jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_EvaluateUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
                                        JSPrincipals *principals,
                                        const jschar *chars, unsigned length,
                                        const char *filename, unsigned lineno,
                                        jsval *rval, JSVersion version);
# 3947 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_EvaluateUCScriptForPrincipalsVersionOrigin(JSContext *cx, JSObject *obj,
                                              JSPrincipals *principals,
                                              JSPrincipals *originPrincipals,
                                              const jschar *chars, unsigned length,
                                              const char *filename, unsigned lineno,
                                              jsval *rval, JSVersion version);

namespace JS {

extern __attribute__((visibility("default"))) bool
Evaluate(JSContext *cx, JSHandleObject obj, CompileOptions options,
         const jschar *chars, size_t length, jsval *rval);

extern __attribute__((visibility("default"))) bool
Evaluate(JSContext *cx, JSHandleObject obj, CompileOptions options,
         const char *bytes, size_t length, jsval *rval);

extern __attribute__((visibility("default"))) bool
Evaluate(JSContext *cx, JSHandleObject obj, CompileOptions options,
         const char *filename, jsval *rval);

}

extern __attribute__((visibility("default"))) JSBool
JS_CallFunction(JSContext *cx, JSObject *obj, JSFunction *fun, unsigned argc,
                jsval *argv, jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_CallFunctionName(JSContext *cx, JSObject *obj, const char *name, unsigned argc,
                    jsval *argv, jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, unsigned argc,
                     jsval *argv, jsval *rval);

namespace JS {

static inline bool
Call(JSContext *cx, JSObject *thisObj, JSFunction *fun, unsigned argc, jsval *argv, jsval *rval) {
    return !!JS_CallFunction(cx, thisObj, fun, argc, argv, rval);
}

static inline bool
Call(JSContext *cx, JSObject *thisObj, const char *name, unsigned argc, jsval *argv, jsval *rval) {
    return !!JS_CallFunctionName(cx, thisObj, name, argc, argv, rval);
}

static inline bool
Call(JSContext *cx, JSObject *thisObj, jsval fun, unsigned argc, jsval *argv, jsval *rval) {
    return !!JS_CallFunctionValue(cx, thisObj, fun, argc, argv, rval);
}

extern __attribute__((visibility("default"))) bool
Call(JSContext *cx, jsval thisv, jsval fun, unsigned argc, jsval *argv, jsval *rval);

static inline bool
Call(JSContext *cx, jsval thisv, JSObject *funObj, unsigned argc, jsval *argv, jsval *rval) {
    return Call(cx, thisv, OBJECT_TO_JSVAL(funObj), argc, argv, rval);
}

}
# 4023 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSOperationCallback
JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback);

extern __attribute__((visibility("default"))) JSOperationCallback
JS_GetOperationCallback(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_TriggerOperationCallback(JSRuntime *rt);

extern __attribute__((visibility("default"))) JSBool
JS_IsRunning(JSContext *cx);
# 4046 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_SaveFrameChain(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_RestoreFrameChain(JSContext *cx);
# 4080 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSString *
JS_NewStringCopyN(JSContext *cx, const char *s, size_t n);

extern __attribute__((visibility("default"))) JSString *
JS_NewStringCopyZ(JSContext *cx, const char *s);

extern __attribute__((visibility("default"))) JSString *
JS_InternJSString(JSContext *cx, JSString *str);

extern __attribute__((visibility("default"))) JSString *
JS_InternStringN(JSContext *cx, const char *s, size_t length);

extern __attribute__((visibility("default"))) JSString *
JS_InternString(JSContext *cx, const char *s);

extern __attribute__((visibility("default"))) JSString *
JS_NewUCString(JSContext *cx, jschar *chars, size_t length);

extern __attribute__((visibility("default"))) JSString *
JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n);

extern __attribute__((visibility("default"))) JSString *
JS_NewUCStringCopyZ(JSContext *cx, const jschar *s);

extern __attribute__((visibility("default"))) JSString *
JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length);

extern __attribute__((visibility("default"))) JSString *
JS_InternUCString(JSContext *cx, const jschar *s);

extern __attribute__((visibility("default"))) JSBool
JS_CompareStrings(JSContext *cx, JSString *str1, JSString *str2, int32_t *result);

extern __attribute__((visibility("default"))) JSBool
JS_StringEqualsAscii(JSContext *cx, JSString *str, const char *asciiBytes, JSBool *match);

extern __attribute__((visibility("default"))) size_t
JS_PutEscapedString(JSContext *cx, char *buffer, size_t size, JSString *str, char quote);

extern __attribute__((visibility("default"))) JSBool
JS_FileEscapedString(FILE *fp, JSString *str, char quote);
# 4157 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) size_t
JS_GetStringLength(JSString *str);

extern __attribute__((visibility("default"))) const jschar *
JS_GetStringCharsAndLength(JSContext *cx, JSString *str, size_t *length);

extern __attribute__((visibility("default"))) const jschar *
JS_GetInternedStringChars(JSString *str);

extern __attribute__((visibility("default"))) const jschar *
JS_GetInternedStringCharsAndLength(JSString *str, size_t *length);

extern __attribute__((visibility("default"))) const jschar *
JS_GetStringCharsZ(JSContext *cx, JSString *str);

extern __attribute__((visibility("default"))) const jschar *
JS_GetStringCharsZAndLength(JSContext *cx, JSString *str, size_t *length);

extern __attribute__((visibility("default"))) JSFlatString *
JS_FlattenString(JSContext *cx, JSString *str);

extern __attribute__((visibility("default"))) const jschar *
JS_GetFlatStringChars(JSFlatString *str);

static __attribute__((always_inline)) inline JSFlatString *
JSID_TO_FLAT_STRING(jsid id)
{
    do { } while(0);
    return (JSFlatString *)((id));
}

static __attribute__((always_inline)) inline JSFlatString *
JS_ASSERT_STRING_IS_FLAT(JSString *str)
{
    do { } while(0);
    return (JSFlatString *)str;
}

static __attribute__((always_inline)) inline JSString *
JS_FORGET_STRING_FLATNESS(JSFlatString *fstr)
{
    return (JSString *)fstr;
}





extern __attribute__((visibility("default"))) JSBool
JS_FlatStringEqualsAscii(JSFlatString *str, const char *asciiBytes);

extern __attribute__((visibility("default"))) size_t
JS_PutEscapedFlatString(char *buffer, size_t size, JSFlatString *str, char quote);





extern __attribute__((visibility("default"))) JSString *
JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length);






extern __attribute__((visibility("default"))) JSString *
JS_NewDependentString(JSContext *cx, JSString *str, size_t start,
                      size_t length);





extern __attribute__((visibility("default"))) JSString *
JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right);
# 4247 "../../dist/include/jsapi.h"
__attribute__((visibility("default"))) JSBool
JS_DecodeBytes(JSContext *cx, const char *src, size_t srclen, jschar *dst,
               size_t *dstlenp);





__attribute__((visibility("default"))) char *
JS_EncodeString(JSContext *cx, JSRawString str);




__attribute__((visibility("default"))) char *
JS_EncodeStringToUTF8(JSContext *cx, JSRawString str);






__attribute__((visibility("default"))) size_t
JS_GetStringEncodingLength(JSContext *cx, JSString *str);
# 4280 "../../dist/include/jsapi.h"
__attribute__((visibility("default"))) size_t
JS_EncodeStringToBuffer(JSContext *cx, JSString *str, char *buffer, size_t length);

class JSAutoByteString
{
  public:
    JSAutoByteString(JSContext *cx, JSString *str
                     )
      : mBytes(JS_EncodeString(cx, str))
    {
        do { } while(0);
        do { } while (0);
    }

    JSAutoByteString()
      : mBytes(__null)
    {
        do { } while (0);
    }

    ~JSAutoByteString() {
        js_free(mBytes);
    }


    void initBytes(char *bytes) {
        do { } while(0);
        mBytes = bytes;
    }

    char *encodeLatin1(JSContext *cx, JSString *str) {
        do { } while(0);
        do { } while(0);
        mBytes = JS_EncodeString(cx, str);
        return mBytes;
    }

    char *encodeUtf8(JSContext *cx, JSString *str) {
        do { } while(0);
        do { } while(0);
        mBytes = JS_EncodeStringToUTF8(cx, str);
        return mBytes;
    }

    void clear() {
        js_free(mBytes);
        mBytes = __null;
    }

    char *ptr() const {
        return mBytes;
    }

    bool operator!() const {
        return !mBytes;
    }

    size_t length() const {
        if (!mBytes)
            return 0;
        return strlen(mBytes);
    }

  private:
    char *mBytes;
   


    JSAutoByteString(const JSAutoByteString &another);
    JSAutoByteString &operator=(const JSAutoByteString &another);
};





typedef JSBool (* JSONWriteCallback)(const jschar *buf, uint32_t len, void *data);




__attribute__((visibility("default"))) JSBool
JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacer, jsval space,
             JSONWriteCallback callback, void *data);




__attribute__((visibility("default"))) JSBool
JS_ParseJSON(JSContext *cx, const jschar *chars, uint32_t len, jsval *vp);

__attribute__((visibility("default"))) JSBool
JS_ParseJSONWithReviver(JSContext *cx, const jschar *chars, uint32_t len, jsval reviver,
                        jsval *vp);
# 4382 "../../dist/include/jsapi.h"
struct JSStructuredCloneCallbacks {
    ReadStructuredCloneOp read;
    WriteStructuredCloneOp write;
    StructuredCloneErrorOp reportError;
};



__attribute__((visibility("default"))) JSBool
JS_ReadStructuredClone(JSContext *cx, uint64_t *data, size_t nbytes,
                       uint32_t version, jsval *vp,
                       const JSStructuredCloneCallbacks *optionalCallbacks,
                       void *closure);



__attribute__((visibility("default"))) JSBool
JS_WriteStructuredClone(JSContext *cx, jsval v, uint64_t **datap, size_t *nbytesp,
                        const JSStructuredCloneCallbacks *optionalCallbacks,
                        void *closure, jsval transferable);

__attribute__((visibility("default"))) JSBool
JS_ClearStructuredClone(const uint64_t *data, size_t nbytes);

__attribute__((visibility("default"))) JSBool
JS_StructuredCloneHasTransferables(const uint64_t *data, size_t nbytes,
                                   JSBool *hasTransferable);

__attribute__((visibility("default"))) JSBool
JS_StructuredClone(JSContext *cx, jsval v, jsval *vp,
                   const JSStructuredCloneCallbacks *optionalCallbacks,
                   void *closure);


class __attribute__((visibility("default"))) JSAutoStructuredCloneBuffer {
    uint64_t *data_;
    size_t nbytes_;
    uint32_t version_;

  public:
    JSAutoStructuredCloneBuffer()
        : data_(__null), nbytes_(0), version_(1) {}

    ~JSAutoStructuredCloneBuffer() { clear(); }

    uint64_t *data() const { return data_; }
    size_t nbytes() const { return nbytes_; }

    void clear();


    bool copy(const uint64_t *data, size_t nbytes, uint32_t version=1);






    void adopt(uint64_t *data, size_t nbytes, uint32_t version=1);






    void steal(uint64_t **datap, size_t *nbytesp, uint32_t *versionp=__null);

    bool read(JSContext *cx, jsval *vp,
              const JSStructuredCloneCallbacks *optionalCallbacks=__null,
              void *closure=__null);

    bool write(JSContext *cx, jsval v,
               const JSStructuredCloneCallbacks *optionalCallbacks=__null,
               void *closure=__null);

    bool write(JSContext *cx, jsval v,
               jsval transferable,
               const JSStructuredCloneCallbacks *optionalCallbacks=__null,
               void *closure=__null);




    void swap(JSAutoStructuredCloneBuffer &other);

  private:

    JSAutoStructuredCloneBuffer(const JSAutoStructuredCloneBuffer &other);
    JSAutoStructuredCloneBuffer &operator=(const JSAutoStructuredCloneBuffer &other);
};
# 4482 "../../dist/include/jsapi.h"
__attribute__((visibility("default"))) void
JS_SetStructuredCloneCallbacks(JSRuntime *rt, const JSStructuredCloneCallbacks *callbacks);

__attribute__((visibility("default"))) JSBool
JS_ReadUint32Pair(JSStructuredCloneReader *r, uint32_t *p1, uint32_t *p2);

__attribute__((visibility("default"))) JSBool
JS_ReadBytes(JSStructuredCloneReader *r, void *p, size_t len);

__attribute__((visibility("default"))) JSBool
JS_ReadTypedArray(JSStructuredCloneReader *r, jsval *vp);

__attribute__((visibility("default"))) JSBool
JS_WriteUint32Pair(JSStructuredCloneWriter *w, uint32_t tag, uint32_t data);

__attribute__((visibility("default"))) JSBool
JS_WriteBytes(JSStructuredCloneWriter *w, const void *p, size_t len);

__attribute__((visibility("default"))) JSBool
JS_WriteTypedArray(JSStructuredCloneWriter *w, jsval v);
# 4512 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_SetDefaultLocale(JSRuntime *rt, const char *locale);




extern __attribute__((visibility("default"))) void
JS_ResetDefaultLocale(JSRuntime *rt);




struct JSLocaleCallbacks {
    JSLocaleToUpperCase localeToUpperCase;
    JSLocaleToLowerCase localeToLowerCase;
    JSLocaleCompare localeCompare;
    JSLocaleToUnicode localeToUnicode;
    JSErrorCallback localeGetErrorMessage;
};





extern __attribute__((visibility("default"))) void
JS_SetLocaleCallbacks(JSRuntime *rt, JSLocaleCallbacks *callbacks);





extern __attribute__((visibility("default"))) JSLocaleCallbacks *
JS_GetLocaleCallbacks(JSRuntime *rt);
# 4557 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_ReportError(JSContext *cx, const char *format, ...);




extern __attribute__((visibility("default"))) void
JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
                     void *userRef, const unsigned errorNumber, ...);


extern __attribute__((visibility("default"))) void
JS_ReportErrorNumberVA(JSContext *cx, JSErrorCallback errorCallback,
                       void *userRef, const unsigned errorNumber, va_list ap);





extern __attribute__((visibility("default"))) void
JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
                     void *userRef, const unsigned errorNumber, ...);

extern __attribute__((visibility("default"))) void
JS_ReportErrorNumberUCArray(JSContext *cx, JSErrorCallback errorCallback,
                            void *userRef, const unsigned errorNumber,
                            const jschar **args);







extern __attribute__((visibility("default"))) JSBool
JS_ReportWarning(JSContext *cx, const char *format, ...);

extern __attribute__((visibility("default"))) JSBool
JS_ReportErrorFlagsAndNumber(JSContext *cx, unsigned flags,
                             JSErrorCallback errorCallback, void *userRef,
                             const unsigned errorNumber, ...);

extern __attribute__((visibility("default"))) JSBool
JS_ReportErrorFlagsAndNumberUC(JSContext *cx, unsigned flags,
                               JSErrorCallback errorCallback, void *userRef,
                               const unsigned errorNumber, ...);




extern __attribute__((visibility("default"))) void
JS_ReportOutOfMemory(JSContext *cx);




extern __attribute__((visibility("default"))) void
JS_ReportAllocationOverflow(JSContext *cx);

struct JSErrorReport {
    const char *filename;
    JSPrincipals *originPrincipals;
    unsigned lineno;
    const char *linebuf;
    const char *tokenptr;
    const jschar *uclinebuf;
    const jschar *uctokenptr;
    unsigned flags;
    unsigned errorNumber;
    const jschar *ucmessage;
    const jschar **messageArgs;
    int16_t exnType;
    unsigned column;
};
# 4661 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSErrorReporter
JS_GetErrorReporter(JSContext *cx);

extern __attribute__((visibility("default"))) JSErrorReporter
JS_SetErrorReporter(JSContext *cx, JSErrorReporter er);







extern __attribute__((visibility("default"))) JSObject *
JS_NewDateObject(JSContext *cx, int year, int mon, int mday, int hour, int min, int sec);

extern __attribute__((visibility("default"))) JSObject *
JS_NewDateObjectMsec(JSContext *cx, double msec);




extern __attribute__((visibility("default"))) JSBool
JS_ObjectIsDate(JSContext *cx, JSRawObject obj);





extern __attribute__((visibility("default"))) void
JS_ClearDateCaches(JSContext *cx);
# 4702 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSObject *
JS_NewRegExpObject(JSContext *cx, JSObject *obj, char *bytes, size_t length, unsigned flags);

extern __attribute__((visibility("default"))) JSObject *
JS_NewUCRegExpObject(JSContext *cx, JSObject *obj, jschar *chars, size_t length, unsigned flags);

extern __attribute__((visibility("default"))) void
JS_SetRegExpInput(JSContext *cx, JSObject *obj, JSString *input, JSBool multiline);

extern __attribute__((visibility("default"))) void
JS_ClearRegExpStatics(JSContext *cx, JSObject *obj);

extern __attribute__((visibility("default"))) JSBool
JS_ExecuteRegExp(JSContext *cx, JSObject *obj, JSObject *reobj, jschar *chars, size_t length,
                 size_t *indexp, JSBool test, jsval *rval);



extern __attribute__((visibility("default"))) JSObject *
JS_NewRegExpObjectNoStatics(JSContext *cx, char *bytes, size_t length, unsigned flags);

extern __attribute__((visibility("default"))) JSObject *
JS_NewUCRegExpObjectNoStatics(JSContext *cx, jschar *chars, size_t length, unsigned flags);

extern __attribute__((visibility("default"))) JSBool
JS_ExecuteRegExpNoStatics(JSContext *cx, JSObject *reobj, jschar *chars, size_t length,
                          size_t *indexp, JSBool test, jsval *rval);

extern __attribute__((visibility("default"))) JSBool
JS_ObjectIsRegExp(JSContext *cx, JSObject *obj);

extern __attribute__((visibility("default"))) unsigned
JS_GetRegExpFlags(JSContext *cx, JSObject *obj);

extern __attribute__((visibility("default"))) JSString *
JS_GetRegExpSource(JSContext *cx, JSObject *obj);



extern __attribute__((visibility("default"))) JSBool
JS_IsExceptionPending(JSContext *cx);

extern __attribute__((visibility("default"))) JSBool
JS_GetPendingException(JSContext *cx, jsval *vp);

extern __attribute__((visibility("default"))) void
JS_SetPendingException(JSContext *cx, jsval v);

extern __attribute__((visibility("default"))) void
JS_ClearPendingException(JSContext *cx);

extern __attribute__((visibility("default"))) JSBool
JS_ReportPendingException(JSContext *cx);
# 4767 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSExceptionState *
JS_SaveExceptionState(JSContext *cx);

extern __attribute__((visibility("default"))) void
JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state);

extern __attribute__((visibility("default"))) void
JS_DropExceptionState(JSContext *cx, JSExceptionState *state);
# 4783 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) JSErrorReport *
JS_ErrorFromException(JSContext *cx, jsval v);





extern __attribute__((visibility("default"))) JSBool
JS_ThrowReportedError(JSContext *cx, const char *message,
                      JSErrorReport *reportp);




extern __attribute__((visibility("default"))) JSBool
JS_ThrowStopIteration(JSContext *cx);

extern __attribute__((visibility("default"))) intptr_t
JS_GetCurrentThread();
# 4819 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_AbortIfWrongThread(JSRuntime *rt);

extern __attribute__((visibility("default"))) void
JS_ClearRuntimeThread(JSRuntime *rt);

extern __attribute__((visibility("default"))) void
JS_SetRuntimeThread(JSRuntime *rt);

class JSAutoSetRuntimeThread
{
    JSRuntime *runtime_;

  public:
    JSAutoSetRuntimeThread(JSRuntime *runtime) : runtime_(runtime) {
        JS_SetRuntimeThread(runtime_);
    }

    ~JSAutoSetRuntimeThread() {
        JS_ClearRuntimeThread(runtime_);
    }
};
# 4851 "../../dist/include/jsapi.h"
static __attribute__((always_inline)) inline JSBool
JS_IsConstructing(JSContext *cx, const jsval *vp)
{
# 4863 "../../dist/include/jsapi.h"
    (void)cx;


    return JSVAL_IS_MAGIC_IMPL(JSVAL_TO_IMPL(vp[1]));
}






extern __attribute__((visibility("default"))) JSObject *
JS_NewObjectForConstructor(JSContext *cx, JSClass *clasp, const jsval *vp);
# 4889 "../../dist/include/jsapi.h"
extern __attribute__((visibility("default"))) void
JS_SetParallelCompilationEnabled(JSContext *cx, bool enabled);




extern __attribute__((visibility("default"))) JSBool
JS_IndexToId(JSContext *cx, uint32_t index, jsid *id);






extern __attribute__((visibility("default"))) JSBool
JS_CharsToId(JSContext* cx, JS::TwoByteChars chars, jsid *idp);




extern __attribute__((visibility("default"))) JSBool
JS_IsIdentifier(JSContext *cx, JSString *str, JSBool *isIdentifier);





extern __attribute__((visibility("default"))) JSBool
JS_DescribeScriptedCaller(JSContext *cx, JSScript **script, unsigned *lineno);






extern __attribute__((visibility("default"))) void *
JS_EncodeScript(JSContext *cx, JSScript *script, uint32_t *lengthp);

extern __attribute__((visibility("default"))) void *
JS_EncodeInterpretedFunction(JSContext *cx, JSRawObject funobj, uint32_t *lengthp);

extern __attribute__((visibility("default"))) JSScript *
JS_DecodeScript(JSContext *cx, const void *data, uint32_t length,
                JSPrincipals *principals, JSPrincipals *originPrincipals);

extern __attribute__((visibility("default"))) JSObject *
JS_DecodeInterpretedFunction(JSContext *cx, const void *data, uint32_t length,
                             JSPrincipals *principals, JSPrincipals *originPrincipals);

namespace JS {

extern __attribute__((visibility("default"))) const HandleId JSID_VOIDHANDLE;
extern __attribute__((visibility("default"))) const HandleId JSID_EMPTYHANDLE;

};

namespace js {






using JS::Value;
using JS::IsPoisonedValue;
using JS::NullValue;
using JS::UndefinedValue;
using JS::Int32Value;
using JS::DoubleValue;
using JS::StringValue;
using JS::BooleanValue;
using JS::ObjectValue;
using JS::MagicValue;
using JS::NumberValue;
using JS::ObjectOrNullValue;
using JS::PrivateValue;
using JS::PrivateUint32Value;

using JS::IsPoisonedPtr;
using JS::IsPoisonedId;

using JS::StableCharPtr;
using JS::TwoByteChars;
using JS::Latin1CharsZ;

using JS::AutoIdVector;
using JS::AutoValueVector;
using JS::AutoScriptVector;
using JS::AutoIdArray;

using JS::AutoGCRooter;
using JS::AutoValueRooter;
using JS::AutoObjectRooter;
using JS::AutoArrayRooter;
using JS::AutoVectorRooter;
using JS::AutoHashMapRooter;
using JS::AutoHashSetRooter;

using JS::CallArgs;
using JS::IsAcceptableThis;
using JS::NativeImpl;
using JS::CallReceiver;
using JS::CompileOptions;
using JS::CallNonGenericMethod;

using JS::Rooted;
using JS::RootedObject;
using JS::RootedModule;
using JS::RootedFunction;
using JS::RootedScript;
using JS::RootedString;
using JS::RootedId;
using JS::RootedValue;

using JS::Handle;
using JS::HandleObject;
using JS::HandleModule;
using JS::HandleFunction;
using JS::HandleScript;
using JS::HandleString;
using JS::HandleId;
using JS::HandleValue;

using JS::MutableHandle;
using JS::MutableHandleObject;
using JS::MutableHandleFunction;
using JS::MutableHandleScript;
using JS::MutableHandleString;
using JS::MutableHandleId;
using JS::MutableHandleValue;

using JS::Zone;

}
# 17 "../../dist/include/jsclass.h" 2
# 1 "../../dist/include/jsprvtd.h" 1
# 39 "../../dist/include/jsprvtd.h"
static const unsigned JS_GCTHING_ALIGN = 8;
static const unsigned JS_GCTHING_ZEROBITS = 3;


typedef uint8_t jsbytecode;
typedef uint8_t jssrcnote;
typedef uintptr_t jsatomid;


typedef struct JSGCThing JSGCThing;
typedef struct JSGenerator JSGenerator;
typedef struct JSNativeEnumerator JSNativeEnumerator;
typedef struct JSTryNote JSTryNote;


typedef struct JSAtomState JSAtomState;
typedef struct JSCodeSpec JSCodeSpec;
typedef struct JSPrinter JSPrinter;
typedef struct JSStackHeader JSStackHeader;
typedef struct JSSubString JSSubString;
typedef struct JSSpecializedNative JSSpecializedNative;
# 70 "../../dist/include/jsprvtd.h"
extern "C++" {

class JSDependentString;
class JSExtensibleString;
class JSExternalString;
class JSLinearString;
class JSRope;
class JSAtom;
class JSWrapper;

namespace js {

struct ArgumentsData;
struct Class;

class RegExpGuard;
class RegExpObject;
class RegExpObjectBuilder;
class RegExpShared;
class RegExpStatics;
class MatchPairs;
class PropertyName;

enum RegExpFlag
{
    IgnoreCaseFlag = 0x01,
    GlobalFlag = 0x02,
    MultilineFlag = 0x04,
    StickyFlag = 0x08,

    NoFlags = 0x00,
    AllFlags = 0x0f
};

class ExecuteArgsGuard;
class InvokeFrameGuard;
class InvokeArgsGuard;
class StringBuffer;

class FrameRegs;
class StackFrame;
class StackSegment;
class StackSpace;
class ContextStack;
class ScriptFrameIter;

class Proxy;
class __attribute__((visibility("default"))) BaseProxyHandler;
class __attribute__((visibility("default"))) Wrapper;
class __attribute__((visibility("default"))) CrossCompartmentWrapper;

class TempAllocPolicy;
class RuntimeAllocPolicy;

class GlobalObject;

template <typename K,
          typename V,
          size_t InlineElems>
class InlineMap;

class LifoAlloc;

class Shape;

class Breakpoint;
class BreakpointSite;
class Debugger;
class WatchpointMap;







typedef JSObject Env;

typedef JSNative Native;
typedef JSPropertyOp PropertyOp;
typedef JSStrictPropertyOp StrictPropertyOp;
typedef JSPropertyDescriptor PropertyDescriptor;

namespace frontend {

struct BytecodeEmitter;
struct Definition;
class FunctionBox;
class ObjectBox;
struct Token;
struct TokenPos;
class TokenStream;
class ParseMapPool;
struct ParseNode;

template <typename ParseHandler>
struct Parser;

}

namespace analyze {

struct LifetimeVariable;
class LoopAnalysis;
class ScriptAnalysis;
class SlotValue;
class SSAValue;
class SSAUseChain;

}

namespace types {

class TypeSet;
struct TypeCallsite;
struct TypeObject;
struct TypeCompartment;

}

typedef JS::Handle<Shape*> HandleShape;
typedef JS::Handle<types::TypeObject*> HandleTypeObject;
typedef JS::Handle<JSAtom*> HandleAtom;
typedef JS::Handle<PropertyName*> HandlePropertyName;

typedef JS::MutableHandle<Shape*> MutableHandleShape;
typedef JS::MutableHandle<JSAtom*> MutableHandleAtom;

typedef JS::Rooted<Shape*> RootedShape;
typedef JS::Rooted<types::TypeObject*> RootedTypeObject;
typedef JS::Rooted<JSAtom*> RootedAtom;
typedef JS::Rooted<PropertyName*> RootedPropertyName;

enum XDRMode {
    XDR_ENCODE,
    XDR_DECODE
};

template <XDRMode mode>
class XDRState;

class FreeOp;

struct IdValuePair
{
    jsid id;
    Value value;

    IdValuePair() {}
    IdValuePair(jsid idArg)
      : id(idArg), value(UndefinedValue())
    {}
};

}

namespace JSC {

class ExecutableAllocator;

}

namespace WTF {

class BumpPointerAllocator;

}

}
# 247 "../../dist/include/jsprvtd.h"
typedef enum JSTrapStatus {
    JSTRAP_ERROR,
    JSTRAP_CONTINUE,
    JSTRAP_RETURN,
    JSTRAP_THROW,
    JSTRAP_LIMIT
} JSTrapStatus;

typedef JSTrapStatus
(* JSTrapHandler)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
                  jsval closure);

typedef JSTrapStatus
(* JSInterruptHook)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
                    void *closure);

typedef JSTrapStatus
(* JSDebuggerHandler)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
                      void *closure);

typedef JSTrapStatus
(* JSThrowHook)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
                void *closure);

typedef JSBool
(* JSWatchPointHandler)(JSContext *cx, JSObject *obj, jsid id, jsval old,
                        jsval *newp, void *closure);


typedef void
(* JSNewScriptHook)(JSContext *cx,
                    const char *filename,
                    unsigned lineno,
                    JSScript *script,
                    JSFunction *fun,
                    void *callerdata);


typedef void
(* JSDestroyScriptHook)(JSFreeOp *fop,
                        JSScript *script,
                        void *callerdata);

typedef void
(* JSSourceHandler)(const char *filename, unsigned lineno, const jschar *str,
                    size_t length, void **listenerTSData, void *closure);







typedef JSObject *
(* JSObjectOp)(JSContext *cx, JSHandleObject obj);


typedef JSObject *
(* JSClassInitializerOp)(JSContext *cx, JSHandleObject obj);





typedef JSObject *
(* JSIteratorOp)(JSContext *cx, JSHandleObject obj, JSBool keysonly);
# 18 "../../dist/include/jsclass.h" 2



namespace js {

class PropertyName;
class SpecialId;
class PropertyId;

static __attribute__((always_inline)) inline jsid
SPECIALID_TO_JSID(const SpecialId &sid);
# 41 "../../dist/include/jsclass.h"
class SpecialId
{
    uintptr_t bits_;


    friend __attribute__((always_inline)) inline jsid SPECIALID_TO_JSID(const SpecialId &sid);
    friend class PropertyId;

    static const uintptr_t TYPE_VOID = 0x2;
    static const uintptr_t TYPE_OBJECT = 0x4;
    static const uintptr_t TYPE_MASK = 0x7;

    SpecialId(uintptr_t bits) : bits_(bits) { }

  public:
    SpecialId() : bits_(TYPE_VOID) { }



    SpecialId(JSObject &obj)
      : bits_(uintptr_t(&obj) | TYPE_OBJECT)
    {
        do { } while(0);
        do { } while(0);
    }

    bool isObject() const {
        return (bits_ & TYPE_MASK) == TYPE_OBJECT && bits_ != TYPE_OBJECT;
    }

    JSObject *toObject() const {
        do { } while(0);
        return reinterpret_cast<JSObject *>(bits_ & ~TYPE_MASK);
    }



    static SpecialId empty() {
        SpecialId sid(TYPE_OBJECT);
        do { } while(0);
        return sid;
    }

    bool isEmpty() const {
        return bits_ == TYPE_OBJECT;
    }



    static SpecialId voidId() {
        SpecialId sid(TYPE_VOID);
        do { } while(0);
        return sid;
    }

    bool isVoid() const {
        return bits_ == TYPE_VOID;
    }
};

static __attribute__((always_inline)) inline jsid
SPECIALID_TO_JSID(const SpecialId &sid)
{
    jsid id;
    (id) = sid.bits_;
    do { } while (0);
    do { } while (0);
    do { } while (0);
    return id;
}

static __attribute__((always_inline)) inline bool
JSID_IS_SPECIAL(jsid id)
{
    return JSID_IS_OBJECT(id) || JSID_IS_EMPTY(id) || JSID_IS_VOID(id);
}

static __attribute__((always_inline)) inline SpecialId
JSID_TO_SPECIALID(jsid id)
{
    do { } while(0);
    if (JSID_IS_OBJECT(id))
        return SpecialId(*JSID_TO_OBJECT(id));
    if (JSID_IS_EMPTY(id))
        return SpecialId::empty();
    do { } while(0);
    return SpecialId::voidId();
}

typedef JS::Handle<SpecialId> HandleSpecialId;



typedef JSBool
(* LookupGenericOp)(JSContext *cx, HandleObject obj, HandleId id,
                    MutableHandleObject objp, MutableHandleShape propp);
typedef JSBool
(* LookupPropOp)(JSContext *cx, HandleObject obj, HandlePropertyName name,
                 MutableHandleObject objp, MutableHandleShape propp);
typedef JSBool
(* LookupElementOp)(JSContext *cx, HandleObject obj, uint32_t index,
                    MutableHandleObject objp, MutableHandleShape propp);
typedef JSBool
(* LookupSpecialOp)(JSContext *cx, HandleObject obj, HandleSpecialId sid,
                    MutableHandleObject objp, MutableHandleShape propp);
typedef JSBool
(* DefineGenericOp)(JSContext *cx, HandleObject obj, HandleId id, HandleValue value,
                    PropertyOp getter, StrictPropertyOp setter, unsigned attrs);
typedef JSBool
(* DefinePropOp)(JSContext *cx, HandleObject obj, HandlePropertyName name, HandleValue value,
                 PropertyOp getter, StrictPropertyOp setter, unsigned attrs);
typedef JSBool
(* DefineElementOp)(JSContext *cx, HandleObject obj, uint32_t index, HandleValue value,
                    PropertyOp getter, StrictPropertyOp setter, unsigned attrs);
typedef JSBool
(* DefineSpecialOp)(JSContext *cx, HandleObject obj, HandleSpecialId sid, HandleValue value,
                    PropertyOp getter, StrictPropertyOp setter, unsigned attrs);
typedef JSBool
(* GenericIdOp)(JSContext *cx, HandleObject obj, HandleObject receiver, HandleId id, MutableHandleValue vp);
typedef JSBool
(* PropertyIdOp)(JSContext *cx, HandleObject obj, HandleObject receiver, HandlePropertyName name, MutableHandleValue vp);
typedef JSBool
(* ElementIdOp)(JSContext *cx, HandleObject obj, HandleObject receiver, uint32_t index, MutableHandleValue vp);
typedef JSBool
(* ElementIfPresentOp)(JSContext *cx, HandleObject obj, HandleObject receiver, uint32_t index, MutableHandleValue vp, bool* present);
typedef JSBool
(* SpecialIdOp)(JSContext *cx, HandleObject obj, HandleObject receiver, HandleSpecialId sid, MutableHandleValue vp);
typedef JSBool
(* StrictGenericIdOp)(JSContext *cx, HandleObject obj, HandleId id, MutableHandleValue vp, JSBool strict);
typedef JSBool
(* StrictPropertyIdOp)(JSContext *cx, HandleObject obj, HandlePropertyName name, MutableHandleValue vp, JSBool strict);
typedef JSBool
(* StrictElementIdOp)(JSContext *cx, HandleObject obj, uint32_t index, MutableHandleValue vp, JSBool strict);
typedef JSBool
(* StrictSpecialIdOp)(JSContext *cx, HandleObject obj, HandleSpecialId sid, MutableHandleValue vp, JSBool strict);
typedef JSBool
(* GenericAttributesOp)(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp);
typedef JSBool
(* PropertyAttributesOp)(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp);
typedef JSBool
(* ElementAttributesOp)(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp);
typedef JSBool
(* SpecialAttributesOp)(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp);
typedef JSBool
(* DeletePropertyOp)(JSContext *cx, HandleObject obj, HandlePropertyName name, MutableHandleValue vp, JSBool strict);
typedef JSBool
(* DeleteElementOp)(JSContext *cx, HandleObject obj, uint32_t index, MutableHandleValue vp, JSBool strict);
typedef JSBool
(* DeleteSpecialOp)(JSContext *cx, HandleObject obj, HandleSpecialId sid, MutableHandleValue vp, JSBool strict);


typedef JSObject *
(* ObjectOp)(JSContext *cx, HandleObject obj);
typedef void
(* FinalizeOp)(FreeOp *fop, RawObject obj);
# 222 "../../dist/include/jsclass.h"
struct ClassSizeMeasurement
{
    const char *name; uint32_t flags; JSPropertyOp addProperty; JSPropertyOp delProperty; JSPropertyOp getProperty; JSStrictPropertyOp setProperty; JSEnumerateOp enumerate; JSResolveOp resolve; JSConvertOp convert; FinalizeOp finalize; JSCheckAccessOp checkAccess; JSNative call; JSHasInstanceOp hasInstance; JSNative construct; JSTraceOp trace;
};

struct ClassExtension
{
    JSObjectOp outerObject;
    JSObjectOp innerObject;
    JSIteratorOp iteratorObject;





    bool isWrappedNative;
# 250 "../../dist/include/jsclass.h"
    JSWeakmapKeyDelegateOp weakmapKeyDelegateOp;
};



struct ObjectOps
{
    LookupGenericOp lookupGeneric;
    LookupPropOp lookupProperty;
    LookupElementOp lookupElement;
    LookupSpecialOp lookupSpecial;
    DefineGenericOp defineGeneric;
    DefinePropOp defineProperty;
    DefineElementOp defineElement;
    DefineSpecialOp defineSpecial;
    GenericIdOp getGeneric;
    PropertyIdOp getProperty;
    ElementIdOp getElement;
    ElementIfPresentOp getElementIfPresent;
    SpecialIdOp getSpecial;
    StrictGenericIdOp setGeneric;
    StrictPropertyIdOp setProperty;
    StrictElementIdOp setElement;
    StrictSpecialIdOp setSpecial;
    GenericAttributesOp getGenericAttributes;
    PropertyAttributesOp getPropertyAttributes;
    ElementAttributesOp getElementAttributes;
    SpecialAttributesOp getSpecialAttributes;
    GenericAttributesOp setGenericAttributes;
    PropertyAttributesOp setPropertyAttributes;
    ElementAttributesOp setElementAttributes;
    SpecialAttributesOp setSpecialAttributes;
    DeletePropertyOp deleteProperty;
    DeleteElementOp deleteElement;
    DeleteSpecialOp deleteSpecial;

    JSNewEnumerateOp enumerate;
    ObjectOp thisObject;
};






struct Class
{
    const char *name; uint32_t flags; JSPropertyOp addProperty; JSPropertyOp delProperty; JSPropertyOp getProperty; JSStrictPropertyOp setProperty; JSEnumerateOp enumerate; JSResolveOp resolve; JSConvertOp convert; FinalizeOp finalize; JSCheckAccessOp checkAccess; JSNative call; JSHasInstanceOp hasInstance; JSNative construct; JSTraceOp trace;
    ClassExtension ext;
    ObjectOps ops;
    uint8_t pad[sizeof(JSClass) - sizeof(ClassSizeMeasurement) -
                            sizeof(ClassExtension) - sizeof(ObjectOps)];


    static const uint32_t NON_NATIVE = (1<<((8 + 8)+2));

    bool isNative() const {
        return !(flags & NON_NATIVE);
    }

    bool hasPrivate() const {
        return !!(flags & (1<<0));
    }

    bool emulatesUndefined() const {
        return flags & (1<<6);
    }

    static size_t offsetOfFlags() { return __builtin_offsetof (Class, flags); }
};

static_assert((__builtin_offsetof (JSClass, name) == __builtin_offsetof (Class, name)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, flags) == __builtin_offsetof (Class, flags)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, addProperty) == __builtin_offsetof (Class, addProperty)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, delProperty) == __builtin_offsetof (Class, delProperty)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, getProperty) == __builtin_offsetof (Class, getProperty)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, setProperty) == __builtin_offsetof (Class, setProperty)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, enumerate) == __builtin_offsetof (Class, enumerate)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, resolve) == __builtin_offsetof (Class, resolve)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, convert) == __builtin_offsetof (Class, convert)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, finalize) == __builtin_offsetof (Class, finalize)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, checkAccess) == __builtin_offsetof (Class, checkAccess)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, call) == __builtin_offsetof (Class, call)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, construct) == __builtin_offsetof (Class, construct)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, hasInstance) == __builtin_offsetof (Class, hasInstance)), "JS_STATIC_ASSERT");
static_assert((__builtin_offsetof (JSClass, trace) == __builtin_offsetof (Class, trace)), "JS_STATIC_ASSERT");
static_assert((sizeof(JSClass) == sizeof(Class)), "JS_STATIC_ASSERT");

static __attribute__((always_inline)) inline JSClass *
Jsvalify(Class *c)
{
    return (JSClass *)c;
}
static __attribute__((always_inline)) inline const JSClass *
Jsvalify(const Class *c)
{
    return (const JSClass *)c;
}

static __attribute__((always_inline)) inline Class *
Valueify(JSClass *c)
{
    return (Class *)c;
}
static __attribute__((always_inline)) inline const Class *
Valueify(const JSClass *c)
{
    return (const Class *)c;
}





enum ESClassValue {
    ESClass_Array, ESClass_Number, ESClass_String, ESClass_Boolean,
    ESClass_RegExp, ESClass_ArrayBuffer
};







inline bool
ObjectClassIs(JSObject &obj, ESClassValue classValue, JSContext *cx);


inline bool
IsObjectWithClass(const Value &v, ESClassValue classValue, JSContext *cx);

inline bool
IsPoisonedSpecialId(js::SpecialId iden)
{
    if (iden.isObject())
        return IsPoisonedPtr(iden.toObject());
    return false;
}

template <> struct RootMethods<SpecialId>
{
    static SpecialId initial() { return SpecialId(); }
    static ThingRootKind kind() { return THING_ROOT_ID; }
    static bool poisoned(SpecialId id) { return IsPoisonedSpecialId(id); }
};

}
# 13 "../../dist/include/jsfriendapi.h" 2
# 32 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) void
JS_SetGrayGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data);

extern __attribute__((visibility("default"))) JSString *
JS_GetAnonymousString(JSRuntime *rt);

extern __attribute__((visibility("default"))) JSObject *
JS_FindCompilationScope(JSContext *cx, JSRawObject obj);

extern __attribute__((visibility("default"))) JSFunction *
JS_GetObjectFunction(JSRawObject obj);

extern __attribute__((visibility("default"))) JSBool
JS_SplicePrototype(JSContext *cx, JSObject *obj, JSObject *proto);

extern __attribute__((visibility("default"))) JSObject *
JS_NewObjectWithUniqueType(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent);

extern __attribute__((visibility("default"))) uint32_t
JS_ObjectCountDynamicSlots(JSHandleObject obj);

extern __attribute__((visibility("default"))) size_t
JS_SetProtoCalled(JSContext *cx);

extern __attribute__((visibility("default"))) size_t
JS_GetCustomIteratorCount(JSContext *cx);

extern __attribute__((visibility("default"))) JSBool
JS_NondeterministicGetWeakMapKeys(JSContext *cx, JSObject *obj, JSObject **ret);







extern __attribute__((visibility("default"))) JSBool
JS_IsDeadWrapper(JSObject *obj);






extern __attribute__((visibility("default"))) void
JS_TraceShapeCycleCollectorChildren(JSTracer *trc, void *shape);

enum {
    JS_TELEMETRY_GC_REASON,
    JS_TELEMETRY_GC_IS_COMPARTMENTAL,
    JS_TELEMETRY_GC_MS,
    JS_TELEMETRY_GC_MAX_PAUSE_MS,
    JS_TELEMETRY_GC_MARK_MS,
    JS_TELEMETRY_GC_SWEEP_MS,
    JS_TELEMETRY_GC_MARK_ROOTS_MS,
    JS_TELEMETRY_GC_MARK_GRAY_MS,
    JS_TELEMETRY_GC_SLICE_MS,
    JS_TELEMETRY_GC_MMU_50,
    JS_TELEMETRY_GC_RESET,
    JS_TELEMETRY_GC_INCREMENTAL_DISABLED,
    JS_TELEMETRY_GC_NON_INCREMENTAL,
    JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS,
    JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS
};

typedef void
(* JSAccumulateTelemetryDataCallback)(int id, uint32_t sample);

extern __attribute__((visibility("default"))) void
JS_SetAccumulateTelemetryCallback(JSRuntime *rt, JSAccumulateTelemetryDataCallback callback);

extern __attribute__((visibility("default"))) JSPrincipals *
JS_GetCompartmentPrincipals(JSCompartment *compartment);

extern __attribute__((visibility("default"))) void
JS_SetCompartmentPrincipals(JSCompartment *compartment, JSPrincipals *principals);


extern __attribute__((visibility("default"))) JSObject *
JS_ObjectToInnerObject(JSContext *cx, JSObject *obj);


extern __attribute__((visibility("default"))) JSObject *
JS_ObjectToOuterObject(JSContext *cx, JSObject *obj);

extern __attribute__((visibility("default"))) JSObject *
JS_CloneObject(JSContext *cx, JSObject *obj, JSObject *proto, JSObject *parent);

extern __attribute__((visibility("default"))) JSBool
js_GetterOnlyPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, JSMutableHandleValue vp);

__attribute__((visibility("default"))) void
js_ReportOverRecursed(JSContext *maybecx);
# 147 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) bool
JS_CopyPropertiesFrom(JSContext *cx, JSObject *target, JSObject *obj);

extern __attribute__((visibility("default"))) JSBool
JS_WrapPropertyDescriptor(JSContext *cx, js::PropertyDescriptor *desc);

extern __attribute__((visibility("default"))) JSBool
JS_WrapAutoIdVector(JSContext *cx, JS::AutoIdVector &props);

extern __attribute__((visibility("default"))) JSBool
JS_EnumerateState(JSContext *cx, JSHandleObject obj, JSIterateOp enum_op,
                  js::MutableHandleValue statep, js::MutableHandleId idp);

struct JSFunctionSpecWithHelp {
    const char *name;
    JSNative call;
    uint16_t nargs;
    uint16_t flags;
    const char *usage;
    const char *help;
};






extern __attribute__((visibility("default"))) bool
JS_DefineFunctionsWithHelp(JSContext *cx, JSObject *obj, const JSFunctionSpecWithHelp *fs);

typedef bool (* JS_SourceHook)(JSContext *cx, JSScript *script, jschar **src, uint32_t *length);

extern __attribute__((visibility("default"))) void
JS_SetSourceHook(JSRuntime *rt, JS_SourceHook hook);

namespace js {

extern mozilla::ThreadLocal<PerThreadData *> TlsPerThreadData;

inline JSRuntime *
GetRuntime(const JSContext *cx)
{
    return ContextFriendFields::get(cx)->runtime;
}

inline JSCompartment *
GetContextCompartment(const JSContext *cx)
{
    return ContextFriendFields::get(cx)->compartment;
}

inline JS::Zone *
GetContextZone(const JSContext *cx)
{
    return ContextFriendFields::get(cx)->zone_;
}

extern __attribute__((visibility("default"))) JS::Zone *
GetCompartmentZone(JSCompartment *comp);

typedef bool
(* PreserveWrapperCallback)(JSContext *cx, JSObject *obj);





extern __attribute__((visibility("default"))) void
DumpHeapComplete(JSRuntime *rt, FILE *fp);

class __attribute__((visibility("default"))) AutoSwitchCompartment {
  private:
    JSContext *cx;
    JSCompartment *oldCompartment;
  public:
    AutoSwitchCompartment(JSContext *cx, JSCompartment *newCompartment
                          );
    AutoSwitchCompartment(JSContext *cx, JSHandleObject target
                          );
    ~AutoSwitchCompartment();
   
};


__attribute__((visibility("default"))) JSBool obj_defineGetter(JSContext *cx, unsigned argc, js::Value *vp);
__attribute__((visibility("default"))) JSBool obj_defineSetter(JSContext *cx, unsigned argc, js::Value *vp);


extern __attribute__((visibility("default"))) bool
IsSystemCompartment(JSCompartment *comp);

extern __attribute__((visibility("default"))) bool
IsSystemZone(JS::Zone *zone);

extern __attribute__((visibility("default"))) bool
IsAtomsCompartment(JSCompartment *comp);
# 251 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) bool
ReportIfUndeclaredVarAssignment(JSContext *cx, HandleString propname);

struct WeakMapTracer;







typedef void
(* WeakMapTraceCallback)(WeakMapTracer *trc, JSObject *m,
                         void *k, JSGCTraceKind kkind,
                         void *v, JSGCTraceKind vkind);

struct WeakMapTracer {
    JSRuntime *runtime;
    WeakMapTraceCallback callback;

    WeakMapTracer(JSRuntime *rt, WeakMapTraceCallback cb)
        : runtime(rt), callback(cb) {}
};

extern __attribute__((visibility("default"))) void
TraceWeakMaps(WeakMapTracer *trc);

extern __attribute__((visibility("default"))) bool
AreGCGrayBitsValid(JSRuntime *rt);

typedef void
(*GCThingCallback)(void *closure, void *gcthing);

extern __attribute__((visibility("default"))) void
VisitGrayWrapperTargets(JS::Zone *zone, GCThingCallback callback, void *closure);

extern __attribute__((visibility("default"))) JSObject *
GetWeakmapKeyDelegate(JSObject *key);

__attribute__((visibility("default"))) JSGCTraceKind
GCThingTraceKind(void *thing);




extern __attribute__((visibility("default"))) void
IterateGrayObjects(JS::Zone *zone, GCThingCallback cellCallback, void *data);


extern __attribute__((visibility("default"))) size_t
SizeOfDataIfCDataObject(JSMallocSizeOfFun mallocSizeOf, JSObject *obj);


extern __attribute__((visibility("default"))) JSCompartment *
GetAnyCompartmentInZone(JS::Zone *zone);







namespace shadow {

struct TypeObject {
    Class *clasp;
    JSObject *proto;
};

struct BaseShape {
    js::Class *clasp;
    JSObject *parent;
    JSCompartment *compartment;
};

class Shape {
public:
    shadow::BaseShape *base;
    jsid _1;
    uint32_t slotInfo;

    static const uint32_t FIXED_SLOTS_SHIFT = 27;
};

struct Object {
    shadow::Shape *shape;
    shadow::TypeObject *type;
    js::Value *slots;
    js::Value *_1;

    size_t numFixedSlots() const { return shape->slotInfo >> Shape::FIXED_SLOTS_SHIFT; }
    Value *fixedSlots() const {
        return (Value *)(uintptr_t(this) + sizeof(shadow::Object));
    }

    js::Value &slotRef(size_t slot) const {
        size_t nfixed = numFixedSlots();
        if (slot < nfixed)
            return fixedSlots()[slot];
        return slots[slot - nfixed];
    }
};

struct Function {
    Object base;
    uint16_t nargs;
    uint16_t flags;

    Native native;
    const JSJitInfo *jitinfo;
    void *_1;
};

struct Atom {
    size_t _;
    const jschar *chars;
};

}

extern __attribute__((visibility("default"))) js::Class CallClass;
extern __attribute__((visibility("default"))) js::Class DeclEnvClass;
extern __attribute__((visibility("default"))) js::Class FunctionClass;
extern __attribute__((visibility("default"))) js::Class FunctionProxyClass;
extern __attribute__((visibility("default"))) js::Class OuterWindowProxyClass;
extern __attribute__((visibility("default"))) js::Class ObjectProxyClass;
extern __attribute__((visibility("default"))) js::Class ObjectClass;

inline js::Class *
GetObjectClass(RawObject obj)
{
    return reinterpret_cast<const shadow::Object*>(obj)->type->clasp;
}

inline JSClass *
GetObjectJSClass(RawObject obj)
{
    return js::Jsvalify(GetObjectClass(obj));
}

inline bool
IsInnerObject(JSObject *obj) {
    return !!GetObjectClass(obj)->ext.outerObject;
}

inline bool
IsOuterObject(JSObject *obj) {
    return !!GetObjectClass(obj)->ext.innerObject;
}

__attribute__((visibility("default"))) bool
IsScopeObject(RawObject obj);

inline JSObject *
GetObjectParent(RawObject obj)
{
    do { } while(0);
    return reinterpret_cast<shadow::Object*>(obj)->shape->base->parent;
}

static __attribute__((always_inline)) inline JSCompartment *
GetObjectCompartment(JSObject *obj)
{
    return reinterpret_cast<shadow::Object*>(obj)->shape->base->compartment;
}

__attribute__((visibility("default"))) JSObject *
GetObjectParentMaybeScope(RawObject obj);

__attribute__((visibility("default"))) JSObject *
GetGlobalForObjectCrossCompartment(RawObject obj);

__attribute__((visibility("default"))) void
NotifyAnimationActivity(RawObject obj);

__attribute__((visibility("default"))) bool
IsOriginalScriptFunction(JSFunction *fun);
# 438 "../../dist/include/jsfriendapi.h"
__attribute__((visibility("default"))) JSScript *
GetOutermostEnclosingFunctionOfScriptedCaller(JSContext *cx);

__attribute__((visibility("default"))) JSFunction *
DefineFunctionWithReserved(JSContext *cx, JSObject *obj, const char *name, JSNative call,
                           unsigned nargs, unsigned attrs);

__attribute__((visibility("default"))) JSFunction *
NewFunctionWithReserved(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
                        JSObject *parent, const char *name);

__attribute__((visibility("default"))) JSFunction *
NewFunctionByIdWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
                            JSObject *parent, jsid id);

__attribute__((visibility("default"))) JSObject *
InitClassWithReserved(JSContext *cx, JSObject *obj, JSObject *parent_proto,
                      JSClass *clasp, JSNative constructor, unsigned nargs,
                      JSPropertySpec *ps, JSFunctionSpec *fs,
                      JSPropertySpec *static_ps, JSFunctionSpec *static_fs);

__attribute__((visibility("default"))) const Value &
GetFunctionNativeReserved(RawObject fun, size_t which);

__attribute__((visibility("default"))) void
SetFunctionNativeReserved(RawObject fun, size_t which, const Value &val);

inline bool
GetObjectProto(JSContext *cx, JSObject *obj, JSObject **proto)
{
    js::Class *clasp = GetObjectClass(obj);
    if (clasp == &js::ObjectProxyClass ||
        clasp == &js::OuterWindowProxyClass ||
        clasp == &js::FunctionProxyClass)
    {
        return JS_GetPrototype(cx, obj, proto);
    }

    *proto = reinterpret_cast<const shadow::Object*>(obj)->type->proto;
    return true;
}

inline void *
GetObjectPrivate(RawObject obj)
{
    const shadow::Object *nobj = reinterpret_cast<const shadow::Object*>(obj);
    void **addr = reinterpret_cast<void**>(&nobj->fixedSlots()[nobj->numFixedSlots()]);
    return *addr;
}





inline const Value &
GetReservedSlot(RawObject obj, size_t slot)
{
    do { } while(0);
    return reinterpret_cast<const shadow::Object *>(obj)->slotRef(slot);
}

__attribute__((visibility("default"))) void
SetReservedSlotWithBarrier(RawObject obj, size_t slot, const Value &value);

inline void
SetReservedSlot(RawObject obj, size_t slot, const Value &value)
{
    do { } while(0);
    shadow::Object *sobj = reinterpret_cast<shadow::Object *>(obj);
    if (sobj->slotRef(slot).isMarkable()



       )
    {
        SetReservedSlotWithBarrier(obj, slot, value);
    } else {
        sobj->slotRef(slot) = value;
    }
}

__attribute__((visibility("default"))) uint32_t
GetObjectSlotSpan(RawObject obj);

inline const Value &
GetObjectSlot(RawObject obj, size_t slot)
{
    do { } while(0);
    return reinterpret_cast<const shadow::Object *>(obj)->slotRef(slot);
}

inline const jschar *
GetAtomChars(JSAtom *atom)
{
    return reinterpret_cast<shadow::Atom *>(atom)->chars;
}

inline JSLinearString *
AtomToLinearString(JSAtom *atom)
{
    return reinterpret_cast<JSLinearString *>(atom);
}

static inline js::PropertyOp
CastAsJSPropertyOp(RawObject object)
{
    return (__extension__ (js::PropertyOp) (size_t) (object));
}

static inline js::StrictPropertyOp
CastAsJSStrictPropertyOp(RawObject object)
{
    return (__extension__ (js::StrictPropertyOp) (size_t) (object));
}

__attribute__((visibility("default"))) bool
GetPropertyNames(JSContext *cx, RawObject obj, unsigned flags, js::AutoIdVector *props);

__attribute__((visibility("default"))) bool
AppendUnique(JSContext *cx, AutoIdVector &base, AutoIdVector &others);

__attribute__((visibility("default"))) bool
GetGeneric(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp);

__attribute__((visibility("default"))) bool
StringIsArrayIndex(JSLinearString *str, uint32_t *indexp);

__attribute__((visibility("default"))) void
SetPreserveWrapperCallback(JSRuntime *rt, PreserveWrapperCallback callback);

__attribute__((visibility("default"))) bool
IsObjectInContextCompartment(RawObject obj, const JSContext *cx);
# 583 "../../dist/include/jsfriendapi.h"
inline uintptr_t
GetNativeStackLimit(const JSRuntime *rt)
{
    return PerThreadDataFriendFields::getMainThread(rt)->nativeStackLimit;
}
# 616 "../../dist/include/jsfriendapi.h"
__attribute__((visibility("default"))) void
StartPCCountProfiling(JSContext *cx);

__attribute__((visibility("default"))) void
StopPCCountProfiling(JSContext *cx);

__attribute__((visibility("default"))) void
PurgePCCounts(JSContext *cx);

__attribute__((visibility("default"))) size_t
GetPCCountScriptCount(JSContext *cx);

__attribute__((visibility("default"))) JSString *
GetPCCountScriptSummary(JSContext *cx, size_t script);

__attribute__((visibility("default"))) JSString *
GetPCCountScriptContents(JSContext *cx, size_t script);







class ProfileEntry
{
# 657 "../../dist/include/jsfriendapi.h"
    const char * volatile string;
    void * volatile sp;
    JSScript * volatile script_;
    int32_t volatile idx;

  public:







    bool js() volatile {
        do { } while (0);
        return sp == __null;
    }

    uint32_t line() volatile { do { } while(0); return idx; }
    JSScript *script() volatile { do { } while(0); return script_; }
    void *stackAddress() volatile { return sp; }
    const char *label() volatile { return string; }

    void setLine(uint32_t aLine) volatile { do { } while(0); idx = aLine; }
    void setLabel(const char *aString) volatile { string = aString; }
    void setStackAddress(void *aSp) volatile { sp = aSp; }
    void setScript(JSScript *aScript) volatile { script_ = aScript; }


    __attribute__((visibility("default"))) jsbytecode * pc() volatile;
    __attribute__((visibility("default"))) void setPC(jsbytecode *pc) volatile;

    static size_t offsetOfString() { return __builtin_offsetof (ProfileEntry, string); }
    static size_t offsetOfStackAddress() { return __builtin_offsetof (ProfileEntry, sp); }
    static size_t offsetOfPCIdx() { return __builtin_offsetof (ProfileEntry, idx); }
    static size_t offsetOfScript() { return __builtin_offsetof (ProfileEntry, script_); }






    static const int32_t NullPCIndex = -1;
};

__attribute__((visibility("default"))) void
SetRuntimeProfilingStack(JSRuntime *rt, ProfileEntry *stack, uint32_t *size,
                         uint32_t max);

__attribute__((visibility("default"))) void
EnableRuntimeProfilingStack(JSRuntime *rt, bool enabled);

__attribute__((visibility("default"))) jsbytecode*
ProfilingGetPC(JSRuntime *rt, RawScript script, void *ip);


__attribute__((visibility("default"))) void *
GetOwnerThread(const JSContext *cx);

__attribute__((visibility("default"))) bool
ContextHasOutstandingRequests(const JSContext *cx);


__attribute__((visibility("default"))) bool
HasUnrootedGlobal(const JSContext *cx);

typedef void
(* ActivityCallback)(void *arg, JSBool active);






__attribute__((visibility("default"))) void
SetActivityCallback(JSRuntime *rt, ActivityCallback cb, void *arg);

extern __attribute__((visibility("default"))) const JSStructuredCloneCallbacks *
GetContextStructuredCloneCallbacks(JSContext *cx);

extern __attribute__((visibility("default"))) bool
CanCallContextDebugHandler(JSContext *cx);

extern __attribute__((visibility("default"))) JSTrapStatus
CallContextDebugHandler(JSContext *cx, JSScript *script, jsbytecode *bc, Value *rval);

extern __attribute__((visibility("default"))) bool
IsContextRunningJS(JSContext *cx);

typedef void
(* AnalysisPurgeCallback)(JSRuntime *rt, JSFlatString *desc);

extern __attribute__((visibility("default"))) AnalysisPurgeCallback
SetAnalysisPurgeCallback(JSRuntime *rt, AnalysisPurgeCallback callback);

typedef JSBool
(* DOMInstanceClassMatchesProto)(JSHandleObject protoObject, uint32_t protoID,
                                 uint32_t depth);
struct JSDOMCallbacks {
    DOMInstanceClassMatchesProto instanceClassMatchesProto;
};
typedef struct JSDOMCallbacks DOMCallbacks;

extern __attribute__((visibility("default"))) void
SetDOMCallbacks(JSRuntime *rt, const DOMCallbacks *callbacks);

extern __attribute__((visibility("default"))) const DOMCallbacks *
GetDOMCallbacks(JSRuntime *rt);

extern __attribute__((visibility("default"))) JSObject *
GetTestingFunctions(JSContext *cx);






inline JSFreeOp *
CastToJSFreeOp(FreeOp *fop)
{
    return reinterpret_cast<JSFreeOp *>(fop);
}







extern __attribute__((visibility("default"))) const jschar*
GetErrorTypeName(JSContext* cx, int16_t exnType);







typedef enum NukeReferencesToWindow {
    NukeWindowReferences,
    DontNukeWindowReferences
} NukeReferencesToWindow;





struct CompartmentFilter {
    virtual bool match(JSCompartment *c) const = 0;
};

struct AllCompartments : public CompartmentFilter {
    virtual bool match(JSCompartment *c) const { return true; }
};

struct ContentCompartmentsOnly : public CompartmentFilter {
    virtual bool match(JSCompartment *c) const {
        return !IsSystemCompartment(c);
    }
};

struct ChromeCompartmentsOnly : public CompartmentFilter {
    virtual bool match(JSCompartment *c) const {
        return IsSystemCompartment(c);
    }
};

struct SingleCompartment : public CompartmentFilter {
    JSCompartment *ours;
    SingleCompartment(JSCompartment *c) : ours(c) {}
    virtual bool match(JSCompartment *c) const { return c == ours; }
};

struct CompartmentsWithPrincipals : public CompartmentFilter {
    JSPrincipals *principals;
    CompartmentsWithPrincipals(JSPrincipals *p) : principals(p) {}
    virtual bool match(JSCompartment *c) const {
        return JS_GetCompartmentPrincipals(c) == principals;
    }
};

extern __attribute__((visibility("default"))) JSBool
NukeCrossCompartmentWrappers(JSContext* cx,
                             const CompartmentFilter& sourceFilter,
                             const CompartmentFilter& targetFilter,
                             NukeReferencesToWindow nukeReferencesToWindow);


__attribute__((visibility("default"))) void
SetListBaseInformation(void *listBaseHandlerFamily, uint32_t listBaseExpandoSlot);

void *GetListBaseHandlerFamily();
uint32_t GetListBaseExpandoSlot();

}







extern __attribute__((visibility("default"))) JSBool
js_DateIsValid(JSObject* obj);

extern __attribute__((visibility("default"))) double
js_DateGetMsecSinceEpoch(JSRawObject obj);







typedef enum JSErrNum {


# 1 "../../dist/include/js.msg" 1
# 53 "../../dist/include/js.msg"
JSMSG_NOT_AN_ERROR = 0,
JSMSG_NOT_DEFINED = 1,
JSMSG_INACTIVE = 2,
JSMSG_MORE_ARGS_NEEDED = 3,
JSMSG_BAD_CHAR = 4,
JSMSG_BAD_TYPE = 5,
JSMSG_ALLOC_OVERFLOW = 6,
JSMSG_MISSING_HEXDIGITS = 7,
JSMSG_INCOMPATIBLE_PROTO = 8,
JSMSG_NO_CONSTRUCTOR = 9,
JSMSG_CANT_ALIAS = 10,
JSMSG_NOT_SCRIPTED_FUNCTION = 11,
JSMSG_BAD_SORT_ARG = 12,
JSMSG_BAD_ATOMIC_NUMBER = 13,
JSMSG_TOO_MANY_LITERALS = 14,
JSMSG_CANT_WATCH = 15,
JSMSG_STACK_UNDERFLOW = 16,
JSMSG_NEED_DIET = 17,
JSMSG_TOO_MANY_LOCAL_ROOTS = 18,
JSMSG_READ_ONLY = 19,
JSMSG_BAD_FORMAL = 20,
JSMSG_CANT_DELETE = 21,
JSMSG_NOT_FUNCTION = 22,
JSMSG_NOT_CONSTRUCTOR = 23,
JSMSG_INVALID_DATE = 24,
JSMSG_TOO_DEEP = 25,
JSMSG_OVER_RECURSED = 26,
JSMSG_IN_NOT_OBJECT = 27,
JSMSG_BAD_NEW_RESULT = 28,
JSMSG_OBJECT_ACCESS_DENIED = 29,
JSMSG_PROPERTY_ACCESS_DENIED = 30,
JSMSG_BAD_INSTANCEOF_RHS = 31,
JSMSG_BAD_BYTECODE = 32,
JSMSG_BAD_RADIX = 33,
JSMSG_PAREN_BEFORE_LET = 34,
JSMSG_CANT_CONVERT = 35,
JSMSG_CYCLIC_VALUE = 36,
JSMSG_COMPILE_EXECED_SCRIPT = 37,
JSMSG_CANT_CONVERT_TO = 38,
JSMSG_NO_PROPERTIES = 39,
JSMSG_CANT_FIND_CLASS = 40,
JSMSG_DEAD_OBJECT = 41,
JSMSG_BYTECODE_TOO_BIG = 42,
JSMSG_UNKNOWN_FORMAT = 43,
JSMSG_TOO_MANY_CON_ARGS = 44,
JSMSG_TOO_MANY_FUN_ARGS = 45,
JSMSG_BAD_QUANTIFIER = 46,
JSMSG_MIN_TOO_BIG = 47,
JSMSG_MAX_TOO_BIG = 48,
JSMSG_OUT_OF_ORDER = 49,
JSMSG_BAD_DESTRUCT_DECL = 50,
JSMSG_BAD_DESTRUCT_ASS = 51,
JSMSG_PAREN_AFTER_LET = 52,
JSMSG_CURLY_AFTER_LET = 53,
JSMSG_MISSING_PAREN = 54,
JSMSG_UNTERM_CLASS = 55,
JSMSG_TRAILING_SLASH = 56,
JSMSG_BAD_CLASS_RANGE = 57,
JSMSG_BAD_REGEXP_FLAG = 58,
JSMSG_NO_INPUT = 59,
JSMSG_CANT_OPEN = 60,
JSMSG_TOO_MANY_FUN_APPLY_ARGS = 61,
JSMSG_UNMATCHED_RIGHT_PAREN = 62,
JSMSG_TOO_BIG_TO_ENCODE = 63,
JSMSG_ARG_INDEX_OUT_OF_RANGE = 64,
JSMSG_SPREAD_TOO_LARGE = 65,
JSMSG_SOURCE_TOO_LONG = 66,
JSMSG_BAD_WEAKMAP_KEY = 67,
JSMSG_BAD_SCRIPT_MAGIC = 68,
JSMSG_PAREN_BEFORE_FORMAL = 69,
JSMSG_MISSING_FORMAL = 70,
JSMSG_PAREN_AFTER_FORMAL = 71,
JSMSG_CURLY_BEFORE_BODY = 72,
JSMSG_CURLY_AFTER_BODY = 73,
JSMSG_PAREN_BEFORE_COND = 74,
JSMSG_PAREN_AFTER_COND = 75,
JSMSG_BAD_DUP_ARGS = 76,
JSMSG_NAME_AFTER_DOT = 77,
JSMSG_BRACKET_IN_INDEX = 78,
JSMSG_ACCESSOR_DEF_DENIED = 79,
JSMSG_PAREN_BEFORE_SWITCH = 80,
JSMSG_PAREN_AFTER_SWITCH = 81,
JSMSG_CURLY_BEFORE_SWITCH = 82,
JSMSG_COLON_AFTER_CASE = 83,
JSMSG_WHILE_AFTER_DO = 84,
JSMSG_PAREN_AFTER_FOR = 85,
JSMSG_SEMI_AFTER_FOR_INIT = 86,
JSMSG_SEMI_AFTER_FOR_COND = 87,
JSMSG_PAREN_AFTER_FOR_CTRL = 88,
JSMSG_CURLY_BEFORE_TRY = 89,
JSMSG_CURLY_AFTER_TRY = 90,
JSMSG_PAREN_BEFORE_CATCH = 91,
JSMSG_CATCH_IDENTIFIER = 92,
JSMSG_PAREN_AFTER_CATCH = 93,
JSMSG_CURLY_BEFORE_CATCH = 94,
JSMSG_CURLY_AFTER_CATCH = 95,
JSMSG_CURLY_BEFORE_FINALLY = 96,
JSMSG_CURLY_AFTER_FINALLY = 97,
JSMSG_CATCH_OR_FINALLY = 98,
JSMSG_PAREN_BEFORE_WITH = 99,
JSMSG_PAREN_AFTER_WITH = 100,
JSMSG_CURLY_IN_COMPOUND = 101,
JSMSG_NO_VARIABLE_NAME = 102,
JSMSG_COLON_IN_COND = 103,
JSMSG_PAREN_AFTER_ARGS = 104,
JSMSG_BRACKET_AFTER_LIST = 105,
JSMSG_COLON_AFTER_ID = 106,
JSMSG_CURLY_AFTER_LIST = 107,
JSMSG_PAREN_IN_PAREN = 108,
JSMSG_SEMI_BEFORE_STMNT = 109,
JSMSG_NO_RETURN_VALUE = 110,
JSMSG_DUPLICATE_FORMAL = 111,
JSMSG_EQUAL_AS_ASSIGN = 112,
JSMSG_OPTIMIZED_CLOSURE_LEAK = 113,
JSMSG_TOO_MANY_DEFAULTS = 114,
JSMSG_TOO_MANY_CASES = 115,
JSMSG_BAD_SWITCH = 116,
JSMSG_BAD_FOR_LEFTSIDE = 117,
JSMSG_CATCH_AFTER_GENERAL = 118,
JSMSG_CATCH_WITHOUT_TRY = 119,
JSMSG_FINALLY_WITHOUT_TRY = 120,
JSMSG_LABEL_NOT_FOUND = 121,
JSMSG_TOUGH_BREAK = 122,
JSMSG_BAD_CONTINUE = 123,
JSMSG_BAD_RETURN_OR_YIELD = 124,
JSMSG_BAD_LABEL = 125,
JSMSG_DUPLICATE_LABEL = 126,
JSMSG_VAR_HIDES_ARG = 127,
JSMSG_BAD_VAR_INIT = 128,
JSMSG_BAD_LEFTSIDE_OF_ASS = 129,
JSMSG_BAD_OPERAND = 130,
JSMSG_BAD_PROP_ID = 131,
JSMSG_RESERVED_ID = 132,
JSMSG_SYNTAX_ERROR = 133,
JSMSG_UNUSED134 = 134,
JSMSG_BAD_PROTOTYPE = 135,
JSMSG_MISSING_EXPONENT = 136,
JSMSG_OUT_OF_MEMORY = 137,
JSMSG_UNTERMINATED_STRING = 138,
JSMSG_TOO_MANY_PARENS = 139,
JSMSG_UNTERMINATED_COMMENT = 140,
JSMSG_UNTERMINATED_REGEXP = 141,
JSMSG_BAD_CLONE_FUNOBJ_SCOPE = 142,
JSMSG_UNUSED143 = 143,
JSMSG_ILLEGAL_CHARACTER = 144,
JSMSG_BAD_OCTAL = 145,
JSMSG_UNUSED146 = 146,
JSMSG_UNCAUGHT_EXCEPTION = 147,
JSMSG_INVALID_BACKREF = 148,
JSMSG_BAD_BACKREF = 149,
JSMSG_PRECISION_RANGE = 150,
JSMSG_BAD_GETTER_OR_SETTER = 151,
JSMSG_BAD_ARRAY_LENGTH = 152,
JSMSG_CANT_DESCRIBE_PROPS = 153,
JSMSG_BAD_APPLY_ARGS = 154,
JSMSG_REDECLARED_VAR = 155,
JSMSG_UNDECLARED_VAR = 156,
JSMSG_ANON_NO_RETURN_VALUE = 157,
JSMSG_DEPRECATED_USAGE = 158,
JSMSG_BAD_URI = 159,
JSMSG_GETTER_ONLY = 160,
JSMSG_IDSTART_AFTER_NUMBER = 161,
JSMSG_UNDEFINED_PROP = 162,
JSMSG_USELESS_EXPR = 163,
JSMSG_REDECLARED_PARAM = 164,
JSMSG_NEWREGEXP_FLAGGED = 165,
JSMSG_RESERVED_SLOT_RANGE = 166,
JSMSG_CANT_DECODE_PRINCIPALS = 167,
JSMSG_CANT_SEAL_OBJECT = 168,
JSMSG_TOO_MANY_CATCH_VARS = 169,
JSMSG_UNUSED170 = 170,
JSMSG_UNUSED171 = 171,
JSMSG_UNUSED172 = 172,
JSMSG_UNUSED173 = 173,
JSMSG_UNUSED174 = 174,
JSMSG_NESTING_GENERATOR = 175,
JSMSG_UNUSED176 = 176,
JSMSG_UNUSED177 = 177,
JSMSG_UNUSED178 = 178,
JSMSG_UNUSED179 = 179,
JSMSG_UNUSED180 = 180,
JSMSG_UNUSED181 = 181,
JSMSG_BAD_GENERATOR_SEND = 182,
JSMSG_UNUSED183 = 183,
JSMSG_UNUSED184 = 184,
JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 185,
JSMSG_UNUSED186 = 186,
JSMSG_UNUSED187 = 187,
JSMSG_INCOMPATIBLE_METHOD = 188,
JSMSG_UNUSED189 = 189,
JSMSG_UNUSED190 = 190,
JSMSG_UNUSED191 = 191,
JSMSG_UNUSED192 = 192,
JSMSG_BAD_FOR_EACH_LOOP = 193,
JSMSG_UNUSED194 = 194,
JSMSG_UNUSED195 = 195,
JSMSG_UNUSED196 = 196,
JSMSG_INTERNAL_INTL_ERROR = 197,
JSMSG_DEFAULT_LOCALE_ERROR = 198,
JSMSG_TOO_MANY_LOCALS = 199,
JSMSG_ARRAY_INIT_TOO_BIG = 200,
JSMSG_REGEXP_TOO_COMPLEX = 201,
JSMSG_BUFFER_TOO_SMALL = 202,
JSMSG_BAD_SURROGATE_CHAR = 203,
JSMSG_UTF8_CHAR_TOO_LARGE = 204,
JSMSG_MALFORMED_UTF8_CHAR = 205,
JSMSG_USER_DEFINED_ERROR = 206,
JSMSG_WRONG_CONSTRUCTOR = 207,
JSMSG_BAD_GENERATOR_RETURN = 208,
JSMSG_BAD_ANON_GENERATOR_RETURN = 209,
JSMSG_NAME_AFTER_FOR_PAREN = 210,
JSMSG_IN_AFTER_FOR_NAME = 211,
JSMSG_BAD_TRAP_RETURN_VALUE = 212,
JSMSG_UNUSED213 = 213,
JSMSG_BAD_GENERATOR_YIELD = 214,
JSMSG_BAD_GENERATOR_SYNTAX = 215,
JSMSG_ARRAY_COMP_LEFTSIDE = 216,
JSMSG_UNUSED217 = 217,
JSMSG_EMPTY_ARRAY_REDUCE = 218,
JSMSG_UNUSED219 = 219,
JSMSG_BAD_DELETE_OPERAND = 220,
JSMSG_BAD_INCOP_OPERAND = 221,
JSMSG_UNEXPECTED_TYPE = 222,
JSMSG_LET_DECL_NOT_IN_BLOCK = 223,
JSMSG_BAD_OBJECT_INIT = 224,
JSMSG_CANT_SET_ARRAY_ATTRS = 225,
JSMSG_EVAL_ARITY = 226,
JSMSG_MISSING_FUN_ARG = 227,
JSMSG_JSON_BAD_PARSE = 228,
JSMSG_JSON_BAD_STRINGIFY = 229,
JSMSG_NOT_CALLABLE_OR_UNDEFINED = 230,
JSMSG_NOT_NONNULL_OBJECT = 231,
JSMSG_DEPRECATED_OCTAL = 232,
JSMSG_STRICT_CODE_WITH = 233,
JSMSG_DUPLICATE_PROPERTY = 234,
JSMSG_DEPRECATED_DELETE_OPERAND = 235,
JSMSG_DEPRECATED_ASSIGN = 236,
JSMSG_BAD_BINDING = 237,
JSMSG_INVALID_DESCRIPTOR = 238,
JSMSG_OBJECT_NOT_EXTENSIBLE = 239,
JSMSG_CANT_REDEFINE_PROP = 240,
JSMSG_CANT_APPEND_TO_ARRAY = 241,
JSMSG_CANT_DEFINE_ARRAY_LENGTH = 242,
JSMSG_CANT_DEFINE_ARRAY_INDEX = 243,
JSMSG_TYPED_ARRAY_BAD_INDEX = 244,
JSMSG_TYPED_ARRAY_NEGATIVE_ARG = 245,
JSMSG_TYPED_ARRAY_BAD_ARGS = 246,
JSMSG_CSP_BLOCKED_FUNCTION = 247,
JSMSG_BAD_GET_SET_FIELD = 248,
JSMSG_BAD_PROXY_FIX = 249,
JSMSG_INVALID_EVAL_SCOPE_ARG = 250,
JSMSG_ACCESSOR_WRONG_ARGS = 251,
JSMSG_THROW_TYPE_ERROR = 252,
JSMSG_BAD_TOISOSTRING_PROP = 253,
JSMSG_BAD_PARSE_NODE = 254,
JSMSG_NOT_EXPECTED_TYPE = 255,
JSMSG_CALLER_IS_STRICT = 256,
JSMSG_NEED_DEBUG_MODE = 257,
JSMSG_STRICT_CODE_LET_EXPR_STMT = 258,
JSMSG_CANT_CHANGE_EXTENSIBILITY = 259,
JSMSG_SC_BAD_SERIALIZED_DATA = 260,
JSMSG_SC_UNSUPPORTED_TYPE = 261,
JSMSG_SC_RECURSION = 262,
JSMSG_UNUSED263 = 263,
JSMSG_BAD_CLONE_VERSION = 264,
JSMSG_CANT_CLONE_OBJECT = 265,
JSMSG_UNUSED266 = 266,
JSMSG_STRICT_FUNCTION_STATEMENT = 267,
JSMSG_INVALID_FOR_IN_INIT = 268,
JSMSG_CLEARED_SCOPE = 269,
JSMSG_MALFORMED_ESCAPE = 270,
JSMSG_BAD_GENEXP_BODY = 271,
JSMSG_UNUSED272 = 272,
JSMSG_UNNAMED_FUNCTION_STMT = 273,
JSMSG_CCW_REQUIRED = 274,
JSMSG_DEBUG_BAD_RESUMPTION = 275,
JSMSG_ASSIGN_FUNCTION_OR_NULL = 276,
JSMSG_DEBUG_NOT_LIVE = 277,
JSMSG_DEBUG_OBJECT_WRONG_OWNER = 278,
JSMSG_DEBUG_OBJECT_PROTO = 279,
JSMSG_DEBUG_LOOP = 280,
JSMSG_DEBUG_NOT_IDLE = 281,
JSMSG_DEBUG_BAD_OFFSET = 282,
JSMSG_DEBUG_BAD_LINE = 283,
JSMSG_DEBUG_NOT_DEBUGGING = 284,
JSMSG_DEBUG_COMPARTMENT_MISMATCH = 285,
JSMSG_DEBUG_NOT_SCRIPT_FRAME = 286,
JSMSG_CANT_WATCH_PROP = 287,
JSMSG_CSP_BLOCKED_EVAL = 288,
JSMSG_DEBUG_NO_SCOPE_OBJECT = 289,
JSMSG_EMPTY_CONSEQUENT = 290,
JSMSG_NOT_ITERABLE = 291,
JSMSG_QUERY_LINE_WITHOUT_URL = 292,
JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 293,
JSMSG_DEBUG_VARIABLE_NOT_FOUND = 294,
JSMSG_PARAMETER_AFTER_REST = 295,
JSMSG_NO_REST_NAME = 296,
JSMSG_ARGUMENTS_AND_REST = 297,
JSMSG_FUNCTION_ARGUMENTS_AND_REST = 298,
JSMSG_REST_WITH_DEFAULT = 299,
JSMSG_NONDEFAULT_FORMAL_AFTER_DEFAULT = 300,
JSMSG_YIELD_IN_DEFAULT = 301,
JSMSG_INTRINSIC_NOT_DEFINED = 302,
JSMSG_ALREADY_HAS_SOURCEMAP = 303,
JSMSG_PAR_ARRAY_BAD_ARG = 304,
JSMSG_PAR_ARRAY_BAD_PARTITION = 305,
JSMSG_PAR_ARRAY_REDUCE_EMPTY = 306,
JSMSG_PAR_ARRAY_ALREADY_FLAT = 307,
JSMSG_PAR_ARRAY_SCATTER_CONFLICT = 308,
JSMSG_PAR_ARRAY_SCATTER_BOUNDS = 309,
JSMSG_CANT_REPORT_NC_AS_NE = 310,
JSMSG_CANT_REPORT_E_AS_NE = 311,
JSMSG_CANT_REPORT_NEW = 312,
JSMSG_CANT_REPORT_INVALID = 313,
JSMSG_CANT_REPORT_NE_AS_NC = 314,
JSMSG_CANT_DEFINE_NEW = 315,
JSMSG_CANT_DEFINE_INVALID = 316,
JSMSG_CANT_DEFINE_NE_AS_NC = 317,
JSMSG_INVALID_TRAP_RESULT = 318,
JSMSG_CANT_SKIP_NC = 319,
JSMSG_MUST_REPORT_SAME_VALUE = 320,
JSMSG_MUST_REPORT_UNDEFINED = 321,
JSMSG_CANT_SET_NW_NC = 322,
JSMSG_CANT_SET_WO_SETTER = 323,
JSMSG_DEBUG_BAD_REFERENT = 324,
JSMSG_DEBUG_WRAPPER_IN_WAY = 325,
JSMSG_UNWRAP_DENIED = 326,
JSMSG_INTL_OBJECT_NOT_INITED = 327,
JSMSG_INVALID_LOCALES_ELEMENT = 328,
JSMSG_INVALID_LANGUAGE_TAG = 329,
JSMSG_INVALID_LOCALE_MATCHER = 330,
JSMSG_INVALID_OPTION_VALUE = 331,
JSMSG_INVALID_DIGITS_VALUE = 332,
JSMSG_INTL_OBJECT_REINITED = 333,
JSMSG_INVALID_CURRENCY_CODE = 334,
JSMSG_UNDEFINED_CURRENCY = 335,
JSMSG_INVALID_TIME_ZONE = 336,
JSMSG_DATE_NOT_FINITE = 337,
JSMSG_MODULE_STATEMENT = 338,
JSMSG_CURLY_BEFORE_MODULE = 339,
JSMSG_CURLY_AFTER_MODULE = 340,
JSMSG_USE_ASM_DIRECTIVE_FAIL = 341,
JSMSG_USE_ASM_TYPE_FAIL = 342,
JSMSG_USE_ASM_LINK_FAIL = 343,
JSMSG_USE_ASM_TYPE_OK = 344,
JSMSG_BAD_ARROW_ARGS = 345,
JSMSG_YIELD_IN_ARROW = 346,
JSMSG_WRONG_VALUE = 347,
JSMSG_PAR_ARRAY_SCATTER_BAD_TARGET = 348,
# 875 "../../dist/include/jsfriendapi.h" 2

    JSErr_Limit
} JSErrNum;

extern __attribute__((visibility("default"))) const JSErrorFormatString *
js_GetErrorMessage(void *userRef, const char *locale, const unsigned errorNumber);



extern __attribute__((visibility("default"))) uint64_t
js_GetSCOffset(JSStructuredCloneWriter* writer);



namespace js {
namespace ArrayBufferView {

enum ViewType {
    TYPE_INT8 = 0,
    TYPE_UINT8,
    TYPE_INT16,
    TYPE_UINT16,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_FLOAT32,
    TYPE_FLOAT64,





    TYPE_UINT8_CLAMPED,





    TYPE_DATAVIEW,

    TYPE_MAX
};

}
}

typedef js::ArrayBufferView::ViewType JSArrayBufferViewType;







extern __attribute__((visibility("default"))) JSObject *
JS_NewInt8Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint8Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint8ClampedArray(JSContext *cx, uint32_t nelements);

extern __attribute__((visibility("default"))) JSObject *
JS_NewInt16Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint16Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt32Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint32Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewFloat32Array(JSContext *cx, uint32_t nelements);
extern __attribute__((visibility("default"))) JSObject *
JS_NewFloat64Array(JSContext *cx, uint32_t nelements);
# 956 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt8ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint8ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint8ClampedArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt16ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint16ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt32ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint32ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewFloat32ArrayFromArray(JSContext *cx, JSObject *array);
extern __attribute__((visibility("default"))) JSObject *
JS_NewFloat64ArrayFromArray(JSContext *cx, JSObject *array);
# 982 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                          uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                           uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint8ClampedArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                                  uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                           uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                            uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewInt32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                           uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewUint32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                            uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewFloat32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                             uint32_t byteOffset, int32_t length);
extern __attribute__((visibility("default"))) JSObject *
JS_NewFloat64ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                             uint32_t byteOffset, int32_t length);




extern __attribute__((visibility("default"))) JSObject *
JS_NewArrayBuffer(JSContext *cx, uint32_t nbytes);







extern __attribute__((visibility("default"))) JSBool
JS_IsTypedArrayObject(JSObject *obj);
# 1032 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) JSBool
JS_IsArrayBufferViewObject(JSObject *obj);





extern __attribute__((visibility("default"))) JSBool
JS_IsInt8Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsUint8Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsUint8ClampedArray(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsInt16Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsUint16Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsInt32Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsUint32Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsFloat32Array(JSObject *obj);
extern __attribute__((visibility("default"))) JSBool
JS_IsFloat64Array(JSObject *obj);






extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsInt8Array(JSObject *obj, uint32_t *length, int8_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsUint8Array(JSObject *obj, uint32_t *length, uint8_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsUint8ClampedArray(JSObject *obj, uint32_t *length, uint8_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsInt16Array(JSObject *obj, uint32_t *length, int16_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsUint16Array(JSObject *obj, uint32_t *length, uint16_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsInt32Array(JSObject *obj, uint32_t *length, int32_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsUint32Array(JSObject *obj, uint32_t *length, uint32_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsFloat32Array(JSObject *obj, uint32_t *length, float **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsFloat64Array(JSObject *obj, uint32_t *length, double **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsArrayBufferView(JSObject *obj, uint32_t *length, uint8_t **data);
extern __attribute__((visibility("default"))) JSObject *
JS_GetObjectAsArrayBuffer(JSObject *obj, uint32_t *length, uint8_t **data);
# 1093 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) JSArrayBufferViewType
JS_GetArrayBufferViewType(JSObject *obj);







extern __attribute__((visibility("default"))) JSBool
JS_IsArrayBufferObject(JSObject *obj);
# 1112 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) uint32_t
JS_GetArrayBufferByteLength(JSObject *obj);
# 1124 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) uint8_t *
JS_GetArrayBufferData(JSObject *obj);
# 1134 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) uint32_t
JS_GetTypedArrayLength(JSObject *obj);
# 1145 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) uint32_t
JS_GetTypedArrayByteOffset(JSObject *obj);
# 1155 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) uint32_t
JS_GetTypedArrayByteLength(JSObject *obj);






extern __attribute__((visibility("default"))) JSBool
JS_IsArrayBufferViewObject(JSObject *obj);




extern __attribute__((visibility("default"))) uint32_t
JS_GetArrayBufferViewByteLength(JSObject *obj);
# 1182 "../../dist/include/jsfriendapi.h"
extern __attribute__((visibility("default"))) int8_t *
JS_GetInt8ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) uint8_t *
JS_GetUint8ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) uint8_t *
JS_GetUint8ClampedArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) int16_t *
JS_GetInt16ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) uint16_t *
JS_GetUint16ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) int32_t *
JS_GetInt32ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) uint32_t *
JS_GetUint32ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) float *
JS_GetFloat32ArrayData(JSObject *obj);
extern __attribute__((visibility("default"))) double *
JS_GetFloat64ArrayData(JSObject *obj);





extern __attribute__((visibility("default"))) void *
JS_GetArrayBufferViewData(JSObject *obj);






extern __attribute__((visibility("default"))) JSObject *
JS_GetArrayBufferViewBuffer(JSObject *obj);




__attribute__((visibility("default"))) JSBool
JS_IsDataViewObject(JSObject *obj);
# 1230 "../../dist/include/jsfriendapi.h"
__attribute__((visibility("default"))) uint32_t
JS_GetDataViewByteOffset(JSObject *obj);
# 1241 "../../dist/include/jsfriendapi.h"
__attribute__((visibility("default"))) uint32_t
JS_GetDataViewByteLength(JSObject *obj);
# 1252 "../../dist/include/jsfriendapi.h"
__attribute__((visibility("default"))) void *
JS_GetDataViewData(JSObject *obj);






typedef bool
(* JSJitPropertyOp)(JSContext *cx, JSHandleObject thisObj,
                    void *specializedThis, JS::Value *vp);
typedef bool
(* JSJitMethodOp)(JSContext *cx, JSHandleObject thisObj,
                  void *specializedThis, unsigned argc, JS::Value *vp);

struct JSJitInfo {
    enum OpType {
        Getter,
        Setter,
        Method
    };

    JSJitPropertyOp op;
    uint32_t protoID;
    uint32_t depth;
    OpType type;
    bool isInfallible;
    bool isConstant;
    bool isPure;


    JSValueType returnType;
};

static __attribute__((always_inline)) inline const JSJitInfo *
FUNCTION_VALUE_TO_JITINFO(const JS::Value& v)
{
    do { } while(0);
    return reinterpret_cast<js::shadow::Function *>(&v.toObject())->jitinfo;
}


static const unsigned JS_FUNCTION_INTERPRETED_BIT = 0x1;

static __attribute__((always_inline)) inline void
SET_JITINFO(JSFunction * func, const JSJitInfo *info)
{
    js::shadow::Function *fun = reinterpret_cast<js::shadow::Function *>(func);
    do { } while(0);
    fun->jitinfo = info;
}






static __attribute__((always_inline)) inline jsid
JSID_FROM_BITS(size_t bits)
{
    jsid id;
    (id) = bits;
    return id;
}
# 1338 "../../dist/include/jsfriendapi.h"
static __attribute__((always_inline)) inline jsid
NON_INTEGER_ATOM_TO_JSID(JSAtom *atom)
{
    do { } while(0);
    jsid id = JSID_FROM_BITS((size_t)atom);
    do { } while(0);
    return id;
}


static __attribute__((always_inline)) inline JSBool
JSID_IS_ATOM(jsid id)
{
    return JSID_IS_STRING(id);
}

static __attribute__((always_inline)) inline JSBool
JSID_IS_ATOM(jsid id, JSAtom *atom)
{
    return id == JSID_FROM_BITS((size_t)atom);
}

static __attribute__((always_inline)) inline JSAtom *
JSID_TO_ATOM(jsid id)
{
    return (JSAtom *)JSID_TO_STRING(id);
}

static_assert((sizeof(jsid) == 8), "JS_STATIC_ASSERT");

namespace js {

static __attribute__((always_inline)) inline Value
IdToValue(jsid id)
{
    if (JSID_IS_STRING(id))
        return StringValue(JSID_TO_STRING(id));
    if ((__builtin_expect((JSID_IS_INT(id)), 1)))
        return Int32Value(JSID_TO_INT(id));
    if ((__builtin_expect((JSID_IS_OBJECT(id)), 1)))
        return ObjectValue(*JSID_TO_OBJECT(id));
    do { } while(0);
    return UndefinedValue();
}

static __attribute__((always_inline)) inline jsval
IdToJsval(jsid id)
{
    return IdToValue(id);
}

extern __attribute__((visibility("default"))) bool
IsReadOnlyDateMethod(JS::IsAcceptableThis test, JS::NativeImpl method);

extern __attribute__((visibility("default"))) bool
IsTypedArrayThisCheck(JS::IsAcceptableThis test);

enum CTypesActivityType {
    CTYPES_CALL_BEGIN,
    CTYPES_CALL_END,
    CTYPES_CALLBACK_BEGIN,
    CTYPES_CALLBACK_END
};

typedef void
(* CTypesActivityCallback)(JSContext *cx, CTypesActivityType type);





__attribute__((visibility("default"))) void
SetCTypesActivityCallback(JSRuntime *rt, CTypesActivityCallback cb);

class __attribute__((visibility("default"))) AutoCTypesActivityCallback {
  private:
    JSContext *cx;
    CTypesActivityCallback callback;
    CTypesActivityType endType;
   

  public:
    AutoCTypesActivityCallback(JSContext *cx, CTypesActivityType beginType,
                               CTypesActivityType endType
                               );
    ~AutoCTypesActivityCallback() {
        DoEndCallback();
    }
    void DoEndCallback() {
        if (callback) {
            callback(cx, endType);
            callback = __null;
        }
    }
};





inline void assertEnteredPolicy(JSContext *cx, JSObject *obj, jsid id) {};


}

extern __attribute__((visibility("default"))) JSBool
js_DefineOwnProperty(JSContext *cx, JSObject *objArg, jsid idArg,
                     const js::PropertyDescriptor& descriptor, JSBool *bp);
# 53 "../../dist/include/GeckoProfiler.h" 2

# 1 "../../dist/include/mozilla/TimeStamp.h" 1
# 55 "../../dist/include/GeckoProfiler.h" 2
# 140 "../../dist/include/GeckoProfiler.h"
# 1 "../../dist/include/GeckoProfilerImpl.h" 1
# 9 "../../dist/include/GeckoProfilerImpl.h"
# 1 "../../dist/system_wrappers/stdlib.h" 1
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 10 "../../dist/include/GeckoProfilerImpl.h" 2
# 1 "../../dist/system_wrappers/signal.h" 1
       
# 2 "../../dist/system_wrappers/signal.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 11 "../../dist/include/GeckoProfilerImpl.h" 2
# 1 "../../dist/system_wrappers/stdarg.h" 1
       
# 2 "../../dist/system_wrappers/stdarg.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 12 "../../dist/include/GeckoProfilerImpl.h" 2
# 1 "../../dist/stl_wrappers/algorithm" 1
# 18 "../../dist/stl_wrappers/algorithm"
       
# 19 "../../dist/stl_wrappers/algorithm" 3
# 33 "../../dist/stl_wrappers/algorithm" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/algorithm" 2 3
# 54 "../../dist/stl_wrappers/algorithm" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/algorithm" 1 3
       
# 2 "../../dist/system_wrappers/algorithm" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/algorithm" 1 3
# 59 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/algorithm" 3
       
# 60 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/algorithm" 3

# 1 "../../dist/stl_wrappers/utility" 1 3
# 18 "../../dist/stl_wrappers/utility" 3
       
# 19 "../../dist/stl_wrappers/utility" 3
# 33 "../../dist/stl_wrappers/utility" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/utility" 2 3
# 54 "../../dist/stl_wrappers/utility" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/utility" 1 3
       
# 2 "../../dist/system_wrappers/utility" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 1 3
# 60 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 3
       
# 61 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 3
# 71 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_relops.h" 1 3
# 68 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 86 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 99 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 112 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 125 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 72 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_pair.h" 1 3
# 61 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_pair.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/concept_check.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/concept_check.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/concept_check.h" 3
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() { return value; }
    };


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };

  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };


  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };



  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename>
    struct __is_nullptr_t_helper
    : public false_type { };

  template<>
    struct __is_nullptr_t_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public integral_constant<bool, (__is_nullptr_t_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };




  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>
    { };


  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl_1
  {
    template<typename _Up>
      struct __w { _Up __u; };

    template<typename _Tp, typename
             = decltype(declval<__w<_Tp>&>().~__w<_Tp>())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl_1
    : public __do_is_destructible_impl_1
    {
      typedef decltype(__test<_Tp>(0)) type;
    };


  struct __do_is_destructible_impl_2
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl_2
    : public __do_is_destructible_impl_2
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_function<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public conditional<is_abstract<_Tp>::value,
    __is_destructible_impl_2<_Tp>,
                         __is_destructible_impl_1<_Tp>>::type::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public integral_constant<bool, (__is_default_constructible_safe<
          _Tp>::value)>
    { };
# 726 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public integral_constant<bool, (__is_direct_constructible_new<
          _Tp, _Arg>::value)>
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public integral_constant<bool, (__is_constructible_impl<_Tp,
          _Args...>::value)>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    : public __sfinae_types
    {
      template<typename _Tp1, typename _Up1>
        static decltype(declval<_Tp1>() = declval<_Up1>(), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_Tp, _Up>(0)) == 1;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public integral_constant<bool,
                               __is_assignable_helper<_Tp, _Up>::value>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_destructor
    : public integral_constant<bool, __has_trivial_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { static constexpr bool value = is_void<_To>::value; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    : public __sfinae_types
    {
      template<typename _To1>
        static void __test_aux(_To1);

      template<typename _From1, typename _To1>
        static decltype(__test_aux<_To1>(std::declval<_From1>()), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_From, _To>(0)) == 1;
    };


  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::value>
    { };


  template<typename _From, typename _To>
    struct is_explicitly_convertible
    : public is_constructible<_To, _From>
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp,
    bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp,
           bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };



  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };



  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1643 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };



  template<typename... _Tp>
    struct common_type;

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    { typedef decltype(true ? declval<_Tp>() : declval<_Up>()) type; };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    {
      typedef typename
        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
    };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;

  template<typename _MemPtr, typename _Arg>
    struct _Result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct _Result_of_memobj<_Res _Class::*, _Arg>
    {
    private:
      typedef _Res _Class::* _Func;

      template<typename _Tp>
 static _Tp _S_get(const _Class&);
      template<typename _Tp>
 static decltype(*std::declval<_Tp>()) _S_get(...);

    public:
      typedef
        decltype(_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())
        __type;
    };

  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>
    struct _Result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct _Result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
    private:
      typedef _Res _Class::* _Func;

      template<typename _Tp>
 static _Tp _S_get(const _Class&);
      template<typename _Tp>
 static decltype(*std::declval<_Tp>()) _S_get(...);

    public:
      typedef
        decltype((_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())
            (std::declval<_Args>()...) )
        __type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct _Result_of_impl;

  template<typename _Functor, typename... _ArgTypes>
    struct _Result_of_impl<false, false, _Functor, _ArgTypes...>
    {
      typedef
        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )
        __type;
    };

  template<typename _MemPtr, typename _Arg>
    struct _Result_of_impl<true, false, _MemPtr, _Arg>
    : _Result_of_memobj<typename remove_reference<_MemPtr>::type, _Arg>
    {
      typedef typename _Result_of_memobj<
 typename remove_reference<_MemPtr>::type, _Arg>::__type
 __type;
    };

  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>
    struct _Result_of_impl<false, true, _MemPtr, _Arg, _ArgTypes...>
    : _Result_of_memfun<typename remove_reference<_MemPtr>::type, _Arg,
                        _ArgTypes...>
    {
      typedef typename _Result_of_memfun<
 typename remove_reference<_MemPtr>::type, _Arg, _ArgTypes...>::__type
 __type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : _Result_of_impl<is_member_object_pointer<
                        typename remove_reference<_Functor>::type >::value,
                      is_member_function_pointer<
   typename remove_reference<_Functor>::type >::value,
        _Functor, _ArgTypes...>
    {
      typedef typename _Result_of_impl<
 is_member_object_pointer<
   typename remove_reference<_Functor>::type >::value,
        is_member_function_pointer<
   typename remove_reference<_Functor>::type >::value,
        _Functor, _ArgTypes...>::__type
 type;
    };
# 1903 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/type_traits" 3

}
# 58 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 75 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 3
  template<typename _Tp>
    inline typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 134 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



}
# 150 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 165 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{




  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;



  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }







      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<class _U1, class = typename
        enable_if<is_convertible<_U1, _T1>::value>::type>
 constexpr pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        enable_if<is_convertible<_U2, _T2>::value>::type>
 constexpr pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
        && noexcept(swap(second, __p.second)))
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 265 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }








}
# 73 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 2 3



# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/initializer_list" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/initializer_list" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
  };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/utility" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<class _Tp>
    class tuple_size;

  template<std::size_t _Int, class _Tp>
    class tuple_element;


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };

  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };

  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }


}
# 4 "../../dist/system_wrappers/utility" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/utility" 2 3
#pragma GCC visibility pop
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/algorithm" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 1 3
# 61 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functexcept.h" 1 3
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cpp_type_traits.h" 1 3
# 36 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cpp_type_traits.h" 3
       
# 37 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cpp_type_traits.h" 3
# 69 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/type_traits.h" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/type_traits.h" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/numeric_traits.h" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/numeric_traits.h" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 65 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 1 3
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 3
       
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 117 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 3
template<typename _Tp> class __has_iterator_category_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::iterator_category>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_iterator_category : integral_constant<bool, __has_iterator_category_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Iterator,
    bool = __has_iterator_category<_Iterator>::value>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator, true>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 175 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
# 67 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_funcs.h" 3
       
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 170 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
# 68 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 1 3
# 69 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 97 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 161 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 291 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 403 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 437 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 479 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 494 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 527 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 569 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 588 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 639 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 683 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 707 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 805 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 931 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;
      typedef value_type&& reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return std::move(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }




}
# 69 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/debug/debug.h" 1 3
# 47 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 71 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = std::move(*__a);
          *__a = std::move(*__b);
          *__b = std::move(__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 116 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 157 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 185 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 208 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 231 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 252 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 442 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 475 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 611 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 647 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 713 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 773 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 935 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1021 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1053 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1084 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1118 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1158 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1195 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/algorithm" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 1 3
# 61 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
# 1 "../../dist/stl_wrappers/cstdlib" 1 3
# 18 "../../dist/stl_wrappers/cstdlib" 3
       
# 19 "../../dist/stl_wrappers/cstdlib" 3
# 33 "../../dist/stl_wrappers/cstdlib" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/cstdlib" 2 3
# 54 "../../dist/stl_wrappers/cstdlib" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/cstdlib" 1 3
       
# 2 "../../dist/system_wrappers/cstdlib" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 3
# 66 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 3
# 1 "../../dist/system_wrappers/stdlib.h" 1 3
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 67 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 2 3
# 98 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



}
# 160 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 195 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



namespace std
{


  using std::lldiv_t;


  using std::llabs;
  using std::lldiv;


  using std::atoll;
  using std::strtoll;
  using std::strtoull;

  using std::strtof;
  using std::strtold;


  using std::abs;

  using std::div;

}
# 4 "../../dist/system_wrappers/cstdlib" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/cstdlib" 2 3
#pragma GCC visibility pop
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/algorithmfwd.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/algorithmfwd.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/algorithmfwd.h" 3
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 194 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 535 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    ;

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    ;

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 1 3
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 155 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 205 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value));
    }
# 280 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 355 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
# 379 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 419 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 458 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 487 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 516 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;

      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last));
    }
# 542 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;

      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last),
         __comp);
    }
# 564 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 577 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_tempbuf.h" 1 3
# 62 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_tempbuf.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_construct.h" 1 3
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_construct.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/alloc_traits.h" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/alloc_traits.h" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/alloc_traits.h" 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 1 3
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/ptr_traits.h" 1 3
# 37 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp> class __has_element_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::element_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_element_type : integral_constant<bool, __has_element_type_helper <typename remove_cv<_Tp>::type>::value> { };
template<typename _Tp> class __has_difference_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::difference_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_difference_type : integral_constant<bool, __has_difference_type_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Tp, bool = __has_element_type<_Tp>::value>
    struct __ptrtr_elt_type;

  template<typename _Tp>
    struct __ptrtr_elt_type<_Tp, true>
    {
      typedef typename _Tp::element_type __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Tp,
            typename... _Args>
    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>
    {
      typedef _Tp __type;
    };

  template<typename _Tp, bool = __has_difference_type<_Tp>::value>
    struct __ptrtr_diff_type
    {
      typedef typename _Tp::difference_type __type;
    };

  template<typename _Tp>
    struct __ptrtr_diff_type<_Tp, false>
    {
      typedef ptrdiff_t __type;
    };

  template<typename _Ptr, typename _Up>
    class __ptrtr_rebind_helper
    {
      template<typename _Ptr2, typename _Up2>
 static constexpr bool
        _S_chk(typename _Ptr2::template rebind<_Up2>*)
        { return true; }

      template<typename, typename>
        static constexpr bool
        _S_chk(...)
        { return false; }

    public:
      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);
    };

  template<typename _Ptr, typename _Up>
    const bool __ptrtr_rebind_helper<_Ptr, _Up>::__value;

  template<typename _Tp, typename _Up,
           bool = __ptrtr_rebind_helper<_Tp, _Up>::__value>
    struct __ptrtr_rebind;

  template<typename _Tp, typename _Up>
    struct __ptrtr_rebind<_Tp, _Up, true>
    {
      typedef typename _Tp::template rebind<_Up> __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Up,
            typename _Tp, typename... _Args>
    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false>
    {
      typedef _SomePtr<_Up, _Args...> __type;
    };

  template<typename _Tp, typename = typename remove_cv<_Tp>::type>
    struct __ptrtr_not_void
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __ptrtr_not_void<_Tp, void>
    {
      struct __type { };
    };

  template<typename _Ptr>
    class __ptrtr_pointer_to
    {
      typedef typename __ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;

    public:
      static _Ptr pointer_to(__element_type& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptrtr_pointer_to<_Ptr>
    {

      typedef _Ptr pointer;

      typedef typename __ptrtr_elt_type<_Ptr>::__type element_type;

      typedef typename __ptrtr_diff_type<_Ptr>::__type difference_type;

      template<typename _Up>
        using rebind = typename __ptrtr_rebind<_Ptr, _Up>::__type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r) noexcept
      { return std::addressof(__r); }
    };


}
# 36 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc, typename _Tp>
    class __alloctr_rebind_helper
    {
      template<typename _Alloc2, typename _Tp2>
 static constexpr bool
        _S_chk(typename _Alloc2::template rebind<_Tp2>::other*)
 { return true; }

      template<typename, typename>
        static constexpr bool
        _S_chk(...)
        { return false; }

    public:
      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);
    };

  template<typename _Alloc, typename _Tp>
    const bool __alloctr_rebind_helper<_Alloc, _Tp>::__value;

  template<typename _Alloc, typename _Tp,
           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>
    struct __alloctr_rebind;

  template<typename _Alloc, typename _Tp>
    struct __alloctr_rebind<_Alloc, _Tp, true>
    {
      typedef typename _Alloc::template rebind<_Tp>::other __type;
    };

  template<template<typename, typename...> class _Alloc, typename _Tp,
            typename _Up, typename... _Args>
    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>
    {
      typedef _Alloc<_Tp, _Args...> __type;
    };





  template<typename _Alloc>
    struct allocator_traits
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;
# 99 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
private: template<typename _Tp> static typename _Tp::pointer _S_pointer_helper(_Tp*); static value_type* _S_pointer_helper(...); typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer; public:






      typedef __pointer pointer;

private: template<typename _Tp> static typename _Tp::const_pointer
 _S_const_pointer_helper
# 108 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static typename pointer_traits<pointer>::template rebind<const value_type>
 _S_const_pointer_helper
# 108 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_const_pointer_helper
# 108 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __const_pointer
# 108 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 117 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __const_pointer const_pointer;

private: template<typename _Tp> static typename _Tp::void_pointer
 _S_void_pointer_helper
# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static typename pointer_traits<pointer>::template rebind<void>
 _S_void_pointer_helper
# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_void_pointer_helper
# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __void_pointer
# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 128 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __void_pointer void_pointer;

private: template<typename _Tp> static typename _Tp::const_void_pointer
 _S_const_void_pointer_helper
# 130 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static typename pointer_traits<pointer>::template rebind<const void>
 _S_const_void_pointer_helper
# 130 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_const_void_pointer_helper
# 130 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __const_void_pointer
# 130 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 139 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __const_void_pointer const_void_pointer;

private: template<typename _Tp> static typename _Tp::difference_type
 _S_difference_type_helper
# 141 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static typename pointer_traits<pointer>::difference_type
 _S_difference_type_helper
# 141 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_difference_type_helper
# 141 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __difference_type
# 141 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 150 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __difference_type difference_type;

private: template<typename _Tp> static typename _Tp::size_type
 _S_size_type_helper
# 152 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static typename make_unsigned<difference_type>::type
 _S_size_type_helper
# 152 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_size_type_helper
# 152 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __size_type
# 152 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 161 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __size_type size_type;

private: template<typename _Tp> static typename _Tp::propagate_on_container_copy_assignment
 _S_propagate_on_container_copy_assignment_helper
# 163 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static false_type
 _S_propagate_on_container_copy_assignment_helper
# 163 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_propagate_on_container_copy_assignment_helper
# 163 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __propagate_on_container_copy_assignment
# 163 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 172 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __propagate_on_container_copy_assignment
        propagate_on_container_copy_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_move_assignment
 _S_propagate_on_container_move_assignment_helper
# 175 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static false_type
 _S_propagate_on_container_move_assignment_helper
# 175 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_propagate_on_container_move_assignment_helper
# 175 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __propagate_on_container_move_assignment
# 175 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 184 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __propagate_on_container_move_assignment
        propagate_on_container_move_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_swap
 _S_propagate_on_container_swap_helper
# 187 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (_Tp*); static false_type
 _S_propagate_on_container_swap_helper
# 187 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 (...); typedef decltype(
 _S_propagate_on_container_swap_helper
# 187 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ((_Alloc*)0))
 __propagate_on_container_swap
# 187 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
 ; public:
# 196 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      typedef __propagate_on_container_swap propagate_on_container_swap;



      template<typename _Tp>
        using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;
      template<typename _Tp>
        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 struct __allocate_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->allocate(
    std::declval<size_type>(),
    std::declval<const_void_pointer>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Alloc2>
 static typename
        enable_if<__allocate_helper<_Alloc2>::value, pointer>::type
        _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static typename
        enable_if<!__allocate_helper<_Alloc2>::value, pointer>::type
        _S_allocate(_Alloc2& __a, size_type __n, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Tp, typename... _Args>
 static typename
        enable_if<__construct_helper<_Tp, _Args...>::value, void>::type
        _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static typename
        enable_if<!__construct_helper<_Tp, _Args...>::value, void>::type
        _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Tp>
 struct __destroy_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->destroy(
    std::declval<_Tp*>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Tp>
 static typename enable_if<__destroy_helper<_Tp>::value, void>::type
        _S_destroy(_Alloc& __a, _Tp* __p)
 { __a.destroy(__p); }

      template<typename _Tp>
 static typename enable_if<!__destroy_helper<_Tp>::value, void>::type
        _S_destroy(_Alloc&, _Tp* __p)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 struct __maxsize_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->max_size())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc2>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Alloc2>
 static typename
        enable_if<__maxsize_helper<_Alloc2>::value, size_type>::type
        _S_max_size(_Alloc2& __a)
 { return __a.max_size(); }

      template<typename _Alloc2>
 static typename
        enable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type
 _S_max_size(_Alloc2&)
 { return __gnu_cxx::__numeric_traits<size_type>::__max; }

      template<typename _Alloc2>
 struct __select_helper
 {
   template<typename _Alloc3, typename
     = decltype(std::declval<_Alloc3*>()
  ->select_on_container_copy_construction())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc2>(0)) type;
   static const bool value = type::value;
 };
      template<typename _Alloc2>
 static typename
        enable_if<__select_helper<_Alloc2>::value, _Alloc2>::type
        _S_select(_Alloc2& __a)
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static typename
        enable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type
        _S_select(_Alloc2& __a)
 { return __a; }

    public:
# 347 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 362 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint); }
# 374 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      static void deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 388 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static void construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 400 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      template <class _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p); }
# 412 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a)
      { return _S_max_size(__a); }
# 423 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs); }
    };

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__allocate_helper<_Alloc2>::value;

  template<typename _Alloc>
  template<typename _Tp, typename... _Args>
    const bool
    allocator_traits<_Alloc>::__construct_helper<_Tp, _Args...>::value;

  template<typename _Alloc>
  template<typename _Tp>
    const bool allocator_traits<_Alloc>::__destroy_helper<_Tp>::value;

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__maxsize_helper<_Alloc2>::value;

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__select_helper<_Alloc2>::value;

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }


}
# 36 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/alloc_traits.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename> struct allocator;

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocator_always_compares_equal
    { static const bool value = false; };

  template<typename _Alloc>
    const bool __allocator_always_compares_equal<_Alloc>::value;

  template<typename _Tp>
    struct __allocator_always_compares_equal<std::allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<std::allocator<_Tp>>::value;

  template<typename, typename> struct array_allocator;

  template<typename _Tp, typename _Array>
    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
    { static const bool value = true; };

  template<typename _Tp, typename _Array>
    const bool
    __allocator_always_compares_equal<array_allocator<_Tp, _Array>>::value;

  template<typename> struct mt_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<mt_allocator<_Tp>>::value;

  template<typename> struct new_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<new_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<new_allocator<_Tp>>::value;

  template<typename> struct pool_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<pool_allocator<_Tp>>::value;






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      struct __is_custom_pointer
      : std::integral_constant<bool, std::is_same<pointer, _Ptr>::value
                                     && !std::is_pointer<_Ptr>::value>
      { };

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return __allocator_always_compares_equal<_Alloc>::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    static constexpr bool _S_nothrow_swap()
    {
      using std::swap;
      return !_S_propagate_on_swap()
        || noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 223 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/alloc_traits.h" 3
  };


}
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 92 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 85 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 112 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator __first, _ForwardIterator __last,
       _Tp& __value)
        {
   if(__first == __last)
     return;

   _ForwardIterator __cur = __first;
   if (true)
     {
       std::_Construct(std::__addressof(*__first),
         std::move(__value));
       _ForwardIterator __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       __value = std::move(*__prev);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator, _ForwardIterator, _Tp&) { }
    };
# 231 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_tempbuf.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_construct_buf(_ForwardIterator __first,
      _ForwardIterator __last,
      _Tp& __value)
    {
      typedef typename std::iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __value);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      if (true)
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if(_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            *__first);
 }
      if (false)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   ;
 }
    }


}
# 65 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 2 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 3





# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3




# 1 "../../dist/system_wrappers/math.h" 1 3
       
# 2 "../../dist/system_wrappers/math.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/math.h" 2 3 4

extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/mathdef.h" 2 3 4




typedef float float_t;
typedef double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void
 sincosf
# 82 "/usr/include/bits/mathcalls.h" 3 4
 (float __x, float *__sinx, float *__cosx) throw (); extern void
 __sincosf
# 82 "/usr/include/bits/mathcalls.h" 3 4
 (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 141 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void
 sincosl
# 82 "/usr/include/bits/mathcalls.h" 3 4
 (long double __x, long double *__sinx, long double *__cosx) throw (); extern void
 __sincosl
# 82 "/usr/include/bits/mathcalls.h" 3 4
 (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 142 "/usr/include/math.h" 2 3 4
# 157 "/usr/include/math.h" 3 4
extern int signgam;
# 198 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 291 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 314 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 416 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 25 "/usr/include/bits/mathinline.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/mathinline.h" 2 3 4
# 37 "/usr/include/bits/mathinline.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__signbitf (float __x) throw ()
{




  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return __m & 0x8;

}
extern __inline __attribute__ ((__gnu_inline__)) int
__signbit (double __x) throw ()
{




  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return __m & 0x80;

}
extern __inline __attribute__ ((__gnu_inline__)) int
__signbitl (long double __x) throw ()
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}
# 417 "/usr/include/math.h" 2 3 4
# 472 "/usr/include/math.h" 3 4
}
# 4 "../../dist/system_wrappers/math.h" 2 3
#pragma GCC visibility pop
# 47 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 2 3
# 77 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 434 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 558 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
    FP_SUBNORMAL, FP_ZERO, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
    FP_SUBNORMAL, FP_ZERO, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
    FP_SUBNORMAL, FP_ZERO, __x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? FP_NORMAL : FP_ZERO; }

  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }

  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }

  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }

  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }

  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }

  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }

  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }

  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }

  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 919 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3

}
# 1035 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;


  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }

  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }

  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }

  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }

  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }

  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }

  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }

  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }

  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }

  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }

  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }

  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }

  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }

  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }

  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }


  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }

  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }

  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }

  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }

  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }

  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }

  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }

  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }

  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }

  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }

  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }

  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 2 3
# 1 "../../dist/stl_wrappers/cstdio" 1 3
# 18 "../../dist/stl_wrappers/cstdio" 3
       
# 19 "../../dist/stl_wrappers/cstdio" 3
# 33 "../../dist/stl_wrappers/cstdio" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/cstdio" 2 3
# 54 "../../dist/stl_wrappers/cstdio" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/cstdio" 1 3
       
# 2 "../../dist/system_wrappers/cstdio" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 3


# 1 "../../dist/system_wrappers/stdio.h" 1 3
       
# 2 "../../dist/system_wrappers/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 45 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 2 3
# 95 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 151 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 3
namespace __gnu_cxx
{
# 169 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 4 "../../dist/system_wrappers/cstdio" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/cstdio" 2 3
#pragma GCC visibility pop
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 2 3

# 1 "../../dist/stl_wrappers/string" 1 3
# 18 "../../dist/stl_wrappers/string" 3
       
# 19 "../../dist/stl_wrappers/string" 3
# 33 "../../dist/stl_wrappers/string" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/string" 2 3
# 54 "../../dist/stl_wrappers/string" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/string" 1 3
       
# 2 "../../dist/system_wrappers/string" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 1 3
# 38 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 3
       
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stringfwd.h" 1 3
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stringfwd.h" 3
       
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;

  typedef basic_string<char16_t> u16string;
  typedef basic_string<char32_t> u32string;





}
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 1 3
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 3
       
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 1 3
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3
       
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3

# 1 "../../dist/stl_wrappers/cwchar" 1 3
# 18 "../../dist/stl_wrappers/cwchar" 3
       
# 19 "../../dist/stl_wrappers/cwchar" 3
# 33 "../../dist/stl_wrappers/cwchar" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/cwchar" 2 3
# 54 "../../dist/stl_wrappers/cwchar" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3




# 1 "../../dist/system_wrappers/wchar.h" 1 3
       
# 2 "../../dist/system_wrappers/wchar.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/wchar.h" 1 3 4
# 4 "../../dist/system_wrappers/wchar.h" 2 3
#pragma GCC visibility pop
# 47 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 2 3
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 137 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 259 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 279 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 56 "../../dist/stl_wrappers/cwchar" 2 3
#pragma GCC visibility pop
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 2 3
# 70 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3
  typedef long streamoff;
# 100 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 113 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 135 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 2 3


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 59 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 84 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 228 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdint" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdint" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdint" 3
# 50 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdint" 3
# 1 "../../dist/system_wrappers/stdint.h" 1 3
       
# 2 "../../dist/system_wrappers/stdint.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 51 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdint" 2 3
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cstdint" 3
namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 379 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/allocator.h" 1 3
# 48 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/allocator.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++allocator.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/new_allocator.h" 1 3
# 38 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 53 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 125 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }
# 144 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/allocator.h" 3
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c)
      {
 if (true)
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 if (false)
   { return false; }
      }
    };


  template<typename, typename>
    struct uses_allocator;



}
# 44 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 1 3
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 3
       
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 1 3
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
       
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/clocale" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/clocale" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/clocale" 3


# 1 "../../dist/system_wrappers/locale.h" 1 3
       
# 2 "../../dist/system_wrappers/locale.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/locale.h" 1 3 4
# 26 "/usr/include/locale.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/locale.h" 2 3 4


# 1 "../../dist/system_wrappers/stddef.h" 1 3 4
       
# 2 "../../dist/system_wrappers/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include/stddef.h" 1 3 4
# 4 "../../dist/system_wrappers/stddef.h" 2 3
#pragma GCC visibility pop
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 4 "../../dist/system_wrappers/locale.h" 2 3
#pragma GCC visibility pop
# 45 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/clocale" 2 3
# 53 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 89 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/iosfwd" 1 3
# 38 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/iosfwd" 3
       
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 44 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 2 3
# 1 "../../dist/system_wrappers/cctype" 1 3
       
# 2 "../../dist/system_wrappers/cctype" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cctype" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cctype" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cctype" 3


# 1 "../../dist/system_wrappers/ctype.h" 1 3
       
# 2 "../../dist/system_wrappers/ctype.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 45 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cctype" 2 3
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 4 "../../dist/system_wrappers/cctype" 2 3
#pragma GCC visibility pop
# 45 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 46 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/ostream_insert.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/ostream_insert.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/ostream_insert.h" 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cxxabi_forced.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cxxabi_forced.h" 3
       
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     {
       __out._M_setstate(__ios_base::badbit);
       ;
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 47 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3



# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 1 3
# 61 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 102 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 141 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 205 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 269 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 352 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 423 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity





    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st



    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd



    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 551 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward/binders.h" 1 3
# 60 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 742 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_function.h" 2 3
# 51 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3


# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/range_access.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/range_access.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }


}
# 54 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 1 3
# 39 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
       
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/atomicity.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/atomicity.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr.h" 1 3
# 31 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 150 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr.h" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
# 1 "../../dist/system_wrappers/pthread.h" 1 3
       
# 2 "../../dist/system_wrappers/pthread.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3
# 53 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 140 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 258 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{



  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;




  return __gthread_active_ptr != 0;
}
# 677 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}
# 756 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 828 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}
# 864 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 151 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/atomicity.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 108 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 145 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 170 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 480 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 504 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(__str._M_dataplus)
      {

 __str._M_data(_S_empty_rep()._M_refdata());



      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 528 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string() noexcept
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 561 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 576 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      {

 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_rep()->_M_length; }



      size_type
      length() const noexcept
      { return _M_rep()->_M_length; }


      size_type
      max_size() const noexcept
      { return _Rep::_S_max_size; }
# 736 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 749 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit()
      {
 if (capacity() > size())
   {
     if (true)
       { reserve(0); }
     if (false)
       { }
   }
      }






      size_type
      capacity() const noexcept
      { return _M_rep()->_M_capacity; }
# 793 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 822 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 839 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 860 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 879 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }






      reference
      front()
      { return operator[](0); }





      const_reference
      front() const
      { return operator[](0); }





      reference
      back()
      { return operator[](this->size() - 1); }





      const_reference
      back() const
      { return operator[](this->size() - 1); }
# 928 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str);
# 985 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 1017 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1039 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1075 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
# 1096 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1112 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1124 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1140 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1152 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1181 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1197 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1209 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
# 1229 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1251 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1274 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1292 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1315 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1333 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1358 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1374 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1394 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);







      void
      pop_back()
      { erase(size()-1, 1); }
# 1425 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1447 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1472 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1492 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1516 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1534 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1553 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1574 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1595 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1618 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1689 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1776 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1786 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1796 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_dataplus; }
# 1829 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1842 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 1857 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1874 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 1887 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1904 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1917 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1934 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 1948 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1965 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1978 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1997 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2012 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2029 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2042 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2061 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2075 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2092 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2106 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2123 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2138 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2155 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2169 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2186 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2202 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2221 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2253 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2279 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2297 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2321 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2348 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2360 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 2481 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2527 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2564 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2601 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2638 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2675 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2712 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2730 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2748 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2772 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2790 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}




# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/string_conversions.h" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/string_conversions.h" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/string_conversions.h" 3







# 1 "../../dist/system_wrappers/cerrno" 1 3
       
# 2 "../../dist/system_wrappers/cerrno" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cerrno" 1 3
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cerrno" 3
       
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cerrno" 3

# 1 "../../dist/system_wrappers/errno.h" 1 3
       
# 2 "../../dist/system_wrappers/errno.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/errno.h" 1 3 4
# 29 "/usr/include/errno.h" 3 4
# 1 "../../dist/system_wrappers/features.h" 1 3 4
       
# 2 "../../dist/system_wrappers/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 30 "/usr/include/errno.h" 2 3 4


extern "C" {



# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 47 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 4 "../../dist/system_wrappers/errno.h" 2 3
#pragma GCC visibility pop
# 44 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/cerrno" 2 3
# 4 "../../dist/system_wrappers/cerrno" 2 3
#pragma GCC visibility pop
# 41 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 2815 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }


  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}





# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functional_hash.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functional_hash.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functional_hash.h" 3

# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/hash_bytes.h" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/hash_bytes.h" 3
       
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash : public __hash_base<size_t, _Tp>
    {
      static_assert(sizeof(_Tp) < 0,
      "std::hash is not specialized for this type");
      size_t operator()(const _Tp&) const noexcept;
    };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 85 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };




}
# 3033 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };



}
# 55 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.tcc" 1 3
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.tcc" 3
       
# 43 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     __r->_M_destroy(__a);
     ;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 if (true)
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 if (false)
   {
     __r->_M_destroy(__a);
     ;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 579 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
       ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
       ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 56 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/string" 2 3
# 4 "../../dist/system_wrappers/string" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/string" 2 3
#pragma GCC visibility pop
# 42 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 2 3
# 50 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
# 1 "../../dist/stl_wrappers/vector" 1 3
# 18 "../../dist/stl_wrappers/vector" 3
       
# 19 "../../dist/stl_wrappers/vector" 3
# 33 "../../dist/stl_wrappers/vector" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/vector" 2 3
# 54 "../../dist/stl_wrappers/vector" 3
#pragma GCC visibility push(default)
# 1 "../../dist/system_wrappers/vector" 1 3
       
# 2 "../../dist/system_wrappers/vector" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 1 3
# 59 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 3
       
# 60 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 3




# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 1 3
# 61 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   if (true)
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__result, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 107 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 164 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 218 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur, __alloc);
   ;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 348 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      if (true)
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      if (false)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   ;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_1<__is_trivial(_ValueType)>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline void
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_n_1<__is_trivial(_ValueType)>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
   ;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 647 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 65 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 1 3
# 67 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }


 _Vector_impl(_Tp_alloc_type&& __a)
 : _Tp_alloc_type(std::move(__a)),
   _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }


 void _M_swap_data(_Vector_impl& __x)
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a)
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 207 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 265 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      explicit
      vector(size_type __n)
      : _Base(__n)
      { _M_default_initialize(__n); }
# 278 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 307 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 324 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 361 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 386 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 414 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 426 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x),
                       integral_constant<bool, __move_storage>());
 return *this;
      }
# 448 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 466 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 482 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 503 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 643 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 663 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 695 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 734 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 749 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 764 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 789 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 807 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 854 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      _Tp*



      data() noexcept
      { return std::__addressof(front()); }


      const _Tp*



      data() const noexcept
      { return std::__addressof(front()); }
# 880 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 916 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 936 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 952 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 967 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 984 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      insert(iterator __position, initializer_list<value_type> __l)
      { this->insert(__position, __l.begin(), __l.end()); }
# 1002 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1020 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1045 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1066 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1078 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      void
      swap(vector& __x)

   noexcept(_Alloc_traits::_S_nothrow_swap())

      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   if (true)
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   if (false)
     {
       _M_deallocate(__result, __n);
       ;
     }
 }
# 1130 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }



      void
      _M_default_initialize(size_type __n)
      {
 std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
      _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1204 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1244 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 const vector __tmp(std::move(*this));
 this->_M_impl._M_swap_data(__x._M_impl);
 if (_Alloc_traits::_S_propagate_on_move_assign())
   std::__alloc_on_move(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }

    };
# 1368 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1385 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 66 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_bvector.h" 1 3
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage(0)
 { }

      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = 0;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(_S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 490 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;


    template<typename> friend class hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }


    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x)
    {


      this->clear();
      this->swap(__x);
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }


    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }


    void insert(iterator __p, initializer_list<bool> __l)
    { this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 67 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 2 3



# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/vector.tcc" 1 3
# 60 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__position, std::move(__x_copy));
     }
   else

     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(__position, std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;



   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   if (true)
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = 0;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          if (false)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       ;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 if (true)
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = 0;

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 if (false)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     ;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       if (true)
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       if (false)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    ;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       std::__uninitialized_default_n_a(this->_M_impl._M_finish,
            __n, _M_get_Tp_allocator());
       this->_M_impl._M_finish += __n;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       if (true)
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    std::__uninitialized_default_n_a(__new_finish, __n,
         _M_get_Tp_allocator());
    __new_finish += __n;
  }
       if (false)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    ;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  if (true)
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  if (false)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      ;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
      iterator(__q, 0));
      this->_M_deallocate();
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      if (true)
 {
   _M_reallocate(size());
   return true;
 }
      if (false)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 71 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/vector" 2 3
# 4 "../../dist/system_wrappers/vector" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/vector" 2 3
#pragma GCC visibility pop
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __g);






  namespace __detail
  {
 

    template<typename _UIntType, size_t __w,
      bool = __w < static_cast<size_t>
     (std::numeric_limits<_UIntType>::digits)>
      struct _Shift
      { static const _UIntType __value = 0; };

    template<typename _UIntType, size_t __w>
      struct _Shift<_UIntType, __w, true>
      { static const _UIntType __value = _UIntType(1) << __w; };

    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool>
      struct _Mod;



    template<typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0>
      inline _Tp
      __mod(_Tp __x)
      { return _Mod<_Tp, __m, __a, __c, __m == 0>::__calc(__x); }





    template<typename _Engine, typename _DInputType>
      struct _Adaptor
      {

      public:
 _Adaptor(_Engine& __g)
 : _M_g(__g) { }

 _DInputType
 min() const
 { return _DInputType(0); }

 _DInputType
 max() const
 { return _DInputType(1); }






 _DInputType
 operator()()
 {
   return std::generate_canonical<_DInputType,
                             std::numeric_limits<_DInputType>::digits,
                             _Engine>(_M_g);
 }

      private:
 _Engine& _M_g;
      };

 
  }


# 169 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    class linear_congruential_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(__m == 0u || (__a < __m && __c < __m),
      "template argument substituting __m out of bounds");



      static_assert(__m % __a < __m / __a,
      "sorry, not implemented yet: try a smaller 'a' constant");

    public:

      typedef _UIntType result_type;


      static constexpr result_type multiplier = __a;

      static constexpr result_type increment = __c;

      static constexpr result_type modulus = __m;
      static constexpr result_type default_seed = 1u;
# 201 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      explicit
      linear_congruential_engine(result_type __s = default_seed)
      { seed(__s); }







      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, linear_congruential_engine>::value>
        ::type>
        explicit
        linear_congruential_engine(_Sseq& __q)
        { seed(__q); }







      void
      seed(result_type __s = default_seed);
# 234 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _Sseq>
        typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);







      static constexpr result_type
      min()
      { return __c == 0u ? 1u : 0u; }




      static constexpr result_type
      max()
      { return __m - 1u; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()()
      {
 _M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
 return _M_x;
      }
# 286 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      friend bool
      operator==(const linear_congruential_engine& __lhs,
   const linear_congruential_engine& __rhs)
      { return __lhs._M_x == __rhs._M_x; }
# 299 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::linear_congruential_engine<_UIntType1,
     __a1, __c1, __m1>& __lcr);
# 319 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::linear_congruential_engine<_UIntType1, __a1,
     __c1, __m1>& __lcr);

    private:
      _UIntType _M_x;
    };
# 341 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    inline bool
    operator!=(const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __lhs,
        const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __rhs)
    { return !(__lhs == __rhs); }
# 378 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    class mersenne_twister_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(1u <= __m && __m <= __n,
      "template argument substituting __m out of bounds");
      static_assert(__r <= __w, "template argument substituting "
      "__r out of bound");
      static_assert(__u <= __w, "template argument substituting "
      "__u out of bound");
      static_assert(__s <= __w, "template argument substituting "
      "__s out of bound");
      static_assert(__t <= __w, "template argument substituting "
      "__t out of bound");
      static_assert(__l <= __w, "template argument substituting "
      "__l out of bound");
      static_assert(__w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bound");
      static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __a out of bound");
      static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __b out of bound");
      static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __c out of bound");
      static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __d out of bound");
      static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __f out of bound");

    public:

      typedef _UIntType result_type;


      static constexpr size_t word_size = __w;
      static constexpr size_t state_size = __n;
      static constexpr size_t shift_size = __m;
      static constexpr size_t mask_bits = __r;
      static constexpr result_type xor_mask = __a;
      static constexpr size_t tempering_u = __u;
      static constexpr result_type tempering_d = __d;
      static constexpr size_t tempering_s = __s;
      static constexpr result_type tempering_b = __b;
      static constexpr size_t tempering_t = __t;
      static constexpr result_type tempering_c = __c;
      static constexpr size_t tempering_l = __l;
      static constexpr result_type initialization_multiplier = __f;
      static constexpr result_type default_seed = 5489u;


      explicit
      mersenne_twister_engine(result_type __sd = default_seed)
      { seed(__sd); }







      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
        ::type>
        explicit
        mersenne_twister_engine(_Sseq& __q)
        { seed(__q); }

      void
      seed(result_type __sd = default_seed);

      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);




      static constexpr result_type
      min()
      { return 0; };




      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }

      result_type
      operator()();
# 496 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      friend bool
      operator==(const mersenne_twister_engine& __lhs,
   const mersenne_twister_engine& __rhs)
      { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)
  && __lhs._M_p == __rhs._M_p); }
# 514 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
     __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>& __x);
# 540 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
     __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>& __x);

    private:
      _UIntType _M_x[state_size];
      size_t _M_p;
    };
# 571 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    inline bool
    operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
        const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
    { return !(__lhs == __rhs); }
# 603 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    class subtract_with_carry_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __s && __s < __r,
      "template argument substituting __s out of bounds");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");

    public:

      typedef _UIntType result_type;


      static constexpr size_t word_size = __w;
      static constexpr size_t short_lag = __s;
      static constexpr size_t long_lag = __r;
      static constexpr result_type default_seed = 19780503u;





      explicit
      subtract_with_carry_engine(result_type __sd = default_seed)
      { seed(__sd); }







      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, subtract_with_carry_engine>::value>
        ::type>
        explicit
        subtract_with_carry_engine(_Sseq& __q)
        { seed(__q); }
# 656 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      void
      seed(result_type __sd = default_seed);





      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);





      static constexpr result_type
      min()
      { return 0; }





      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 711 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      friend bool
      operator==(const subtract_with_carry_engine& __lhs,
   const subtract_with_carry_engine& __rhs)
      { return (std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x)
  && __lhs._M_carry == __rhs._M_carry
  && __lhs._M_p == __rhs._M_p); }
# 730 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>&);
# 749 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>&);

    private:
      _UIntType _M_x[long_lag];
      _UIntType _M_carry;
      size_t _M_p;
    };
# 774 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    inline bool
    operator!=(const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __lhs,
        const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __rhs)
    { return !(__lhs == __rhs); }
# 789 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    class discard_block_engine
    {
      static_assert(1 <= __r && __r <= __p,
      "template argument substituting __r out of bounds");

    public:

      typedef typename _RandomNumberEngine::result_type result_type;


      static constexpr size_t block_size = __p;
      static constexpr size_t used_block = __r;






      discard_block_engine()
      : _M_b(), _M_n(0) { }







      explicit
      discard_block_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng), _M_n(0) { }







      explicit
      discard_block_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng)), _M_n(0) { }







      explicit
      discard_block_engine(result_type __s)
      : _M_b(__s), _M_n(0) { }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, discard_block_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        discard_block_engine(_Sseq& __q)
 : _M_b(__q), _M_n(0)
        { }





      void
      seed()
      {
 _M_b.seed();
 _M_n = 0;
      }





      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_n = 0;
      }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_n = 0;
 }





      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return _RandomNumberEngine::min(); }




      static constexpr result_type
      max()
      { return _RandomNumberEngine::max(); }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 939 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      friend bool
      operator==(const discard_block_engine& __lhs,
   const discard_block_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b && __lhs._M_n == __rhs._M_n; }
# 955 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>& __x);
# 973 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>& __x);

    private:
      _RandomNumberEngine _M_b;
      size_t _M_n;
    };
# 996 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    inline bool
    operator!=(const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __lhs,
        const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __rhs)
    { return !(__lhs == __rhs); }






  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    class independent_bits_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");

    public:

      typedef _UIntType result_type;






      independent_bits_engine()
      : _M_b() { }







      explicit
      independent_bits_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng) { }







      explicit
      independent_bits_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng)) { }







      explicit
      independent_bits_engine(result_type __s)
      : _M_b(__s) { }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, independent_bits_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
               ::type>
        explicit
        independent_bits_engine(_Sseq& __q)
        : _M_b(__q)
        { }





      void
      seed()
      { _M_b.seed(); }





      void
      seed(result_type __s)
      { _M_b.seed(__s); }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        { _M_b.seed(__q); }





      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return 0U; }




      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 1149 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      friend bool
      operator==(const independent_bits_engine& __lhs,
   const independent_bits_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b; }
# 1166 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::independent_bits_engine<_RandomNumberEngine,
     __w, _UIntType>& __x)
 {
   __is >> __x._M_b;
   return __is;
 }

    private:
      _RandomNumberEngine _M_b;
    };
# 1192 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    inline bool
    operator!=(const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __lhs,
        const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __rhs)
    { return !(__lhs == __rhs); }
# 1210 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::independent_bits_engine<_RandomNumberEngine,
        __w, _UIntType>& __x)
    {
      __os << __x.base();
      return __os;
    }







  template<typename _RandomNumberEngine, size_t __k>
    class shuffle_order_engine
    {
      static_assert(1u <= __k, "template argument substituting "
      "__k out of bound");

    public:

      typedef typename _RandomNumberEngine::result_type result_type;

      static constexpr size_t table_size = __k;






      shuffle_order_engine()
      : _M_b()
      { _M_initialize(); }







      explicit
      shuffle_order_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng)
      { _M_initialize(); }







      explicit
      shuffle_order_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng))
      { _M_initialize(); }







      explicit
      shuffle_order_engine(result_type __s)
      : _M_b(__s)
      { _M_initialize(); }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, shuffle_order_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        shuffle_order_engine(_Sseq& __q)
        : _M_b(__q)
        { _M_initialize(); }





      void
      seed()
      {
 _M_b.seed();
 _M_initialize();
      }





      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_initialize();
      }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_initialize();
 }




      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return _RandomNumberEngine::min(); }




      static constexpr result_type
      max()
      { return _RandomNumberEngine::max(); }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 1378 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      friend bool
      operator==(const shuffle_order_engine& __lhs,
   const shuffle_order_engine& __rhs)
      { return (__lhs._M_b == __rhs._M_b
  && std::equal(__lhs._M_v, __lhs._M_v + __k, __rhs._M_v)
  && __lhs._M_y == __rhs._M_y); }
# 1396 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::shuffle_order_engine<_RandomNumberEngine1,
     __k1>& __x);
# 1414 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::shuffle_order_engine<_RandomNumberEngine1, __k1>& __x);

    private:
      void _M_initialize()
      {
 for (size_t __i = 0; __i < __k; ++__i)
   _M_v[__i] = _M_b();
 _M_y = _M_b();
      }

      _RandomNumberEngine _M_b;
      result_type _M_v[__k];
      result_type _M_y;
    };
# 1444 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __k>
    inline bool
    operator!=(const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __lhs,
        const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __rhs)
    { return !(__lhs == __rhs); }





  typedef linear_congruential_engine<uint_fast32_t, 16807UL, 0UL, 2147483647UL>
  minstd_rand0;




  typedef linear_congruential_engine<uint_fast32_t, 48271UL, 0UL, 2147483647UL>
  minstd_rand;
# 1473 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  typedef mersenne_twister_engine<
    uint_fast32_t,
    32, 624, 397, 31,
    0x9908b0dfUL, 11,
    0xffffffffUL, 7,
    0x9d2c5680UL, 15,
    0xefc60000UL, 18, 1812433253UL> mt19937;




  typedef mersenne_twister_engine<
    uint_fast64_t,
    64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29,
    0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37,
    0xfff7eee000000000ULL, 43,
    6364136223846793005ULL> mt19937_64;

  typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>
    ranlux24_base;

  typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>
    ranlux48_base;

  typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;

  typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;

  typedef shuffle_order_engine<minstd_rand0, 256> knuth_b;

  typedef minstd_rand0 default_random_engine;





  class random_device
  {
  public:

    typedef unsigned int result_type;





    explicit
    random_device(const std::string& __token = "/dev/urandom")
    {
      if ((__token != "/dev/urandom" && __token != "/dev/random")
   || !(_M_file = std::fopen(__token.c_str(), "rb")))
 std::__throw_runtime_error(("random_device::" "random_device(const std::string&)")
                                               );
    }

    ~random_device()
    { std::fclose(_M_file); }
# 1560 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
    static constexpr result_type
    min()
    { return std::numeric_limits<result_type>::min(); }

    static constexpr result_type
    max()
    { return std::numeric_limits<result_type>::max(); }

    double
    entropy() const noexcept
    { return 0.0; }

    result_type
    operator()()
    {

      result_type __ret;
      std::fread(reinterpret_cast<void*>(&__ret), sizeof(result_type),
   1, _M_file);
      return __ret;



    }


    random_device(const random_device&) = delete;
    void operator=(const random_device&) = delete;

  private:


    FILE* _M_file;



  };
# 1617 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator==(const std::uniform_int_distribution<_IntType>& __d1,
        const std::uniform_int_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_int_distribution<_IntType>& __d1,
        const std::uniform_int_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 1762 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_int_distribution<_IntType>&);
# 1776 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_int_distribution<_IntType>&);
# 1789 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class uniform_real_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef uniform_real_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

    public:






      explicit
      uniform_real_distribution(_RealType __a = _RealType(0),
    _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      uniform_real_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return (__aurng() * (__p.b() - __p.a())) + __p.a();
 }

    private:
      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator==(const std::uniform_real_distribution<_IntType>& __d1,
        const std::uniform_real_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_real_distribution<_IntType>& __d1,
        const std::uniform_real_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 1943 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_real_distribution<_RealType>&);
# 1957 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_real_distribution<_RealType>&);
# 1979 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class normal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef normal_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __mean = _RealType(0),
     _RealType __stddev = _RealType(1))
 : _M_mean(__mean), _M_stddev(__stddev)
 {
   ;
 }

 _RealType
 mean() const
 { return _M_mean; }

 _RealType
 stddev() const
 { return _M_stddev; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_mean == __p2._M_mean
    && __p1._M_stddev == __p2._M_stddev); }

      private:
 _RealType _M_mean;
 _RealType _M_stddev;
      };

    public:




      explicit
      normal_distribution(result_type __mean = result_type(0),
     result_type __stddev = result_type(1))
      : _M_param(__mean, __stddev), _M_saved_available(false)
      { }

      explicit
      normal_distribution(const param_type& __p)
      : _M_param(__p), _M_saved_available(false)
      { }




      void
      reset()
      { _M_saved_available = false; }




      _RealType
      mean() const
      { return _M_param.mean(); }




      _RealType
      stddev() const
      { return _M_param.stddev(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);






      template<typename _RealType1>
 friend bool
        operator==(const std::normal_distribution<_RealType1>& __d1,
     const std::normal_distribution<_RealType1>& __d2);
# 2118 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::normal_distribution<_RealType1>& __x);
# 2133 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::normal_distribution<_RealType1>& __x);

    private:
      param_type _M_param;
      result_type _M_saved;
      bool _M_saved_available;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2163 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class lognormal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef lognormal_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __m = _RealType(0),
     _RealType __s = _RealType(1))
 : _M_m(__m), _M_s(__s)
 { }

 _RealType
 m() const
 { return _M_m; }

 _RealType
 s() const
 { return _M_s; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_s == __p2._M_s; }

      private:
 _RealType _M_m;
 _RealType _M_s;
      };

      explicit
      lognormal_distribution(_RealType __m = _RealType(0),
        _RealType __s = _RealType(1))
      : _M_param(__m, __s), _M_nd()
      { }

      explicit
      lognormal_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _RealType
      m() const
      { return _M_param.m(); }

      _RealType
      s() const
      { return _M_param.s(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        { return std::exp(__p.s() * _M_nd(__urng) + __p.m()); }






      friend bool
      operator==(const lognormal_distribution& __d1,
   const lognormal_distribution& __d2)
      { return (__d1.param() == __d2.param()
  && __d1._M_nd == __d2._M_nd); }
# 2293 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::lognormal_distribution<_RealType1>& __x);
# 2308 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::lognormal_distribution<_RealType1>& __x);

    private:
      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::lognormal_distribution<_RealType>& __d1,
        const std::lognormal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2338 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class gamma_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef gamma_distribution<_RealType> distribution_type;
 friend class gamma_distribution<_RealType>;

 explicit
 param_type(_RealType __alpha_val = _RealType(1),
     _RealType __beta_val = _RealType(1))
 : _M_alpha(__alpha_val), _M_beta(__beta_val)
 {
   ;
   _M_initialize();
 }

 _RealType
 alpha() const
 { return _M_alpha; }

 _RealType
 beta() const
 { return _M_beta; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_alpha == __p2._M_alpha
    && __p1._M_beta == __p2._M_beta); }

      private:
 void
 _M_initialize();

 _RealType _M_alpha;
 _RealType _M_beta;

 _RealType _M_malpha, _M_a2;
      };

    public:




      explicit
      gamma_distribution(_RealType __alpha_val = _RealType(1),
    _RealType __beta_val = _RealType(1))
      : _M_param(__alpha_val, __beta_val), _M_nd()
      { }

      explicit
      gamma_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _RealType
      alpha() const
      { return _M_param.alpha(); }




      _RealType
      beta() const
      { return _M_param.beta(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);






      friend bool
      operator==(const gamma_distribution& __d1,
   const gamma_distribution& __d2)
      { return (__d1.param() == __d2.param()
  && __d1._M_nd == __d2._M_nd); }
# 2485 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::gamma_distribution<_RealType1>& __x);
# 2499 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::gamma_distribution<_RealType1>& __x);

    private:
      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
    };




   template<typename _RealType>
    inline bool
     operator!=(const std::gamma_distribution<_RealType>& __d1,
  const std::gamma_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2526 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class chi_squared_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef chi_squared_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_n;
      };

      explicit
      chi_squared_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_gd(__n / 2)
      { }

      explicit
      chi_squared_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.n() / 2)
      { }




      void
      reset()
      { _M_gd.reset(); }




      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return 2 * _M_gd(__urng); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return 2 * _M_gd(__urng, param_type(__p.n() / 2));
 }






      friend bool
      operator==(const chi_squared_distribution& __d1,
   const chi_squared_distribution& __d2)
      { return __d1.param() == __d2.param() && __d1._M_gd == __d2._M_gd; }
# 2648 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::chi_squared_distribution<_RealType1>& __x);
# 2663 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::chi_squared_distribution<_RealType1>& __x);

    private:
      param_type _M_param;

      std::gamma_distribution<result_type> _M_gd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::chi_squared_distribution<_RealType>& __d1,
        const std::chi_squared_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2690 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class cauchy_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef cauchy_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      cauchy_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      cauchy_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }

      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

    private:
      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator==(const std::cauchy_distribution<_RealType>& __d1,
        const std::cauchy_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _RealType>
    inline bool
    operator!=(const std::cauchy_distribution<_RealType>& __d1,
        const std::cauchy_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2832 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::cauchy_distribution<_RealType>& __x);
# 2847 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::cauchy_distribution<_RealType>& __x);
# 2863 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class fisher_f_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef fisher_f_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __m = _RealType(1),
     _RealType __n = _RealType(1))
 : _M_m(__m), _M_n(__n)
 { }

 _RealType
 m() const
 { return _M_m; }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_m;
 _RealType _M_n;
      };

      explicit
      fisher_f_distribution(_RealType __m = _RealType(1),
       _RealType __n = _RealType(1))
      : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)
      { }

      explicit
      fisher_f_distribution(const param_type& __p)
      : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)
      { }




      void
      reset()
      {
 _M_gd_x.reset();
 _M_gd_y.reset();
      }




      _RealType
      m() const
      { return _M_param.m(); }

      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return (_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return ((_M_gd_x(__urng, param_type(__p.m() / 2)) * n())
    / (_M_gd_y(__urng, param_type(__p.n() / 2)) * m()));
 }






      friend bool
      operator==(const fisher_f_distribution& __d1,
   const fisher_f_distribution& __d2)
      { return (__d1.param() == __d2.param()
  && __d1._M_gd_x == __d2._M_gd_x
  && __d1._M_gd_y == __d2._M_gd_y); }
# 3002 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::fisher_f_distribution<_RealType1>& __x);
# 3017 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::fisher_f_distribution<_RealType1>& __x);

    private:
      param_type _M_param;

      std::gamma_distribution<result_type> _M_gd_x, _M_gd_y;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::fisher_f_distribution<_RealType>& __d1,
        const std::fisher_f_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 3046 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class student_t_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef student_t_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_n;
      };

      explicit
      student_t_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)
      { }

      explicit
      student_t_distribution(const param_type& __p)
      : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)
      { }




      void
      reset()
      {
 _M_nd.reset();
 _M_gd.reset();
      }




      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng)
        { return _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng)); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;

   const result_type __g = _M_gd(__urng, param_type(__p.n() / 2, 2));
   return _M_nd(__urng) * std::sqrt(__p.n() / __g);
        }






      friend bool
      operator==(const student_t_distribution& __d1,
   const student_t_distribution& __d2)
      { return (__d1.param() == __d2.param()
  && __d1._M_nd == __d2._M_nd && __d1._M_gd == __d2._M_gd); }
# 3174 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::student_t_distribution<_RealType1>& __x);
# 3189 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::student_t_distribution<_RealType1>& __x);

    private:
      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
      std::gamma_distribution<result_type> _M_gd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::student_t_distribution<_RealType>& __d1,
        const std::student_t_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 3225 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  class bernoulli_distribution
  {
  public:

    typedef bool result_type;

    struct param_type
    {
      typedef bernoulli_distribution distribution_type;

      explicit
      param_type(double __p = 0.5)
      : _M_p(__p)
      {
 ;
      }

      double
      p() const
      { return _M_p; }

      friend bool
      operator==(const param_type& __p1, const param_type& __p2)
      { return __p1._M_p == __p2._M_p; }

    private:
      double _M_p;
    };

  public:






    explicit
    bernoulli_distribution(double __p = 0.5)
    : _M_param(__p)
    { }

    explicit
    bernoulli_distribution(const param_type& __p)
    : _M_param(__p)
    { }






    void
    reset() { }




    double
    p() const
    { return _M_param.p(); }




    param_type
    param() const
    { return _M_param; }





    void
    param(const param_type& __param)
    { _M_param = __param; }




    result_type
    min() const
    { return std::numeric_limits<result_type>::min(); }




    result_type
    max() const
    { return std::numeric_limits<result_type>::max(); }




    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng)
      { return this->operator()(__urng, this->param()); }

    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 if ((__aurng() - __aurng.min())
      < __p.p() * (__aurng.max() - __aurng.min()))
   return true;
 return false;
      }

  private:
    param_type _M_param;
  };





  inline bool
  operator==(const std::bernoulli_distribution& __d1,
      const std::bernoulli_distribution& __d2)
  { return __d1.param() == __d2.param(); }





  inline bool
  operator!=(const std::bernoulli_distribution& __d1,
      const std::bernoulli_distribution& __d2)
  { return !(__d1 == __d2); }
# 3368 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::bernoulli_distribution& __x);
# 3382 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::bernoulli_distribution& __x)
    {
      double __p;
      __is >> __p;
      __x.param(bernoulli_distribution::param_type(__p));
      return __is;
    }
# 3401 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType = int>
    class binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef binomial_distribution<_IntType> distribution_type;
 friend class binomial_distribution<_IntType>;

 explicit
 param_type(_IntType __t = _IntType(1), double __p = 0.5)
 : _M_t(__t), _M_p(__p)
 {
  

                     ;
   _M_initialize();
 }

 _IntType
 t() const
 { return _M_t; }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p; }

      private:
 void
 _M_initialize();

 _IntType _M_t;
 double _M_p;

 double _M_q;

 double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,
        _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;

 bool _M_easy;
      };


      explicit
      binomial_distribution(_IntType __t = _IntType(1),
       double __p = 0.5)
      : _M_param(__t, __p), _M_nd()
      { }

      explicit
      binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _IntType
      t() const
      { return _M_param.t(); }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return _M_param.t(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);






 friend bool
        operator==(const binomial_distribution& __d1,
     const binomial_distribution& __d2)

 { return __d1.param() == __d2.param() && __d1._M_nd == __d2._M_nd; }
# 3552 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::binomial_distribution<_IntType1>& __x);
# 3568 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::binomial_distribution<_IntType1>& __x);

    private:
      template<typename _UniformRandomNumberGenerator>
 result_type
 _M_waiting(_UniformRandomNumberGenerator& __urng, _IntType __t);

      param_type _M_param;


      std::normal_distribution<double> _M_nd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::binomial_distribution<_IntType>& __d1,
        const std::binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 3602 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType = int>
    class geometric_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef geometric_distribution<_IntType> distribution_type;
 friend class geometric_distribution<_IntType>;

 explicit
 param_type(double __p = 0.5)
 : _M_p(__p)
 {
   ;
   _M_initialize();
 }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_p == __p2._M_p; }

      private:
 void
 _M_initialize()
 { _M_log_1_p = std::log(1.0 - _M_p); }

 double _M_p;

 double _M_log_1_p;
      };


      explicit
      geometric_distribution(double __p = 0.5)
      : _M_param(__p)
      { }

      explicit
      geometric_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

    private:
      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator==(const std::geometric_distribution<_IntType>& __d1,
        const std::geometric_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _IntType>
    inline bool
    operator!=(const std::geometric_distribution<_IntType>& __d1,
        const std::geometric_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 3745 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::geometric_distribution<_IntType>& __x);
# 3760 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::geometric_distribution<_IntType>& __x);
# 3774 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType = int>
    class negative_binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef negative_binomial_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __k = 1, double __p = 0.5)
 : _M_k(__k), _M_p(__p)
 {
   ;
 }

 _IntType
 k() const
 { return _M_k; }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p; }

      private:
 _IntType _M_k;
 double _M_p;
      };

      explicit
      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)
      { }

      explicit
      negative_binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())
      { }




      void
      reset()
      { _M_gd.reset(); }




      _IntType
      k() const
      { return _M_param.k(); }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng);

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);






      friend bool
      operator==(const negative_binomial_distribution& __d1,
   const negative_binomial_distribution& __d2)
      { return __d1.param() == __d2.param() && __d1._M_gd == __d2._M_gd; }
# 3905 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::negative_binomial_distribution<_IntType1>& __x);
# 3920 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::negative_binomial_distribution<_IntType1>& __x);

    private:
      param_type _M_param;

      std::gamma_distribution<double> _M_gd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::negative_binomial_distribution<_IntType>& __d1,
        const std::negative_binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 3956 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType = int>
    class poisson_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef poisson_distribution<_IntType> distribution_type;
 friend class poisson_distribution<_IntType>;

 explicit
 param_type(double __mean = 1.0)
 : _M_mean(__mean)
 {
   ;
   _M_initialize();
 }

 double
 mean() const
 { return _M_mean; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_mean == __p2._M_mean; }

      private:

 void
 _M_initialize();

 double _M_mean;

 double _M_lm_thr;

 double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;

      };


      explicit
      poisson_distribution(double __mean = 1.0)
      : _M_param(__mean), _M_nd()
      { }

      explicit
      poisson_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      double
      mean() const
      { return _M_param.mean(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);






      friend bool
      operator==(const poisson_distribution& __d1,
   const poisson_distribution& __d2)

      { return __d1.param() == __d2.param() && __d1._M_nd == __d2._M_nd; }
# 4091 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::poisson_distribution<_IntType1>& __x);
# 4106 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::poisson_distribution<_IntType1>& __x);

    private:
      param_type _M_param;


      std::normal_distribution<double> _M_nd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::poisson_distribution<_IntType>& __d1,
        const std::poisson_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 4143 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class exponential_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef exponential_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __lambda = _RealType(1))
 : _M_lambda(__lambda)
 {
   ;
 }

 _RealType
 lambda() const
 { return _M_lambda; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_lambda == __p2._M_lambda; }

      private:
 _RealType _M_lambda;
      };

    public:




      explicit
      exponential_distribution(const result_type& __lambda = result_type(1))
      : _M_param(__lambda)
      { }

      explicit
      exponential_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }




      _RealType
      lambda() const
      { return _M_param.lambda(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return -std::log(__aurng()) / __p.lambda();
 }

    private:
      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator==(const std::exponential_distribution<_RealType>& __d1,
        const std::exponential_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _RealType>
    inline bool
    operator!=(const std::exponential_distribution<_RealType>& __d1,
        const std::exponential_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 4287 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::exponential_distribution<_RealType>& __x);
# 4302 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::exponential_distribution<_RealType>& __x);
# 4317 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class weibull_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef weibull_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(1),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      weibull_distribution(_RealType __a = _RealType(1),
      _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      weibull_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }




      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

    private:
      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator==(const std::weibull_distribution<_RealType>& __d1,
        const std::weibull_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _RealType>
    inline bool
    operator!=(const std::weibull_distribution<_RealType>& __d1,
        const std::weibull_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 4462 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::weibull_distribution<_RealType>& __x);
# 4477 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::weibull_distribution<_RealType>& __x);
# 4492 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class extreme_value_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef extreme_value_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      extreme_value_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      extreme_value_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }




      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

    private:
      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator==(const std::extreme_value_distribution<_RealType>& __d1,
        const std::extreme_value_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _RealType>
    inline bool
    operator!=(const std::extreme_value_distribution<_RealType>& __d1,
        const std::extreme_value_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 4637 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::extreme_value_distribution<_RealType>& __x);
# 4652 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::extreme_value_distribution<_RealType>& __x);
# 4664 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _IntType = int>
    class discrete_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef discrete_distribution<_IntType> distribution_type;
 friend class discrete_distribution<_IntType>;

 param_type()
 : _M_prob(), _M_cp()
 { }

 template<typename _InputIterator>
   param_type(_InputIterator __wbegin,
       _InputIterator __wend)
   : _M_prob(__wbegin, __wend), _M_cp()
   { _M_initialize(); }

 param_type(initializer_list<double> __wil)
 : _M_prob(__wil.begin(), __wil.end()), _M_cp()
 { _M_initialize(); }

 template<typename _Func>
   param_type(size_t __nw, double __xmin, double __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<double>
 probabilities() const
 { return _M_prob.empty() ? std::vector<double>(1, 1.0) : _M_prob; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_prob == __p2._M_prob; }

      private:
 void
 _M_initialize();

 std::vector<double> _M_prob;
 std::vector<double> _M_cp;
      };

      discrete_distribution()
      : _M_param()
      { }

      template<typename _InputIterator>
 discrete_distribution(_InputIterator __wbegin,
         _InputIterator __wend)
 : _M_param(__wbegin, __wend)
 { }

      discrete_distribution(initializer_list<double> __wl)
      : _M_param(__wl)
      { }

      template<typename _Func>
 discrete_distribution(size_t __nw, double __xmin, double __xmax,
         _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      discrete_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<double>
      probabilities() const
      {
 return _M_param._M_prob.empty()
   ? std::vector<double>(1, 1.0) : _M_param._M_prob;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      {
 return _M_param._M_prob.empty()
   ? result_type(0) : result_type(_M_param._M_prob.size() - 1);
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
# 4814 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::discrete_distribution<_IntType1>& __x);
# 4830 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::discrete_distribution<_IntType1>& __x);

    private:
      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator==(const std::discrete_distribution<_IntType>& __d1,
        const std::discrete_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _IntType>
    inline bool
    operator!=(const std::discrete_distribution<_IntType>& __d1,
        const std::discrete_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 4866 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class piecewise_constant_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef piecewise_constant_distribution<_RealType> distribution_type;
 friend class piecewise_constant_distribution<_RealType>;

 param_type()
 : _M_int(), _M_den(), _M_cp()
 { }

 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);

 template<typename _Func>
   param_type(initializer_list<_RealType> __bi, _Func __fw);

 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<_RealType>
 intervals() const
 {
   if (_M_int.empty())
     {
       std::vector<_RealType> __tmp(2);
       __tmp[1] = _RealType(1);
       return __tmp;
     }
   else
     return _M_int;
 }

 std::vector<double>
 densities() const
 { return _M_den.empty() ? std::vector<double>(1, 1.0) : _M_den; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den; }

      private:
 void
 _M_initialize();

 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
      };

      explicit
      piecewise_constant_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_constant_distribution(_InputIteratorB __bfirst,
     _InputIteratorB __bend,
     _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }

      template<typename _Func>
 piecewise_constant_distribution(initializer_list<_RealType> __bl,
     _Func __fw)
 : _M_param(__bl, __fw)
 { }

      template<typename _Func>
 piecewise_constant_distribution(size_t __nw,
     _RealType __xmin, _RealType __xmax,
     _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      piecewise_constant_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<_RealType>
      intervals() const
      {
 if (_M_param._M_int.empty())
   {
     std::vector<_RealType> __tmp(2);
     __tmp[1] = _RealType(1);
     return __tmp;
   }
 else
   return _M_param._M_int;
      }




      std::vector<double>
      densities() const
      {
 return _M_param._M_den.empty()
   ? std::vector<double>(1, 1.0) : _M_param._M_den;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      {
 return _M_param._M_int.empty()
   ? result_type(0) : _M_param._M_int.front();
      }




      result_type
      max() const
      {
 return _M_param._M_int.empty()
   ? result_type(1) : _M_param._M_int.back();
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
# 5053 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::piecewise_constant_distribution<_RealType1>& __x);
# 5069 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::piecewise_constant_distribution<_RealType1>& __x);

    private:
      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator==(const std::piecewise_constant_distribution<_RealType>& __d1,
        const std::piecewise_constant_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_constant_distribution<_RealType>& __d1,
        const std::piecewise_constant_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 5105 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  template<typename _RealType = double>
    class piecewise_linear_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef piecewise_linear_distribution<_RealType> distribution_type;
 friend class piecewise_linear_distribution<_RealType>;

 param_type()
 : _M_int(), _M_den(), _M_cp(), _M_m()
 { }

 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);

 template<typename _Func>
   param_type(initializer_list<_RealType> __bl, _Func __fw);

 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<_RealType>
 intervals() const
 {
   if (_M_int.empty())
     {
       std::vector<_RealType> __tmp(2);
       __tmp[1] = _RealType(1);
       return __tmp;
     }
   else
     return _M_int;
 }

 std::vector<double>
 densities() const
 { return _M_den.empty() ? std::vector<double>(2, 1.0) : _M_den; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_int == __p2._M_int
    && __p1._M_den == __p2._M_den); }

      private:
 void
 _M_initialize();

 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
 std::vector<double> _M_m;
      };

      explicit
      piecewise_linear_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_linear_distribution(_InputIteratorB __bfirst,
          _InputIteratorB __bend,
          _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }

      template<typename _Func>
 piecewise_linear_distribution(initializer_list<_RealType> __bl,
          _Func __fw)
 : _M_param(__bl, __fw)
 { }

      template<typename _Func>
 piecewise_linear_distribution(size_t __nw,
          _RealType __xmin, _RealType __xmax,
          _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      piecewise_linear_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<_RealType>
      intervals() const
      {
 if (_M_param._M_int.empty())
   {
     std::vector<_RealType> __tmp(2);
     __tmp[1] = _RealType(1);
     return __tmp;
   }
 else
   return _M_param._M_int;
      }





      std::vector<double>
      densities() const
      {
 return _M_param._M_den.empty()
   ? std::vector<double>(2, 1.0) : _M_param._M_den;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      {
 return _M_param._M_int.empty()
   ? result_type(0) : _M_param._M_int.front();
      }




      result_type
      max() const
      {
 return _M_param._M_int.empty()
   ? result_type(1) : _M_param._M_int.back();
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
# 5295 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::piecewise_linear_distribution<_RealType1>& __x);
# 5311 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::piecewise_linear_distribution<_RealType1>& __x);

    private:
      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator==(const std::piecewise_linear_distribution<_RealType>& __d1,
        const std::piecewise_linear_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }





  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_linear_distribution<_RealType>& __d1,
        const std::piecewise_linear_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 5355 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.h" 3
  class seed_seq
  {

  public:

    typedef uint_least32_t result_type;


    seed_seq()
    : _M_v()
    { }

    template<typename _IntType>
      seed_seq(std::initializer_list<_IntType> il);

    template<typename _InputIterator>
      seed_seq(_InputIterator __begin, _InputIterator __end);


    template<typename _RandomAccessIterator>
      void
      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);


    size_t size() const
    { return _M_v.size(); }

    template<typename OutputIterator>
      void
      param(OutputIterator __dest) const
      { std::copy(_M_v.begin(), _M_v.end(), __dest); }

  private:

    std::vector<result_type> _M_v;
  };






}
# 51 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 1 3
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/numeric" 1 3
# 58 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/numeric" 3
       
# 59 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/numeric" 3



# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 1 3
# 66 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 81 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
    {

     

     

      ;

      for (; __first != __last; ++__first)
 {
   *__first = __value;
   ++__value;
 }
    }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {

     
      ;

      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
# 145 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {

     
      ;

      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
# 173 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
# 204 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
# 236 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
# 276 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
# 316 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = std::move(__tmp);
 }
      return ++__result;
    }
# 358 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;


     
     

      ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = std::move(__tmp);
 }
      return ++__result;
    }


}
# 63 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/numeric" 2 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  namespace __detail
  {
 
# 54 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 3
    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool>
      struct _Mod
      {
 static _Tp
 __calc(_Tp __x)
 {
   if (__a == 1)
     __x %= __m;
   else
     {
       static const _Tp __q = __m / __a;
       static const _Tp __r = __m % __a;

       _Tp __t1 = __a * (__x % __q);
       _Tp __t2 = __r * (__x / __q);
       if (__t1 >= __t2)
  __x = __t1 - __t2;
       else
  __x = __m - __t2 + __t1;
     }

   if (__c != 0)
     {
       const _Tp __d = __m - __x;
       if (__d > __c)
  __x += __c;
       else
  __x = __c - __d;
     }
   return __x;
 }
      };



    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
      struct _Mod<_Tp, __m, __a, __c, true>
      {
 static _Tp
 __calc(_Tp __x)
 { return __a * __x + __c; }
      };

    template<typename _InputIterator, typename _OutputIterator,
      typename _UnaryOperation>
      _OutputIterator
      __transform(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _UnaryOperation __unary_op)
      {
 for (; __first != __last; ++__first, ++__result)
   *__result = __unary_op(*__first);
 return __result;
      }

 
  }



  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;





  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    void
    linear_congruential_engine<_UIntType, __a, __c, __m>::
    seed(result_type __s)
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
   && (__detail::__mod<_UIntType, __m>(__s) == 0))
 _M_x = 1;
      else
 _M_x = __detail::__mod<_UIntType, __m>(__s);
    }




  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      linear_congruential_engine<_UIntType, __a, __c, __m>::
      seed(_Sseq& __q)
      {
 const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits
                                 : std::__lg(__m);
 const _UIntType __k = (__k0 + 31) / 32;
 uint_least32_t __arr[__k + 3];
 __q.generate(__arr + 0, __arr + __k + 3);
 _UIntType __factor = 1u;
 _UIntType __sum = 0u;
 for (size_t __j = 0; __j < __k; ++__j)
   {
     __sum += __arr[__j + 3] * __factor;
     __factor *= __detail::_Shift<_UIntType, 32>::__value;
   }
 seed(__sum);
      }

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const linear_congruential_engine<_UIntType,
      __a, __c, __m>& __lcr)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__os.widen(' '));

      __os << __lcr._M_x;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        linear_congruential_engine<_UIntType, __a, __c, __m>& __lcr)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec);

      __is >> __lcr._M_x;

      __is.flags(__flags);
      return __is;
    }


  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::word_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::state_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::shift_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::mask_bits;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::xor_mask;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_u;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_d;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_s;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_b;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_t;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_c;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_l;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
                                              initialization_multiplier;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::default_seed;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    seed(result_type __sd)
    {
      _M_x[0] = __detail::__mod<_UIntType,
 __detail::_Shift<_UIntType, __w>::__value>(__sd);

      for (size_t __i = 1; __i < state_size; ++__i)
 {
   _UIntType __x = _M_x[__i - 1];
   __x ^= __x >> (__w - 2);
   __x *= __f;
   __x += __detail::__mod<_UIntType, __n>(__i);
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__x);
 }
      _M_p = state_size;
    }

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         __s, __b, __t, __c, __l, __f>::
      seed(_Sseq& __q)
      {
 const _UIntType __upper_mask = (~_UIntType()) << __r;
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__n * __k];
 __q.generate(__arr + 0, __arr + __n * __k);

 bool __zero = true;
 for (size_t __i = 0; __i < state_size; ++__i)
   {
     _UIntType __factor = 1u;
     _UIntType __sum = 0u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);

     if (__zero)
       {
  if (__i == 0)
    {
      if ((_M_x[0] & __upper_mask) != 0u)
        __zero = false;
    }
  else if (_M_x[__i] != 0u)
    __zero = false;
       }
   }
        if (__zero)
          _M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
      }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    typename
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    operator()()
    {

      if (_M_p >= state_size)
 {
   const _UIntType __upper_mask = (~_UIntType()) << __r;
   const _UIntType __lower_mask = ~__upper_mask;

   for (size_t __k = 0; __k < (__n - __m); ++__k)
     {
       _UIntType __y = ((_M_x[__k] & __upper_mask)
          | (_M_x[__k + 1] & __lower_mask));
       _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
      ^ ((__y & 0x01) ? __a : 0));
     }

   for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
     {
       _UIntType __y = ((_M_x[__k] & __upper_mask)
          | (_M_x[__k + 1] & __lower_mask));
       _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
      ^ ((__y & 0x01) ? __a : 0));
     }

   _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
      | (_M_x[0] & __lower_mask));
   _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
      ^ ((__y & 0x01) ? __a : 0));
   _M_p = 0;
 }


      result_type __z = _M_x[_M_p++];
      __z ^= (__z >> __u) & __d;
      __z ^= (__z << __s) & __b;
      __z ^= (__z << __t) & __c;
      __z ^= (__z >> __l);

      return __z;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      for (size_t __i = 0; __i < __n; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_p;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      for (size_t __i = 0; __i < __n; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_p;

      __is.flags(__flags);
      return __is;
    }


  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr _UIntType
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    void
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    seed(result_type __value)
    {
      std::linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
 __lcg(__value == 0u ? default_seed : __value);

      const size_t __n = (__w + 31) / 32;

      for (size_t __i = 0; __i < long_lag; ++__i)
 {
   _UIntType __sum = 0u;
   _UIntType __factor = 1u;
   for (size_t __j = 0; __j < __n; ++__j)
     {
       __sum += __detail::__mod<uint_least32_t,
         __detail::_Shift<uint_least32_t, 32>::__value>
    (__lcg()) * __factor;
       __factor *= __detail::_Shift<_UIntType, 32>::__value;
     }
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__sum);
 }
      _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
      _M_p = 0;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      seed(_Sseq& __q)
      {
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__r * __k];
 __q.generate(__arr + 0, __arr + __r * __k);

 for (size_t __i = 0; __i < long_lag; ++__i)
   {
     _UIntType __sum = 0u;
     _UIntType __factor = 1u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);
   }
 _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
 _M_p = 0;
      }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      result_type
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    operator()()
    {

      long __ps = _M_p - short_lag;
      if (__ps < 0)
 __ps += long_lag;




      _UIntType __xi;
      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)
 {
   __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;
   _M_carry = 0;
 }
      else
 {
   __xi = (__detail::_Shift<_UIntType, __w>::__value
    - _M_x[_M_p] - _M_carry + _M_x[__ps]);
   _M_carry = 1;
 }
      _M_x[_M_p] = __xi;


      if (++_M_p >= long_lag)
 _M_p = 0;

      return __xi;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const subtract_with_carry_engine<_UIntType,
      __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      for (size_t __i = 0; __i < __r; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_carry << __space << __x._M_p;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        subtract_with_carry_engine<_UIntType, __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      for (size_t __i = 0; __i < __r; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_carry;
      __is >> __x._M_p;

      __is.flags(__flags);
      return __is;
    }


  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    constexpr size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;

  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    constexpr size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;

  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    typename discard_block_engine<_RandomNumberEngine,
      __p, __r>::result_type
    discard_block_engine<_RandomNumberEngine, __p, __r>::
    operator()()
    {
      if (_M_n >= used_block)
 {
   _M_b.discard(block_size - _M_n);
   _M_n = 0;
 }
      ++_M_n;
      return _M_b();
    }

  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discard_block_engine<_RandomNumberEngine,
        __p, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      __os << __x.base() << __space << __x._M_n;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discard_block_engine<_RandomNumberEngine, __p, __r>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      __is >> __x._M_b >> __x._M_n;

      __is.flags(__flags);
      return __is;
    }


  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    typename independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
      result_type
    independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
    operator()()
    {
      typedef typename _RandomNumberEngine::result_type _Eresult_type;
      const _Eresult_type __r
 = (_M_b.max() - _M_b.min() < std::numeric_limits<_Eresult_type>::max()
    ? _M_b.max() - _M_b.min() + 1 : 0);
      const unsigned __edig = std::numeric_limits<_Eresult_type>::digits;
      const unsigned __m = __r ? std::__lg(__r) : __edig;

      typedef typename std::common_type<_Eresult_type, result_type>::type
 __ctype;
      const unsigned __cdig = std::numeric_limits<__ctype>::digits;

      unsigned __n, __n0;
      __ctype __s0, __s1, __y0, __y1;

      for (size_t __i = 0; __i < 2; ++__i)
 {
   __n = (__w + __m - 1) / __m + __i;
   __n0 = __n - __w % __n;
   const unsigned __w0 = __w / __n;

   __s0 = 0;
   __s1 = 0;
   if (__w0 < __cdig)
     {
       __s0 = __ctype(1) << __w0;
       __s1 = __s0 << 1;
     }

   __y0 = 0;
   __y1 = 0;
   if (__r)
     {
       __y0 = __s0 * (__r / __s0);
       if (__s1)
  __y1 = __s1 * (__r / __s1);

       if (__r - __y0 <= __y0 / __n)
  break;
     }
   else
     break;
 }

      result_type __sum = 0;
      for (size_t __k = 0; __k < __n0; ++__k)
 {
   __ctype __u;
   do
     __u = _M_b() - _M_b.min();
   while (__y0 && __u >= __y0);
   __sum = __s0 * __sum + (__s0 ? __u % __s0 : __u);
 }
      for (size_t __k = __n0; __k < __n; ++__k)
 {
   __ctype __u;
   do
     __u = _M_b() - _M_b.min();
   while (__y1 && __u >= __y1);
   __sum = __s1 * __sum + (__s1 ? __u % __s1 : __u);
 }
      return __sum;
    }


  template<typename _RandomNumberEngine, size_t __k>
    constexpr size_t
    shuffle_order_engine<_RandomNumberEngine, __k>::table_size;

  template<typename _RandomNumberEngine, size_t __k>
    typename shuffle_order_engine<_RandomNumberEngine, __k>::result_type
    shuffle_order_engine<_RandomNumberEngine, __k>::
    operator()()
    {
      size_t __j = __k * ((_M_y - _M_b.min())
     / (_M_b.max() - _M_b.min() + 1.0L));
      _M_y = _M_v[__j];
      _M_v[__j] = _M_b();

      return _M_y;
    }

  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      __os << __x.base();
      for (size_t __i = 0; __i < __k; ++__i)
 __os << __space << __x._M_v[__i];
      __os << __space << __x._M_y;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      __is >> __x._M_b;
      for (size_t __i = 0; __i < __k; ++__i)
 __is >> __x._M_v[__i];
      __is >> __x._M_y;

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 910 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_int_distribution<_IntType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_real_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bernoulli_distribution& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.p();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename geometric_distribution<_IntType>::result_type
      geometric_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {


 const double __naf =
   (1 - std::numeric_limits<double>::epsilon()) / 2;

 const double __thr =
   std::numeric_limits<_IntType>::max() + __naf;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 double __cand;
 do
   __cand = std::floor(std::log(__aurng()) / __param._M_log_1_p);
 while (__cand >= __thr);

 return result_type(__cand + __naf);
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.p();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __p;
      __is >> __p;
      __x.param(typename geometric_distribution<_IntType>::param_type(__p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng)
      {
 const double __y = _M_gd(__urng);


 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 typedef typename std::gamma_distribution<result_type>::param_type
   param_type;

 const double __y =
   _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));

 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.k() << __space << __x.p()
    << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _IntType __k;
      double __p;
      __is >> __k >> __p >> __x._M_gd;
      __x.param(typename negative_binomial_distribution<_IntType>::
  param_type(__k, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    poisson_distribution<_IntType>::param_type::
    _M_initialize()
    {

      if (_M_mean >= 12)
 {
   const double __m = std::floor(_M_mean);
   _M_lm_thr = std::log(_M_mean);
   _M_lfm = std::lgamma(__m + 1);
   _M_sm = std::sqrt(__m);

   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __dx = std::sqrt(2 * __m * std::log(32 * __m
             / __pi_4));
   _M_d = std::round(std::max(6.0, std::min(__m, __dx)));
   const double __cx = 2 * __m + _M_d;
   _M_scx = std::sqrt(__cx / 2);
   _M_1cx = 1 / __cx;

   _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
   _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
  / _M_d;
 }
      else

 _M_lm_thr = std::exp(-_M_mean);
      }
# 1224 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 3
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename poisson_distribution<_IntType>::result_type
      poisson_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 if (__param.mean() >= 12)
   {
     double __x;


     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;

     const double __m = std::floor(__param.mean());

     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __c1 = __param._M_sm * __spi_2;
     const double __c2 = __param._M_c2b + __c1;
     const double __c3 = __c2 + 1;
     const double __c4 = __c3 + 1;

     const double __e178 = 1.0129030479320018583185514777512983L;
     const double __c5 = __c4 + __e178;
     const double __c = __param._M_cb + __c5;
     const double __2cx = 2 * (2 * __m + __param._M_d);

     bool __reject = true;
     do
       {
  const double __u = __c * __aurng();
  const double __e = -std::log(__aurng());

  double __w = 0.0;

  if (__u <= __c1)
    {
      const double __n = _M_nd(__urng);
      const double __y = -std::abs(__n) * __param._M_sm - 1;
      __x = std::floor(__y);
      __w = -__n * __n / 2;
      if (__x < -__m)
        continue;
    }
  else if (__u <= __c2)
    {
      const double __n = _M_nd(__urng);
      const double __y = 1 + std::abs(__n) * __param._M_scx;
      __x = std::ceil(__y);
      __w = __y * (2 - __y) * __param._M_1cx;
      if (__x > __param._M_d)
        continue;
    }
  else if (__u <= __c3)


    __x = -1;
  else if (__u <= __c4)
    __x = 0;
  else if (__u <= __c5)
    __x = 1;
  else
    {
      const double __v = -std::log(__aurng());
      const double __y = __param._M_d
         + __v * __2cx / __param._M_d;
      __x = std::ceil(__y);
      __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
    }

  __reject = (__w - __e - __x * __param._M_lm_thr
       > __param._M_lfm - std::lgamma(__x + __m + 1));

  __reject |= __x + __m >= __thr;

       } while (__reject);

     return result_type(__x + __m + __naf);
   }
 else

   {
     _IntType __x = 0;
     double __prod = 1.0;

     do
       {
  __prod *= __aurng();
  __x += 1;
       }
     while (__prod > __param._M_lm_thr);

     return __x - 1;
   }
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.mean() << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __mean;
      __is >> __mean >> __x._M_nd;
      __x.param(typename poisson_distribution<_IntType>::param_type(__mean));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    binomial_distribution<_IntType>::param_type::
    _M_initialize()
    {
      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;

      _M_easy = true;


      if (_M_t * __p12 >= 8)
 {
   _M_easy = false;
   const double __np = std::floor(_M_t * __p12);
   const double __pa = __np / _M_t;
   const double __1p = 1 - __pa;

   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __d1x =
     std::sqrt(__np * __1p * std::log(32 * __np
          / (81 * __pi_4 * __1p)));
   _M_d1 = std::round(std::max(1.0, __d1x));
   const double __d2x =
     std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
          / (__pi_4 * __pa)));
   _M_d2 = std::round(std::max(1.0, __d2x));


   const double __spi_2 = 1.2533141373155002512078826424055226L;
   _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
   _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * _M_t * __1p));
   _M_c = 2 * _M_d1 / __np;
   _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
   const double __a12 = _M_a1 + _M_s2 * __spi_2;
   const double __s1s = _M_s1 * _M_s1;
   _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
        * 2 * __s1s / _M_d1
        * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
   const double __s2s = _M_s2 * _M_s2;
   _M_s = (_M_a123 + 2 * __s2s / _M_d2
    * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
   _M_lf = (std::lgamma(__np + 1)
     + std::lgamma(_M_t - __np + 1));
   _M_lp1p = std::log(__pa / __1p);

   _M_q = -std::log(1 - (__p12 - __pa) / __1p);
 }
      else

 _M_q = -std::log(1 - __p12);
    }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      _M_waiting(_UniformRandomNumberGenerator& __urng, _IntType __t)
      {
 _IntType __x = 0;
 double __sum = 0.0;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 do
   {
     const double __e = -std::log(__aurng());
     __sum += __e / (__t - __x);
     __x += 1;
   }
 while (__sum <= _M_param._M_q);

 return __x - 1;
      }
# 1456 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 3
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 const _IntType __t = __param.t();
 const double __p = __param.p();
 const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);


 if (!__param._M_easy)
   {
     double __x;


     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;

     const double __np = std::floor(__t * __p12);


     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __a1 = __param._M_a1;
     const double __a12 = __a1 + __param._M_s2 * __spi_2;
     const double __a123 = __param._M_a123;
     const double __s1s = __param._M_s1 * __param._M_s1;
     const double __s2s = __param._M_s2 * __param._M_s2;

     bool __reject;
     do
       {
  const double __u = __param._M_s * __aurng();

  double __v;

  if (__u <= __a1)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s1 * std::abs(__n);
      __reject = __y >= __param._M_d1;
      if (!__reject)
        {
   const double __e = -std::log(__aurng());
   __x = std::floor(__y);
   __v = -__e - __n * __n / 2 + __param._M_c;
        }
    }
  else if (__u <= __a12)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s2 * std::abs(__n);
      __reject = __y >= __param._M_d2;
      if (!__reject)
        {
   const double __e = -std::log(__aurng());
   __x = std::floor(-__y);
   __v = -__e - __n * __n / 2;
        }
    }
  else if (__u <= __a123)
    {
      const double __e1 = -std::log(__aurng());
      const double __e2 = -std::log(__aurng());

      const double __y = __param._M_d1
         + 2 * __s1s * __e1 / __param._M_d1;
      __x = std::floor(__y);
      __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
          -__y / (2 * __s1s)));
      __reject = false;
    }
  else
    {
      const double __e1 = -std::log(__aurng());
      const double __e2 = -std::log(__aurng());

      const double __y = __param._M_d2
         + 2 * __s2s * __e1 / __param._M_d2;
      __x = std::floor(-__y);
      __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
      __reject = false;
    }

  __reject = __reject || __x < -__np || __x > __t - __np;
  if (!__reject)
    {
      const double __lfx =
        std::lgamma(__np + __x + 1)
        + std::lgamma(__t - (__np + __x) + 1);
      __reject = __v > __param._M_lf - __lfx
        + __x * __param._M_lp1p;
    }

  __reject |= __x + __np >= __thr;
       }
     while (__reject);

     __x += __np + __naf;

     const _IntType __z = _M_waiting(__urng, __t - _IntType(__x));
     __ret = _IntType(__x) + __z;
   }
 else

   __ret = _M_waiting(__urng, __t);

 if (__p12 != __p)
   __ret = __t - __ret;
 return __ret;
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.t() << __space << __x.p()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __t;
      double __p;
      __is >> __t >> __p >> __x._M_nd;
      __x.param(typename binomial_distribution<_IntType>::
  param_type(__t, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.lambda();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __lambda;
      __is >> __lambda;
      __x.param(typename exponential_distribution<_RealType>::
  param_type(__lambda));

      __is.flags(__flags);
      return __is;
    }
# 1673 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/random.tcc" 3
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename normal_distribution<_RealType>::result_type
      normal_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 if (_M_saved_available)
   {
     _M_saved_available = false;
     __ret = _M_saved;
   }
 else
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     _M_saved = __x * __mult;
     _M_saved_available = true;
     __ret = __y * __mult;
   }

 __ret = __ret * __param.stddev() + __param.mean();
 return __ret;
      }

  template<typename _RealType>
    bool
    operator==(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    {
      if (__d1._M_param == __d2._M_param
   && __d1._M_saved_available == __d2._M_saved_available)
 {
   if (__d1._M_saved_available
       && __d1._M_saved == __d2._M_saved)
     return true;
   else if(!__d1._M_saved_available)
     return true;
   else
     return false;
 }
      else
 return false;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const normal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.mean() << __space << __x.stddev()
    << __space << __x._M_saved_available;
      if (__x._M_saved_available)
 __os << __space << __x._M_saved;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        normal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      double __mean, __stddev;
      __is >> __mean >> __stddev
    >> __x._M_saved_available;
      if (__x._M_saved_available)
 __is >> __x._M_saved;
      __x.param(typename normal_distribution<_RealType>::
  param_type(__mean, __stddev));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.s()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __s;
      __is >> __m >> __s >> __x._M_nd;
      __x.param(typename lognormal_distribution<_RealType>::
  param_type(__m, __s));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __n;
      __is >> __n >> __x._M_gd;
      __x.param(typename chi_squared_distribution<_RealType>::
  param_type(__n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename cauchy_distribution<_RealType>::result_type
      cauchy_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 _RealType __u;
 do
   __u = __aurng();
 while (__u == 0.5);

 const _RealType __pi = 3.1415926535897932384626433832795029L;
 return __p.a() + __p.b() * std::tan(__pi * __u);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename cauchy_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.n()
    << __space << __x._M_gd_x << __space << __x._M_gd_y;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __n;
      __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
      __x.param(typename fisher_f_distribution<_RealType>::
  param_type(__m, __n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __n;
      __is >> __n >> __x._M_nd >> __x._M_gd;
      __x.param(typename student_t_distribution<_RealType>::param_type(__n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    gamma_distribution<_RealType>::param_type::
    _M_initialize()
    {
      _M_malpha = _M_alpha < 1.0 ? _M_alpha + _RealType(1.0) : _M_alpha;

      const _RealType __a1 = _M_malpha - _RealType(1.0) / _RealType(3.0);
      _M_a2 = _RealType(1.0) / std::sqrt(_RealType(9.0) * __a1);
    }






  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename gamma_distribution<_RealType>::result_type
      gamma_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 result_type __u, __v, __n;
 const result_type __a1 = (__param._M_malpha
      - _RealType(1.0) / _RealType(3.0));

 do
   {
     do
       {
  __n = _M_nd(__urng);
  __v = result_type(1.0) + __param._M_a2 * __n;
       }
     while (__v <= 0.0);

     __v = __v * __v * __v;
     __u = __aurng();
   }
 while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
        && (std::log(__u) > (0.5 * __n * __n + __a1
        * (1.0 - __v + std::log(__v)))));

 if (__param.alpha() == __param._M_malpha)
   return __a1 * __v * __param.beta();
 else
   {
     do
       __u = __aurng();
     while (__u == 0.0);

     return (std::pow(__u, result_type(1.0) / __param.alpha())
      * __a1 * __v * __param.beta());
   }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.alpha() << __space << __x.beta()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __alpha_val, __beta_val;
      __is >> __alpha_val >> __beta_val >> __x._M_nd;
      __x.param(typename gamma_distribution<_RealType>::
  param_type(__alpha_val, __beta_val));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename weibull_distribution<_RealType>::result_type
      weibull_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.b() * std::pow(-std::log(__aurng()),
      result_type(1) / __p.a());
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename weibull_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename extreme_value_distribution<_RealType>::result_type
      extreme_value_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.a() - __p.b() * std::log(-std::log(__aurng()));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename extreme_value_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    discrete_distribution<_IntType>::param_type::
    _M_initialize()
    {
      if (_M_prob.size() < 2)
 {
   _M_prob.clear();
   return;
 }

      const double __sum = std::accumulate(_M_prob.begin(),
        _M_prob.end(), 0.0);

      __detail::__transform(_M_prob.begin(), _M_prob.end(), _M_prob.begin(),
     std::bind2nd(std::divides<double>(), __sum));

      _M_cp.reserve(_M_prob.size());
      std::partial_sum(_M_prob.begin(), _M_prob.end(),
         std::back_inserter(_M_cp));

      _M_cp[_M_cp.size() - 1] = 1.0;
    }

  template<typename _IntType>
    template<typename _Func>
      discrete_distribution<_IntType>::param_type::
      param_type(size_t __nw, double __xmin, double __xmax, _Func __fw)
      : _M_prob(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const double __delta = (__xmax - __xmin) / __n;

 _M_prob.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_prob.push_back(__fw(__xmin + __k * __delta + 0.5 * __delta));

 _M_initialize();
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename discrete_distribution<_IntType>::result_type
      discrete_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 if (__param._M_cp.empty())
   return result_type(0);

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);

 return __pos - __param._M_cp.begin();
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      std::vector<double> __prob = __x.probabilities();
      __os << __prob.size();
      for (auto __dit = __prob.begin(); __dit != __prob.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<double> __prob_vec;
      __prob_vec.reserve(__n);
      for (; __n != 0; --__n)
 {
   double __prob;
   __is >> __prob;
   __prob_vec.push_back(__prob);
 }

      __x.param(typename discrete_distribution<_IntType>::
  param_type(__prob_vec.begin(), __prob_vec.end()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    piecewise_constant_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2
   || (_M_int.size() == 2
       && _M_int[0] == _RealType(0)
       && _M_int[1] == _RealType(1)))
 {
   _M_int.clear();
   _M_den.clear();
   return;
 }

      const double __sum = std::accumulate(_M_den.begin(),
        _M_den.end(), 0.0);

      __detail::__transform(_M_den.begin(), _M_den.end(), _M_den.begin(),
       std::bind2nd(std::divides<double>(), __sum));

      _M_cp.reserve(_M_den.size());
      std::partial_sum(_M_den.begin(), _M_den.end(),
         std::back_inserter(_M_cp));


      _M_cp[_M_cp.size() - 1] = 1.0;

      for (size_t __k = 0; __k < _M_den.size(); ++__k)
 _M_den[__k] /= _M_int[__k + 1] - _M_int[__k];
    }

  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp()
      {
 if (__bbegin != __bend)
   {
     for (;;)
       {
  _M_int.push_back(*__bbegin);
  ++__bbegin;
  if (__bbegin == __bend)
    break;

  _M_den.push_back(*__wbegin);
  ++__wbegin;
       }
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 _M_int.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   _M_int.push_back(*__biter);

 _M_den.reserve(_M_int.size() - 1);
 for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
   _M_den.push_back(__fw(0.5 * (_M_int[__k + 1] + _M_int[__k])));

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;

 _M_int.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   _M_int.push_back(__xmin + __k * __delta);

 _M_den.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_den.push_back(__fw(_M_int[__k] + 0.5 * __delta));

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_constant_distribution<_RealType>::result_type
      piecewise_constant_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 if (__param._M_cp.empty())
   return __p;

 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();

 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

 return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;

      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;

      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }

      std::vector<double> __den_vec;
      __den_vec.reserve(__n);
      for (size_t __i = 0; __i < __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }

      __x.param(typename piecewise_constant_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    piecewise_linear_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2
   || (_M_int.size() == 2
       && _M_int[0] == _RealType(0)
       && _M_int[1] == _RealType(1)
       && _M_den[0] == _M_den[1]))
 {
   _M_int.clear();
   _M_den.clear();
   return;
 }

      double __sum = 0.0;
      _M_cp.reserve(_M_int.size() - 1);
      _M_m.reserve(_M_int.size() - 1);
      for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
 {
   const _RealType __delta = _M_int[__k + 1] - _M_int[__k];
   __sum += 0.5 * (_M_den[__k + 1] + _M_den[__k]) * __delta;
   _M_cp.push_back(__sum);
   _M_m.push_back((_M_den[__k + 1] - _M_den[__k]) / __delta);
 }


      __detail::__transform(_M_den.begin(), _M_den.end(), _M_den.begin(),
     std::bind2nd(std::divides<double>(), __sum));

      __detail::__transform(_M_cp.begin(), _M_cp.end(), _M_cp.begin(),
       std::bind2nd(std::divides<double>(), __sum));

      __detail::__transform(_M_m.begin(), _M_m.end(), _M_m.begin(),
       std::bind2nd(std::divides<double>(), __sum));

      _M_cp[_M_cp.size() - 1] = 1.0;
     }

  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 for (; __bbegin != __bend; ++__bbegin, ++__wbegin)
   {
     _M_int.push_back(*__bbegin);
     _M_den.push_back(*__wbegin);
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 _M_int.reserve(__bl.size());
 _M_den.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   {
     _M_int.push_back(*__biter);
     _M_den.push_back(__fw(*__biter));
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;

 _M_int.reserve(__n + 1);
 _M_den.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   {
     _M_int.push_back(__xmin + __k * __delta);
     _M_den.push_back(__fw(_M_int[__k] + __delta));
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_linear_distribution<_RealType>::result_type
      piecewise_linear_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 if (__param._M_cp.empty())
   return __p;

 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();

 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

 const double __a = 0.5 * __param._M_m[__i];
 const double __b = __param._M_den[__i];
 const double __cm = __p - __pref;

 _RealType __x = __param._M_int[__i];
 if (__a == 0)
   __x += __cm / __b;
 else
   {
     const double __d = __b * __b + 4.0 * __a * __cm;
     __x += 0.5 * (std::sqrt(__d) - __b) / __a;
          }

        return __x;
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;

      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;

      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }

      std::vector<double> __den_vec;
      __den_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }

      __x.param(typename piecewise_linear_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    seed_seq::seed_seq(std::initializer_list<_IntType> __il)
    {
      for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }

  template<typename _InputIterator>
    seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
    {
      for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }

  template<typename _RandomAccessIterator>
    void
    seed_seq::generate(_RandomAccessIterator __begin,
         _RandomAccessIterator __end)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
        _Type;

      if (__begin == __end)
 return;

      std::fill(__begin, __end, _Type(0x8b8b8b8bu));

      const size_t __n = __end - __begin;
      const size_t __s = _M_v.size();
      const size_t __t = (__n >= 623) ? 11
         : (__n >= 68) ? 7
         : (__n >= 39) ? 5
         : (__n >= 7) ? 3
         : (__n - 1) / 2;
      const size_t __p = (__n - __t) / 2;
      const size_t __q = __p + __t;
      const size_t __m = std::max(size_t(__s + 1), __n);

      for (size_t __k = 0; __k < __m; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    ^ __begin[(__k + __p) % __n]
    ^ __begin[(__k - 1) % __n]);
   _Type __r1 = __arg ^ (__arg >> 27);
   __r1 = __detail::__mod<_Type,
      __detail::_Shift<_Type, 32>::__value>(1664525u * __r1);
   _Type __r2 = __r1;
   if (__k == 0)
     __r2 += __s;
   else if (__k <= __s)
     __r2 += __k % __n + _M_v[__k - 1];
   else
     __r2 += __k % __n;
   __r2 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r2);
   __begin[(__k + __p) % __n] += __r1;
   __begin[(__k + __q) % __n] += __r2;
   __begin[__k % __n] = __r2;
 }

      for (size_t __k = __m; __k < __m + __n; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    + __begin[(__k + __p) % __n]
    + __begin[(__k - 1) % __n]);
   _Type __r3 = __arg ^ (__arg >> 27);
   __r3 = __detail::__mod<_Type,
     __detail::_Shift<_Type, 32>::__value>(1566083941u * __r3);
   _Type __r4 = __r3 - __k % __n;
   __r4 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r4);
   __begin[(__k + __p) % __n] ^= __r3;
   __begin[(__k + __q) % __n] ^= __r4;
   __begin[__k % __n] = __r4;
 }
    }

  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __urng)
    {
      const size_t __b
 = std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                   __bits);
      const long double __r = static_cast<long double>(__urng.max())
       - static_cast<long double>(__urng.min()) + 1.0L;
      const size_t __log2r = std::log(__r) / std::log(2.0L);
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
 {
   __sum += _RealType(__urng() - __urng.min()) * __tmp;
   __tmp *= __r;
 }
      return __sum / __tmp;
    }


}
# 52 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/random" 2 3
# 68 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 2 3
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 1 3
# 47 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
       
# 48 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3






# 1 "../../dist/system_wrappers/typeinfo" 1 3
       
# 2 "../../dist/system_wrappers/typeinfo" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 3
       
# 35 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 3

# 1 "../../dist/system_wrappers/exception" 1 3
       
# 2 "../../dist/system_wrappers/exception" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 37 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 2 3




#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 82 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
# 117 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 4 "../../dist/system_wrappers/typeinfo" 2 3
#pragma GCC visibility pop
# 55 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 2 3

# 1 "../../dist/stl_wrappers/tuple" 1 3
# 18 "../../dist/stl_wrappers/tuple" 3
       
# 19 "../../dist/stl_wrappers/tuple" 3
# 33 "../../dist/stl_wrappers/tuple" 3
# 1 "../../dist/system_wrappers/new" 1 3
       
# 2 "../../dist/system_wrappers/new" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 34 "../../dist/stl_wrappers/tuple" 2 3
# 54 "../../dist/stl_wrappers/tuple" 3
#pragma GCC visibility push(default)
# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/tuple" 1 3
# 32 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/tuple" 3
       
# 33 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/tuple" 3






# 1 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/uses_allocator.h" 1 3
# 34 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct allocator_arg_t { };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template<typename _Tp> class __has_allocator_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::allocator_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_allocator_type : integral_constant<bool, __has_allocator_type_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Tp, typename _Alloc,
    bool = __has_allocator_type<_Tp>::value>
    struct __uses_allocator_helper
    : public false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc, true>
    : public integral_constant<bool, is_convertible<_Alloc,
         typename _Tp::allocator_type>::value>
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : public integral_constant<bool,
          __uses_allocator_helper<_Tp, _Alloc>::value>
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_allocator_arg
    : is_constructible<_Tp, _Alloc, _Args...>
    { static_assert( uses_allocator<_Tp, _Alloc>::value, "uses allocator" ); };

  struct __uses_alloc_base { };
  struct __uses_alloc0 : __uses_alloc_base
  { struct _Anything { _Anything(...) { } } _M_a; };
  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };
  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc_impl
    : __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    __uses_alloc_impl<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_impl<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = &__a;
      return __ret;
    }


}
# 40 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct __add_c_ref
    { typedef const _Tp& type; };

  template<typename _Tp>
    struct __add_c_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_ref
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_r_ref
    { typedef _Tp&& type; };

  template<typename _Tp>
    struct __add_r_ref<_Tp&>
    { typedef _Tp& type; };

  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      template<typename _UHead, typename = typename
        enable_if<!is_convertible<_UHead,
                                  __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(__uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(__uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(__uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      template<typename _UHead, typename = typename
        enable_if<!is_convertible<_UHead,
                                  __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(__uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(__uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(__uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 177 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;





  template<std::size_t _Idx>
    struct _Tuple_impl<_Idx>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      _Tuple_impl() = default;

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&, const _Tuple_impl&) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&, _Tuple_impl&&) { }

    protected:
      void _M_swap(_Tuple_impl&) noexcept { }
    };


  template<typename _Tp>
    using __empty_not_final
      = typename conditional<__is_final(_Tp), false_type, is_empty<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(noexcept(swap(std::declval<_Head&>(),
        std::declval<_Head&>()))
        && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
 explicit
        constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<const _UElements&,
     _Elements>...>::value>::type>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _T1& __a1, const _T2& __a2)
      : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        explicit
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<std::size_t __i, typename _Tp>
    struct tuple_element;





  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename
      add_const<typename tuple_element<__i, _Tp>::type>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename
      add_volatile<typename tuple_element<__i, _Tp>::type>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename
      add_cv<typename tuple_element<__i, _Tp>::type>::type type;
    };


  template<typename _Tp>
    struct tuple_size;

  template<typename _Tp>
    struct tuple_size<const _Tp>
    : public integral_constant<
             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
             tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : public integral_constant<
             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
             tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : public integral_constant<
             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
             tuple_size<_Tp>::value> { };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr typename __add_ref<_Head>::type
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr typename __add_c_ref<_Head>::type
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }




  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>& __t) noexcept
    { return __get_helper<__i>(__t); }

  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_c_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(const tuple<_Elements...>& __t) noexcept
    { return __get_helper<__i>(__t); }

  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_r_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>&& __t) noexcept
    { return std::forward<typename tuple_element<__i,
 tuple<_Elements...>>::type&&>(get<__i>(__t)); }


  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,
    typename _Tp, typename _Up>
    struct __tuple_compare;

  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __j, _Tp, _Up>
    {
      static bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return (get<__i>(__t) == get<__i>(__u) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));
      }

      static bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return ((get<__i>(__t) < get<__i>(__u))
  || !(get<__i>(__u) < get<__i>(__t)) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
      }
    };

  template<std::size_t __i, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __i, _Tp, _Up>
    {
      static bool
      __eq(const _Tp&, const _Up&) { return true; }

      static bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }

  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }


  template<typename, std::size_t> struct array;

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp& get(array<_Tp, _Nm>&) noexcept;

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&& get(array<_Tp, _Nm>&&) noexcept;

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp& get(const array<_Tp, _Nm>&) noexcept;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };

  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };



  template<std::size_t... _Indexes>
    struct _Index_tuple
    {
      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
    };


  template<std::size_t _Num>
    struct _Build_index_tuple
    {
      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };

  template<std::size_t, typename, typename, std::size_t>
    struct __make_tuple_impl;

  template<std::size_t _Idx, typename _Tuple, typename... _Tp,
           std::size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef typename __make_tuple_impl<_Idx + 1, tuple<_Tp...,
 typename std::tuple_element<_Idx, _Tuple>::type>, _Tuple, _Nm>::__type
      __type;
    };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : public __make_tuple_impl<0, tuple<>, _Tuple,
                               std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };

  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }

  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }

  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }


}
# 56 "../../dist/stl_wrappers/tuple" 2 3
#pragma GCC visibility pop
# 57 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*);

template<typename _Tp> class __has_result_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::result_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_result_type : integral_constant<bool, __has_result_type_helper <typename remove_cv<_Tp>::type>::value> { };


  template<bool _Has_result_type, typename _Functor>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<true, _Functor>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<__has_result_type<_Functor>::value, _Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };


  template<typename _Tp>
    struct _Derives_from_unary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _Res>
 static __one __test(const volatile unary_function<_T1, _Res>*);



      static __two __test(...);

    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };


  template<typename _Tp>
    struct _Derives_from_binary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _T2, typename _Res>
 static __one __test(const volatile binary_function<_T1, _T2, _Res>*);



      static __two __test(...);

    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };





  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (!is_member_pointer<_Functor>::value
       && !is_function<_Functor>::value
       && !is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor(_Args&&...)>::type
    >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }

  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
             (is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args&&...)>::type
           >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return mem_fn(__f)(std::forward<_Args>(__args)...);
    }


  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (is_pointer<_Functor>::value
       && is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor(_Args&&...)>::type
    >::type
    __invoke(_Functor __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }






  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp> class __has_argument_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::argument_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_argument_type : integral_constant<bool, __has_argument_type_helper <typename remove_cv<_Tp>::type>::value> { };
  template<typename _Tp> class __has_first_argument_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::first_argument_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_first_argument_type : integral_constant<bool, __has_first_argument_type_helper <typename remove_cv<_Tp>::type>::value> { };
  template<typename _Tp> class __has_second_argument_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::second_argument_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_second_argument_type : integral_constant<bool, __has_second_argument_type_helper <typename remove_cv<_Tp>::type>::value> { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper<_Tp>& __inref) noexcept
      : _M_data(__inref._M_data)
      { }

      reference_wrapper&
      operator=(const reference_wrapper<_Tp>& __inref) noexcept
      {
 _M_data = __inref._M_data;
 return *this;
      }

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return __invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }
# 510 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...);

      template<typename _Tp>
 _Res
 _M_call(_Tp& __object, const volatile _Class *,
  _ArgTypes... __args) const
 { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }

      template<typename _Tp>
 _Res
 _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(_Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }


      _Res
      operator()(_Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }


      template<typename _Tp>
 _Res
 operator()(_Tp& __object, _ArgTypes... __args) const
 {
   return _M_call(__object, &__object,
       std::forward<_ArgTypes>(__args)...);
 }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>
    : public _Maybe_unary_or_binary_function<_Res, const _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;

      template<typename _Tp>
 _Res
 _M_call(_Tp& __object, const volatile _Class *,
  _ArgTypes... __args) const
 { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }

      template<typename _Tp>
 _Res
 _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(const _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }


      _Res
      operator()(const _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }


      template<typename _Tp>
 _Res operator()(_Tp& __object, _ArgTypes... __args) const
 {
   return _M_call(__object, &__object,
       std::forward<_ArgTypes>(__args)...);
 }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>
    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;

      template<typename _Tp>
 _Res
 _M_call(_Tp& __object, const volatile _Class *,
  _ArgTypes... __args) const
 { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }

      template<typename _Tp>
 _Res
 _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(volatile _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }


      _Res
      operator()(volatile _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }


      template<typename _Tp>
 _Res
 operator()(_Tp& __object, _ArgTypes... __args) const
 {
   return _M_call(__object, &__object,
       std::forward<_ArgTypes>(__args)...);
 }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>
    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;

      template<typename _Tp>
 _Res
 _M_call(_Tp& __object, const volatile _Class *,
  _ArgTypes... __args) const
 { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }

      template<typename _Tp>
 _Res
 _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(const volatile _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }


      _Res
      operator()(const volatile _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }


      template<typename _Tp>
 _Res operator()(_Tp& __object, _ArgTypes... __args) const
 {
   return _M_call(__object, &__object,
       std::forward<_ArgTypes>(__args)...);
 }

    private:
      _Functor __pmf;
    };


  template<typename _Tp, bool>
    struct _Mem_fn_const_or_non
    {
      typedef const _Tp& type;
    };

  template<typename _Tp>
    struct _Mem_fn_const_or_non<_Tp, false>
    {
      typedef _Tp& type;
    };

  template<typename _Res, typename _Class>
    class _Mem_fn<_Res _Class::*>
    {


      template<typename _Tp>
 _Res&
 _M_call(_Tp& __object, _Class *) const
 { return __object.*__pm; }

      template<typename _Tp, typename _Up>
 _Res&
 _M_call(_Tp& __object, _Up * const *) const
 { return (*__object).*__pm; }

      template<typename _Tp, typename _Up>
 const _Res&
 _M_call(_Tp& __object, const _Up * const *) const
 { return (*__object).*__pm; }

      template<typename _Tp>
 const _Res&
 _M_call(_Tp& __object, const _Class *) const
 { return __object.*__pm; }

      template<typename _Tp>
 const _Res&
 _M_call(_Tp& __ptr, const volatile void*) const
 { return (*__ptr).*__pm; }

      template<typename _Tp> static _Tp& __get_ref();

      template<typename _Tp>
 static __sfinae_types::__one __check_const(_Tp&, _Class*);
      template<typename _Tp, typename _Up>
 static __sfinae_types::__one __check_const(_Tp&, _Up * const *);
      template<typename _Tp, typename _Up>
 static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);
      template<typename _Tp>
 static __sfinae_types::__two __check_const(_Tp&, const _Class*);
      template<typename _Tp>
 static __sfinae_types::__two __check_const(_Tp&, const volatile void*);

    public:
      template<typename _Tp>
 struct _Result_type
 : _Mem_fn_const_or_non<_Res,
   (sizeof(__sfinae_types::__two)
    == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>
 { };

      template<typename _Signature>
 struct result;

      template<typename _CVMem, typename _Tp>
 struct result<_CVMem(_Tp)>
 : public _Result_type<_Tp> { };

      template<typename _CVMem, typename _Tp>
 struct result<_CVMem(_Tp&)>
 : public _Result_type<_Tp> { };

      explicit
      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }


      _Res&
      operator()(_Class& __object) const
      { return __object.*__pm; }

      const _Res&
      operator()(const _Class& __object) const
      { return __object.*__pm; }


      _Res&
      operator()(_Class* __object) const
      { return __object->*__pm; }

      const _Res&
      operator()(const _Class* __object) const
      { return __object->*__pm; }


      template<typename _Tp>
 typename _Result_type<_Tp>::type
 operator()(_Tp& __unknown) const
 { return _M_call(__unknown, &__unknown); }

    private:
      _Res _Class::*__pm;
    };






  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm)
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }







  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };






  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };

 





  namespace placeholders
  {
 




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
 
  }

 






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };





  struct _No_tuple_element;






  template<std::size_t __i, typename _Tuple, bool _IsSafe>
    struct _Safe_tuple_element_impl
    : tuple_element<__i, _Tuple> { };






  template<std::size_t __i, typename _Tuple>
    struct _Safe_tuple_element_impl<__i, _Tuple, false>
    {
      typedef _No_tuple_element type;
    };





 template<std::size_t __i, typename _Tuple>
   struct _Safe_tuple_element
   : _Safe_tuple_element_impl<__i, _Tuple,
         (__i < tuple_size<_Tuple>::value)>
   { };
# 960 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;





  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      typedef _Tp& result_type;





      template<typename _CVRef, typename _Tuple>
 result_type
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };






  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Signature> class result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 class result<_CVMu(_CVArg, _Tuple)>
 {



   typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
      - 1), _Tuple>::type
     __base_type;

 public:
   typedef typename add_rvalue_reference<__base_type>::type type;
 };

      template<typename _Tuple>
 typename result<_Mu(_Arg, _Tuple)>::type
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _Signature> struct result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 struct result<_CVMu(_CVArg, _Tuple)>
 {
   typedef typename add_lvalue_reference<_CVArg>::type type;
 };


      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> typename tuple_element<_Ind, tuple<_Tp...>>::type volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> typename tuple_element<_Ind, tuple<_Tp...>>::type const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };




  template<typename _Tp>
    class __is_socketlike
    {
      typedef typename decay<_Tp>::type _Tp2;
    public:
      static const bool value =
 is_integral<_Tp2>::value || is_enum<_Tp2>::value;
    };

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename... _Args2, typename = typename
               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        explicit
        _Bind_simple(const _Callable& __callable, _Args2&&... __args)
        : _M_bound(__callable, std::forward<_Args2>(__args)...)
        { }

      template<typename... _Args2, typename = typename
               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        explicit
        _Bind_simple(_Callable&& __callable, _Args2&&... __args)
        : _M_bound(std::move(__callable), std::forward<_Args2>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:

      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;
  };






  template<typename _Tp>
    struct __is_location_invariant
    : integral_constant<bool, (is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {





     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp*& __fp)
   { return __fp; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* const& __mp)
   { return __mp; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

    public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {





     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {

   _Base::_M_init_functor(__functor, &__f.get());
 }
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return __callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 __callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

     public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {





   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      struct _Useless { };

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 2060 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      function(const function& __x);
# 2069 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
# 2092 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      template<typename _Functor>
 function(_Functor __f,
   typename enable_if<
      !is_integral<_Functor>::value, _Useless>::type
     = _Useless());
# 2110 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 2128 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 2142 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      function&
      operator=(nullptr_t)
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = 0;
     _M_invoker = 0;
   }
 return *this;
      }
# 2170 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      template<typename _Functor>
 typename enable_if<!is_integral<_Functor>::value, function&>::type
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 typename enable_if<!is_integral<_Functor>::value, function&>::type
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 2196 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 2224 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 2237 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
      _Res operator()(_ArgTypes... __args) const;
# 2267 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
    private:
      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f,
        typename enable_if<
   !is_integral<_Functor>::value, _Useless>::type)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }
# 2375 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 2393 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 2411 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/functional" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}
# 69 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
    {

     


      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__a, __b);
   else if (*__a < *__c)
     std::iter_swap(__a, __c);
 }
      else if (*__a < *__c)
 return;
      else if (*__b < *__c)
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }


  template<typename _Iterator, typename _Compare>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c,
   _Compare __comp)
    {

     



      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__a, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__a, __c);
 }
      else if (__comp(*__a, *__c))
 return;
      else if (__comp(*__b, *__c))
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 2:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 1:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if_not(__first, __last, __pred,
    std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!bool(__pred(*__first)))
   break;
      return __first;
    }
# 347 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 432 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 671 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 718 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 753 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 770 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 788 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 803 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last, __pred);
    }
# 826 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
# 844 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 897 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 934 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 973 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }


  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 1037 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 1065 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }
# 1115 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
# 1158 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
# 1198 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 1238 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = std::move(*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1466 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1493 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      _RandomAccessIterator __p = __first;

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
# 1699 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1735 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__inplace_stable_partition(__first, __pred, __len / 2);


      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);
      if (__right_len)
 __right_split = std::__inplace_stable_partition(__middle,
       __pred,
       __right_len);
      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }







  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;



   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }
   std::move(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __left_split =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);


   _Distance __right_len = __len - __len / 2;
   _ForwardIterator __right_split =
     std::__find_if_not_n(__middle, __right_len, __pred);
   if (__right_len)
     __right_split =
       std::__stable_partition_adaptive(__right_split, __last, __pred,
            __right_len,
            __buffer, __buffer_size);
   std::rotate(__left_split, __middle, __right_split);
   std::advance(__left_split, std::distance(__middle, __right_split));
   return __left_split;
 }
    }
# 1914 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1998 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2064 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1));
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1), __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2448 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     
                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2495 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2544 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     
                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2597 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
     
      ;
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2659 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

     
                    ;
     
                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val, __comp);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2720 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     
      ;
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2753 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     

     
                    ;
     
                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3177 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3232 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step, __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first,__first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3572 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3622 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3677 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3734 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3790 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3847 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3907 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3944 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3975 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3989 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }
# 4003 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (*__next < *__first)
   return __next;
      return __next;
    }
# 4032 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (__comp(*__next, *__first))
   return __next;
      return __next;
    }
# 4062 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _Tp>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 4082 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                       : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 4101 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (*__next < *__first)
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (*__first < *__min)
  __min = __first;
       else if (!(*__first < *__max))
  __max = __first;
       break;
     }

   if (*__next < *__first)
     {
       if (*__next < *__min)
  __min = __next;
       if (!(*__first < *__max))
  __max = __first;
     }
   else
     {
       if (*__first < *__min)
  __min = __first;
       if (!(*__next < *__max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 4177 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;

      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (__comp(*__next, *__first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(*__first, *__min))
  __min = __first;
       else if (!__comp(*__first, *__max))
  __max = __first;
       break;
     }

   if (__comp(*__next, *__first))
     {
       if (__comp(*__next, *__min))
  __min = __next;
       if (!__comp(*__first, *__max))
  __max = __first;
     }
   else
     {
       if (__comp(*__first, *__min))
  __min = __first;
       if (!__comp(*__next, *__max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }


  template<typename _Tp>
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }
# 4294 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {


      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::find(__first1, __scan, *__scan))
     continue;

   auto __matches = std::count(__first2, __last2, *__scan);
   if (0 == __matches
       || std::count(__scan, __last1, *__scan) != __matches)
     return false;
 }
      return true;
    }
# 4339 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__pred(*__first1, *__first2)))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   using std::placeholders::_1;

   if (__scan != std::find_if(__first1, __scan,
      std::bind(__pred, _1, *__scan)))
     continue;

   auto __matches = std::count_if(__first2, __last2,
      std::bind(__pred, _1, *__scan));
   if (0 == __matches
       || std::count_if(__scan, __last1,
          std::bind(__pred, _1, *__scan)) != __matches)
     return false;
 }
      return true;
    }
# 4389 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







# 4434 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
# 4455 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4479 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4509 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4549 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4581 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4613 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4645 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4670 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4712 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4783 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4858 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4895 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4937 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4974 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 5007 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 5039 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 5071 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 5102 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 5139 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 5178 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 5210 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 5238 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 5274 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5308 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5347 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5384 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5423 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5461 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5497 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5539 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5603 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5663 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5705 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5751 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5818 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5885 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5942 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 6000 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 6061 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 6119 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 6185 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 6242 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6270 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6298 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6326 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }


}
# 64 "/tools/gcc-4.7.2-0moz1/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/algorithm" 2 3
# 4 "../../dist/system_wrappers/algorithm" 2 3
#pragma GCC visibility pop
# 56 "../../dist/stl_wrappers/algorithm" 2 3
#pragma GCC visibility pop
# 13 "../../dist/include/GeckoProfilerImpl.h" 2







# 1 "../../dist/include/GeckoProfilerFunc.h" 1
# 14 "../../dist/include/GeckoProfilerFunc.h"
using mozilla::TimeStamp;
using mozilla::TimeDuration;



inline void* mozilla_sampler_call_enter(const char *aInfo, void *aFrameAddress = __null,
                                        bool aCopy = false, uint32_t line = 0);
inline void mozilla_sampler_call_exit(void* handle);
inline void mozilla_sampler_add_marker(const char *aInfo);

void mozilla_sampler_start(int aEntries, int aInterval, const char** aFeatures,
                            uint32_t aFeatureCount);

void mozilla_sampler_stop();

bool mozilla_sampler_is_active();

void mozilla_sampler_responsiveness(const TimeStamp& time);

void mozilla_sampler_frame_number(int frameNumber);

const double* mozilla_sampler_get_responsiveness();

void mozilla_sampler_save();

char* mozilla_sampler_get_profile();

JSObject *mozilla_sampler_get_profile_data(JSContext *aCx);

const char** mozilla_sampler_get_features();

void mozilla_sampler_init();

void mozilla_sampler_shutdown();

void mozilla_sampler_print_location1();
void mozilla_sampler_print_location2();




void mozilla_sampler_lock();


void mozilla_sampler_unlock();


extern bool sps_version2();
# 21 "../../dist/include/GeckoProfilerImpl.h" 2
# 1 "../../dist/include/PseudoStack.h" 1
# 12 "../../dist/include/PseudoStack.h"
# 1 "../../dist/system_wrappers/stdlib.h" 1
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 13 "../../dist/include/PseudoStack.h" 2
# 78 "../../dist/include/PseudoStack.h"
class StackEntry : public js::ProfileEntry
{
public:

  bool isCopyLabel() volatile {
    return !((uintptr_t)stackAddress() & 0x1);
  }

  void setStackAddressCopy(void *sparg, bool copy) volatile {





    if (copy) {
      setStackAddress(reinterpret_cast<void*>(
                        reinterpret_cast<uintptr_t>(sparg) & ~0x1));
    } else {
      setStackAddress(reinterpret_cast<void*>(
                        reinterpret_cast<uintptr_t>(sparg) | 0x1));
    }
  }
};



struct PseudoStack
{
public:
  PseudoStack()
    : mStackPointer(0)
    , mSignalLock(false)
    , mMarkerPointer(0)
    , mQueueClearMarker(false)
    , mRuntime(nullptr)
    , mStartJSSampling(false)
  { }

  void addMarker(const char *aMarker)
  {
    char* markerCopy = moz_strdup(aMarker);
    mSignalLock = true;
    asm volatile("" ::: "memory");;

    if (mQueueClearMarker) {
      clearMarkers();
    }
    if (!aMarker) {
      return;
    }
    if (size_t(mMarkerPointer) == mozilla::ArrayLength(mMarkers)) {
      return;
    }
    mMarkers[mMarkerPointer] = markerCopy;
    mMarkerPointer++;

    mSignalLock = false;
    asm volatile("" ::: "memory");;
  }


  const char* getMarker(int aMarkerId)
  {







    if (mSignalLock || mQueueClearMarker || aMarkerId < 0 ||
      static_cast<mozilla::sig_safe_t>(aMarkerId) >= mMarkerPointer) {
      return nullptr;
    }
    return mMarkers[aMarkerId];
  }


  void clearMarkers()
  {
    for (mozilla::sig_safe_t i = 0; i < mMarkerPointer; i++) {
      free(mMarkers[i]);
    }
    mMarkerPointer = 0;
    mQueueClearMarker = false;
  }

  void push(const char *aName, uint32_t line)
  {
    push(aName, nullptr, false, line);
  }

  void push(const char *aName, void *aStackAddress, bool aCopy, uint32_t line)
  {
    if (size_t(mStackPointer) >= mozilla::ArrayLength(mStack)) {
      mStackPointer++;
      return;
    }



    mStack[mStackPointer].setLabel(aName);
    mStack[mStackPointer].setStackAddressCopy(aStackAddress, aCopy);
    mStack[mStackPointer].setLine(line);


    asm volatile("" ::: "memory");;
    mStackPointer++;
  }
  void pop()
  {
    mStackPointer--;
  }
  bool isEmpty()
  {
    return mStackPointer == 0;
  }
  uint32_t stackSize() const
  {
    return std::min<uint32_t>(mStackPointer, mozilla::sig_safe_t(mozilla::ArrayLength(mStack)));
  }

  void sampleRuntime(JSRuntime *runtime) {
    mRuntime = runtime;
    if (!runtime) {

      return;
    }

    static_assert((sizeof(mStack[0]) == sizeof(js::ProfileEntry)), "JS_STATIC_ASSERT");
    js::SetRuntimeProfilingStack(runtime,
                                 (js::ProfileEntry*) mStack,
                                 (uint32_t*) &mStackPointer,
                                 uint32_t(mozilla::ArrayLength(mStack)));
    if (mStartJSSampling)
      enableJSSampling();
  }
  void enableJSSampling() {
    if (mRuntime) {
      js::EnableRuntimeProfilingStack(mRuntime, true);
      mStartJSSampling = false;
    } else {
      mStartJSSampling = true;
    }
  }
  void disableJSSampling() {
    mStartJSSampling = false;
    if (mRuntime)
      js::EnableRuntimeProfilingStack(mRuntime, false);
  }


  StackEntry volatile mStack[1024];

  char* mMarkers[1024];
 private:


  mozilla::sig_safe_t mStackPointer;

  volatile bool mSignalLock;
 public:
  volatile mozilla::sig_safe_t mMarkerPointer;


  volatile mozilla::sig_safe_t mQueueClearMarker;

  JSRuntime *mRuntime;

  bool mStartJSSampling;
};
# 22 "../../dist/include/GeckoProfilerImpl.h" 2
# 36 "../../dist/include/GeckoProfilerImpl.h"
struct PseudoStack;
class TableTicker;
class JSCustomObject;

extern mozilla::ThreadLocal<PseudoStack *> tlsPseudoStack;
extern mozilla::ThreadLocal<TableTicker *> tlsTicker;
extern bool stack_key_initialized;
# 54 "../../dist/include/GeckoProfilerImpl.h"
static inline
void profiler_init()
{
  mozilla_sampler_init();
}

static inline
void profiler_shutdown()
{
  mozilla_sampler_shutdown();
}

static inline
void profiler_start(int aProfileEntries, int aInterval,
                       const char** aFeatures, uint32_t aFeatureCount)
{
  mozilla_sampler_start(aProfileEntries, aInterval, aFeatures, aFeatureCount);
}

static inline
void profiler_stop()
{
  mozilla_sampler_stop();
}

static inline
bool profiler_is_active()
{
  return mozilla_sampler_is_active();
}

static inline
void profiler_responsiveness(const TimeStamp& aTime)
{
  mozilla_sampler_responsiveness(aTime);
}

static inline
const double* profiler_get_responsiveness()
{
  return mozilla_sampler_get_responsiveness();
}

static inline
void profiler_set_frame_number(int frameNumber)
{
  return mozilla_sampler_frame_number(frameNumber);
}

static inline
char* profiler_get_profile()
{
  return mozilla_sampler_get_profile();
}

static inline
JSObject* profiler_get_profile_jsobject(JSContext* aCx)
{
  return mozilla_sampler_get_profile_data(aCx);
}

static inline
const char** profiler_get_features()
{
  return mozilla_sampler_get_features();
}

static inline
void profiler_print_location()
{
  if (!sps_version2()) {
    return mozilla_sampler_print_location1();
  } else {
    return mozilla_sampler_print_location2();
  }
}

static inline
void profiler_lock()
{
  return mozilla_sampler_lock();
}

static inline
void profiler_unlock()
{
  return mozilla_sampler_unlock();
}
# 194 "../../dist/include/GeckoProfilerImpl.h"
namespace mozilla {

class SamplerStackFrameRAII {
public:

  SamplerStackFrameRAII(const char *aInfo, uint32_t line) {
    mHandle = mozilla_sampler_call_enter(aInfo, this, false, line);
  }
  ~SamplerStackFrameRAII() {
    mozilla_sampler_call_exit(mHandle);
  }
private:
  void* mHandle;
};

static const int SAMPLER_MAX_STRING = 128;
class SamplerStackFramePrintfRAII {
public:

  SamplerStackFramePrintfRAII(const char *aDefault, uint32_t line, const char *aFormat, ...) {
    if (profiler_is_active()) {
      va_list args;
      __builtin_va_start(args,aFormat);
      char buff[SAMPLER_MAX_STRING];







      vsnprintf(buff, SAMPLER_MAX_STRING, aFormat, args);
      snprintf(mDest, SAMPLER_MAX_STRING, "%s %s", aDefault, buff);

      mHandle = mozilla_sampler_call_enter(mDest, this, true, line);
      __builtin_va_end(args);
    } else {
      mHandle = mozilla_sampler_call_enter(aDefault, __null, false, line);
    }
  }
  ~SamplerStackFramePrintfRAII() {
    mozilla_sampler_call_exit(mHandle);
  }
private:
  char mDest[SAMPLER_MAX_STRING];
  void* mHandle;
};

}

inline PseudoStack* mozilla_get_pseudo_stack(void)
{
  if (!stack_key_initialized)
    return __null;
  return tlsPseudoStack.get();
}

inline void* mozilla_sampler_call_enter(const char *aInfo, void *aFrameAddress,
                                        bool aCopy, uint32_t line)
{


  if (!stack_key_initialized)
    return __null;

  PseudoStack *stack = tlsPseudoStack.get();




  if (!stack) {
    return stack;
  }
  stack->push(aInfo, aFrameAddress, aCopy, line);






  return stack;
}

inline void mozilla_sampler_call_exit(void *aHandle)
{
  if (!aHandle)
    return;

  PseudoStack *stack = (PseudoStack*)aHandle;
  stack->pop();
}

inline void mozilla_sampler_add_marker(const char *aMarker)
{
  if (!stack_key_initialized)
    return;



  if (!profiler_is_active()) {
    return;
  }

  PseudoStack *stack = tlsPseudoStack.get();
  if (!stack) {
    return;
  }
  stack->addMarker(aMarker);
}
# 141 "../../dist/include/GeckoProfiler.h" 2
# 27 "../../dist/include/mozilla/StartupTimeline.h" 2
# 40 "../../dist/include/mozilla/StartupTimeline.h"
namespace mozilla {

void RecordShutdownEndTimeStamp();
void RecordShutdownStartTimeStamp();

class StartupTimeline {
public:
  enum Event {

# 1 "../../dist/include/mozilla/StartupTimeline.h" 1 3





PROCESS_CREATION,
START,
MAIN,


STARTUP_CRASH_DETECTION_BEGIN,
STARTUP_CRASH_DETECTION_END,
FIRST_PAINT,
SESSION_RESTORED,
CREATE_TOP_LEVEL_WINDOW,
LINKER_INITIALIZED,
LIBRARIES_LOADED,
FIRST_LOAD_URI,
# 50 "../../dist/include/mozilla/StartupTimeline.h" 2

    MAX_EVENT_ID
  };

  static PRTime Get(Event ev) {
    return sStartupTimeline[ev];
  }

  static const char *Describe(Event ev) {
    return sStartupTimelineDesc[ev];
  }

  static void Record(Event ev) {
    mozilla_sampler_add_marker(Describe(ev));
    Record(ev, PR_Now());
  }

  static void Record(Event ev, PRTime when) {
    sStartupTimeline[ev] = when;




  }

  static void RecordOnce(Event ev) {
    if (!HasRecord(ev))
      Record(ev);
  }

  static bool HasRecord(Event ev) {
    return sStartupTimeline[ev];
  }

private:
  static __attribute__ ((visibility ("default"))) PRTime sStartupTimeline[MAX_EVENT_ID];
  static __attribute__ ((visibility ("default"))) const char * sStartupTimelineDesc[MAX_EVENT_ID];
};

}
# 12 "../../dist/include/mozilla/Telemetry.h" 2

# 1 "../../dist/include/nsStringGlue.h" 1
# 14 "../../dist/include/mozilla/Telemetry.h" 2

# 1 "../../dist/include/shared-libraries.h" 1
# 17 "../../dist/include/shared-libraries.h"
# 1 "../../dist/system_wrappers/stdlib.h" 1
       
# 2 "../../dist/system_wrappers/stdlib.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 18 "../../dist/include/shared-libraries.h" 2

# 1 "../../dist/include/nsID.h" 1
# 20 "../../dist/include/shared-libraries.h" 2

class SharedLibrary {
public:

  SharedLibrary(uintptr_t aStart,
                uintptr_t aEnd,
                uintptr_t aOffset,
                const std::string& aBreakpadId,
                const std::string& aName)
    : mStart(aStart)
    , mEnd(aEnd)
    , mOffset(aOffset)
    , mBreakpadId(aBreakpadId)
    , mName(aName)
  {}

  SharedLibrary(const SharedLibrary& aEntry)
    : mStart(aEntry.mStart)
    , mEnd(aEntry.mEnd)
    , mOffset(aEntry.mOffset)
    , mBreakpadId(aEntry.mBreakpadId)
    , mName(aEntry.mName)
  {}

  SharedLibrary& operator=(const SharedLibrary& aEntry)
  {

    if (this == &aEntry) return *this;

    mStart = aEntry.mStart;
    mEnd = aEntry.mEnd;
    mOffset = aEntry.mOffset;
    mBreakpadId = aEntry.mBreakpadId;
    mName = aEntry.mName;
    return *this;
  }

  bool operator==(const SharedLibrary& other) const
  {
    return (mStart == other.mStart) &&
           (mEnd == other.mEnd) &&
           (mOffset == other.mOffset) &&
           (mName == other.mName) &&
           (mBreakpadId == other.mBreakpadId);
  }

  uintptr_t GetStart() const { return mStart; }
  uintptr_t GetEnd() const { return mEnd; }
  uintptr_t GetOffset() const { return mOffset; }
  const std::string &GetBreakpadId() const { return mBreakpadId; }
  const std::string &GetName() const { return mName; }

private:
  SharedLibrary() {}

  uintptr_t mStart;
  uintptr_t mEnd;
  uintptr_t mOffset;
  std::string mBreakpadId;
  std::string mName;
};

static bool
CompareAddresses(const SharedLibrary& first, const SharedLibrary& second)
{
  return first.GetStart() < second.GetStart();
}

class SharedLibraryInfo {
public:
  static SharedLibraryInfo GetInfoForSelf();
  SharedLibraryInfo() {}

  void AddSharedLibrary(SharedLibrary entry)
  {
    mEntries.push_back(entry);
  }

  const SharedLibrary& GetEntry(size_t i) const
  {
    return mEntries[i];
  }



  void RemoveEntries(size_t first, size_t last)
  {
    mEntries.erase(mEntries.begin() + first, mEntries.begin() + last);
  }

  bool Contains(const SharedLibrary& searchItem) const
  {
    return (mEntries.end() !=
              std::find(mEntries.begin(), mEntries.end(), searchItem));
  }

  size_t GetSize() const
  {
    return mEntries.size();
  }

  void SortByAddress()
  {
    std::sort(mEntries.begin(), mEntries.end(), CompareAddresses);
  }

  void Clear()
  {
    mEntries.clear();
  }

private:
  std::vector<SharedLibrary> mEntries;
};
# 16 "../../dist/include/mozilla/Telemetry.h" 2


namespace base {
  class Histogram;
}

namespace mozilla {
namespace Telemetry {

# 1 "../../dist/include/mozilla/TelemetryHistogramEnums.h" 1 3


enum ID {
  A11Y_INSTANTIATED_FLAG,
  A11Y_CONSUMERS,
  A11Y_ISIMPLEDOM_USAGE_FLAG,
  A11Y_IATABLE_USAGE_FLAG,
  A11Y_UPDATE_TIME,
  BACKGROUNDFILESAVER_THREAD_COUNT,
  CYCLE_COLLECTOR,
  CYCLE_COLLECTOR_FULL,
  CYCLE_COLLECTOR_FINISH_IGC,
  CYCLE_COLLECTOR_SYNC_SKIPPABLE,
  CYCLE_COLLECTOR_VISITED_REF_COUNTED,
  CYCLE_COLLECTOR_VISITED_GCED,
  CYCLE_COLLECTOR_COLLECTED,
  CYCLE_COLLECTOR_NEED_GC,
  CYCLE_COLLECTOR_TIME_BETWEEN,
  CYCLE_COLLECTOR_CONTENT_UNBIND,
  FORGET_SKIPPABLE_MAX,
  GC_REASON_2,
  GC_IS_COMPARTMENTAL,
  GC_MS,
  GC_MAX_PAUSE_MS,
  GC_MARK_MS,
  GC_SWEEP_MS,
  GC_MARK_ROOTS_MS,
  GC_MARK_GRAY_MS,
  GC_SLICE_MS,
  GC_MMU_50,
  GC_RESET,
  GC_INCREMENTAL_DISABLED,
  GC_NON_INCREMENTAL,
  GC_SCC_SWEEP_TOTAL_MS,
  GC_SCC_SWEEP_MAX_PAUSE_MS,
  TELEMETRY_PING,
  TELEMETRY_SUCCESS,
  MEMORY_RESIDENT,
  MEMORY_VSIZE,
  MEMORY_JS_COMPARTMENTS_SYSTEM,
  MEMORY_JS_COMPARTMENTS_USER,
  MEMORY_JS_MAIN_RUNTIME_TEMPORARY_PEAK,
  MEMORY_JS_GC_HEAP,
  MEMORY_STORAGE_SQLITE,
  MEMORY_IMAGES_CONTENT_USED_UNCOMPRESSED,
  MEMORY_HEAP_ALLOCATED,
  MEMORY_HEAP_COMMITTED_UNUSED,
  MEMORY_HEAP_COMMITTED_UNUSED_RATIO,
  MEMORY_EXPLICIT,
  GHOST_WINDOWS,
# 76 "../../dist/include/mozilla/TelemetryHistogramEnums.h" 3
  EARLY_GLUESTARTUP_HARD_FAULTS,


  GLUESTARTUP_HARD_FAULTS,


  PAGE_FAULTS_HARD,

  FONTLIST_INITOTHERFAMILYNAMES,
  FONTLIST_INITFACENAMELISTS,
# 116 "../../dist/include/mozilla/TelemetryHistogramEnums.h" 3
  SYSTEM_FONT_FALLBACK,
  SYSTEM_FONT_FALLBACK_FIRST,
  SYSTEM_FONT_FALLBACK_SCRIPT,
  GRADIENT_DURATION,
  GRADIENT_RETENTION_TIME,
  STARTUP_CACHE_AGE_HOURS,
  STARTUP_CACHE_INVALID,
  WORD_CACHE_HITS_CONTENT,
  WORD_CACHE_HITS_CHROME,
  WORD_CACHE_MISSES_CONTENT,
  WORD_CACHE_MISSES_CHROME,
  FONT_CACHE_HIT,
  BAD_FALLBACK_FONT,
  SHUTDOWN_OK,
  IMAGE_DECODE_LATENCY_US,
  IMAGE_DECODE_TIME,
  IMAGE_DECODE_ON_DRAW_LATENCY,
  IMAGE_DECODE_CHUNKS,
  IMAGE_DECODE_COUNT,
  IMAGE_MAX_DECODE_COUNT,
  IMAGE_DECODE_SPEED_JPEG,
  IMAGE_DECODE_SPEED_GIF,
  IMAGE_DECODE_SPEED_PNG,
  CANVAS_2D_USED,
  CANVAS_WEBGL_USED,
  TOTAL_CONTENT_PAGE_LOAD_TIME,
  HTTP_SUBITEM_OPEN_LATENCY_TIME,
  HTTP_SUBITEM_FIRST_BYTE_LATENCY_TIME,
  HTTP_REQUEST_PER_PAGE,
  HTTP_REQUEST_PER_PAGE_FROM_CACHE,
  HTTP_REQUEST_PER_CONN,
  HTTP_KBREAD_PER_CONN,
  HTTP_PAGE_DNS_ISSUE_TIME,
  HTTP_PAGE_DNS_LOOKUP_TIME,
  HTTP_PAGE_TCP_CONNECTION,
  HTTP_PAGE_OPEN_TO_FIRST_SENT,
  HTTP_PAGE_FIRST_SENT_TO_LAST_RECEIVED,
  HTTP_PAGE_OPEN_TO_FIRST_RECEIVED,
  HTTP_PAGE_OPEN_TO_FIRST_FROM_CACHE,
  HTTP_PAGE_CACHE_READ_TIME,
  HTTP_PAGE_REVALIDATION,
  HTTP_PAGE_COMPLETE_LOAD,
  HTTP_PAGE_COMPLETE_LOAD_CACHED,
  HTTP_PAGE_COMPLETE_LOAD_NET,
  HTTP_SUB_DNS_ISSUE_TIME,
  HTTP_SUB_DNS_LOOKUP_TIME,
  HTTP_SUB_TCP_CONNECTION,
  HTTP_SUB_OPEN_TO_FIRST_SENT,
  HTTP_SUB_FIRST_SENT_TO_LAST_RECEIVED,
  HTTP_SUB_OPEN_TO_FIRST_RECEIVED,
  HTTP_SUB_OPEN_TO_FIRST_FROM_CACHE,
  HTTP_SUB_CACHE_READ_TIME,
  HTTP_SUB_REVALIDATION,
  HTTP_SUB_COMPLETE_LOAD,
  HTTP_SUB_COMPLETE_LOAD_CACHED,
  HTTP_SUB_COMPLETE_LOAD_NET,
  HTTP_PROXY_TYPE,
  HTTP_TRANSACTION_IS_SSL,
  HTTP_PAGELOAD_IS_SSL,
  SSL_HANDSHAKE_VERSION,
  SSL_TIME_UNTIL_READY,
  SSL_BYTES_BEFORE_CERT_CALLBACK,
  SSL_NPN_TYPE,
  SSL_RESUMED_SESSION,
  CERT_VALIDATION_HTTP_REQUEST_RESULT,
  CERT_VALIDATION_HTTP_REQUEST_CANCELED_TIME,
  CERT_VALIDATION_HTTP_REQUEST_SUCCEEDED_TIME,
  CERT_VALIDATION_HTTP_REQUEST_FAILED_TIME,
  SSL_KEY_EXCHANGE_ALGORITHM,
  WEBSOCKETS_HANDSHAKE_TYPE,
  SPDY_VERSION2,
  SPDY_PARALLEL_STREAMS,
  SPDY_REQUEST_PER_CONN,
  SPDY_SERVER_INITIATED_STREAMS,
  SPDY_CHUNK_RECVD,
  SPDY_SYN_SIZE,
  SPDY_SYN_RATIO,
  SPDY_SYN_REPLY_SIZE,
  SPDY_SYN_REPLY_RATIO,
  SPDY_NPN_CONNECT,
  SPDY_NPN_JOIN,
  SPDY_KBREAD_PER_CONN,
  SPDY_SETTINGS_UL_BW,
  SPDY_SETTINGS_DL_BW,
  SPDY_SETTINGS_RTT,
  SPDY_SETTINGS_MAX_STREAMS,
  SPDY_SETTINGS_CWND,
  SPDY_SETTINGS_RETRANS,
  SPDY_SETTINGS_IW,
  DISK_CACHE_CORRUPT_DETAILS,
  DISK_CACHE_REDUCTION_TRIAL,
  DISK_CACHE_REVALIDATION_SAFE,
  DISK_CACHE_INVALIDATION_SUCCESS,
  DISK_CACHE_REVALIDATION_SUCCESS,
  HTTP_CACHE_DISPOSITION_2,
  HTTP_DISK_CACHE_DISPOSITION_2,
  HTTP_MEMORY_CACHE_DISPOSITION_2,
  HTTP_OFFLINE_CACHE_DISPOSITION_2,
  CACHE_DEVICE_SEARCH_2,
  CACHE_MEMORY_SEARCH_2,
  CACHE_DISK_SEARCH_2,
  CACHE_OFFLINE_SEARCH_2,
  TRANSACTION_WAIT_TIME_HTTP,
  TRANSACTION_WAIT_TIME_HTTP_PIPELINES,
  TRANSACTION_WAIT_TIME_SPDY,
  HTTP_DISK_CACHE_OVERHEAD,
  CACHE_LM_INCONSISTENT,
  CACHE_SERVICE_LOCK_WAIT_2,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_2,
  DISK_CACHE_SMART_SIZE_USING_OLD_MAX,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSSETDISKSMARTSIZECALLBACK_NOTIFY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSPROCESSREQUESTEVENT_RUN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSOUTPUTSTREAMWRAPPER_LAZYINIT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSOUTPUTSTREAMWRAPPER_CLOSEINTERNAL,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSOUTPUTSTREAMWRAPPER_RELEASE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCOMPRESSOUTPUTSTREAMWRAPPER_RELEASE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSINPUTSTREAMWRAPPER_LAZYINIT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSINPUTSTREAMWRAPPER_CLOSEINTERNAL,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSINPUTSTREAMWRAPPER_RELEASE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDECOMPRESSINPUTSTREAMWRAPPER_RELEASE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSEVICTDISKCACHEENTRIESEVENT_RUN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDOOMEVENT_RUN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDISKCACHESTREAMIO_WRITE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDISKCACHESTREAMIO_CLOSEOUTPUTSTREAM,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDISKCACHEDEVICEDEACTIVATEENTRYEVENT_RUN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDISKCACHEBINDING_DESTRUCTOR,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SHUTDOWN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETOFFLINECACHEENABLED,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETOFFLINECACHECAPACITY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETMEMORYCACHE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETDISKSMARTSIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETDISKCACHEMAXENTRYSIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETMEMORYCACHEMAXENTRYSIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETDISKCACHEENABLED,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_SETDISKCACHECAPACITY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_OPENCACHEENTRY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_ONPROFILESHUTDOWN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_ONPROFILECHANGED,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_LEAVEPRIVATEBROWSING,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_ISSTORAGEENABLEDFORPOLICY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_GETCACHEIOTARGET,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_EVICTENTRIESFORCLIENT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_DISKDEVICEHEAPSIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_CLOSEALLSTREAMS,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_DOOM,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETPREDICTEDDATASIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETDATASIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETSTORAGEDATASIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_REQUESTDATASIZECHANGE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETDATASIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_OPENINPUTSTREAM,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_OPENOUTPUTSTREAM,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETCACHEELEMENT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETCACHEELEMENT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETSTORAGEPOLICY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETSTORAGEPOLICY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETFILE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETSECURITYINFO,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETSECURITYINFO,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_DOOMANDFAILPENDINGREQUESTS,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_MARKVALID,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_CLOSE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETMETADATAELEMENT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETMETADATAELEMENT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_VISITMETADATA,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_SETEXPIRATIONTIME,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_ISSTREAMBASED,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETLASTMODIFIED,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETEXPIRATIONTIME,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETKEY,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETFETCHCOUNT,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETDEVICEID,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_PROCESSREQUEST,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHESERVICE_VISITENTRIES,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETPREDICTEDDATASIZE,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETLASTFETCHED,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSCACHEENTRYDESCRIPTOR_GETCLIENTID,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSBLOCKONCACHETHREADEVENT_RUN,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDISKCACHEMAP_REVALIDATION,
  CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSASYNCDOOMEVENT_RUN,
  DNS_LOOKUP_METHOD2,
  DNS_CLEANUP_AGE,
  DNS_LOOKUP_TIME,
  DNS_RENEWAL_TIME,
  DNS_FAILED_LOOKUP_TIME,
  FIND_PLUGINS,
  CHECK_JAVA_ENABLED,
  PLUGIN_HANG_UI_USER_RESPONSE,
  PLUGIN_HANG_UI_DONT_ASK,
  PLUGIN_HANG_UI_RESPONSE_TIME,
  PLUGIN_HANG_TIME,
  PLUGIN_SHUTDOWN_MS,
  PLUGIN_CALLED_DIRECTLY,
  MOZ_SQLITE_OPEN_MS,
  MOZ_SQLITE_OPEN_MAIN_THREAD_MS,
  MOZ_SQLITE_TRUNCATE_MS,
  MOZ_SQLITE_TRUNCATE_MAIN_THREAD_MS,
  MOZ_SQLITE_OTHER_READ_MS,
  MOZ_SQLITE_OTHER_READ_MAIN_THREAD_MS,
  MOZ_SQLITE_PLACES_READ_MS,
  MOZ_SQLITE_PLACES_READ_MAIN_THREAD_MS,
  MOZ_SQLITE_COOKIES_OPEN_MS,
  MOZ_SQLITE_COOKIES_OPEN_READAHEAD_MS,
  MOZ_SQLITE_COOKIES_READ_MS,
  MOZ_SQLITE_COOKIES_READ_MAIN_THREAD_MS,
  MOZ_SQLITE_WEBAPPS_READ_MS,
  MOZ_SQLITE_WEBAPPS_READ_MAIN_THREAD_MS,
  MOZ_SQLITE_OTHER_WRITE_MS,
  MOZ_SQLITE_OTHER_WRITE_MAIN_THREAD_MS,
  MOZ_SQLITE_PLACES_WRITE_MS,
  MOZ_SQLITE_PLACES_WRITE_MAIN_THREAD_MS,
  MOZ_SQLITE_COOKIES_WRITE_MS,
  MOZ_SQLITE_COOKIES_WRITE_MAIN_THREAD_MS,
  MOZ_SQLITE_WEBAPPS_WRITE_MS,
  MOZ_SQLITE_WEBAPPS_WRITE_MAIN_THREAD_MS,
  MOZ_SQLITE_OTHER_SYNC_MS,
  MOZ_SQLITE_OTHER_SYNC_MAIN_THREAD_MS,
  MOZ_SQLITE_PLACES_SYNC_MS,
  MOZ_SQLITE_PLACES_SYNC_MAIN_THREAD_MS,
  MOZ_SQLITE_COOKIES_SYNC_MS,
  MOZ_SQLITE_COOKIES_SYNC_MAIN_THREAD_MS,
  MOZ_SQLITE_WEBAPPS_SYNC_MS,
  MOZ_SQLITE_WEBAPPS_SYNC_MAIN_THREAD_MS,
  MOZ_SQLITE_OTHER_READ_B,
  MOZ_SQLITE_PLACES_READ_B,
  MOZ_SQLITE_COOKIES_READ_B,
  MOZ_SQLITE_WEBAPPS_READ_B,
  MOZ_SQLITE_PLACES_WRITE_B,
  MOZ_SQLITE_COOKIES_WRITE_B,
  MOZ_SQLITE_WEBAPPS_WRITE_B,
  MOZ_SQLITE_OTHER_WRITE_B,
  MOZ_STORAGE_ASYNC_REQUESTS_MS,
  MOZ_STORAGE_ASYNC_REQUESTS_SUCCESS,
  STARTUP_MEASUREMENT_ERRORS,
  NETWORK_DISK_CACHE_OPEN,
  NETWORK_DISK_CACHE_TRASHRENAME,
  NETWORK_DISK_CACHE_DELETEDIR,
  NETWORK_DISK_CACHE_DELETEDIR_SHUTDOWN,
  NETWORK_DISK_CACHE_SHUTDOWN,
  NETWORK_DISK_CACHE_SHUTDOWN_CLEAR_PRIVATE,
  NETWORK_DISK_CACHE_REVALIDATION,
  NETWORK_DISK_CACHE_STREAMIO_CLOSE,
  NETWORK_DISK_CACHE_STREAMIO_CLOSE_MAIN_THREAD,
  HTTP_TRANSACTION_TIME_CONNFAST_CACHEON,
  HTTP_TRANSACTION_TIME_CONNFAST_CACHEOFF,
  HTTP_TRANSACTION_TIME_CONNSLOW_CACHEON,
  HTTP_TRANSACTION_TIME_CONNSLOW_CACHEOFF,
  IDLE_NOTIFY_BACK_MS,
  IDLE_NOTIFY_BACK_LISTENERS,
  IDLE_NOTIFY_IDLE_MS,
  IDLE_NOTIFY_IDLE_LISTENERS,
  URLCLASSIFIER_LOOKUP_TIME,
  URLCLASSIFIER_CL_CHECK_TIME,
  URLCLASSIFIER_CL_UPDATE_TIME,
  URLCLASSIFIER_PS_FILELOAD_TIME,
  URLCLASSIFIER_PS_FALLOCATE_TIME,
  URLCLASSIFIER_PS_CONSTRUCT_TIME,
  URLCLASSIFIER_LC_PREFIXES,
  URLCLASSIFIER_LC_COMPLETIONS,
  URLCLASSIFIER_PS_FAILURE,
  PLACES_PAGES_COUNT,
  PLACES_BOOKMARKS_COUNT,
  PLACES_TAGS_COUNT,
  PLACES_FOLDERS_COUNT,
  PLACES_KEYWORDS_COUNT,






  PLACES_SORTED_BOOKMARKS_PERC,
  PLACES_TAGGED_BOOKMARKS_PERC,
  PLACES_DATABASE_FILESIZE_MB,
  PLACES_DATABASE_JOURNALSIZE_MB,
  PLACES_DATABASE_PAGESIZE_B,
  PLACES_DATABASE_SIZE_PER_PAGE_B,
  PLACES_EXPIRATION_STEPS_TO_CLEAN2,
  PLACES_AUTOCOMPLETE_1ST_RESULT_TIME_MS,
  PLACES_AUTOCOMPLETE_URLINLINE_DOMAIN_QUERY_TIME_MS,
  PLACES_IDLE_FRECENCY_DECAY_TIME_MS,
  PLACES_IDLE_MAINTENANCE_TIME_MS,
  PLACES_ANNOS_BOOKMARKS_COUNT,
  PLACES_ANNOS_BOOKMARKS_SIZE_KB,
  PLACES_ANNOS_PAGES_COUNT,
  PLACES_ANNOS_PAGES_SIZE_KB,
  PLACES_FRECENCY_CALC_TIME_MS,
  UPDATER_STATUS_CODES,
  UPDATER_UPDATES_ENABLED,
  UPDATER_UPDATES_AUTOMATIC,
  UPDATER_SERVICE_ENABLED,
  UPDATER_SERVICE_ERRORS,
  UPDATER_SERVICE_INSTALLED,
  UPDATER_SERVICE_MANUALLY_UNINSTALLED,
  UPDATER_STAGE_ENABLED,
  UPDATER_HAS_PERMISSIONS,
  THUNDERBIRD_GLODA_SIZE_MB,
  THUNDERBIRD_CONVERSATIONS_TIME_TO_2ND_GLODA_QUERY_MS,
  THUNDERBIRD_INDEXING_RATE_MSG_PER_S,
  FX_TAB_ANIM_OPEN_MS,
  FX_TAB_ANIM_CLOSE_MS,
  FX_TAB_ANIM_OPEN_PREVIEW_FRAME_INTERVAL_MS,
  FX_TAB_ANIM_OPEN_PREVIEW_FRAME_PAINT_MS,
  FX_TAB_ANIM_OPEN_FRAME_INTERVAL_MS,
  FX_TAB_ANIM_OPEN_FRAME_PAINT_MS,
  FX_TAB_ANIM_ANY_FRAME_INTERVAL_MS,
  FX_TAB_ANIM_ANY_FRAME_PAINT_MS,
  FX_TAB_SWITCH_UPDATE_MS,
  FX_TAB_SWITCH_TOTAL_MS,
  FX_TAB_CLICK_MS,
  FX_KEYWORD_URL_USERSET,
  FX_IDENTITY_POPUP_OPEN_MS,
  FX_APP_MENU_OPEN_MS,
  FX_BOOKMARKS_TOOLBAR_INIT_MS,
  FX_NEW_WINDOW_MS,
  FX_PAGE_LOAD_MS,
  FX_THUMBNAILS_CAPTURE_TIME_MS,
  FX_THUMBNAILS_STORE_TIME_MS,
  FX_THUMBNAILS_HIT_OR_MISS,
  EVENTLOOP_UI_LAG_EXP_MS,
  FX_SESSION_RESTORE_COLLECT_DATA_MS,
  FX_SESSION_RESTORE_COLLECT_DATA_LONGEST_OP_MS,
  FX_SESSION_RESTORE_SERIALIZE_DATA_MS,
  FX_SESSION_RESTORE_SERIALIZE_DATA_LONGEST_OP_MS,
  FX_SESSION_RESTORE_READ_FILE_MS,
  FX_SESSION_RESTORE_SYNC_READ_FILE_MS,
  FX_SESSION_RESTORE_WRITE_FILE_MS,
  FX_SESSION_RESTORE_WRITE_FILE_LONGEST_OP_MS,
  FX_SESSION_RESTORE_CORRUPT_FILE,
  FX_SESSION_RESTORE_BACKUP_FILE_MS,
  INNERWINDOWS_WITH_MUTATION_LISTENERS,
  CHARSET_OVERRIDE_SITUATION,
  CHARSET_OVERRIDE_USED,
  XUL_FOREGROUND_REFLOW_MS,
  XUL_BACKGROUND_REFLOW_MS,
  HTML_FOREGROUND_REFLOW_MS,
  HTML_BACKGROUND_REFLOW_MS,
  XUL_INITIAL_FRAME_CONSTRUCTION,
  XMLHTTPREQUEST_ASYNC_OR_SYNC,
  DOM_TIMERS_FIRED_PER_NATIVE_TIMEOUT,
  DOM_TIMERS_RECENTLY_SET,
  DOM_RANGE_DETACHED,
  LOCALDOMSTORAGE_GETALLKEYS_MS,
  LOCALDOMSTORAGE_GETVALUE_MS,
  LOCALDOMSTORAGE_SETVALUE_MS,
  LOCALDOMSTORAGE_REMOVEKEY_MS,
  LOCALDOMSTORAGE_REMOVEALL_MS,
  LOCALDOMSTORAGE_FETCH_DOMAIN_MS,
  LOCALDOMSTORAGE_FETCH_QUOTA_USE_MS,
  LOCALDOMSTORAGE_TIMER_FLUSH_MS,
  LOCALDOMSTORAGE_KEY_SIZE_BYTES,
  LOCALDOMSTORAGE_VALUE_SIZE_BYTES,
  SESSIONDOMSTORAGE_KEY_SIZE_BYTES,
  SESSIONDOMSTORAGE_VALUE_SIZE_BYTES,
  RANGE_CHECKSUM_ERRORS,
  BUCKET_ORDER_ERRORS,
  TOTAL_COUNT_HIGH_ERRORS,
  TOTAL_COUNT_LOW_ERRORS,
  TELEMETRY_TEST_FLAG,
  STARTUP_CRASH_DETECTED,
  SAFE_MODE_USAGE,
  NEWTAB_PAGE_ENABLED,
  NEWTAB_PAGE_PINNED_SITES_COUNT,
  NEWTAB_PAGE_BLOCKED_SITES_COUNT,
  PANORAMA_INITIALIZATION_TIME_MS,
  PANORAMA_GROUPS_COUNT,
  PANORAMA_STACKED_GROUPS_COUNT,
  PANORAMA_MEDIAN_TABS_IN_GROUPS_COUNT,
# 523 "../../dist/include/mozilla/TelemetryHistogramEnums.h" 3
  SECURITY_UI,
  SEARCH_SERVICE_INIT_MS,
  SEARCH_SERVICE_BUILD_CACHE_MS,
  SOCIAL_ENABLED_ON_SESSION,
  SOCIAL_TOGGLED,
  ENABLE_PRIVILEGE_EVER_CALLED,
  READ_SAVED_PING_SUCCESS,



  COMPONENTS_OBJECT_ACCESSED_BY_CONTENT,
  COMPONENTS_LOOKUPMETHOD_ACCESSED_BY_CONTENT,
  COMPONENTS_INTERFACES_ACCESSED_BY_CONTENT,
  COMPONENTS_SHIM_ACCESSED_BY_CONTENT,
  CHECK_ADDONS_MODIFIED_MS,
  TELEMETRY_MEMORY_REPORTER_MS,
  SSL_SUCCESFUL_CERT_VALIDATION_TIME_LIBPKIX,
  SSL_SUCCESFUL_CERT_VALIDATION_TIME_CLASSIC,
  SSL_INITIAL_FAILED_CERT_VALIDATION_TIME_LIBPKIX,
  SSL_INITIAL_FAILED_CERT_VALIDATION_TIME_CLASSIC,
  HEALTHREPORT_DB_OPEN_FIRSTRUN_MS,
  HEALTHREPORT_DB_OPEN_MS,
  HEALTHREPORT_INIT_FIRSTRUN_MS,
  HEALTHREPORT_INIT_MS,
  HEALTHREPORT_SHUTDOWN_DELAY_MS,
  HEALTHREPORT_GENERATE_JSON_PAYLOAD_MS,
  HEALTHREPORT_JSON_PAYLOAD_SERIALIZE_MS,
  HEALTHREPORT_PAYLOAD_UNCOMPRESSED_BYTES,
  HEALTHREPORT_PAYLOAD_COMPRESSED_BYTES,
  HEALTHREPORT_UPLOAD_MS,
  HEALTHREPORT_SAVE_LAST_PAYLOAD_MS,
  HEALTHREPORT_COLLECT_CONSTANT_DATA_MS,
  HEALTHREPORT_COLLECT_DAILY_MS,
  HEALTHREPORT_SHUTDOWN_MS,
  HEALTHREPORT_POST_COLLECT_CHECKPOINT_MS,
  POPUP_NOTIFICATION_MAINACTION_TRIGGERED_MS,
  HistogramCount
};
# 26 "../../dist/include/mozilla/Telemetry.h" 2

enum TimerResolution {
  Millisecond,
  Microsecond
};




void Init();







void Accumulate(ID id, uint32_t sample);
# 52 "../../dist/include/mozilla/Telemetry.h"
void AccumulateTimeDelta(ID id, TimeStamp start, TimeStamp end = TimeStamp::Now());




base::Histogram* GetHistogramById(ID id);





template<TimerResolution res>
struct AccumulateDelta_impl
{
  static void compute(ID id, TimeStamp start, TimeStamp end = TimeStamp::Now());
};

template<>
struct AccumulateDelta_impl<Millisecond>
{
  static void compute(ID id, TimeStamp start, TimeStamp end = TimeStamp::Now()) {
    Accumulate(id, static_cast<uint32_t>((end - start).ToMilliseconds()));
  }
};

template<>
struct AccumulateDelta_impl<Microsecond>
{
  static void compute(ID id, TimeStamp start, TimeStamp end = TimeStamp::Now()) {
    Accumulate(id, static_cast<uint32_t>((end - start).ToMicroseconds()));
  }
};


template<ID id, TimerResolution res = Millisecond>
class AutoTimer {
public:
  AutoTimer(TimeStamp aStart = TimeStamp::Now() )
     : start(aStart)
  {
    do { } while (0);
  }

  ~AutoTimer() {
    AccumulateDelta_impl<res>::compute(id, start);
  }

private:
  const TimeStamp start;
 
};

template<ID id>
class AutoCounter {
public:
  AutoCounter(uint32_t counterStart = 0 )
    : counter(counterStart)
  {
    do { } while (0);
  }

  ~AutoCounter() {
    Accumulate(id, counter);
  }


  void operator++() {
    ++counter;
  }


  void operator+=(int increment) {
    counter += increment;
  }

private:
  uint32_t counter;
 
};






bool CanRecord();
# 146 "../../dist/include/mozilla/Telemetry.h"
void RecordSlowSQLStatement(const nsACString_internal &statement,
                            const nsACString_internal &dbName,
                            uint32_t delay);




const uint32_t kSlowSQLThresholdForMainThread = 50;
const uint32_t kSlowSQLThresholdForHelperThreads = 100;

class ProcessedStack;
# 166 "../../dist/include/mozilla/Telemetry.h"
void RecordChromeHang(uint32_t duration,
                      ProcessedStack &aStack);







void WriteFailedProfileLock(nsIFile* aProfileDir);

}
}
# 25 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h" 2

class nsCacheRequest;
class nsCacheProfilePrefObserver;
class nsDiskCacheDevice;
class nsMemoryCacheDevice;
class nsOfflineCacheDevice;
class nsCacheServiceAutoLock;
class nsITimer;






class nsNotifyDoomListener : public nsRunnable {
public:
    nsNotifyDoomListener(nsICacheListener *listener,
                         nsresult status)
        : mListener(listener)
        , mStatus(status)
    {}

    virtual __attribute__ ((visibility ("hidden"))) nsresult Run()
    {
        mListener->OnCacheEntryDoomed(mStatus);
        do { (mListener)->Release(); (mListener) = 0; } while (0);
        return nsresult::NS_OK;
    }

private:
    nsICacheListener *mListener;
    nsresult mStatus;
};





class nsCacheService : public nsICacheService
{
public:
    public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
    virtual __attribute__ ((visibility ("hidden"))) nsresult CreateSession(const char * clientID, nsCacheStoragePolicy storagePolicy, bool streamBased, nsICacheSession * *_retval); virtual __attribute__ ((visibility ("hidden"))) nsresult VisitEntries(nsICacheVisitor *visitor); virtual __attribute__ ((visibility ("hidden"))) nsresult EvictEntries(nsCacheStoragePolicy storagePolicy); virtual __attribute__ ((visibility ("hidden"))) nsresult GetCacheIOTarget(nsIEventTarget * *aCacheIOTarget);

    nsCacheService();
    virtual ~nsCacheService();


    static nsresult
    Create(nsISupports* outer, const nsIID& iid, void* *result);





    static nsresult OpenCacheEntry(nsCacheSession * session,
                                    const nsACString_internal & key,
                                    nsCacheAccessMode accessRequested,
                                    bool blockingMode,
                                    nsICacheListener * listener,
                                    nsICacheEntryDescriptor ** result);

    static nsresult EvictEntriesForSession(nsCacheSession * session);

    static nsresult IsStorageEnabledForPolicy(nsCacheStoragePolicy storagePolicy,
                                               bool * result);

    static nsresult DoomEntry(nsCacheSession *session,
                               const nsACString_internal &key,
                               nsICacheListener *listener);





    static void CloseDescriptor(nsCacheEntryDescriptor * descriptor);

    static nsresult GetFileForEntry(nsCacheEntry * entry,
                                     nsIFile ** result);

    static nsresult OpenInputStreamForEntry(nsCacheEntry * entry,
                                             nsCacheAccessMode mode,
                                             uint32_t offset,
                                             nsIInputStream ** result);

    static nsresult OpenOutputStreamForEntry(nsCacheEntry * entry,
                                              nsCacheAccessMode mode,
                                              uint32_t offset,
                                              nsIOutputStream ** result);

    static nsresult OnDataSizeChange(nsCacheEntry * entry, int32_t deltaSize);

    static nsresult SetCacheElement(nsCacheEntry * entry, nsISupports * element);

    static nsresult ValidateEntry(nsCacheEntry * entry);

    static int32_t CacheCompressionLevel();

    static bool GetClearingEntries();





    static
    nsCacheService * GlobalInstance() { return gService; }

    static nsresult DoomEntry(nsCacheEntry * entry);

    static bool IsStorageEnabledForPolicy_Locked(nsCacheStoragePolicy policy);




    static void MarkStartingFresh();





    nsresult GetOfflineDevice(nsOfflineCacheDevice ** aDevice);






    nsresult GetCustomOfflineDevice(nsIFile *aProfileDir,
                                    int32_t aQuota,
                                    nsOfflineCacheDevice **aDevice);






    static void ReleaseObject_Locked(nsISupports * object,
                                          nsIEventTarget * target = nullptr);

    static nsresult DispatchToCacheIOThread(nsIRunnable* event);




    static nsresult SyncWithCacheIOThread();





    static void OnProfileShutdown(bool cleanse);
    static void OnProfileChanged();

    static void SetDiskCacheEnabled(bool enabled);

    static void SetDiskCacheCapacity(int32_t capacity);


    static void SetDiskCacheMaxEntrySize(int32_t maxSize);


    static void SetMemoryCacheMaxEntrySize(int32_t maxSize);

    static void SetOfflineCacheEnabled(bool enabled);

    static void SetOfflineCacheCapacity(int32_t capacity);

    static void SetMemoryCache();

    static void SetCacheCompressionLevel(int32_t level);


    static nsresult SetDiskSmartSize();

    static void MoveOrRemoveDiskCache(nsIFile *aOldCacheDir,
                                           nsIFile *aNewCacheDir,
                                           const char *aCacheSubdir);

    nsresult Init();
    void Shutdown();

    static bool IsInitialized()
    {
      if (!gService) {
          return false;
      }
      return gService->mInitialized;
    }

    static void AssertOwnsLock()
    { gService->mLock.AssertCurrentThreadOwns(); }

    static void LeavePrivateBrowsing();
    bool IsDoomListEmpty();

    typedef bool (*DoomCheckFn)(nsCacheEntry* entry);

private:
    friend class nsCacheServiceAutoLock;
    friend class nsOfflineCacheDevice;
    friend class nsProcessRequestEvent;
    friend class nsSetSmartSizeEvent;
    friend class nsBlockOnCacheThreadEvent;
    friend class nsSetDiskSmartSizeCallback;
    friend class nsDoomEvent;
    friend class nsDisableOldMaxSmartSizePrefEvent;
    friend class nsDiskCacheMap;
    friend class nsAsyncDoomEvent;
    friend class nsCacheEntryDescriptor;





    static void Lock(::mozilla::Telemetry::ID mainThreadLockerID);
    static void Unlock();

    nsresult CreateDiskDevice();
    nsresult CreateOfflineDevice();
    nsresult CreateCustomOfflineDevice(nsIFile *aProfileDir,
                                               int32_t aQuota,
                                               nsOfflineCacheDevice **aDevice);
    nsresult CreateMemoryDevice();

    nsresult RemoveCustomOfflineDevice(nsOfflineCacheDevice *aDevice);

    nsresult CreateRequest(nsCacheSession * session,
                                   const nsACString_internal & clientKey,
                                   nsCacheAccessMode accessRequested,
                                   bool blockingMode,
                                   nsICacheListener * listener,
                                   nsCacheRequest ** request);

    nsresult DoomEntry_Internal(nsCacheEntry * entry,
                                        bool doProcessPendingRequests);

    nsresult EvictEntriesForClient(const char * clientID,
                                           nsCacheStoragePolicy storagePolicy);




    nsresult NotifyListener(nsCacheRequest * request,
                                    nsICacheEntryDescriptor * descriptor,
                                    nsCacheAccessMode accessGranted,
                                    nsresult error);

    nsresult ActivateEntry(nsCacheRequest * request,
                                   nsCacheEntry ** entry,
                                   nsCacheEntry ** doomedEntry);

    nsCacheDevice * EnsureEntryHasDevice(nsCacheEntry * entry);

    nsCacheEntry * SearchCacheDevices(nsCString * key, nsCacheStoragePolicy policy, bool *collision);

    void DeactivateEntry(nsCacheEntry * entry);

    nsresult ProcessRequest(nsCacheRequest * request,
                                    bool calledFromOpenCacheEntry,
                                    nsICacheEntryDescriptor ** result);

    nsresult ProcessPendingRequests(nsCacheEntry * entry);

    void ClearDoomList(void);
    void DoomActiveEntries(DoomCheckFn check);
    void CloseAllStreams();

    static
    PLDHashOperator GetActiveEntries(PLDHashTable * table,
                                      PLDHashEntryHdr * hdr,
                                      uint32_t number,
                                      void * arg);
    static
    PLDHashOperator RemoveActiveEntry(PLDHashTable * table,
                                       PLDHashEntryHdr * hdr,
                                       uint32_t number,
                                       void * arg);

    static
    PLDHashOperator ShutdownCustomCacheDeviceEnum(const nsAString_internal& aProfileDir,
                                                   nsRefPtr<nsOfflineCacheDevice>& aDevice,
                                                   void* aUserArg);

    void LogCacheStatistics();


    nsresult SetDiskSmartSize_Locked();





    static nsCacheService * gService;

    nsCacheProfilePrefObserver * mObserver;

    mozilla::Mutex mLock;
    mozilla::CondVar mCondVar;

    nsCOMPtr<nsIThread> mCacheIOThread;

    nsTArray<nsISupports*> mDoomedObjects;
    nsCOMPtr<nsITimer> mSmartSizeTimer;

    bool mInitialized;
    bool mClearingEntries;

    bool mEnableMemoryDevice;
    bool mEnableDiskDevice;
    bool mEnableOfflineDevice;

    nsMemoryCacheDevice * mMemoryDevice;
    nsDiskCacheDevice * mDiskDevice;
    nsOfflineCacheDevice * mOfflineDevice;

    nsRefPtrHashtable<nsStringHashKey, nsOfflineCacheDevice> mCustomOfflineDevices;

    nsCacheEntryHashTable mActiveEntries;
    PRCList mDoomedEntries;



    uint32_t mTotalEntries;
    uint32_t mCacheHits;
    uint32_t mCacheMisses;
    uint32_t mMaxKeyLength;
    uint32_t mMaxDataSize;
    uint32_t mMaxMetaSize;


    uint32_t mDeactivateFailures;
    uint32_t mDeactivatedUnboundEntries;
};
# 368 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsCacheService.h"
class nsCacheServiceAutoLock {
public:
    nsCacheServiceAutoLock(mozilla::Telemetry::ID mainThreadLockerID) {
        nsCacheService::Lock(mainThreadLockerID);
    }
    ~nsCacheServiceAutoLock() {
        nsCacheService::Unlock();
    }
};
# 13 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2

# 1 "../../dist/system_wrappers/string.h" 1
       
# 2 "../../dist/system_wrappers/string.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 15 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "../../dist/include/nsPrintfCString.h" 1
# 24 "../../dist/include/nsPrintfCString.h"
class nsPrintfCString : public nsFixedCString
{
  typedef nsCString string_type;

public:
  explicit nsPrintfCString( const char_type* format, ... )
    : nsFixedCString(mLocalBuffer, kLocalBufferSize, 0)
  {
    va_list ap;
    __builtin_va_start(ap,format);
    AppendPrintf(format, ap);
    __builtin_va_end(ap);
  }

private:
  static const uint32_t kLocalBufferSize = 16;
  char_type mLocalBuffer[kLocalBufferSize];
};
# 16 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2

# 1 "../../dist/include/nsISerializable.h" 1
# 17 "../../dist/include/nsISerializable.h"
class nsIObjectInputStream;

class nsIObjectOutputStream;
# 29 "../../dist/include/nsISerializable.h"
class nsISerializable : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Read(nsIObjectInputStream *aInputStream) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Write(nsIObjectOutputStream *aOutputStream) = 0;

};

  template <class Dummy> const nsIID nsISerializable::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x91cca981, 0xc26d, 0x44a8, { 0xbe, 0xbe, 0xd9, 0xed, 0x48, 0x91, 0x50, 0x3a }};
# 18 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2
# 1 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/../base/src/nsSerializationHelper.h" 1
# 12 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/../base/src/nsSerializationHelper.h"
# 1 "../../dist/include/nsStringFwd.h" 1
# 13 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/../base/src/nsSerializationHelper.h" 2
# 1 "../../dist/include/nsISerializationHelper.h" 1
# 17 "../../dist/include/nsISerializationHelper.h"
class nsISerializable;
# 27 "../../dist/include/nsISerializationHelper.h"
class nsISerializationHelper : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult SerializeToString(nsISerializable *serializable, nsACString_internal & _retval) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult DeserializeObject(const nsACString_internal & input, nsISupports * *_retval) = 0;

};

  template <class Dummy> const nsIID nsISerializationHelper::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x31654c0f, 0x35f3, 0x44c6, { 0xb3, 0x1e, 0x37, 0xa1, 0x15, 0x16, 0xe6, 0xbc }};
# 14 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/../base/src/nsSerializationHelper.h" 2


class nsISerializable;
class nsISupports;




nsresult NS_SerializeToString(nsISerializable* obj,
                              nsCSubstring& str);




nsresult NS_DeserializeObject(const nsCSubstring& str,
                              nsISupports** obj);

class nsSerializationHelper final : public nsISerializationHelper
{
  public: virtual __attribute__ ((visibility ("hidden"))) nsresult QueryInterface(const nsIID& aIID, void** aInstancePtr); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt AddRef(void); virtual __attribute__ ((visibility ("hidden"))) nsrefcnt Release(void); protected: nsAutoRefCnt mRefCnt; public:
  virtual __attribute__ ((visibility ("hidden"))) nsresult SerializeToString(nsISerializable *serializable, nsACString_internal & _retval); virtual __attribute__ ((visibility ("hidden"))) nsresult DeserializeObject(const nsACString_internal & input, nsISupports * *_retval);
};
# 19 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2


# 1 "../../dist/include/mozilla/VisualEventTracer.h" 1
# 25 "../../dist/include/mozilla/VisualEventTracer.h"
# 1 "../../dist/include/nsIVisualEventTracer.h" 1
# 17 "../../dist/include/nsIVisualEventTracer.h"
class nsIVisualEventTracerLog;
# 27 "../../dist/include/nsIVisualEventTracer.h"
class nsIVisualEventTracer : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult Start(uint32_t minBacklogSeconds) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Stop(void) = 0;


  virtual __attribute__ ((visibility ("hidden"))) nsresult Snapshot(nsIVisualEventTracerLog * *_retval) = 0;

};

  template <class Dummy> const nsIID nsIVisualEventTracer::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0xd51f7867, 0x42f3, 0x4029, { 0x8c, 0x4e, 0xc0, 0x06, 0x76, 0x25, 0x3a, 0x8e }};
# 124 "../../dist/include/nsIVisualEventTracer.h"
class nsIVisualEventTracerLog : public nsISupports {
 public:

  template <class Dummy> struct COMTypeInfo { static const nsIID kIID __attribute__ ((visibility ("hidden"))); }; static const nsIID& GetIID() {return COMTypeInfo<int>::kIID;}


  virtual __attribute__ ((visibility ("hidden"))) nsresult GetJSONString(nsACString_internal & aJSONString) = 0;

};

  template <class Dummy> const nsIID nsIVisualEventTracerLog::COMTypeInfo<Dummy>::kIID __attribute__ ((visibility ("hidden"))) = {0x52ec8962, 0xf67c, 0x4f49, { 0xa9, 0xd6, 0x89, 0xb8, 0xeb, 0xda, 0x26, 0x49 }};
# 26 "../../dist/include/mozilla/VisualEventTracer.h" 2
# 119 "../../dist/include/mozilla/VisualEventTracer.h"
namespace mozilla {
namespace eventtracer {


void Init();



void Shutdown();

enum MarkType {
  eNone,
  eName,

  eShot,
  eWait,
  eExec,
  eDone,
  eLast,




  eThreadConcurrent = 0x10000
};
# 158 "../../dist/include/mozilla/VisualEventTracer.h"
void Mark(uint32_t aType, void * aItem,
          const char * aText, const char * aText2 = 0);
# 172 "../../dist/include/mozilla/VisualEventTracer.h"
class AutoEventTracer
{
public:
  AutoEventTracer(void * aInstance,
               uint32_t aTypeOn,
               uint32_t aTypeOff,
               const char * aName,
               const char * aName2 = 0
               )
    : mInstance(aInstance)
    , mName(aName)
    , mName2(aName2)
    , mTypeOn(aTypeOn)
    , mTypeOff(aTypeOff)
  {
    do { } while (0);

    ::mozilla::eventtracer::Mark(mTypeOn, mInstance, mName, mName2);
  }

  ~AutoEventTracer()
  {
    ::mozilla::eventtracer::Mark(mTypeOff, mInstance, mName, mName2);
  }

private:
  void * mInstance;
  const char * mName;
  const char * mName2;
  uint32_t mTypeOn;
  uint32_t mTypeOff;

 
};
# 225 "../../dist/include/mozilla/VisualEventTracer.h"
}
}
# 22 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp" 2


using namespace mozilla;
# 34 "/builds/slave/try-l64-0000000000000000000000/build/netwerk/cache/nsDiskCacheMap.cpp"
nsresult
nsDiskCacheMap::Open(nsIFile * cacheDirectory,
                     nsDiskCache::CorruptCacheInfo * corruptInfo,
                     bool reportCacheCleanTelemetryData)
{
    do { if ((__builtin_expect(!!(!(corruptInfo)), 0))) { do { } while(0); return nsresult::NS_ERROR_INVALID_POINTER; } } while(0);


    *corruptInfo = nsDiskCache::kUnexpectedError;
    do { if ((__builtin_expect(!!(!(cacheDirectory)), 0))) { do { } while(0); return nsresult::NS_ERROR_INVALID_POINTER; } } while(0);
    if (mMapFD) return nsresult::NS_ERROR_ALREADY_INITIALIZED;

    mCacheDirectory = cacheDirectory;


    nsresult rv;
    nsCOMPtr<nsIFile> file;
    rv = cacheDirectory->Clone(getter_AddRefs(file));
    rv = file->AppendNative(static_cast<const nsDependentCString&>(nsDependentCString("_CACHE_MAP_", mozilla::internal::LiteralStringLength("_CACHE_MAP_"))));
    do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);


    rv = file->OpenNSPRFileDesc(0x04 | 0x08, 00600, &mMapFD);
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        *corruptInfo = nsDiskCache::kOpenCacheMapError;
        do { } while(0);
        return nsresult::NS_ERROR_FILE_CORRUPTED;
    }

    bool cacheFilesExist = CacheFilesExist();
    rv = nsresult::NS_ERROR_FILE_CORRUPTED;
    uint32_t mapSize = PR_Available(mMapFD);

    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(InitCacheClean(cacheDirectory, corruptInfo, reportCacheCleanTelemetryData))), 0)))

                                                                ) {

        goto error_exit;
    }


    if (mapSize == 0) {


        if (cacheFilesExist) {
            *corruptInfo = nsDiskCache::kBlockFilesShouldNotExist;
            goto error_exit;
        }

        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(CreateCacheSubDirectories())), 0)))) {
            *corruptInfo = nsDiskCache::kCreateCacheSubdirectories;
            goto error_exit;
        }


        memset(&mHeader, 0, sizeof(nsDiskCacheHeader));
        mHeader.mVersion = nsDiskCache::kCurrentVersion;
        mHeader.mRecordCount = 512;
        mRecordArray = (nsDiskCacheRecord *)
            (PR_Calloc(1, (mHeader.mRecordCount * sizeof(nsDiskCacheRecord))));
        if (!mRecordArray) {
            *corruptInfo = nsDiskCache::kOutOfMemory;
            rv = nsresult::NS_ERROR_OUT_OF_MEMORY;
            goto error_exit;
        }
    } else if (mapSize >= sizeof(nsDiskCacheHeader)) {


        if (!cacheFilesExist) {
            *corruptInfo = nsDiskCache::kBlockFilesShouldExist;
            goto error_exit;
        }

        do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: nsDiskCacheMap::Open [this=%p] reading map", this); } } while (0);


        uint32_t bytesRead = PR_Read(mMapFD, &mHeader, sizeof(nsDiskCacheHeader));
        if (sizeof(nsDiskCacheHeader) != bytesRead) {
            *corruptInfo = nsDiskCache::kHeaderSizeNotRead;
            goto error_exit;
        }
        mHeader.Unswap();

        if (mHeader.mIsDirty) {
            *corruptInfo = nsDiskCache::kHeaderIsDirty;
            goto error_exit;
        }

        if (mHeader.mVersion != nsDiskCache::kCurrentVersion) {
            *corruptInfo = nsDiskCache::kVersionMismatch;
            goto error_exit;
        }

        uint32_t recordArraySize =
                mHeader.mRecordCount * sizeof(nsDiskCacheRecord);
        if (mapSize < recordArraySize + sizeof(nsDiskCacheHeader)) {
            *corruptInfo = nsDiskCache::kRecordsIncomplete;
            goto error_exit;
        }


        mRecordArray = (nsDiskCacheRecord *) (PR_Malloc((recordArraySize)));
        if (!mRecordArray) {
            *corruptInfo = nsDiskCache::kOutOfMemory;
            rv = nsresult::NS_ERROR_OUT_OF_MEMORY;
            goto error_exit;
        }


        bytesRead = PR_Read(mMapFD, mRecordArray, recordArraySize);
        if (bytesRead < recordArraySize) {
            *corruptInfo = nsDiskCache::kNotEnoughToRead;
            goto error_exit;
        }


        int32_t total = 0;
        for (int32_t i = 0; i < mHeader.mRecordCount; ++i) {
            if (mRecordArray[i].HashNumber()) {

                mRecordArray[i].Unswap();

                total ++;
            }
        }


        if (total != mHeader.mEntryCount) {
            *corruptInfo = nsDiskCache::kEntryCountIncorrect;
            goto error_exit;
        }

    } else {
        *corruptInfo = nsDiskCache::kHeaderIncomplete;
        goto error_exit;
    }

    rv = OpenBlockFiles(corruptInfo);
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {

        goto error_exit;
    }


    mHeader.mIsDirty = true;
    rv = FlushHeader();
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        *corruptInfo = nsDiskCache::kFlushHeaderError;
        goto error_exit;
    }

    Telemetry::Accumulate(Telemetry::HTTP_DISK_CACHE_OVERHEAD,
                          (uint32_t)SizeOfExcludingThis(moz_malloc_size_of));

    *corruptInfo = nsDiskCache::kNotCorrupt;
    return nsresult::NS_OK;

error_exit:
    (void) Close(false);

    return rv;
}


nsresult
nsDiskCacheMap::Close(bool flush)
{
    nsCacheService::AssertOwnsLock();
    nsresult rv = nsresult::NS_OK;



    if (mCleanCacheTimer) {
        mCleanCacheTimer->Cancel();
    }


    if (mMapFD) {

        rv = CloseBlockFiles(flush);
        if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1))) && flush && mRecordArray) {

            rv = FlushRecords(false);
            if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {

                mHeader.mIsDirty = false;
                rv = FlushHeader();
            }
        }
        if ((PR_Close(mMapFD) != PR_SUCCESS) && (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))))
            rv = nsresult::NS_ERROR_UNEXPECTED;

        mMapFD = nullptr;
    }

    if (mCleanFD) {
        PR_Close(mCleanFD);
        mCleanFD = nullptr;
    }

    if (mRecordArray) { PR_Free(mRecordArray); (mRecordArray) = __null; };
    if (mBuffer) { PR_Free(mBuffer); (mBuffer) = __null; };
    mBufferSize = 0;
    return rv;
}


nsresult
nsDiskCacheMap::Trim()
{
    nsresult rv, rv2 = nsresult::NS_OK;
    for (int i=0; i < 3; ++i) {
        rv = mBlockFile[i].Trim();
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) rv2 = rv;
    }

    rv = ShrinkRecords();
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) rv2 = rv;
    return rv2;
}


nsresult
nsDiskCacheMap::FlushHeader()
{
    if (!mMapFD) return nsresult::NS_ERROR_NOT_AVAILABLE;


    int32_t filePos = PR_Seek(mMapFD, 0, PR_SEEK_SET);
    if (filePos != 0) return nsresult::NS_ERROR_UNEXPECTED;


    mHeader.Swap();
    int32_t bytesWritten = PR_Write(mMapFD, &mHeader, sizeof(nsDiskCacheHeader));
    mHeader.Unswap();
    if (sizeof(nsDiskCacheHeader) != bytesWritten) {
        return nsresult::NS_ERROR_UNEXPECTED;
    }

    PRStatus err = PR_Sync(mMapFD);
    if (err != PR_SUCCESS) return nsresult::NS_ERROR_UNEXPECTED;


    if (!mHeader.mIsDirty) {
        RevalidateCache();
    }

    return nsresult::NS_OK;
}


nsresult
nsDiskCacheMap::FlushRecords(bool unswap)
{
    if (!mMapFD) return nsresult::NS_ERROR_NOT_AVAILABLE;


    int32_t filePos = PR_Seek(mMapFD, sizeof(nsDiskCacheHeader), PR_SEEK_SET);
    if (filePos != sizeof(nsDiskCacheHeader))
        return nsresult::NS_ERROR_UNEXPECTED;



    for (int32_t i = 0; i < mHeader.mRecordCount; ++i) {
        if (mRecordArray[i].HashNumber())
            mRecordArray[i].Swap();
    }


    int32_t recordArraySize = sizeof(nsDiskCacheRecord) * mHeader.mRecordCount;

    int32_t bytesWritten = PR_Write(mMapFD, mRecordArray, recordArraySize);
    if (bytesWritten != recordArraySize)
        return nsresult::NS_ERROR_UNEXPECTED;


    if (unswap) {

        for (int32_t i = 0; i < mHeader.mRecordCount; ++i) {
            if (mRecordArray[i].HashNumber())
                mRecordArray[i].Unswap();
        }
    }


    return nsresult::NS_OK;
}






uint32_t
nsDiskCacheMap::GetBucketRank(uint32_t bucketIndex, uint32_t targetRank)
{
    nsDiskCacheRecord * records = GetFirstRecordInBucket(bucketIndex);
    uint32_t rank = 0;

    for (int i = mHeader.mBucketUsage[bucketIndex]-1; i >= 0; i--) {
        if ((rank < records[i].EvictionRank()) &&
            ((targetRank == 0) || (records[i].EvictionRank() < targetRank)))
                rank = records[i].EvictionRank();
    }
    return rank;
}

nsresult
nsDiskCacheMap::GrowRecords()
{
    if (mHeader.mRecordCount >= mMaxRecordCount)
        return nsresult::NS_OK;
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: GrowRecords\n"); } } while (0);


    int32_t newCount = mHeader.mRecordCount << 1;
    if (newCount > mMaxRecordCount)
        newCount = mMaxRecordCount;
    nsDiskCacheRecord *newArray = (nsDiskCacheRecord *)
            (PR_Realloc((mRecordArray), (newCount * sizeof(nsDiskCacheRecord))));
    if (!newArray)
        return nsresult::NS_ERROR_OUT_OF_MEMORY;


    uint32_t oldRecordsPerBucket = GetRecordsPerBucket();
    uint32_t newRecordsPerBucket = newCount / (1 << 5);

    for (int bucketIndex = (1 << 5) - 1; bucketIndex >= 0; --bucketIndex) {

        nsDiskCacheRecord *newRecords = newArray + bucketIndex * newRecordsPerBucket;
        const uint32_t count = mHeader.mBucketUsage[bucketIndex];
        memmove(newRecords,
                newArray + bucketIndex * oldRecordsPerBucket,
                count * sizeof(nsDiskCacheRecord));

        memset(newRecords + count, 0,
               (newRecordsPerBucket - count) * sizeof(nsDiskCacheRecord));
    }


    mRecordArray = newArray;
    mHeader.mRecordCount = newCount;

    InvalidateCache();

    return nsresult::NS_OK;
}

nsresult
nsDiskCacheMap::ShrinkRecords()
{
    if (mHeader.mRecordCount <= 512)
        return nsresult::NS_OK;
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: ShrinkRecords\n"); } } while (0);



    uint32_t maxUsage = 0, bucketIndex;
    for (bucketIndex = 0; bucketIndex < (1 << 5); ++bucketIndex) {
        if (maxUsage < mHeader.mBucketUsage[bucketIndex])
            maxUsage = mHeader.mBucketUsage[bucketIndex];
    }

    uint32_t oldRecordsPerBucket = GetRecordsPerBucket();
    uint32_t newRecordsPerBucket = oldRecordsPerBucket;
    while (maxUsage < (newRecordsPerBucket >> 1))
        newRecordsPerBucket >>= 1;
    if (newRecordsPerBucket < (512 / (1 << 5)))
        newRecordsPerBucket = (512 / (1 << 5));
    do { } while(0)
                                                       ;
    if (newRecordsPerBucket == oldRecordsPerBucket)
        return nsresult::NS_OK;

    for (bucketIndex = 1; bucketIndex < (1 << 5); ++bucketIndex) {

        memmove(mRecordArray + bucketIndex * newRecordsPerBucket,
                mRecordArray + bucketIndex * oldRecordsPerBucket,
                newRecordsPerBucket * sizeof(nsDiskCacheRecord));
    }


    uint32_t newCount = newRecordsPerBucket * (1 << 5);
    nsDiskCacheRecord* newArray = (nsDiskCacheRecord *)
            (PR_Realloc((mRecordArray), (newCount * sizeof(nsDiskCacheRecord))));
    if (!newArray)
        return nsresult::NS_ERROR_OUT_OF_MEMORY;


    mRecordArray = newArray;
    mHeader.mRecordCount = newCount;

    InvalidateCache();

    return nsresult::NS_OK;
}

nsresult
nsDiskCacheMap::AddRecord( nsDiskCacheRecord * mapRecord,
                           nsDiskCacheRecord * oldRecord)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: AddRecord [%x]\n", mapRecord->HashNumber()); } } while (0);

    const uint32_t hashNumber = mapRecord->HashNumber();
    const uint32_t bucketIndex = GetBucketIndex(hashNumber);
    const uint32_t count = mHeader.mBucketUsage[bucketIndex];

    oldRecord->SetHashNumber(0);

    if (count == GetRecordsPerBucket()) {

        GrowRecords();
    }

    nsDiskCacheRecord * records = GetFirstRecordInBucket(bucketIndex);
    if (count < GetRecordsPerBucket()) {

        records[count] = *mapRecord;
        mHeader.mEntryCount++;
        mHeader.mBucketUsage[bucketIndex]++;
        if (mHeader.mEvictionRank[bucketIndex] < mapRecord->EvictionRank())
            mHeader.mEvictionRank[bucketIndex] = mapRecord->EvictionRank();
        InvalidateCache();
    } else {

        nsDiskCacheRecord * mostEvictable = &records[0];
        for (int i = count-1; i > 0; i--) {
            if (records[i].EvictionRank() > mostEvictable->EvictionRank())
                mostEvictable = &records[i];
        }
        *oldRecord = *mostEvictable;

        *mostEvictable = *mapRecord;

        if (mHeader.mEvictionRank[bucketIndex] < mapRecord->EvictionRank())
            mHeader.mEvictionRank[bucketIndex] = mapRecord->EvictionRank();
        if (oldRecord->EvictionRank() >= mHeader.mEvictionRank[bucketIndex])
            mHeader.mEvictionRank[bucketIndex] = GetBucketRank(bucketIndex, 0);
        InvalidateCache();
    }

    do { } while(0)
                                             ;
    return nsresult::NS_OK;
}


nsresult
nsDiskCacheMap::UpdateRecord( nsDiskCacheRecord * mapRecord)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: UpdateRecord [%x]\n", mapRecord->HashNumber()); } } while (0);

    const uint32_t hashNumber = mapRecord->HashNumber();
    const uint32_t bucketIndex = GetBucketIndex(hashNumber);
    nsDiskCacheRecord * records = GetFirstRecordInBucket(bucketIndex);

    for (int i = mHeader.mBucketUsage[bucketIndex]-1; i >= 0; i--) {
        if (records[i].HashNumber() == hashNumber) {
            const uint32_t oldRank = records[i].EvictionRank();


            records[i] = *mapRecord;


            if (mHeader.mEvictionRank[bucketIndex] < mapRecord->EvictionRank())
                mHeader.mEvictionRank[bucketIndex] = mapRecord->EvictionRank();
            else if (mHeader.mEvictionRank[bucketIndex] == oldRank)
                mHeader.mEvictionRank[bucketIndex] = GetBucketRank(bucketIndex, 0);

            InvalidateCache();

do { } while(0)
                                         ;
            return nsresult::NS_OK;
        }
    }
    do { } while(0);
    return nsresult::NS_ERROR_UNEXPECTED;
}


nsresult
nsDiskCacheMap::FindRecord( uint32_t hashNumber, nsDiskCacheRecord * result)
{
    const uint32_t bucketIndex = GetBucketIndex(hashNumber);
    nsDiskCacheRecord * records = GetFirstRecordInBucket(bucketIndex);

    for (int i = mHeader.mBucketUsage[bucketIndex]-1; i >= 0; i--) {
        if (records[i].HashNumber() == hashNumber) {
            *result = records[i];
            do { } while(0);
            return nsresult::NS_OK;
        }
    }
    return nsresult::NS_ERROR_CACHE_KEY_NOT_FOUND;
}


nsresult
nsDiskCacheMap::DeleteRecord( nsDiskCacheRecord * mapRecord)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: DeleteRecord [%x]\n", mapRecord->HashNumber()); } } while (0);

    const uint32_t hashNumber = mapRecord->HashNumber();
    const uint32_t bucketIndex = GetBucketIndex(hashNumber);
    nsDiskCacheRecord * records = GetFirstRecordInBucket(bucketIndex);
    uint32_t last = mHeader.mBucketUsage[bucketIndex]-1;

    for (int i = last; i >= 0; i--) {
        if (records[i].HashNumber() == hashNumber) {

            uint32_t evictionRank = records[i].EvictionRank();
            do { } while(0)
                                                    ;

            records[i] = records[last];
            records[last].SetHashNumber(0);
            mHeader.mBucketUsage[bucketIndex] = last;
            mHeader.mEntryCount--;


            uint32_t bucketIndex = GetBucketIndex(mapRecord->HashNumber());
            if (mHeader.mEvictionRank[bucketIndex] <= evictionRank) {
                mHeader.mEvictionRank[bucketIndex] = GetBucketRank(bucketIndex, 0);
            }

            InvalidateCache();

            do { } while(0)
                                                                                    ;
            return nsresult::NS_OK;
        }
    }
    return nsresult::NS_ERROR_UNEXPECTED;
}


int32_t
nsDiskCacheMap::VisitEachRecord(uint32_t bucketIndex,
                                nsDiskCacheRecordVisitor * visitor,
                                uint32_t evictionRank)
{
    int32_t rv = kVisitNextRecord;
    uint32_t count = mHeader.mBucketUsage[bucketIndex];
    nsDiskCacheRecord * records = GetFirstRecordInBucket(bucketIndex);


    for (int i = count-1; i >= 0; i--) {
        if (evictionRank > records[i].EvictionRank()) continue;

        rv = visitor->VisitRecord(&records[i]);
        if (rv == kStopVisitingRecords)
            break;

        if (rv == kDeleteRecordAndContinue) {
            --count;
            records[i] = records[count];
            records[count].SetHashNumber(0);
            InvalidateCache();
        }
    }

    if (mHeader.mBucketUsage[bucketIndex] - count != 0) {
        mHeader.mEntryCount -= mHeader.mBucketUsage[bucketIndex] - count;
        mHeader.mBucketUsage[bucketIndex] = count;

        mHeader.mEvictionRank[bucketIndex] = GetBucketRank(bucketIndex, 0);
    }
    do { } while(0)
                                                                            ;

    return rv;
}







nsresult
nsDiskCacheMap::VisitRecords( nsDiskCacheRecordVisitor * visitor)
{
    for (int bucketIndex = 0; bucketIndex < (1 << 5); ++bucketIndex) {
        if (VisitEachRecord(bucketIndex, visitor, 0) == kStopVisitingRecords)
            break;
    }
    return nsresult::NS_OK;
}







nsresult
nsDiskCacheMap::EvictRecords( nsDiskCacheRecordVisitor * visitor)
{
    uint32_t tempRank[(1 << 5)];
    int bucketIndex = 0;


    for (bucketIndex = 0; bucketIndex < (1 << 5); ++bucketIndex)
        tempRank[bucketIndex] = mHeader.mEvictionRank[bucketIndex];




    int32_t entryCount = mHeader.mEntryCount;
    for (int n = 0; n < entryCount; ++n) {


        uint32_t rank = 0;
        for (int i = 0; i < (1 << 5); ++i) {
            if (rank < tempRank[i]) {
                rank = tempRank[i];
                bucketIndex = i;
            }
        }

        if (rank == 0) break;


        if (VisitEachRecord(bucketIndex, visitor, rank) == kStopVisitingRecords)
            break;


        tempRank[bucketIndex] = GetBucketRank(bucketIndex, rank);
    }
    return nsresult::NS_OK;
}



nsresult
nsDiskCacheMap::OpenBlockFiles(nsDiskCache::CorruptCacheInfo * corruptInfo)
{
    do { if ((__builtin_expect(!!(!(corruptInfo)), 0))) { do { } while(0); return nsresult::NS_ERROR_INVALID_POINTER; } } while(0);


    nsCOMPtr<nsIFile> blockFile;
    nsresult rv = nsresult::NS_OK;
    *corruptInfo = nsDiskCache::kUnexpectedError;

    for (int i = 0; i < 3; ++i) {
        rv = GetBlockFileForIndex(i, getter_AddRefs(blockFile));
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
            *corruptInfo = nsDiskCache::kCouldNotGetBlockFileForIndex;
            break;
        }

        uint32_t blockSize = GetBlockSizeForIndex(i+1);
        uint32_t bitMapSize = GetBitMapSizeForIndex(i+1);
        rv = mBlockFile[i].Open(blockFile, blockSize, bitMapSize, corruptInfo);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {

            break;
        }
    }

    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0))))
        (void)CloseBlockFiles(false);

    return rv;
}


nsresult
nsDiskCacheMap::CloseBlockFiles(bool flush)
{
    nsresult rv, rv2 = nsresult::NS_OK;
    for (int i=0; i < 3; ++i) {
        rv = mBlockFile[i].Close(flush);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) rv2 = rv;
    }
    return rv2;
}


bool
nsDiskCacheMap::CacheFilesExist()
{
    nsCOMPtr<nsIFile> blockFile;
    nsresult rv;

    for (int i = 0; i < 3; ++i) {
        bool exists;
        rv = GetBlockFileForIndex(i, getter_AddRefs(blockFile));
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return false;

        rv = blockFile->Exists(&exists);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0))) || !exists) return false;
    }

    return true;
}


nsresult
nsDiskCacheMap::CreateCacheSubDirectories()
{
    if (!mCacheDirectory)
        return nsresult::NS_ERROR_UNEXPECTED;

    for (int32_t index = 0 ; index < 16 ; index++) {
        nsCOMPtr<nsIFile> file;
        nsresult rv = mCacheDirectory->Clone(getter_AddRefs(file));
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0))))
            return rv;

        rv = file->AppendNative(nsPrintfCString("%X", index));
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0))))
            return rv;

        rv = file->Create(nsIFile::DIRECTORY_TYPE, 0700);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0))))
            return rv;
    }

    return nsresult::NS_OK;
}


nsDiskCacheEntry *
nsDiskCacheMap::ReadDiskCacheEntry(nsDiskCacheRecord * record)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: ReadDiskCacheEntry [%x]\n", record->HashNumber()); } } while (0);

    nsresult rv = nsresult::NS_ERROR_UNEXPECTED;
    nsDiskCacheEntry * diskEntry = nullptr;
    uint32_t metaFile = record->MetaFile();
    int32_t bytesRead = 0;

    if (!record->MetaLocationInitialized()) return nullptr;

    if (metaFile == 0) {

        nsCOMPtr<nsIFile> file;
        rv = GetLocalFileForDiskCacheRecord(record,
                                            nsDiskCache::kMetaData,
                                            false,
                                            getter_AddRefs(file));
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return nullptr; } } while(0);

        do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: nsDiskCacheMap::ReadDiskCacheEntry" "[this=%p] reading disk cache entry", this); } } while (0)
                                                                     ;

        PRFileDesc * fd = nullptr;


        rv = file->OpenNSPRFileDesc(0x01, 00600, &fd);
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return nullptr; } } while(0);

        int32_t fileSize = PR_Available(fd);
        if (fileSize < 0) {

            rv = nsresult::NS_ERROR_UNEXPECTED;
        } else {
            rv = EnsureBuffer(fileSize);
            if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {
                bytesRead = PR_Read(fd, mBuffer, fileSize);
                if (bytesRead < fileSize) {
                    rv = nsresult::NS_ERROR_UNEXPECTED;
                }
            }
        }
        PR_Close(fd);
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return nullptr; } } while(0);

    } else if (metaFile < (3 + 1)) {



        uint32_t blockCount = record->MetaBlockCount();
        bytesRead = blockCount * GetBlockSizeForIndex(metaFile);

        rv = EnsureBuffer(bytesRead);
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return nullptr; } } while(0);




        rv = mBlockFile[metaFile - 1].ReadBlocks(mBuffer,
                                                 record->MetaStartBlock(),
                                                 blockCount,
                                                 &bytesRead);
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return nullptr; } } while(0);
    }
    diskEntry = (nsDiskCacheEntry *)mBuffer;
    diskEntry->Unswap();

    if (bytesRead < 0 || (uint32_t)bytesRead < diskEntry->Size())
        return nullptr;


    return diskEntry;
}







nsDiskCacheEntry *
nsDiskCacheMap::CreateDiskCacheEntry(nsDiskCacheBinding * binding,
                                     uint32_t * aSize)
{
    nsCacheEntry * entry = binding->mCacheEntry;
    if (!entry) return nullptr;


    nsCOMPtr<nsISupports> infoObj = entry->SecurityInfo();
    nsCOMPtr<nsISerializable> serializable = do_QueryInterface(infoObj);
    if (infoObj && !serializable) return nullptr;
    if (serializable) {
        nsCString info;
        nsresult rv = NS_SerializeToString(serializable, info);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return nullptr;
        rv = entry->SetMetaDataElement("security-info", info.get());
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return nullptr;
    }

    uint32_t keySize = entry->Key()->Length() + 1;
    uint32_t metaSize = entry->MetaDataSize();
    uint32_t size = sizeof(nsDiskCacheEntry) + keySize + metaSize;

    if (aSize) *aSize = size;

    nsresult rv = EnsureBuffer(size);
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return nullptr;

    nsDiskCacheEntry *diskEntry = (nsDiskCacheEntry *)mBuffer;
    diskEntry->mHeaderVersion = nsDiskCache::kCurrentVersion;
    diskEntry->mMetaLocation = binding->mRecord.MetaLocation();
    diskEntry->mFetchCount = entry->FetchCount();
    diskEntry->mLastFetched = entry->LastFetched();
    diskEntry->mLastModified = entry->LastModified();
    diskEntry->mExpirationTime = entry->ExpirationTime();
    diskEntry->mDataSize = entry->DataSize();
    diskEntry->mKeySize = keySize;
    diskEntry->mMetaDataSize = metaSize;

    memcpy(diskEntry->Key(), entry->Key()->get(), keySize);

    rv = entry->FlattenMetaData(diskEntry->MetaData(), metaSize);
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return nullptr;

    return diskEntry;
}


nsresult
nsDiskCacheMap::WriteDiskCacheEntry(nsDiskCacheBinding * binding)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: WriteDiskCacheEntry [%x]\n", binding->mRecord.HashNumber()); } } while (0)
                                       ;

    mozilla::eventtracer::AutoEventTracer writeDiskCacheEntry(
        binding->mCacheEntry,
        mozilla::eventtracer::eExec,
        mozilla::eventtracer::eDone,
        "net::cache::WriteDiskCacheEntry");

    nsresult rv = nsresult::NS_OK;
    uint32_t size;
    nsDiskCacheEntry * diskEntry = CreateDiskCacheEntry(binding, &size);
    if (!diskEntry) return nsresult::NS_ERROR_UNEXPECTED;

    uint32_t fileIndex = CalculateFileIndex(size);


    if (binding->mRecord.MetaLocationInitialized()) {


        if ((binding->mRecord.MetaFile() == 0) &&
            (fileIndex == 0)) {

            DecrementTotalSize(binding->mRecord.MetaFileSize());
            do { } while(0)
                                                   ;
        } else {
            rv = DeleteStorage(&binding->mRecord, nsDiskCache::kMetaData);
            do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);
        }
    }

    binding->mRecord.SetEvictionRank((9223372036854775807L * 2UL + 1UL) - SecondsFromPRTime(PR_Now()));

    diskEntry->Swap();

    if (fileIndex != 0) {
        while (1) {
            uint32_t blockSize = GetBlockSizeForIndex(fileIndex);
            uint32_t blocks = ((size - 1) / blockSize) + 1;

            int32_t startBlock;
            rv = mBlockFile[fileIndex - 1].WriteBlocks(diskEntry, size, blocks,
                                                       &startBlock);
            if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {

                binding->mRecord.SetMetaBlocks(fileIndex, startBlock, blocks);

                rv = UpdateRecord(&binding->mRecord);
                do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);



                IncrementTotalSize(blocks, blockSize);
                break;
            }

            if (fileIndex == 3) {
                fileIndex = 0;
                break;
            }


            fileIndex++;
        }
    }

    if (fileIndex == 0) {

        uint32_t metaFileSizeK = ((size + 0x03FF) >> 10);
        if (metaFileSizeK > 0xFFFF)
            metaFileSizeK = 0xFFFF;

        binding->mRecord.SetMetaFileGeneration(binding->mGeneration);
        binding->mRecord.SetMetaFileSize(metaFileSizeK);
        rv = UpdateRecord(&binding->mRecord);
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);

        nsCOMPtr<nsIFile> localFile;
        rv = GetLocalFileForDiskCacheRecord(&binding->mRecord,
                                            nsDiskCache::kMetaData,
                                            true,
                                            getter_AddRefs(localFile));
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);


        PRFileDesc * fd;

        rv = localFile->OpenNSPRFileDesc(0x04 | 0x20 | 0x08, 00600, &fd);
        do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);


        int32_t bytesWritten = PR_Write(fd, diskEntry, size);

        PRStatus err = PR_Close(fd);
        if ((bytesWritten != (int32_t)size) || (err != PR_SUCCESS)) {
            return nsresult::NS_ERROR_UNEXPECTED;
        }

        IncrementTotalSize(metaFileSizeK);
    }

    return rv;
}


nsresult
nsDiskCacheMap::ReadDataCacheBlocks(nsDiskCacheBinding * binding, char * buffer, uint32_t size)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: ReadDataCacheBlocks [%x size=%u]\n", binding->mRecord.HashNumber(), size); } } while (0)
                                             ;

    uint32_t fileIndex = binding->mRecord.DataFile();
    int32_t readSize = size;

    nsresult rv = mBlockFile[fileIndex - 1].ReadBlocks(buffer,
                                                       binding->mRecord.DataStartBlock(),
                                                       binding->mRecord.DataBlockCount(),
                                                       &readSize);
    do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);
    if (readSize < (int32_t)size) {
        rv = nsresult::NS_ERROR_UNEXPECTED;
    }
    return rv;
}


nsresult
nsDiskCacheMap::WriteDataCacheBlocks(nsDiskCacheBinding * binding, char * buffer, uint32_t size)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: WriteDataCacheBlocks [%x size=%u]\n", binding->mRecord.HashNumber(), size); } } while (0)
                                             ;

    mozilla::eventtracer::AutoEventTracer writeDataCacheBlocks(
        binding->mCacheEntry,
        mozilla::eventtracer::eExec,
        mozilla::eventtracer::eDone,
        "net::cache::WriteDataCacheBlocks");

    nsresult rv = nsresult::NS_OK;


    uint32_t fileIndex = CalculateFileIndex(size);
    uint32_t blockCount = 0;
    int32_t startBlock = 0;

    if (size > 0) {
        while (1) {
            uint32_t blockSize = GetBlockSizeForIndex(fileIndex);
            blockCount = ((size - 1) / blockSize) + 1;

            rv = mBlockFile[fileIndex - 1].WriteBlocks(buffer, size, blockCount,
                                                       &startBlock);
            if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {
                IncrementTotalSize(blockCount, blockSize);
                break;
            }

            if (fileIndex == 3)
                return rv;

            fileIndex++;
        }
    }


    binding->mRecord.SetDataBlocks(fileIndex, startBlock, blockCount);
    if (!binding->mDoomed) {
        rv = UpdateRecord(&binding->mRecord);
    }
    return rv;
}


nsresult
nsDiskCacheMap::DeleteStorage(nsDiskCacheRecord * record)
{
    nsresult rv1 = DeleteStorage(record, nsDiskCache::kData);
    nsresult rv2 = DeleteStorage(record, nsDiskCache::kMetaData);
    return ((bool)(__builtin_expect(!!(NS_FAILED_impl(rv1)), 0))) ? rv1 : rv2;
}


nsresult
nsDiskCacheMap::DeleteStorage(nsDiskCacheRecord * record, bool metaData)
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: DeleteStorage [%x %u]\n", record->HashNumber(), metaData); } } while (0)
                  ;

    nsresult rv = nsresult::NS_ERROR_UNEXPECTED;
    uint32_t fileIndex = metaData ? record->MetaFile() : record->DataFile();
    nsCOMPtr<nsIFile> file;

    if (fileIndex == 0) {

        uint32_t sizeK = metaData ? record->MetaFileSize() : record->DataFileSize();


        rv = GetFileForDiskCacheRecord(record, metaData, false, getter_AddRefs(file));
        if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {
            rv = file->Remove(false);
        }
        DecrementTotalSize(sizeK);

    } else if (fileIndex < (3 + 1)) {

        uint32_t startBlock = metaData ? record->MetaStartBlock() : record->DataStartBlock();
        uint32_t blockCount = metaData ? record->MetaBlockCount() : record->DataBlockCount();

        rv = mBlockFile[fileIndex - 1].DeallocateBlocks(startBlock, blockCount);
        DecrementTotalSize(blockCount, GetBlockSizeForIndex(fileIndex));
    }
    if (metaData) record->ClearMetaLocation();
    else record->ClearDataLocation();

    return rv;
}


nsresult
nsDiskCacheMap::GetFileForDiskCacheRecord(nsDiskCacheRecord * record,
                                          bool meta,
                                          bool createPath,
                                          nsIFile ** result)
{
    if (!mCacheDirectory) return nsresult::NS_ERROR_NOT_AVAILABLE;

    nsCOMPtr<nsIFile> file;
    nsresult rv = mCacheDirectory->Clone(getter_AddRefs(file));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;

    uint32_t hash = record->HashNumber();



    rv = file->AppendNative(nsPrintfCString("%X", hash >> 28));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;
    rv = file->AppendNative(nsPrintfCString("%02X", (hash >> 20) & 0xFF));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;

    bool exists;
    if (createPath && (((bool)(__builtin_expect(!!(NS_FAILED_impl(file->Exists(&exists))), 0))) || !exists)) {
        rv = file->Create(nsIFile::DIRECTORY_TYPE, 0700);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;
    }

    int16_t generation = record->Generation();
    char name[32];

    ::sprintf(name, "%05X%c%02X", hash & 0xFFFFF, (meta ? 'm' : 'd'),
              generation);
    rv = file->AppendNative(nsDependentCString(name));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;

    ns_if_addref(*result = file);
    return rv;
}


nsresult
nsDiskCacheMap::GetLocalFileForDiskCacheRecord(nsDiskCacheRecord * record,
                                               bool meta,
                                               bool createPath,
                                               nsIFile ** result)
{
    nsCOMPtr<nsIFile> file;
    nsresult rv = GetFileForDiskCacheRecord(record,
                                            meta,
                                            createPath,
                                            getter_AddRefs(file));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;

    ns_if_addref(*result = file);
    return rv;
}


nsresult
nsDiskCacheMap::GetBlockFileForIndex(uint32_t index, nsIFile ** result)
{
    if (!mCacheDirectory) return nsresult::NS_ERROR_NOT_AVAILABLE;

    nsCOMPtr<nsIFile> file;
    nsresult rv = mCacheDirectory->Clone(getter_AddRefs(file));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;

    char name[32];
    ::sprintf(name, "_CACHE_%03d_", index + 1);
    rv = file->AppendNative(nsDependentCString(name));
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) return rv;

    ns_if_addref(*result = file);

    return rv;
}


uint32_t
nsDiskCacheMap::CalculateFileIndex(uint32_t size)
{




    if (size <= 3 * ((1) ? (256 << (2 * ((1) - 1))) : 0)) return 1;
    if (size <= 3 * ((2) ? (256 << (2 * ((2) - 1))) : 0)) return 2;
    if (size <= 4 * ((3) ? (256 << (2 * ((3) - 1))) : 0)) return 3;
    return 0;
}

nsresult
nsDiskCacheMap::EnsureBuffer(uint32_t bufSize)
{
    if (mBufferSize < bufSize) {
        char * buf = (char *)(PR_Realloc((mBuffer), (bufSize)));
        if (!buf) {
            mBufferSize = 0;
            return nsresult::NS_ERROR_OUT_OF_MEMORY;
        }
        mBuffer = buf;
        mBufferSize = bufSize;
    }
    return nsresult::NS_OK;
}

void
nsDiskCacheMap::NotifyCapacityChange(uint32_t capacity)
{



  const int32_t RECORD_COUNT_LIMIT = 32 * 1024 * 1024 / sizeof(nsDiskCacheRecord);
  int32_t maxRecordCount = std::min(int32_t(capacity), RECORD_COUNT_LIMIT);
  if (mMaxRecordCount < maxRecordCount) {

    mMaxRecordCount = maxRecordCount;
  }
}

size_t
nsDiskCacheMap::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf)
{
  size_t usage = aMallocSizeOf(mRecordArray);

  usage += aMallocSizeOf(mBuffer);
  usage += aMallocSizeOf(mMapFD);
  usage += aMallocSizeOf(mCleanFD);
  usage += aMallocSizeOf(mCacheDirectory);
  usage += aMallocSizeOf(mCleanCacheTimer);

  for (int i = 0; i < 3; i++) {
    usage += mBlockFile[i].SizeOfExcludingThis(aMallocSizeOf);
  }

  return usage;
}

nsresult
nsDiskCacheMap::InitCacheClean(nsIFile * cacheDirectory,
                               nsDiskCache::CorruptCacheInfo * corruptInfo,
                               bool reportCacheCleanTelemetryData)
{


    bool cacheCleanFileExists = false;
    nsCOMPtr<nsIFile> cacheCleanFile;
    nsresult rv = cacheDirectory->GetParent(getter_AddRefs(cacheCleanFile));
    if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {
        rv = cacheCleanFile->AppendNative(
                 static_cast<const nsDependentCString&>(nsDependentCString("_CACHE_CLEAN_", mozilla::internal::LiteralStringLength("_CACHE_CLEAN_"))));
        if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {


            cacheCleanFile->Exists(&cacheCleanFileExists);
        }
    }
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        do { } while(0);
        *corruptInfo = nsDiskCache::kCacheCleanFilePathError;
        return rv;
    }


    rv = cacheCleanFile->OpenNSPRFileDesc(0x04 | 0x08,
                                          00600, &mCleanFD);
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        do { } while(0);
        *corruptInfo = nsDiskCache::kCacheCleanOpenFileError;
        return rv;
    }

    if (cacheCleanFileExists) {
        char clean = '0';
        int32_t bytesRead = PR_Read(mCleanFD, &clean, 1);
        if (bytesRead != 1) {
            do { } while(0);
        } else if (reportCacheCleanTelemetryData) {
            Telemetry::Accumulate(Telemetry::DISK_CACHE_REDUCTION_TRIAL,
                                  clean == '1' ? 1 : 0);
        }
    }



    mCleanCacheTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    if (((bool)(__builtin_expect(!!(!NS_FAILED_impl(rv)), 1)))) {
        mCleanCacheTimer->SetTarget(nsCacheService::GlobalInstance()->mCacheIOThread);
        rv = ResetCacheTimer();
    }

    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        do { } while(0);
        mCleanCacheTimer = nullptr;
        *corruptInfo = nsDiskCache::kCacheCleanTimerError;
        return rv;
    }

    return nsresult::NS_OK;
}

nsresult
nsDiskCacheMap::WriteCacheClean(bool clean)
{
    nsCacheService::AssertOwnsLock();
    if (!mCleanFD) {
        do { } while(0);
        return nsresult::NS_ERROR_FAILURE;
    }

    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: WriteCacheClean: %d\n", clean? 1 : 0); } } while (0);


    char data = clean? '1' : '0';
    int32_t filePos = PR_Seek(mCleanFD, 0, PR_SEEK_SET);
    if (filePos != 0) {
        do { } while(0);
        return nsresult::NS_ERROR_FAILURE;
    }
    int32_t bytesWritten = PR_Write(mCleanFD, &data, 1);
    if (bytesWritten != 1) {
        do { } while(0);
        return nsresult::NS_ERROR_FAILURE;
    }
    PRStatus err = PR_Sync(mCleanFD);
    if (err != PR_SUCCESS) {
        do { } while(0);
    }

    return nsresult::NS_OK;
}

nsresult
nsDiskCacheMap::InvalidateCache()
{
    nsCacheService::AssertOwnsLock();
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: InvalidateCache\n"); } } while (0);
    nsresult rv;

    if (!mIsDirtyCacheFlushed) {
        rv = WriteCacheClean(false);
        if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
          Telemetry::Accumulate(Telemetry::DISK_CACHE_INVALIDATION_SUCCESS, 0);
          return rv;
        }

        Telemetry::Accumulate(Telemetry::DISK_CACHE_INVALIDATION_SUCCESS, 1);
        mIsDirtyCacheFlushed = true;
    }

    rv = ResetCacheTimer();
    do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);

    return nsresult::NS_OK;
}

nsresult
nsDiskCacheMap::ResetCacheTimer(int32_t timeout)
{
    mCleanCacheTimer->Cancel();
    nsresult rv =
      mCleanCacheTimer->InitWithFuncCallback(RevalidateTimerCallback,
                                             nullptr, timeout,
                                             nsITimer::TYPE_ONE_SHOT);
    do { nsresult __rv = rv; if (((bool)(__builtin_expect(!!(NS_FAILED_impl(__rv)), 0)))) { do { } while(0); return rv; } } while(0);
    mLastInvalidateTime = PR_IntervalNow();

    return rv;
}

void
nsDiskCacheMap::RevalidateTimerCallback(nsITimer *aTimer, void *arg)
{
    nsCacheServiceAutoLock lock((::mozilla::Telemetry::CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_NSDISKCACHEMAP_REVALIDATION));
    if (!nsCacheService::gService->mDiskDevice ||
        !nsCacheService::gService->mDiskDevice->Initialized()) {
        return;
    }

    nsDiskCacheMap *diskCacheMap =
        &nsCacheService::gService->mDiskDevice->mCacheMap;







    uint32_t delta =
        PR_IntervalToMilliseconds(PR_IntervalNow() -
                                  diskCacheMap->mLastInvalidateTime) +
        10;
    if (delta < 3000) {
        diskCacheMap->ResetCacheTimer();
        return;
    }

    nsresult rv = diskCacheMap->RevalidateCache();
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        diskCacheMap->ResetCacheTimer(1000);
    }
}

bool
nsDiskCacheMap::IsCacheInSafeState()
{
    return nsCacheService::GlobalInstance()->IsDoomListEmpty();
}

nsresult
nsDiskCacheMap::RevalidateCache()
{
    do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: RevalidateCache\n"); } } while (0);
    nsresult rv;

    if (!IsCacheInSafeState()) {
        Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SAFE, 0);
        do { if (((gCacheLog)->level >= (PR_LOG_DEBUG))) { PR_LogPrint ("CACHE: Revalidation should not performed because " "cache not in a safe state\n"); } } while (0)
                                                        ;





    } else {
        Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SAFE, 1);
    }


    Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_REVALIDATION> totalTimer;





    rv = WriteCacheClean(true);
    if (((bool)(__builtin_expect(!!(NS_FAILED_impl(rv)), 0)))) {
        Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SUCCESS, 0);
        return rv;
    }

    Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SUCCESS, 1);
    mIsDirtyCacheFlushed = false;

    return nsresult::NS_OK;
}
